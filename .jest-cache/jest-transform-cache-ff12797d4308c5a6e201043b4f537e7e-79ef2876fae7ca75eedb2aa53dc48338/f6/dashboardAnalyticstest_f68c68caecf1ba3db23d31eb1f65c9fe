f14f24e17996df741f40843d0898796f
"use strict";
jest.mock("@/hooks/useAuth", ()=>({
        useAuth: ()=>mockUseAuth()
    }));
// Mock next/navigation
jest.mock("next/navigation", ()=>({
        useRouter: ()=>({
                push: jest.fn(),
                replace: jest.fn(),
                back: jest.fn(),
                forward: jest.fn(),
                refresh: jest.fn(),
                prefetch: jest.fn()
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
require("@testing-library/jest-dom");
// Mock the useAuth hook
const mockUseAuth = jest.fn();
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
describe("Dashboard and Analytics System", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock localStorage
        Object.defineProperty(window, "localStorage", {
            value: {
                getItem: jest.fn(()=>"mock-token"),
                setItem: jest.fn(),
                removeItem: jest.fn()
            },
            writable: true
        });
        // Mock user with dashboard permissions
        mockUseAuth.mockReturnValue({
            user: {
                id: "1",
                name: "Dashboard User",
                email: "dashboard@test.com",
                permissions: [
                    "dashboard:view",
                    "analytics:view",
                    "reports:view",
                    "sales:view",
                    "inventory:view"
                ]
            },
            isLoading: false,
            isAuthenticated: true,
            login: jest.fn(),
            logout: jest.fn(),
            hasPermission: jest.fn((permission)=>{
                const userPermissions = [
                    "dashboard:view",
                    "analytics:view",
                    "reports:view",
                    "sales:view",
                    "inventory:view"
                ];
                return userPermissions.includes(permission);
            })
        });
    });
    describe("Sales Analytics", ()=>{
        test("should calculate sales metrics correctly", ()=>{
            const calculateSalesMetrics = (salesData)=>{
                const totalRevenue = salesData.reduce((sum, sale)=>sum + sale.amount, 0);
                const totalTransactions = salesData.length;
                const averageOrderValue = totalTransactions > 0 ? totalRevenue / totalTransactions : 0;
                const today = new Date();
                const todaySales = salesData.filter((sale)=>{
                    const saleDate = new Date(sale.date);
                    return saleDate.toDateString() === today.toDateString();
                });
                const thisMonth = salesData.filter((sale)=>{
                    const saleDate = new Date(sale.date);
                    return saleDate.getMonth() === today.getMonth() && saleDate.getFullYear() === today.getFullYear();
                });
                return {
                    totalRevenue,
                    totalTransactions,
                    averageOrderValue: Math.round(averageOrderValue * 100) / 100,
                    todayRevenue: todaySales.reduce((sum, sale)=>sum + sale.amount, 0),
                    monthlyRevenue: thisMonth.reduce((sum, sale)=>sum + sale.amount, 0),
                    todayTransactions: todaySales.length,
                    monthlyTransactions: thisMonth.length
                };
            };
            const salesData = [
                {
                    id: 1,
                    amount: 1000,
                    date: new Date().toISOString()
                },
                {
                    id: 2,
                    amount: 1500,
                    date: new Date().toISOString()
                },
                {
                    id: 3,
                    amount: 800,
                    date: new Date(Date.now() - 86400000).toISOString()
                },
                {
                    id: 4,
                    amount: 1200,
                    date: new Date(Date.now() - 172800000).toISOString()
                } // 2 days ago
            ];
            const metrics = calculateSalesMetrics(salesData);
            expect(metrics.totalRevenue).toBe(4500);
            expect(metrics.totalTransactions).toBe(4);
            expect(metrics.averageOrderValue).toBe(1125);
            expect(metrics.todayRevenue).toBe(2500);
            expect(metrics.todayTransactions).toBe(2);
        });
        test("should calculate growth rates", ()=>{
            const calculateGrowthRate = (current, previous)=>{
                if (previous === 0) return current > 0 ? 100 : 0;
                return Math.round((current - previous) / previous * 100 * 100) / 100;
            };
            const comparePerformance = (currentPeriod, previousPeriod)=>{
                const currentRevenue = currentPeriod.reduce((sum, sale)=>sum + sale.amount, 0);
                const previousRevenue = previousPeriod.reduce((sum, sale)=>sum + sale.amount, 0);
                const revenueGrowth = calculateGrowthRate(currentRevenue, previousRevenue);
                const transactionGrowth = calculateGrowthRate(currentPeriod.length, previousPeriod.length);
                return {
                    currentRevenue,
                    previousRevenue,
                    revenueGrowth,
                    transactionGrowth,
                    trend: revenueGrowth > 0 ? "up" : revenueGrowth < 0 ? "down" : "stable"
                };
            };
            const currentMonth = [
                {
                    amount: 1000
                },
                {
                    amount: 1500
                },
                {
                    amount: 800
                }
            ];
            const previousMonth = [
                {
                    amount: 900
                },
                {
                    amount: 1100
                }
            ];
            const performance = comparePerformance(currentMonth, previousMonth);
            expect(performance.currentRevenue).toBe(3300);
            expect(performance.previousRevenue).toBe(2000);
            expect(performance.revenueGrowth).toBe(65);
            expect(performance.transactionGrowth).toBe(50);
            expect(performance.trend).toBe("up");
        });
        test("should generate sales by category data", ()=>{
            const generateCategoryAnalysis = (salesData)=>{
                const categoryTotals = salesData.reduce((acc, sale)=>{
                    const category = sale.category || "Uncategorized";
                    acc[category] = (acc[category] || 0) + sale.amount;
                    return acc;
                }, {});
                const totalRevenue = Object.values(categoryTotals).reduce((sum, amount)=>sum + amount, 0);
                return Object.entries(categoryTotals).map(([category, amount])=>({
                        category,
                        amount,
                        percentage: Math.round(amount / totalRevenue * 100 * 100) / 100
                    })).sort((a, b)=>b.amount - a.amount);
            };
            const salesData = [
                {
                    category: "Electronics",
                    amount: 2000
                },
                {
                    category: "Clothing",
                    amount: 1500
                },
                {
                    category: "Electronics",
                    amount: 1000
                },
                {
                    category: "Books",
                    amount: 500
                },
                {
                    category: "Clothing",
                    amount: 800
                }
            ];
            const analysis = generateCategoryAnalysis(salesData);
            expect(analysis[0]).toEqual({
                category: "Electronics",
                amount: 3000,
                percentage: 51.72
            });
            expect(analysis[1]).toEqual({
                category: "Clothing",
                amount: 2300,
                percentage: 39.66
            });
        });
    });
    describe("Inventory Analytics", ()=>{
        test("should calculate inventory turnover", ()=>{
            const calculateInventoryTurnover = (costOfGoodsSold, averageInventoryValue)=>{
                if (averageInventoryValue === 0) return 0;
                return Math.round(costOfGoodsSold / averageInventoryValue * 100) / 100;
            };
            const calculateDaysInInventory = (inventoryTurnover)=>{
                if (inventoryTurnover === 0) return 0;
                return Math.round(365 / inventoryTurnover * 100) / 100;
            };
            const turnover = calculateInventoryTurnover(120000, 20000);
            const daysInInventory = calculateDaysInInventory(turnover);
            expect(turnover).toBe(6);
            expect(daysInInventory).toBe(60.83);
        });
        test("should identify slow-moving inventory", ()=>{
            const identifySlowMovingItems = (inventoryItems, salesData, daysThreshold = 90)=>{
                const itemSales = salesData.reduce((acc, sale)=>{
                    sale.items.forEach((item)=>{
                        acc[item.productId] = (acc[item.productId] || 0) + item.quantity;
                    });
                    return acc;
                }, {});
                const cutoffDate = new Date(Date.now() - daysThreshold * 24 * 60 * 60 * 1000);
                return inventoryItems.filter((item)=>{
                    const lastSaleQuantity = itemSales[item.id] || 0;
                    const lastUpdated = new Date(item.lastUpdated);
                    return lastSaleQuantity === 0 || lastUpdated < cutoffDate;
                }).map((item)=>({
                        ...item,
                        daysSinceLastSale: Math.floor((Date.now() - new Date(item.lastUpdated).getTime()) / (24 * 60 * 60 * 1000)),
                        totalSales: itemSales[item.id] || 0
                    }));
            };
            const inventoryItems = [
                {
                    id: "item1",
                    name: "Product A",
                    lastUpdated: new Date(Date.now() - 100 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    id: "item2",
                    name: "Product B",
                    lastUpdated: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    id: "item3",
                    name: "Product C",
                    lastUpdated: new Date(Date.now() - 120 * 24 * 60 * 60 * 1000).toISOString()
                }
            ];
            const salesData = [
                {
                    items: [
                        {
                            productId: "item2",
                            quantity: 5
                        }
                    ]
                }
            ];
            const slowMoving = identifySlowMovingItems(inventoryItems, salesData, 90);
            expect(slowMoving).toHaveLength(2); // item1 and item3
            expect(slowMoving.find((item)=>item.id === "item1")?.daysSinceLastSale).toBe(100);
        });
        test("should calculate stock level alerts", ()=>{
            const generateStockAlerts = (inventoryItems)=>{
                return inventoryItems.map((item)=>{
                    const stockLevel = item.currentStock;
                    const reorderPoint = item.reorderPoint || 0;
                    const maxStock = item.maxStock || 0;
                    let alertType = "normal";
                    let alertMessage = "";
                    if (stockLevel <= 0) {
                        alertType = "critical";
                        alertMessage = "Out of stock";
                    } else if (stockLevel <= reorderPoint) {
                        alertType = "warning";
                        alertMessage = "Low stock - reorder needed";
                    } else if (stockLevel >= maxStock && maxStock > 0) {
                        alertType = "info";
                        alertMessage = "Overstock";
                    }
                    return {
                        ...item,
                        alertType,
                        alertMessage,
                        stockPercentage: maxStock > 0 ? Math.round(stockLevel / maxStock * 100) : 0
                    };
                }).filter((item)=>item.alertType !== "normal");
            };
            const inventoryItems = [
                {
                    id: "item1",
                    name: "Product A",
                    currentStock: 0,
                    reorderPoint: 10,
                    maxStock: 100
                },
                {
                    id: "item2",
                    name: "Product B",
                    currentStock: 5,
                    reorderPoint: 10,
                    maxStock: 100
                },
                {
                    id: "item3",
                    name: "Product C",
                    currentStock: 50,
                    reorderPoint: 10,
                    maxStock: 100
                },
                {
                    id: "item4",
                    name: "Product D",
                    currentStock: 120,
                    reorderPoint: 10,
                    maxStock: 100
                }
            ];
            const alerts = generateStockAlerts(inventoryItems);
            expect(alerts).toHaveLength(3);
            expect(alerts.find((alert)=>alert.id === "item1")?.alertType).toBe("critical");
            expect(alerts.find((alert)=>alert.id === "item2")?.alertType).toBe("warning");
            expect(alerts.find((alert)=>alert.id === "item4")?.alertType).toBe("info");
        });
    });
    describe("Financial Analytics", ()=>{
        test("should calculate profit margins", ()=>{
            const calculateProfitMargins = (salesData)=>{
                return salesData.map((sale)=>{
                    const revenue = sale.amount;
                    const cost = sale.cost || 0;
                    const profit = revenue - cost;
                    const marginPercentage = revenue > 0 ? Math.round(profit / revenue * 100 * 100) / 100 : 0;
                    return {
                        ...sale,
                        profit,
                        marginPercentage,
                        profitCategory: marginPercentage >= 30 ? "high" : marginPercentage >= 15 ? "medium" : "low"
                    };
                });
            };
            const salesData = [
                {
                    id: 1,
                    amount: 1000,
                    cost: 600
                },
                {
                    id: 2,
                    amount: 1500,
                    cost: 1200
                },
                {
                    id: 3,
                    amount: 800,
                    cost: 400
                }
            ];
            const margins = calculateProfitMargins(salesData);
            expect(margins[0].profit).toBe(400);
            expect(margins[0].marginPercentage).toBe(40);
            expect(margins[0].profitCategory).toBe("high");
            expect(margins[1].marginPercentage).toBe(20);
            expect(margins[1].profitCategory).toBe("medium");
            expect(margins[2].marginPercentage).toBe(50);
            expect(margins[2].profitCategory).toBe("high");
        });
        test("should calculate cash flow projections", ()=>{
            const calculateCashFlow = (transactions, projectionDays = 30)=>{
                const today = new Date();
                const projectionDate = new Date(today.getTime() + projectionDays * 24 * 60 * 60 * 1000);
                const inflows = transactions.filter((t)=>t.type === "income" && new Date(t.dueDate) <= projectionDate).reduce((sum, t)=>sum + t.amount, 0);
                const outflows = transactions.filter((t)=>t.type === "expense" && new Date(t.dueDate) <= projectionDate).reduce((sum, t)=>sum + t.amount, 0);
                const netCashFlow = inflows - outflows;
                return {
                    projectionPeriod: projectionDays,
                    expectedInflows: inflows,
                    expectedOutflows: outflows,
                    netCashFlow,
                    cashFlowStatus: netCashFlow > 0 ? "positive" : netCashFlow < 0 ? "negative" : "neutral"
                };
            };
            const transactions = [
                {
                    type: "income",
                    amount: 5000,
                    dueDate: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    type: "income",
                    amount: 3000,
                    dueDate: new Date(Date.now() + 20 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    type: "expense",
                    amount: 2000,
                    dueDate: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    type: "expense",
                    amount: 1500,
                    dueDate: new Date(Date.now() + 40 * 24 * 60 * 60 * 1000).toISOString()
                } // Outside 30-day window
            ];
            const cashFlow = calculateCashFlow(transactions, 30);
            expect(cashFlow.expectedInflows).toBe(8000);
            expect(cashFlow.expectedOutflows).toBe(2000);
            expect(cashFlow.netCashFlow).toBe(6000);
            expect(cashFlow.cashFlowStatus).toBe("positive");
        });
    });
    describe("Customer Analytics", ()=>{
        test("should calculate customer lifetime value", ()=>{
            const calculateCustomerLTV = (customer, averageOrderValue, purchaseFrequency, customerLifespan)=>{
                return Math.round(averageOrderValue * purchaseFrequency * customerLifespan * 100) / 100;
            };
            const segmentCustomers = (customers)=>{
                return customers.map((customer)=>{
                    const totalSpent = customer.orders.reduce((sum, order)=>sum + order.amount, 0);
                    const orderCount = customer.orders.length;
                    const avgOrderValue = orderCount > 0 ? totalSpent / orderCount : 0;
                    // Calculate days since first order
                    const firstOrderDate = new Date(Math.min(...customer.orders.map((o)=>new Date(o.date).getTime())));
                    const daysSinceFirst = Math.floor((Date.now() - firstOrderDate.getTime()) / (24 * 60 * 60 * 1000));
                    const purchaseFrequency = daysSinceFirst > 0 ? orderCount / (daysSinceFirst / 365) : 0;
                    const ltv = calculateCustomerLTV(customer, avgOrderValue, purchaseFrequency, 2); // 2 year lifespan
                    let segment = "low-value";
                    if (ltv >= 5000) segment = "high-value";
                    else if (ltv >= 2000) segment = "medium-value";
                    return {
                        ...customer,
                        totalSpent,
                        orderCount,
                        avgOrderValue: Math.round(avgOrderValue * 100) / 100,
                        purchaseFrequency: Math.round(purchaseFrequency * 100) / 100,
                        ltv,
                        segment
                    };
                });
            };
            const customers = [
                {
                    id: "cust1",
                    name: "High Value Customer",
                    orders: [
                        {
                            amount: 1000,
                            date: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString()
                        },
                        {
                            amount: 1500,
                            date: new Date(Date.now() - 300 * 24 * 60 * 60 * 1000).toISOString()
                        },
                        {
                            amount: 2000,
                            date: new Date(Date.now() - 200 * 24 * 60 * 60 * 1000).toISOString()
                        }
                    ]
                },
                {
                    id: "cust2",
                    name: "Low Value Customer",
                    orders: [
                        {
                            amount: 100,
                            date: new Date(Date.now() - 100 * 24 * 60 * 60 * 1000).toISOString()
                        }
                    ]
                }
            ];
            const segmented = segmentCustomers(customers);
            expect(segmented[0].totalSpent).toBe(4500);
            expect(segmented[0].orderCount).toBe(3);
            expect(segmented[0].segment).toBe("high-value");
            expect(segmented[1].totalSpent).toBe(100);
            expect(segmented[1].segment).toBe("low-value");
        });
        test("should identify customer churn risk", ()=>{
            const identifyChurnRisk = (customers, daysSinceLastOrder = 90)=>{
                const cutoffDate = new Date(Date.now() - daysSinceLastOrder * 24 * 60 * 60 * 1000);
                return customers.map((customer)=>{
                    const lastOrderDate = new Date(Math.max(...customer.orders.map((o)=>new Date(o.date).getTime())));
                    const daysSinceLast = Math.floor((Date.now() - lastOrderDate.getTime()) / (24 * 60 * 60 * 1000));
                    let churnRisk = "low";
                    if (daysSinceLast > daysSinceLastOrder * 2) churnRisk = "high";
                    else if (daysSinceLast > daysSinceLastOrder) churnRisk = "medium";
                    return {
                        ...customer,
                        lastOrderDate: lastOrderDate.toISOString(),
                        daysSinceLastOrder: daysSinceLast,
                        churnRisk
                    };
                }).filter((customer)=>customer.churnRisk !== "low");
            };
            const customers = [
                {
                    id: "cust1",
                    orders: [
                        {
                            date: new Date(Date.now() - 200 * 24 * 60 * 60 * 1000).toISOString()
                        }
                    ] // 200 days ago
                },
                {
                    id: "cust2",
                    orders: [
                        {
                            date: new Date(Date.now() - 50 * 24 * 60 * 60 * 1000).toISOString()
                        }
                    ] // 50 days ago
                }
            ];
            const atRisk = identifyChurnRisk(customers, 90);
            expect(atRisk).toHaveLength(1);
            expect(atRisk[0].id).toBe("cust1");
            expect(atRisk[0].churnRisk).toBe("high");
        });
    });
    describe("Dashboard API Integration", ()=>{
        test("should fetch dashboard data", async ()=>{
            const fetchDashboardData = async (dateRange = "30d")=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            data: {
                                sales: {
                                    totalRevenue: 125000,
                                    totalTransactions: 450,
                                    averageOrderValue: 277.78,
                                    growth: 15.5
                                },
                                inventory: {
                                    totalItems: 1250,
                                    lowStockItems: 23,
                                    outOfStockItems: 5,
                                    inventoryValue: 85000
                                },
                                customers: {
                                    totalCustomers: 890,
                                    newCustomers: 45,
                                    activeCustomers: 234,
                                    churnRate: 5.2
                                }
                            }
                        })
                });
                const response = await fetch(`/api/dashboard?range=${dateRange}`, {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return response.json();
            };
            const result = await fetchDashboardData("30d");
            expect(result.success).toBe(true);
            expect(result.data.sales.totalRevenue).toBe(125000);
            expect(result.data.inventory.totalItems).toBe(1250);
            expect(result.data.customers.totalCustomers).toBe(890);
        });
        test("should fetch chart data for different periods", async ()=>{
            const fetchChartData = async (chartType, period)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            chartData: {
                                labels: [
                                    "Jan",
                                    "Feb",
                                    "Mar",
                                    "Apr",
                                    "May"
                                ],
                                datasets: [
                                    {
                                        label: "Revenue",
                                        data: [
                                            12000,
                                            15000,
                                            18000,
                                            16000,
                                            20000
                                        ]
                                    }
                                ]
                            }
                        })
                });
                const response = await fetch(`/api/analytics/charts/${chartType}?period=${period}`, {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return response.json();
            };
            const result = await fetchChartData("revenue", "6m");
            expect(result.success).toBe(true);
            expect(result.chartData.labels).toHaveLength(5);
            expect(result.chartData.datasets[0].data).toEqual([
                12000,
                15000,
                18000,
                16000,
                20000
            ]);
        });
    });
    describe("Real-time Updates", ()=>{
        test("should handle real-time dashboard updates", ()=>{
            const createDashboardUpdater = ()=>{
                let subscribers = [];
                const subscribe = (callback)=>{
                    subscribers.push(callback);
                    return ()=>{
                        subscribers = subscribers.filter((sub)=>sub !== callback);
                    };
                };
                const broadcast = (data)=>{
                    subscribers.forEach((callback)=>callback(data));
                };
                return {
                    subscribe,
                    broadcast
                };
            };
            const updater = createDashboardUpdater();
            const mockCallback1 = jest.fn();
            const mockCallback2 = jest.fn();
            const unsubscribe1 = updater.subscribe(mockCallback1);
            const unsubscribe2 = updater.subscribe(mockCallback2);
            const updateData = {
                type: "sales_update",
                value: 1000
            };
            updater.broadcast(updateData);
            expect(mockCallback1).toHaveBeenCalledWith(updateData);
            expect(mockCallback2).toHaveBeenCalledWith(updateData);
            unsubscribe1();
            updater.broadcast({
                type: "another_update",
                value: 2000
            });
            expect(mockCallback1).toHaveBeenCalledTimes(1); // Should not be called again
            expect(mockCallback2).toHaveBeenCalledTimes(2); // Should be called again
        });
        test("should throttle frequent updates", ()=>{
            const createThrottledUpdater = (delay = 1000)=>{
                let lastUpdate = 0;
                let pendingData = null;
                let timeoutId = null;
                const update = (data, callback)=>{
                    const now = Date.now();
                    pendingData = data;
                    if (now - lastUpdate >= delay) {
                        lastUpdate = now;
                        callback(data);
                        pendingData = null;
                    } else if (!timeoutId) {
                        timeoutId = setTimeout(()=>{
                            if (pendingData) {
                                lastUpdate = Date.now();
                                callback(pendingData);
                                pendingData = null;
                            }
                            timeoutId = null;
                        }, delay - (now - lastUpdate));
                    }
                };
                return {
                    update
                };
            };
            const mockCallback = jest.fn();
            const updater = createThrottledUpdater(100);
            // First update should go through immediately
            updater.update({
                value: 1
            }, mockCallback);
            expect(mockCallback).toHaveBeenCalledTimes(1);
            // Subsequent updates within delay should be throttled
            updater.update({
                value: 2
            }, mockCallback);
            updater.update({
                value: 3
            }, mockCallback);
            expect(mockCallback).toHaveBeenCalledTimes(1); // Still only called once
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvaW50ZWdyYXRpb24vZGFzaGJvYXJkQW5hbHl0aWNzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIGZpcmVFdmVudCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2plc3QtZG9tJztcblxuLy8gTW9jayB0aGUgdXNlQXV0aCBob29rXG5jb25zdCBtb2NrVXNlQXV0aCA9IGplc3QuZm4oKTtcbmplc3QubW9jaygnQC9ob29rcy91c2VBdXRoJywgKCkgPT4gKHtcbiAgdXNlQXV0aDogKCkgPT4gbW9ja1VzZUF1dGgoKSxcbn0pKTtcblxuLy8gTW9jayBuZXh0L25hdmlnYXRpb25cbmplc3QubW9jaygnbmV4dC9uYXZpZ2F0aW9uJywgKCkgPT4gKHtcbiAgdXNlUm91dGVyOiAoKSA9PiAoe1xuICAgIHB1c2g6IGplc3QuZm4oKSxcbiAgICByZXBsYWNlOiBqZXN0LmZuKCksXG4gICAgYmFjazogamVzdC5mbigpLFxuICAgIGZvcndhcmQ6IGplc3QuZm4oKSxcbiAgICByZWZyZXNoOiBqZXN0LmZuKCksXG4gICAgcHJlZmV0Y2g6IGplc3QuZm4oKSxcbiAgfSksXG59KSk7XG5cbi8vIE1vY2sgZmV0Y2ggZ2xvYmFsbHlcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKTtcbmdsb2JhbC5mZXRjaCA9IG1vY2tGZXRjaDtcblxuZGVzY3JpYmUoJ0Rhc2hib2FyZCBhbmQgQW5hbHl0aWNzIFN5c3RlbScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgXG4gICAgLy8gTW9jayBsb2NhbFN0b3JhZ2VcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnbG9jYWxTdG9yYWdlJywge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgZ2V0SXRlbTogamVzdC5mbigoKSA9PiAnbW9jay10b2tlbicpLFxuICAgICAgICBzZXRJdGVtOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUl0ZW06IGplc3QuZm4oKSxcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8vIE1vY2sgdXNlciB3aXRoIGRhc2hib2FyZCBwZXJtaXNzaW9uc1xuICAgIG1vY2tVc2VBdXRoLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICB1c2VyOiB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIG5hbWU6ICdEYXNoYm9hcmQgVXNlcicsXG4gICAgICAgIGVtYWlsOiAnZGFzaGJvYXJkQHRlc3QuY29tJyxcbiAgICAgICAgcGVybWlzc2lvbnM6IFsnZGFzaGJvYXJkOnZpZXcnLCAnYW5hbHl0aWNzOnZpZXcnLCAncmVwb3J0czp2aWV3JywgJ3NhbGVzOnZpZXcnLCAnaW52ZW50b3J5OnZpZXcnXVxuICAgICAgfSxcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICBsb2dpbjogamVzdC5mbigpLFxuICAgICAgbG9nb3V0OiBqZXN0LmZuKCksXG4gICAgICBoYXNQZXJtaXNzaW9uOiBqZXN0LmZuKChwZXJtaXNzaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJQZXJtaXNzaW9ucyA9IFsnZGFzaGJvYXJkOnZpZXcnLCAnYW5hbHl0aWNzOnZpZXcnLCAncmVwb3J0czp2aWV3JywgJ3NhbGVzOnZpZXcnLCAnaW52ZW50b3J5OnZpZXcnXTtcbiAgICAgICAgcmV0dXJuIHVzZXJQZXJtaXNzaW9ucy5pbmNsdWRlcyhwZXJtaXNzaW9uKTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTYWxlcyBBbmFseXRpY3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNhbGN1bGF0ZSBzYWxlcyBtZXRyaWNzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZVNhbGVzTWV0cmljcyA9IChzYWxlc0RhdGE6IGFueVtdKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdGFsUmV2ZW51ZSA9IHNhbGVzRGF0YS5yZWR1Y2UoKHN1bSwgc2FsZSkgPT4gc3VtICsgc2FsZS5hbW91bnQsIDApO1xuICAgICAgICBjb25zdCB0b3RhbFRyYW5zYWN0aW9ucyA9IHNhbGVzRGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGF2ZXJhZ2VPcmRlclZhbHVlID0gdG90YWxUcmFuc2FjdGlvbnMgPiAwID8gdG90YWxSZXZlbnVlIC8gdG90YWxUcmFuc2FjdGlvbnMgOiAwO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0b2RheVNhbGVzID0gc2FsZXNEYXRhLmZpbHRlcihzYWxlID0+IHtcbiAgICAgICAgICBjb25zdCBzYWxlRGF0ZSA9IG5ldyBEYXRlKHNhbGUuZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHNhbGVEYXRlLnRvRGF0ZVN0cmluZygpID09PSB0b2RheS50b0RhdGVTdHJpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0aGlzTW9udGggPSBzYWxlc0RhdGEuZmlsdGVyKHNhbGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHNhbGVEYXRlID0gbmV3IERhdGUoc2FsZS5kYXRlKTtcbiAgICAgICAgICByZXR1cm4gc2FsZURhdGUuZ2V0TW9udGgoKSA9PT0gdG9kYXkuZ2V0TW9udGgoKSAmJiBzYWxlRGF0ZS5nZXRGdWxsWWVhcigpID09PSB0b2RheS5nZXRGdWxsWWVhcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG90YWxSZXZlbnVlLFxuICAgICAgICAgIHRvdGFsVHJhbnNhY3Rpb25zLFxuICAgICAgICAgIGF2ZXJhZ2VPcmRlclZhbHVlOiBNYXRoLnJvdW5kKGF2ZXJhZ2VPcmRlclZhbHVlICogMTAwKSAvIDEwMCxcbiAgICAgICAgICB0b2RheVJldmVudWU6IHRvZGF5U2FsZXMucmVkdWNlKChzdW0sIHNhbGUpID0+IHN1bSArIHNhbGUuYW1vdW50LCAwKSxcbiAgICAgICAgICBtb250aGx5UmV2ZW51ZTogdGhpc01vbnRoLnJlZHVjZSgoc3VtLCBzYWxlKSA9PiBzdW0gKyBzYWxlLmFtb3VudCwgMCksXG4gICAgICAgICAgdG9kYXlUcmFuc2FjdGlvbnM6IHRvZGF5U2FsZXMubGVuZ3RoLFxuICAgICAgICAgIG1vbnRobHlUcmFuc2FjdGlvbnM6IHRoaXNNb250aC5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNhbGVzRGF0YSA9IFtcbiAgICAgICAgeyBpZDogMSwgYW1vdW50OiAxMDAwLCBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSwgLy8gVG9kYXlcbiAgICAgICAgeyBpZDogMiwgYW1vdW50OiAxNTAwLCBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSwgLy8gVG9kYXlcbiAgICAgICAgeyBpZDogMywgYW1vdW50OiA4MDAsIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSA4NjQwMDAwMCkudG9JU09TdHJpbmcoKSB9LCAvLyBZZXN0ZXJkYXlcbiAgICAgICAgeyBpZDogNCwgYW1vdW50OiAxMjAwLCBkYXRlOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTcyODAwMDAwKS50b0lTT1N0cmluZygpIH0gLy8gMiBkYXlzIGFnb1xuICAgICAgXTtcblxuICAgICAgY29uc3QgbWV0cmljcyA9IGNhbGN1bGF0ZVNhbGVzTWV0cmljcyhzYWxlc0RhdGEpO1xuICAgICAgXG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbFJldmVudWUpLnRvQmUoNDUwMCk7XG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbFRyYW5zYWN0aW9ucykudG9CZSg0KTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmF2ZXJhZ2VPcmRlclZhbHVlKS50b0JlKDExMjUpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MudG9kYXlSZXZlbnVlKS50b0JlKDI1MDApO1xuICAgICAgZXhwZWN0KG1ldHJpY3MudG9kYXlUcmFuc2FjdGlvbnMpLnRvQmUoMik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgY2FsY3VsYXRlIGdyb3d0aCByYXRlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZUdyb3d0aFJhdGUgPSAoY3VycmVudDogbnVtYmVyLCBwcmV2aW91czogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aW91cyA9PT0gMCkgcmV0dXJuIGN1cnJlbnQgPiAwID8gMTAwIDogMDtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKChjdXJyZW50IC0gcHJldmlvdXMpIC8gcHJldmlvdXMpICogMTAwICogMTAwKSAvIDEwMDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvbXBhcmVQZXJmb3JtYW5jZSA9IChjdXJyZW50UGVyaW9kOiBhbnlbXSwgcHJldmlvdXNQZXJpb2Q6IGFueVtdKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZXZlbnVlID0gY3VycmVudFBlcmlvZC5yZWR1Y2UoKHN1bSwgc2FsZSkgPT4gc3VtICsgc2FsZS5hbW91bnQsIDApO1xuICAgICAgICBjb25zdCBwcmV2aW91c1JldmVudWUgPSBwcmV2aW91c1BlcmlvZC5yZWR1Y2UoKHN1bSwgc2FsZSkgPT4gc3VtICsgc2FsZS5hbW91bnQsIDApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmV2ZW51ZUdyb3d0aCA9IGNhbGN1bGF0ZUdyb3d0aFJhdGUoY3VycmVudFJldmVudWUsIHByZXZpb3VzUmV2ZW51ZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR3Jvd3RoID0gY2FsY3VsYXRlR3Jvd3RoUmF0ZShjdXJyZW50UGVyaW9kLmxlbmd0aCwgcHJldmlvdXNQZXJpb2QubGVuZ3RoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3VycmVudFJldmVudWUsXG4gICAgICAgICAgcHJldmlvdXNSZXZlbnVlLFxuICAgICAgICAgIHJldmVudWVHcm93dGgsXG4gICAgICAgICAgdHJhbnNhY3Rpb25Hcm93dGgsXG4gICAgICAgICAgdHJlbmQ6IHJldmVudWVHcm93dGggPiAwID8gJ3VwJyA6IHJldmVudWVHcm93dGggPCAwID8gJ2Rvd24nIDogJ3N0YWJsZSdcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IFtcbiAgICAgICAgeyBhbW91bnQ6IDEwMDAgfSxcbiAgICAgICAgeyBhbW91bnQ6IDE1MDAgfSxcbiAgICAgICAgeyBhbW91bnQ6IDgwMCB9XG4gICAgICBdO1xuICAgICAgXG4gICAgICBjb25zdCBwcmV2aW91c01vbnRoID0gW1xuICAgICAgICB7IGFtb3VudDogOTAwIH0sXG4gICAgICAgIHsgYW1vdW50OiAxMTAwIH1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHBlcmZvcm1hbmNlID0gY29tcGFyZVBlcmZvcm1hbmNlKGN1cnJlbnRNb250aCwgcHJldmlvdXNNb250aCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChwZXJmb3JtYW5jZS5jdXJyZW50UmV2ZW51ZSkudG9CZSgzMzAwKTtcbiAgICAgIGV4cGVjdChwZXJmb3JtYW5jZS5wcmV2aW91c1JldmVudWUpLnRvQmUoMjAwMCk7XG4gICAgICBleHBlY3QocGVyZm9ybWFuY2UucmV2ZW51ZUdyb3d0aCkudG9CZSg2NSk7XG4gICAgICBleHBlY3QocGVyZm9ybWFuY2UudHJhbnNhY3Rpb25Hcm93dGgpLnRvQmUoNTApO1xuICAgICAgZXhwZWN0KHBlcmZvcm1hbmNlLnRyZW5kKS50b0JlKCd1cCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGdlbmVyYXRlIHNhbGVzIGJ5IGNhdGVnb3J5IGRhdGEnLCAoKSA9PiB7XG4gICAgICBjb25zdCBnZW5lcmF0ZUNhdGVnb3J5QW5hbHlzaXMgPSAoc2FsZXNEYXRhOiBhbnlbXSkgPT4ge1xuICAgICAgICBjb25zdCBjYXRlZ29yeVRvdGFscyA9IHNhbGVzRGF0YS5yZWR1Y2UoKGFjYywgc2FsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gc2FsZS5jYXRlZ29yeSB8fCAnVW5jYXRlZ29yaXplZCc7XG4gICAgICAgICAgYWNjW2NhdGVnb3J5XSA9IChhY2NbY2F0ZWdvcnldIHx8IDApICsgc2FsZS5hbW91bnQ7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0b3RhbFJldmVudWUgPSBPYmplY3QudmFsdWVzKGNhdGVnb3J5VG90YWxzKS5yZWR1Y2UoKHN1bSwgYW1vdW50KSA9PiBzdW0gKyBhbW91bnQsIDApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNhdGVnb3J5VG90YWxzKVxuICAgICAgICAgIC5tYXAoKFtjYXRlZ29yeSwgYW1vdW50XSkgPT4gKHtcbiAgICAgICAgICAgIGNhdGVnb3J5LFxuICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgcGVyY2VudGFnZTogTWF0aC5yb3VuZCgoYW1vdW50IC8gdG90YWxSZXZlbnVlKSAqIDEwMCAqIDEwMCkgLyAxMDBcbiAgICAgICAgICB9KSlcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5hbW91bnQgLSBhLmFtb3VudCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzYWxlc0RhdGEgPSBbXG4gICAgICAgIHsgY2F0ZWdvcnk6ICdFbGVjdHJvbmljcycsIGFtb3VudDogMjAwMCB9LFxuICAgICAgICB7IGNhdGVnb3J5OiAnQ2xvdGhpbmcnLCBhbW91bnQ6IDE1MDAgfSxcbiAgICAgICAgeyBjYXRlZ29yeTogJ0VsZWN0cm9uaWNzJywgYW1vdW50OiAxMDAwIH0sXG4gICAgICAgIHsgY2F0ZWdvcnk6ICdCb29rcycsIGFtb3VudDogNTAwIH0sXG4gICAgICAgIHsgY2F0ZWdvcnk6ICdDbG90aGluZycsIGFtb3VudDogODAwIH1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGFuYWx5c2lzID0gZ2VuZXJhdGVDYXRlZ29yeUFuYWx5c2lzKHNhbGVzRGF0YSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChhbmFseXNpc1swXSkudG9FcXVhbCh7XG4gICAgICAgIGNhdGVnb3J5OiAnRWxlY3Ryb25pY3MnLFxuICAgICAgICBhbW91bnQ6IDMwMDAsXG4gICAgICAgIHBlcmNlbnRhZ2U6IDUxLjcyXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChhbmFseXNpc1sxXSkudG9FcXVhbCh7XG4gICAgICAgIGNhdGVnb3J5OiAnQ2xvdGhpbmcnLFxuICAgICAgICBhbW91bnQ6IDIzMDAsXG4gICAgICAgIHBlcmNlbnRhZ2U6IDM5LjY2XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludmVudG9yeSBBbmFseXRpY3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNhbGN1bGF0ZSBpbnZlbnRvcnkgdHVybm92ZXInLCAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxjdWxhdGVJbnZlbnRvcnlUdXJub3ZlciA9IChjb3N0T2ZHb29kc1NvbGQ6IG51bWJlciwgYXZlcmFnZUludmVudG9yeVZhbHVlOiBudW1iZXIpID0+IHtcbiAgICAgICAgaWYgKGF2ZXJhZ2VJbnZlbnRvcnlWYWx1ZSA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChjb3N0T2ZHb29kc1NvbGQgLyBhdmVyYWdlSW52ZW50b3J5VmFsdWUpICogMTAwKSAvIDEwMDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNhbGN1bGF0ZURheXNJbkludmVudG9yeSA9IChpbnZlbnRvcnlUdXJub3ZlcjogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChpbnZlbnRvcnlUdXJub3ZlciA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCgzNjUgLyBpbnZlbnRvcnlUdXJub3ZlcikgKiAxMDApIC8gMTAwO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgdHVybm92ZXIgPSBjYWxjdWxhdGVJbnZlbnRvcnlUdXJub3ZlcigxMjAwMDAsIDIwMDAwKTtcbiAgICAgIGNvbnN0IGRheXNJbkludmVudG9yeSA9IGNhbGN1bGF0ZURheXNJbkludmVudG9yeSh0dXJub3Zlcik7XG4gICAgICBcbiAgICAgIGV4cGVjdCh0dXJub3ZlcikudG9CZSg2KTtcbiAgICAgIGV4cGVjdChkYXlzSW5JbnZlbnRvcnkpLnRvQmUoNjAuODMpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGlkZW50aWZ5IHNsb3ctbW92aW5nIGludmVudG9yeScsICgpID0+IHtcbiAgICAgIGNvbnN0IGlkZW50aWZ5U2xvd01vdmluZ0l0ZW1zID0gKGludmVudG9yeUl0ZW1zOiBhbnlbXSwgc2FsZXNEYXRhOiBhbnlbXSwgZGF5c1RocmVzaG9sZDogbnVtYmVyID0gOTApID0+IHtcbiAgICAgICAgY29uc3QgaXRlbVNhbGVzID0gc2FsZXNEYXRhLnJlZHVjZSgoYWNjLCBzYWxlKSA9PiB7XG4gICAgICAgICAgc2FsZS5pdGVtcy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGFjY1tpdGVtLnByb2R1Y3RJZF0gPSAoYWNjW2l0ZW0ucHJvZHVjdElkXSB8fCAwKSArIGl0ZW0ucXVhbnRpdHk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIGRheXNUaHJlc2hvbGQgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBpbnZlbnRvcnlJdGVtcy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgY29uc3QgbGFzdFNhbGVRdWFudGl0eSA9IGl0ZW1TYWxlc1tpdGVtLmlkXSB8fCAwO1xuICAgICAgICAgIGNvbnN0IGxhc3RVcGRhdGVkID0gbmV3IERhdGUoaXRlbS5sYXN0VXBkYXRlZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIGxhc3RTYWxlUXVhbnRpdHkgPT09IDAgfHwgbGFzdFVwZGF0ZWQgPCBjdXRvZmZEYXRlO1xuICAgICAgICB9KS5tYXAoaXRlbSA9PiAoe1xuICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgZGF5c1NpbmNlTGFzdFNhbGU6IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBuZXcgRGF0ZShpdGVtLmxhc3RVcGRhdGVkKS5nZXRUaW1lKCkpIC8gKDI0ICogNjAgKiA2MCAqIDEwMDApKSxcbiAgICAgICAgICB0b3RhbFNhbGVzOiBpdGVtU2FsZXNbaXRlbS5pZF0gfHwgMFxuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbnZlbnRvcnlJdGVtcyA9IFtcbiAgICAgICAgeyBpZDogJ2l0ZW0xJywgbmFtZTogJ1Byb2R1Y3QgQScsIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTAwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSB9LFxuICAgICAgICB7IGlkOiAnaXRlbTInLCBuYW1lOiAnUHJvZHVjdCBCJywgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgICAgeyBpZDogJ2l0ZW0zJywgbmFtZTogJ1Byb2R1Y3QgQycsIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTIwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSB9XG4gICAgICBdO1xuICAgICAgXG4gICAgICBjb25zdCBzYWxlc0RhdGEgPSBbXG4gICAgICAgIHsgaXRlbXM6IFt7IHByb2R1Y3RJZDogJ2l0ZW0yJywgcXVhbnRpdHk6IDUgfV0gfVxuICAgICAgXTtcblxuICAgICAgY29uc3Qgc2xvd01vdmluZyA9IGlkZW50aWZ5U2xvd01vdmluZ0l0ZW1zKGludmVudG9yeUl0ZW1zLCBzYWxlc0RhdGEsIDkwKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHNsb3dNb3ZpbmcpLnRvSGF2ZUxlbmd0aCgyKTsgLy8gaXRlbTEgYW5kIGl0ZW0zXG4gICAgICBleHBlY3Qoc2xvd01vdmluZy5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PT0gJ2l0ZW0xJyk/LmRheXNTaW5jZUxhc3RTYWxlKS50b0JlKDEwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgY2FsY3VsYXRlIHN0b2NrIGxldmVsIGFsZXJ0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGdlbmVyYXRlU3RvY2tBbGVydHMgPSAoaW52ZW50b3J5SXRlbXM6IGFueVtdKSA9PiB7XG4gICAgICAgIHJldHVybiBpbnZlbnRvcnlJdGVtcy5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RvY2tMZXZlbCA9IGl0ZW0uY3VycmVudFN0b2NrO1xuICAgICAgICAgIGNvbnN0IHJlb3JkZXJQb2ludCA9IGl0ZW0ucmVvcmRlclBvaW50IHx8IDA7XG4gICAgICAgICAgY29uc3QgbWF4U3RvY2sgPSBpdGVtLm1heFN0b2NrIHx8IDA7XG4gICAgICAgICAgXG4gICAgICAgICAgbGV0IGFsZXJ0VHlwZSA9ICdub3JtYWwnO1xuICAgICAgICAgIGxldCBhbGVydE1lc3NhZ2UgPSAnJztcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc3RvY2tMZXZlbCA8PSAwKSB7XG4gICAgICAgICAgICBhbGVydFR5cGUgPSAnY3JpdGljYWwnO1xuICAgICAgICAgICAgYWxlcnRNZXNzYWdlID0gJ091dCBvZiBzdG9jayc7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9ja0xldmVsIDw9IHJlb3JkZXJQb2ludCkge1xuICAgICAgICAgICAgYWxlcnRUeXBlID0gJ3dhcm5pbmcnO1xuICAgICAgICAgICAgYWxlcnRNZXNzYWdlID0gJ0xvdyBzdG9jayAtIHJlb3JkZXIgbmVlZGVkJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0b2NrTGV2ZWwgPj0gbWF4U3RvY2sgJiYgbWF4U3RvY2sgPiAwKSB7XG4gICAgICAgICAgICBhbGVydFR5cGUgPSAnaW5mbyc7XG4gICAgICAgICAgICBhbGVydE1lc3NhZ2UgPSAnT3ZlcnN0b2NrJztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICBhbGVydFR5cGUsXG4gICAgICAgICAgICBhbGVydE1lc3NhZ2UsXG4gICAgICAgICAgICBzdG9ja1BlcmNlbnRhZ2U6IG1heFN0b2NrID4gMCA/IE1hdGgucm91bmQoKHN0b2NrTGV2ZWwgLyBtYXhTdG9jaykgKiAxMDApIDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLmZpbHRlcihpdGVtID0+IGl0ZW0uYWxlcnRUeXBlICE9PSAnbm9ybWFsJyk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbnZlbnRvcnlJdGVtcyA9IFtcbiAgICAgICAgeyBpZDogJ2l0ZW0xJywgbmFtZTogJ1Byb2R1Y3QgQScsIGN1cnJlbnRTdG9jazogMCwgcmVvcmRlclBvaW50OiAxMCwgbWF4U3RvY2s6IDEwMCB9LFxuICAgICAgICB7IGlkOiAnaXRlbTInLCBuYW1lOiAnUHJvZHVjdCBCJywgY3VycmVudFN0b2NrOiA1LCByZW9yZGVyUG9pbnQ6IDEwLCBtYXhTdG9jazogMTAwIH0sXG4gICAgICAgIHsgaWQ6ICdpdGVtMycsIG5hbWU6ICdQcm9kdWN0IEMnLCBjdXJyZW50U3RvY2s6IDUwLCByZW9yZGVyUG9pbnQ6IDEwLCBtYXhTdG9jazogMTAwIH0sXG4gICAgICAgIHsgaWQ6ICdpdGVtNCcsIG5hbWU6ICdQcm9kdWN0IEQnLCBjdXJyZW50U3RvY2s6IDEyMCwgcmVvcmRlclBvaW50OiAxMCwgbWF4U3RvY2s6IDEwMCB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBhbGVydHMgPSBnZW5lcmF0ZVN0b2NrQWxlcnRzKGludmVudG9yeUl0ZW1zKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGFsZXJ0cykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KGFsZXJ0cy5maW5kKGFsZXJ0ID0+IGFsZXJ0LmlkID09PSAnaXRlbTEnKT8uYWxlcnRUeXBlKS50b0JlKCdjcml0aWNhbCcpO1xuICAgICAgZXhwZWN0KGFsZXJ0cy5maW5kKGFsZXJ0ID0+IGFsZXJ0LmlkID09PSAnaXRlbTInKT8uYWxlcnRUeXBlKS50b0JlKCd3YXJuaW5nJyk7XG4gICAgICBleHBlY3QoYWxlcnRzLmZpbmQoYWxlcnQgPT4gYWxlcnQuaWQgPT09ICdpdGVtNCcpPy5hbGVydFR5cGUpLnRvQmUoJ2luZm8nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZpbmFuY2lhbCBBbmFseXRpY3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNhbGN1bGF0ZSBwcm9maXQgbWFyZ2lucycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZVByb2ZpdE1hcmdpbnMgPSAoc2FsZXNEYXRhOiBhbnlbXSkgPT4ge1xuICAgICAgICByZXR1cm4gc2FsZXNEYXRhLm1hcChzYWxlID0+IHtcbiAgICAgICAgICBjb25zdCByZXZlbnVlID0gc2FsZS5hbW91bnQ7XG4gICAgICAgICAgY29uc3QgY29zdCA9IHNhbGUuY29zdCB8fCAwO1xuICAgICAgICAgIGNvbnN0IHByb2ZpdCA9IHJldmVudWUgLSBjb3N0O1xuICAgICAgICAgIGNvbnN0IG1hcmdpblBlcmNlbnRhZ2UgPSByZXZlbnVlID4gMCA/IE1hdGgucm91bmQoKHByb2ZpdCAvIHJldmVudWUpICogMTAwICogMTAwKSAvIDEwMCA6IDA7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNhbGUsXG4gICAgICAgICAgICBwcm9maXQsXG4gICAgICAgICAgICBtYXJnaW5QZXJjZW50YWdlLFxuICAgICAgICAgICAgcHJvZml0Q2F0ZWdvcnk6IG1hcmdpblBlcmNlbnRhZ2UgPj0gMzAgPyAnaGlnaCcgOiBtYXJnaW5QZXJjZW50YWdlID49IDE1ID8gJ21lZGl1bScgOiAnbG93J1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2FsZXNEYXRhID0gW1xuICAgICAgICB7IGlkOiAxLCBhbW91bnQ6IDEwMDAsIGNvc3Q6IDYwMCB9LFxuICAgICAgICB7IGlkOiAyLCBhbW91bnQ6IDE1MDAsIGNvc3Q6IDEyMDAgfSxcbiAgICAgICAgeyBpZDogMywgYW1vdW50OiA4MDAsIGNvc3Q6IDQwMCB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBtYXJnaW5zID0gY2FsY3VsYXRlUHJvZml0TWFyZ2lucyhzYWxlc0RhdGEpO1xuICAgICAgXG4gICAgICBleHBlY3QobWFyZ2luc1swXS5wcm9maXQpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChtYXJnaW5zWzBdLm1hcmdpblBlcmNlbnRhZ2UpLnRvQmUoNDApO1xuICAgICAgZXhwZWN0KG1hcmdpbnNbMF0ucHJvZml0Q2F0ZWdvcnkpLnRvQmUoJ2hpZ2gnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1hcmdpbnNbMV0ubWFyZ2luUGVyY2VudGFnZSkudG9CZSgyMCk7XG4gICAgICBleHBlY3QobWFyZ2luc1sxXS5wcm9maXRDYXRlZ29yeSkudG9CZSgnbWVkaXVtJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtYXJnaW5zWzJdLm1hcmdpblBlcmNlbnRhZ2UpLnRvQmUoNTApO1xuICAgICAgZXhwZWN0KG1hcmdpbnNbMl0ucHJvZml0Q2F0ZWdvcnkpLnRvQmUoJ2hpZ2gnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBjYWxjdWxhdGUgY2FzaCBmbG93IHByb2plY3Rpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgY2FsY3VsYXRlQ2FzaEZsb3cgPSAodHJhbnNhY3Rpb25zOiBhbnlbXSwgcHJvamVjdGlvbkRheXM6IG51bWJlciA9IDMwKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkRhdGUgPSBuZXcgRGF0ZSh0b2RheS5nZXRUaW1lKCkgKyBwcm9qZWN0aW9uRGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW5mbG93cyA9IHRyYW5zYWN0aW9uc1xuICAgICAgICAgIC5maWx0ZXIodCA9PiB0LnR5cGUgPT09ICdpbmNvbWUnICYmIG5ldyBEYXRlKHQuZHVlRGF0ZSkgPD0gcHJvamVjdGlvbkRhdGUpXG4gICAgICAgICAgLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyB0LmFtb3VudCwgMCk7XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IG91dGZsb3dzID0gdHJhbnNhY3Rpb25zXG4gICAgICAgICAgLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gJ2V4cGVuc2UnICYmIG5ldyBEYXRlKHQuZHVlRGF0ZSkgPD0gcHJvamVjdGlvbkRhdGUpXG4gICAgICAgICAgLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyB0LmFtb3VudCwgMCk7XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IG5ldENhc2hGbG93ID0gaW5mbG93cyAtIG91dGZsb3dzO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcm9qZWN0aW9uUGVyaW9kOiBwcm9qZWN0aW9uRGF5cyxcbiAgICAgICAgICBleHBlY3RlZEluZmxvd3M6IGluZmxvd3MsXG4gICAgICAgICAgZXhwZWN0ZWRPdXRmbG93czogb3V0Zmxvd3MsXG4gICAgICAgICAgbmV0Q2FzaEZsb3csXG4gICAgICAgICAgY2FzaEZsb3dTdGF0dXM6IG5ldENhc2hGbG93ID4gMCA/ICdwb3NpdGl2ZScgOiBuZXRDYXNoRmxvdyA8IDAgPyAnbmVnYXRpdmUnIDogJ25ldXRyYWwnXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBbXG4gICAgICAgIHsgdHlwZTogJ2luY29tZScsIGFtb3VudDogNTAwMCwgZHVlRGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSArIDEwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSB9LFxuICAgICAgICB7IHR5cGU6ICdpbmNvbWUnLCBhbW91bnQ6IDMwMDAsIGR1ZURhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgKyAyMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgICAgeyB0eXBlOiAnZXhwZW5zZScsIGFtb3VudDogMjAwMCwgZHVlRGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSArIDE1ICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSB9LFxuICAgICAgICB7IHR5cGU6ICdleHBlbnNlJywgYW1vdW50OiAxNTAwLCBkdWVEYXRlOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNDAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpIH0gLy8gT3V0c2lkZSAzMC1kYXkgd2luZG93XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBjYXNoRmxvdyA9IGNhbGN1bGF0ZUNhc2hGbG93KHRyYW5zYWN0aW9ucywgMzApO1xuICAgICAgXG4gICAgICBleHBlY3QoY2FzaEZsb3cuZXhwZWN0ZWRJbmZsb3dzKS50b0JlKDgwMDApO1xuICAgICAgZXhwZWN0KGNhc2hGbG93LmV4cGVjdGVkT3V0Zmxvd3MpLnRvQmUoMjAwMCk7XG4gICAgICBleHBlY3QoY2FzaEZsb3cubmV0Q2FzaEZsb3cpLnRvQmUoNjAwMCk7XG4gICAgICBleHBlY3QoY2FzaEZsb3cuY2FzaEZsb3dTdGF0dXMpLnRvQmUoJ3Bvc2l0aXZlJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDdXN0b21lciBBbmFseXRpY3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNhbGN1bGF0ZSBjdXN0b21lciBsaWZldGltZSB2YWx1ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZUN1c3RvbWVyTFRWID0gKGN1c3RvbWVyOiBhbnksIGF2ZXJhZ2VPcmRlclZhbHVlOiBudW1iZXIsIHB1cmNoYXNlRnJlcXVlbmN5OiBudW1iZXIsIGN1c3RvbWVyTGlmZXNwYW46IG51bWJlcikgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhdmVyYWdlT3JkZXJWYWx1ZSAqIHB1cmNoYXNlRnJlcXVlbmN5ICogY3VzdG9tZXJMaWZlc3BhbiAqIDEwMCkgLyAxMDA7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZWdtZW50Q3VzdG9tZXJzID0gKGN1c3RvbWVyczogYW55W10pID0+IHtcbiAgICAgICAgcmV0dXJuIGN1c3RvbWVycy5tYXAoY3VzdG9tZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IHRvdGFsU3BlbnQgPSBjdXN0b21lci5vcmRlcnMucmVkdWNlKChzdW06IG51bWJlciwgb3JkZXI6IGFueSkgPT4gc3VtICsgb3JkZXIuYW1vdW50LCAwKTtcbiAgICAgICAgICBjb25zdCBvcmRlckNvdW50ID0gY3VzdG9tZXIub3JkZXJzLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBhdmdPcmRlclZhbHVlID0gb3JkZXJDb3VudCA+IDAgPyB0b3RhbFNwZW50IC8gb3JkZXJDb3VudCA6IDA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIGRheXMgc2luY2UgZmlyc3Qgb3JkZXJcbiAgICAgICAgICBjb25zdCBmaXJzdE9yZGVyRGF0ZSA9IG5ldyBEYXRlKE1hdGgubWluKC4uLmN1c3RvbWVyLm9yZGVycy5tYXAoKG86IGFueSkgPT4gbmV3IERhdGUoby5kYXRlKS5nZXRUaW1lKCkpKSk7XG4gICAgICAgICAgY29uc3QgZGF5c1NpbmNlRmlyc3QgPSBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gZmlyc3RPcmRlckRhdGUuZ2V0VGltZSgpKSAvICgyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgY29uc3QgcHVyY2hhc2VGcmVxdWVuY3kgPSBkYXlzU2luY2VGaXJzdCA+IDAgPyBvcmRlckNvdW50IC8gKGRheXNTaW5jZUZpcnN0IC8gMzY1KSA6IDA7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbHR2ID0gY2FsY3VsYXRlQ3VzdG9tZXJMVFYoY3VzdG9tZXIsIGF2Z09yZGVyVmFsdWUsIHB1cmNoYXNlRnJlcXVlbmN5LCAyKTsgLy8gMiB5ZWFyIGxpZmVzcGFuXG4gICAgICAgICAgXG4gICAgICAgICAgbGV0IHNlZ21lbnQgPSAnbG93LXZhbHVlJztcbiAgICAgICAgICBpZiAobHR2ID49IDUwMDApIHNlZ21lbnQgPSAnaGlnaC12YWx1ZSc7XG4gICAgICAgICAgZWxzZSBpZiAobHR2ID49IDIwMDApIHNlZ21lbnQgPSAnbWVkaXVtLXZhbHVlJztcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY3VzdG9tZXIsXG4gICAgICAgICAgICB0b3RhbFNwZW50LFxuICAgICAgICAgICAgb3JkZXJDb3VudCxcbiAgICAgICAgICAgIGF2Z09yZGVyVmFsdWU6IE1hdGgucm91bmQoYXZnT3JkZXJWYWx1ZSAqIDEwMCkgLyAxMDAsXG4gICAgICAgICAgICBwdXJjaGFzZUZyZXF1ZW5jeTogTWF0aC5yb3VuZChwdXJjaGFzZUZyZXF1ZW5jeSAqIDEwMCkgLyAxMDAsXG4gICAgICAgICAgICBsdHYsXG4gICAgICAgICAgICBzZWdtZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjdXN0b21lcnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2N1c3QxJyxcbiAgICAgICAgICBuYW1lOiAnSGlnaCBWYWx1ZSBDdXN0b21lcicsXG4gICAgICAgICAgb3JkZXJzOiBbXG4gICAgICAgICAgICB7IGFtb3VudDogMTAwMCwgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgICAgICAgIHsgYW1vdW50OiAxNTAwLCBkYXRlOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMzAwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSB9LFxuICAgICAgICAgICAgeyBhbW91bnQ6IDIwMDAsIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSAyMDAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2N1c3QyJyxcbiAgICAgICAgICBuYW1lOiAnTG93IFZhbHVlIEN1c3RvbWVyJyxcbiAgICAgICAgICBvcmRlcnM6IFtcbiAgICAgICAgICAgIHsgYW1vdW50OiAxMDAsIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSAxMDAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHNlZ21lbnRlZCA9IHNlZ21lbnRDdXN0b21lcnMoY3VzdG9tZXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHNlZ21lbnRlZFswXS50b3RhbFNwZW50KS50b0JlKDQ1MDApO1xuICAgICAgZXhwZWN0KHNlZ21lbnRlZFswXS5vcmRlckNvdW50KS50b0JlKDMpO1xuICAgICAgZXhwZWN0KHNlZ21lbnRlZFswXS5zZWdtZW50KS50b0JlKCdoaWdoLXZhbHVlJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzZWdtZW50ZWRbMV0udG90YWxTcGVudCkudG9CZSgxMDApO1xuICAgICAgZXhwZWN0KHNlZ21lbnRlZFsxXS5zZWdtZW50KS50b0JlKCdsb3ctdmFsdWUnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBpZGVudGlmeSBjdXN0b21lciBjaHVybiByaXNrJywgKCkgPT4ge1xuICAgICAgY29uc3QgaWRlbnRpZnlDaHVyblJpc2sgPSAoY3VzdG9tZXJzOiBhbnlbXSwgZGF5c1NpbmNlTGFzdE9yZGVyOiBudW1iZXIgPSA5MCkgPT4ge1xuICAgICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIGRheXNTaW5jZUxhc3RPcmRlciAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGN1c3RvbWVycy5tYXAoY3VzdG9tZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IGxhc3RPcmRlckRhdGUgPSBuZXcgRGF0ZShNYXRoLm1heCguLi5jdXN0b21lci5vcmRlcnMubWFwKChvOiBhbnkpID0+IG5ldyBEYXRlKG8uZGF0ZSkuZ2V0VGltZSgpKSkpO1xuICAgICAgICAgIGNvbnN0IGRheXNTaW5jZUxhc3QgPSBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gbGFzdE9yZGVyRGF0ZS5nZXRUaW1lKCkpIC8gKDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgY2h1cm5SaXNrID0gJ2xvdyc7XG4gICAgICAgICAgaWYgKGRheXNTaW5jZUxhc3QgPiBkYXlzU2luY2VMYXN0T3JkZXIgKiAyKSBjaHVyblJpc2sgPSAnaGlnaCc7XG4gICAgICAgICAgZWxzZSBpZiAoZGF5c1NpbmNlTGFzdCA+IGRheXNTaW5jZUxhc3RPcmRlcikgY2h1cm5SaXNrID0gJ21lZGl1bSc7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmN1c3RvbWVyLFxuICAgICAgICAgICAgbGFzdE9yZGVyRGF0ZTogbGFzdE9yZGVyRGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZGF5c1NpbmNlTGFzdE9yZGVyOiBkYXlzU2luY2VMYXN0LFxuICAgICAgICAgICAgY2h1cm5SaXNrXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkuZmlsdGVyKGN1c3RvbWVyID0+IGN1c3RvbWVyLmNodXJuUmlzayAhPT0gJ2xvdycpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY3VzdG9tZXJzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdjdXN0MScsXG4gICAgICAgICAgb3JkZXJzOiBbeyBkYXRlOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMjAwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSB9XSAvLyAyMDAgZGF5cyBhZ29cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnY3VzdDInLFxuICAgICAgICAgIG9yZGVyczogW3sgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDUwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSB9XSAvLyA1MCBkYXlzIGFnb1xuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBhdFJpc2sgPSBpZGVudGlmeUNodXJuUmlzayhjdXN0b21lcnMsIDkwKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGF0UmlzaykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KGF0Umlza1swXS5pZCkudG9CZSgnY3VzdDEnKTtcbiAgICAgIGV4cGVjdChhdFJpc2tbMF0uY2h1cm5SaXNrKS50b0JlKCdoaWdoJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEYXNoYm9hcmQgQVBJIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBmZXRjaCBkYXNoYm9hcmQgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZldGNoRGFzaGJvYXJkRGF0YSA9IGFzeW5jIChkYXRlUmFuZ2U6IHN0cmluZyA9ICczMGQnKSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBzYWxlczoge1xuICAgICAgICAgICAgICAgIHRvdGFsUmV2ZW51ZTogMTI1MDAwLFxuICAgICAgICAgICAgICAgIHRvdGFsVHJhbnNhY3Rpb25zOiA0NTAsXG4gICAgICAgICAgICAgICAgYXZlcmFnZU9yZGVyVmFsdWU6IDI3Ny43OCxcbiAgICAgICAgICAgICAgICBncm93dGg6IDE1LjVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaW52ZW50b3J5OiB7XG4gICAgICAgICAgICAgICAgdG90YWxJdGVtczogMTI1MCxcbiAgICAgICAgICAgICAgICBsb3dTdG9ja0l0ZW1zOiAyMyxcbiAgICAgICAgICAgICAgICBvdXRPZlN0b2NrSXRlbXM6IDUsXG4gICAgICAgICAgICAgICAgaW52ZW50b3J5VmFsdWU6IDg1MDAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGN1c3RvbWVyczoge1xuICAgICAgICAgICAgICAgIHRvdGFsQ3VzdG9tZXJzOiA4OTAsXG4gICAgICAgICAgICAgICAgbmV3Q3VzdG9tZXJzOiA0NSxcbiAgICAgICAgICAgICAgICBhY3RpdmVDdXN0b21lcnM6IDIzNCxcbiAgICAgICAgICAgICAgICBjaHVyblJhdGU6IDUuMlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXNoYm9hcmQ/cmFuZ2U9JHtkYXRlUmFuZ2V9YCwge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoRGFzaGJvYXJkRGF0YSgnMzBkJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zYWxlcy50b3RhbFJldmVudWUpLnRvQmUoMTI1MDAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5pbnZlbnRvcnkudG90YWxJdGVtcykudG9CZSgxMjUwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5jdXN0b21lcnMudG90YWxDdXN0b21lcnMpLnRvQmUoODkwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBmZXRjaCBjaGFydCBkYXRhIGZvciBkaWZmZXJlbnQgcGVyaW9kcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZldGNoQ2hhcnREYXRhID0gYXN5bmMgKGNoYXJ0VHlwZTogc3RyaW5nLCBwZXJpb2Q6IHN0cmluZykgPT4ge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGNoYXJ0RGF0YToge1xuICAgICAgICAgICAgICBsYWJlbHM6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heSddLFxuICAgICAgICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1JldmVudWUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IFsxMjAwMCwgMTUwMDAsIDE4MDAwLCAxNjAwMCwgMjAwMDBdXG4gICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9hbmFseXRpY3MvY2hhcnRzLyR7Y2hhcnRUeXBlfT9wZXJpb2Q9JHtwZXJpb2R9YCwge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoQ2hhcnREYXRhKCdyZXZlbnVlJywgJzZtJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY2hhcnREYXRhLmxhYmVscykudG9IYXZlTGVuZ3RoKDUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jaGFydERhdGEuZGF0YXNldHNbMF0uZGF0YSkudG9FcXVhbChbMTIwMDAsIDE1MDAwLCAxODAwMCwgMTYwMDAsIDIwMDAwXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZWFsLXRpbWUgVXBkYXRlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHJlYWwtdGltZSBkYXNoYm9hcmQgdXBkYXRlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNyZWF0ZURhc2hib2FyZFVwZGF0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGxldCBzdWJzY3JpYmVyczogQXJyYXk8KGRhdGE6IGFueSkgPT4gdm9pZD4gPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChjYWxsYmFjazogKGRhdGE6IGFueSkgPT4gdm9pZCkgPT4ge1xuICAgICAgICAgIHN1YnNjcmliZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmZpbHRlcihzdWIgPT4gc3ViICE9PSBjYWxsYmFjayk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdCA9IChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGRhdGEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHN1YnNjcmliZSwgYnJvYWRjYXN0IH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVyID0gY3JlYXRlRGFzaGJvYXJkVXBkYXRlcigpO1xuICAgICAgY29uc3QgbW9ja0NhbGxiYWNrMSA9IGplc3QuZm4oKTtcbiAgICAgIGNvbnN0IG1vY2tDYWxsYmFjazIgPSBqZXN0LmZuKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlMSA9IHVwZGF0ZXIuc3Vic2NyaWJlKG1vY2tDYWxsYmFjazEpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUyID0gdXBkYXRlci5zdWJzY3JpYmUobW9ja0NhbGxiYWNrMik7XG4gICAgICBcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7IHR5cGU6ICdzYWxlc191cGRhdGUnLCB2YWx1ZTogMTAwMCB9O1xuICAgICAgdXBkYXRlci5icm9hZGNhc3QodXBkYXRlRGF0YSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrQ2FsbGJhY2sxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh1cGRhdGVEYXRhKTtcbiAgICAgIGV4cGVjdChtb2NrQ2FsbGJhY2syKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh1cGRhdGVEYXRhKTtcbiAgICAgIFxuICAgICAgdW5zdWJzY3JpYmUxKCk7XG4gICAgICB1cGRhdGVyLmJyb2FkY2FzdCh7IHR5cGU6ICdhbm90aGVyX3VwZGF0ZScsIHZhbHVlOiAyMDAwIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja0NhbGxiYWNrMSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpOyAvLyBTaG91bGQgbm90IGJlIGNhbGxlZCBhZ2FpblxuICAgICAgZXhwZWN0KG1vY2tDYWxsYmFjazIpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTsgLy8gU2hvdWxkIGJlIGNhbGxlZCBhZ2FpblxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRocm90dGxlIGZyZXF1ZW50IHVwZGF0ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjcmVhdGVUaHJvdHRsZWRVcGRhdGVyID0gKGRlbGF5OiBudW1iZXIgPSAxMDAwKSA9PiB7XG4gICAgICAgIGxldCBsYXN0VXBkYXRlID0gMDtcbiAgICAgICAgbGV0IHBlbmRpbmdEYXRhOiBhbnkgPSBudWxsO1xuICAgICAgICBsZXQgdGltZW91dElkOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdXBkYXRlID0gKGRhdGE6IGFueSwgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IHZvaWQpID0+IHtcbiAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHBlbmRpbmdEYXRhID0gZGF0YTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAobm93IC0gbGFzdFVwZGF0ZSA+PSBkZWxheSkge1xuICAgICAgICAgICAgbGFzdFVwZGF0ZSA9IG5vdztcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgcGVuZGluZ0RhdGEgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXRJZCkge1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nRGF0YSkge1xuICAgICAgICAgICAgICAgIGxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBlbmRpbmdEYXRhKTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIH0sIGRlbGF5IC0gKG5vdyAtIGxhc3RVcGRhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyB1cGRhdGUgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tDYWxsYmFjayA9IGplc3QuZm4oKTtcbiAgICAgIGNvbnN0IHVwZGF0ZXIgPSBjcmVhdGVUaHJvdHRsZWRVcGRhdGVyKDEwMCk7XG4gICAgICBcbiAgICAgIC8vIEZpcnN0IHVwZGF0ZSBzaG91bGQgZ28gdGhyb3VnaCBpbW1lZGlhdGVseVxuICAgICAgdXBkYXRlci51cGRhdGUoeyB2YWx1ZTogMSB9LCBtb2NrQ2FsbGJhY2spO1xuICAgICAgZXhwZWN0KG1vY2tDYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgXG4gICAgICAvLyBTdWJzZXF1ZW50IHVwZGF0ZXMgd2l0aGluIGRlbGF5IHNob3VsZCBiZSB0aHJvdHRsZWRcbiAgICAgIHVwZGF0ZXIudXBkYXRlKHsgdmFsdWU6IDIgfSwgbW9ja0NhbGxiYWNrKTtcbiAgICAgIHVwZGF0ZXIudXBkYXRlKHsgdmFsdWU6IDMgfSwgbW9ja0NhbGxiYWNrKTtcbiAgICAgIGV4cGVjdChtb2NrQ2FsbGJhY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTsgLy8gU3RpbGwgb25seSBjYWxsZWQgb25jZVxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZUF1dGgiLCJtb2NrVXNlQXV0aCIsInVzZVJvdXRlciIsInB1c2giLCJmbiIsInJlcGxhY2UiLCJiYWNrIiwiZm9yd2FyZCIsInJlZnJlc2giLCJwcmVmZXRjaCIsIm1vY2tGZXRjaCIsImdsb2JhbCIsImZldGNoIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid2luZG93IiwidmFsdWUiLCJnZXRJdGVtIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJ3cml0YWJsZSIsIm1vY2tSZXR1cm5WYWx1ZSIsInVzZXIiLCJpZCIsIm5hbWUiLCJlbWFpbCIsInBlcm1pc3Npb25zIiwiaXNMb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwibG9naW4iLCJsb2dvdXQiLCJoYXNQZXJtaXNzaW9uIiwicGVybWlzc2lvbiIsInVzZXJQZXJtaXNzaW9ucyIsImluY2x1ZGVzIiwidGVzdCIsImNhbGN1bGF0ZVNhbGVzTWV0cmljcyIsInNhbGVzRGF0YSIsInRvdGFsUmV2ZW51ZSIsInJlZHVjZSIsInN1bSIsInNhbGUiLCJhbW91bnQiLCJ0b3RhbFRyYW5zYWN0aW9ucyIsImxlbmd0aCIsImF2ZXJhZ2VPcmRlclZhbHVlIiwidG9kYXkiLCJEYXRlIiwidG9kYXlTYWxlcyIsImZpbHRlciIsInNhbGVEYXRlIiwiZGF0ZSIsInRvRGF0ZVN0cmluZyIsInRoaXNNb250aCIsImdldE1vbnRoIiwiZ2V0RnVsbFllYXIiLCJNYXRoIiwicm91bmQiLCJ0b2RheVJldmVudWUiLCJtb250aGx5UmV2ZW51ZSIsInRvZGF5VHJhbnNhY3Rpb25zIiwibW9udGhseVRyYW5zYWN0aW9ucyIsInRvSVNPU3RyaW5nIiwibm93IiwibWV0cmljcyIsImV4cGVjdCIsInRvQmUiLCJjYWxjdWxhdGVHcm93dGhSYXRlIiwiY3VycmVudCIsInByZXZpb3VzIiwiY29tcGFyZVBlcmZvcm1hbmNlIiwiY3VycmVudFBlcmlvZCIsInByZXZpb3VzUGVyaW9kIiwiY3VycmVudFJldmVudWUiLCJwcmV2aW91c1JldmVudWUiLCJyZXZlbnVlR3Jvd3RoIiwidHJhbnNhY3Rpb25Hcm93dGgiLCJ0cmVuZCIsImN1cnJlbnRNb250aCIsInByZXZpb3VzTW9udGgiLCJwZXJmb3JtYW5jZSIsImdlbmVyYXRlQ2F0ZWdvcnlBbmFseXNpcyIsImNhdGVnb3J5VG90YWxzIiwiYWNjIiwiY2F0ZWdvcnkiLCJ2YWx1ZXMiLCJlbnRyaWVzIiwibWFwIiwicGVyY2VudGFnZSIsInNvcnQiLCJhIiwiYiIsImFuYWx5c2lzIiwidG9FcXVhbCIsImNhbGN1bGF0ZUludmVudG9yeVR1cm5vdmVyIiwiY29zdE9mR29vZHNTb2xkIiwiYXZlcmFnZUludmVudG9yeVZhbHVlIiwiY2FsY3VsYXRlRGF5c0luSW52ZW50b3J5IiwiaW52ZW50b3J5VHVybm92ZXIiLCJ0dXJub3ZlciIsImRheXNJbkludmVudG9yeSIsImlkZW50aWZ5U2xvd01vdmluZ0l0ZW1zIiwiaW52ZW50b3J5SXRlbXMiLCJkYXlzVGhyZXNob2xkIiwiaXRlbVNhbGVzIiwiaXRlbXMiLCJmb3JFYWNoIiwiaXRlbSIsInByb2R1Y3RJZCIsInF1YW50aXR5IiwiY3V0b2ZmRGF0ZSIsImxhc3RTYWxlUXVhbnRpdHkiLCJsYXN0VXBkYXRlZCIsImRheXNTaW5jZUxhc3RTYWxlIiwiZmxvb3IiLCJnZXRUaW1lIiwidG90YWxTYWxlcyIsInNsb3dNb3ZpbmciLCJ0b0hhdmVMZW5ndGgiLCJmaW5kIiwiZ2VuZXJhdGVTdG9ja0FsZXJ0cyIsInN0b2NrTGV2ZWwiLCJjdXJyZW50U3RvY2siLCJyZW9yZGVyUG9pbnQiLCJtYXhTdG9jayIsImFsZXJ0VHlwZSIsImFsZXJ0TWVzc2FnZSIsInN0b2NrUGVyY2VudGFnZSIsImFsZXJ0cyIsImFsZXJ0IiwiY2FsY3VsYXRlUHJvZml0TWFyZ2lucyIsInJldmVudWUiLCJjb3N0IiwicHJvZml0IiwibWFyZ2luUGVyY2VudGFnZSIsInByb2ZpdENhdGVnb3J5IiwibWFyZ2lucyIsImNhbGN1bGF0ZUNhc2hGbG93IiwidHJhbnNhY3Rpb25zIiwicHJvamVjdGlvbkRheXMiLCJwcm9qZWN0aW9uRGF0ZSIsImluZmxvd3MiLCJ0IiwidHlwZSIsImR1ZURhdGUiLCJvdXRmbG93cyIsIm5ldENhc2hGbG93IiwicHJvamVjdGlvblBlcmlvZCIsImV4cGVjdGVkSW5mbG93cyIsImV4cGVjdGVkT3V0Zmxvd3MiLCJjYXNoRmxvd1N0YXR1cyIsImNhc2hGbG93IiwiY2FsY3VsYXRlQ3VzdG9tZXJMVFYiLCJjdXN0b21lciIsInB1cmNoYXNlRnJlcXVlbmN5IiwiY3VzdG9tZXJMaWZlc3BhbiIsInNlZ21lbnRDdXN0b21lcnMiLCJjdXN0b21lcnMiLCJ0b3RhbFNwZW50Iiwib3JkZXJzIiwib3JkZXIiLCJvcmRlckNvdW50IiwiYXZnT3JkZXJWYWx1ZSIsImZpcnN0T3JkZXJEYXRlIiwibWluIiwibyIsImRheXNTaW5jZUZpcnN0IiwibHR2Iiwic2VnbWVudCIsInNlZ21lbnRlZCIsImlkZW50aWZ5Q2h1cm5SaXNrIiwiZGF5c1NpbmNlTGFzdE9yZGVyIiwibGFzdE9yZGVyRGF0ZSIsIm1heCIsImRheXNTaW5jZUxhc3QiLCJjaHVyblJpc2siLCJhdFJpc2siLCJmZXRjaERhc2hib2FyZERhdGEiLCJkYXRlUmFuZ2UiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJvayIsImpzb24iLCJzdWNjZXNzIiwiZGF0YSIsInNhbGVzIiwiZ3Jvd3RoIiwiaW52ZW50b3J5IiwidG90YWxJdGVtcyIsImxvd1N0b2NrSXRlbXMiLCJvdXRPZlN0b2NrSXRlbXMiLCJpbnZlbnRvcnlWYWx1ZSIsInRvdGFsQ3VzdG9tZXJzIiwibmV3Q3VzdG9tZXJzIiwiYWN0aXZlQ3VzdG9tZXJzIiwiY2h1cm5SYXRlIiwicmVzcG9uc2UiLCJoZWFkZXJzIiwicmVzdWx0IiwiZmV0Y2hDaGFydERhdGEiLCJjaGFydFR5cGUiLCJwZXJpb2QiLCJjaGFydERhdGEiLCJsYWJlbHMiLCJkYXRhc2V0cyIsImxhYmVsIiwiY3JlYXRlRGFzaGJvYXJkVXBkYXRlciIsInN1YnNjcmliZXJzIiwic3Vic2NyaWJlIiwiY2FsbGJhY2siLCJzdWIiLCJicm9hZGNhc3QiLCJ1cGRhdGVyIiwibW9ja0NhbGxiYWNrMSIsIm1vY2tDYWxsYmFjazIiLCJ1bnN1YnNjcmliZTEiLCJ1bnN1YnNjcmliZTIiLCJ1cGRhdGVEYXRhIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJjcmVhdGVUaHJvdHRsZWRVcGRhdGVyIiwiZGVsYXkiLCJsYXN0VXBkYXRlIiwicGVuZGluZ0RhdGEiLCJ0aW1lb3V0SWQiLCJ1cGRhdGUiLCJzZXRUaW1lb3V0IiwibW9ja0NhbGxiYWNrIl0sIm1hcHBpbmdzIjoiO0FBS0FBLEtBQUtDLElBQUksQ0FBQyxtQkFBbUIsSUFBTyxDQUFBO1FBQ2xDQyxTQUFTLElBQU1DO0lBQ2pCLENBQUE7QUFFQSx1QkFBdUI7QUFDdkJILEtBQUtDLElBQUksQ0FBQyxtQkFBbUIsSUFBTyxDQUFBO1FBQ2xDRyxXQUFXLElBQU8sQ0FBQTtnQkFDaEJDLE1BQU1MLEtBQUtNLEVBQUU7Z0JBQ2JDLFNBQVNQLEtBQUtNLEVBQUU7Z0JBQ2hCRSxNQUFNUixLQUFLTSxFQUFFO2dCQUNiRyxTQUFTVCxLQUFLTSxFQUFFO2dCQUNoQkksU0FBU1YsS0FBS00sRUFBRTtnQkFDaEJLLFVBQVVYLEtBQUtNLEVBQUU7WUFDbkIsQ0FBQTtJQUNGLENBQUE7Ozs7UUFsQk87QUFFUCx3QkFBd0I7QUFDeEIsTUFBTUgsY0FBY0gsS0FBS00sRUFBRTtBQWlCM0Isc0JBQXNCO0FBQ3RCLE1BQU1NLFlBQVlaLEtBQUtNLEVBQUU7QUFDekJPLE9BQU9DLEtBQUssR0FBR0Y7QUFFZkcsU0FBUyxrQ0FBa0M7SUFDekNDLFdBQVc7UUFDVGhCLEtBQUtpQixhQUFhO1FBRWxCLG9CQUFvQjtRQUNwQkMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRLGdCQUFnQjtZQUM1Q0MsT0FBTztnQkFDTEMsU0FBU3RCLEtBQUtNLEVBQUUsQ0FBQyxJQUFNO2dCQUN2QmlCLFNBQVN2QixLQUFLTSxFQUFFO2dCQUNoQmtCLFlBQVl4QixLQUFLTSxFQUFFO1lBQ3JCO1lBQ0FtQixVQUFVO1FBQ1o7UUFFQSx1Q0FBdUM7UUFDdkN0QixZQUFZdUIsZUFBZSxDQUFDO1lBQzFCQyxNQUFNO2dCQUNKQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxhQUFhO29CQUFDO29CQUFrQjtvQkFBa0I7b0JBQWdCO29CQUFjO2lCQUFpQjtZQUNuRztZQUNBQyxX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