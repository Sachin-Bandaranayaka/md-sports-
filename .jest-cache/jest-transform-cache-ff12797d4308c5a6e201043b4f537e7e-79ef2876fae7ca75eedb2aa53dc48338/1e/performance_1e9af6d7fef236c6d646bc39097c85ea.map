{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/lib/performance.ts"],"sourcesContent":["/**\n * Performance monitoring utility for tracking function execution times\n * and identifying performance bottlenecks\n */\n\n// Node.js compatible performance timing\nconst getPerformanceNow = (): number => {\n  if (typeof performance !== 'undefined' && performance.now) {\n    // Browser environment\n    return performance.now();\n  } else {\n    // Node.js environment\n    const hrTime = process.hrtime();\n    return hrTime[0] * 1000 + hrTime[1] / 1000000;\n  }\n};\n\ninterface PerformanceMetric {\n  name: string;\n  duration: number;\n  timestamp: Date;\n  metadata?: Record<string, any>;\n}\n\nclass PerformanceMonitor {\n  private metrics: PerformanceMetric[] = [];\n  private timers: Map<string, number> = new Map();\n  private enabled: boolean = process.env.NODE_ENV === 'development';\n\n  /**\n   * Start timing a function or operation\n   * @param name - Unique identifier for the timer\n   * @param metadata - Optional metadata to store with the metric\n   */\n  startTimer(name: string, metadata?: Record<string, any>): void {\n    if (!this.enabled) return;\n\n    this.timers.set(name, getPerformanceNow());\n    if (metadata) {\n      console.log(`‚è±Ô∏è  Started: ${name}`, metadata);\n    }\n  }\n\n  /**\n   * End timing and record the metric\n   * @param name - Timer identifier\n   * @param metadata - Optional metadata to store with the metric\n   * @returns Duration in milliseconds\n   */\n  endTimer(name: string, metadata?: Record<string, any>): number {\n    if (!this.enabled) return 0;\n\n    const startTime = this.timers.get(name);\n    if (!startTime) {\n      console.warn(`‚ö†Ô∏è  Timer '${name}' was not started`);\n      return 0;\n    }\n\n    const duration = getPerformanceNow() - startTime;\n    this.timers.delete(name);\n\n    const metric: PerformanceMetric = {\n      name,\n      duration,\n      timestamp: new Date(),\n      metadata\n    };\n\n    this.metrics.push(metric);\n\n    // Log performance metric\n    const color = duration > 1000 ? 'üî¥' : duration > 500 ? 'üü°' : 'üü¢';\n    console.log(`${color} Completed: ${name} - ${duration.toFixed(2)}ms`, metadata);\n\n    return duration;\n  }\n\n  /**\n   * Measure the execution time of an async function\n   * @param name - Identifier for the measurement\n   * @param fn - Async function to measure\n   * @param metadata - Optional metadata\n   * @returns Promise with the function result\n   */\n  async measureAsync<T>(\n    name: string,\n    fn: () => Promise<T>,\n    metadata?: Record<string, any>\n  ): Promise<T> {\n    if (!this.enabled) return fn();\n\n    this.startTimer(name, metadata);\n    try {\n      const result = await fn();\n      this.endTimer(name, { ...metadata, success: true });\n      return result;\n    } catch (error) {\n      this.endTimer(name, { ...metadata, success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n      throw error;\n    }\n  }\n\n  /**\n   * Measure the execution time of a synchronous function\n   * @param name - Identifier for the measurement\n   * @param fn - Function to measure\n   * @param metadata - Optional metadata\n   * @returns Function result\n   */\n  measureSync<T>(\n    name: string,\n    fn: () => T,\n    metadata?: Record<string, any>\n  ): T {\n    if (!this.enabled) return fn();\n\n    this.startTimer(name, metadata);\n    try {\n      const result = fn();\n      this.endTimer(name, { ...metadata, success: true });\n      return result;\n    } catch (error) {\n      this.endTimer(name, { ...metadata, success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n      throw error;\n    }\n  }\n\n  /**\n   * Get all recorded metrics\n   * @returns Array of performance metrics\n   */\n  getMetrics(): PerformanceMetric[] {\n    return [...this.metrics];\n  }\n\n  /**\n   * Get metrics filtered by name pattern\n   * @param pattern - String or regex pattern to match\n   * @returns Filtered metrics\n   */\n  getMetricsByName(pattern: string | RegExp): PerformanceMetric[] {\n    const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;\n    return this.metrics.filter(metric => regex.test(metric.name));\n  }\n\n  /**\n   * Get performance statistics for a specific metric name\n   * @param name - Metric name\n   * @returns Statistics object\n   */\n  getStats(name: string): {\n    count: number;\n    avg: number;\n    min: number;\n    max: number;\n    total: number;\n  } {\n    const metrics = this.metrics.filter(m => m.name === name);\n\n    if (metrics.length === 0) {\n      return { count: 0, avg: 0, min: 0, max: 0, total: 0 };\n    }\n\n    const durations = metrics.map(m => m.duration);\n    const total = durations.reduce((sum, d) => sum + d, 0);\n\n    return {\n      count: metrics.length,\n      avg: total / metrics.length,\n      min: Math.min(...durations),\n      max: Math.max(...durations),\n      total\n    };\n  }\n\n  /**\n   * Clear all recorded metrics\n   */\n  clearMetrics(): void {\n    this.metrics = [];\n    this.timers.clear();\n  }\n\n  /**\n   * Generate a performance report\n   * @returns Formatted performance report\n   */\n  generateReport(): string {\n    if (this.metrics.length === 0) {\n      return 'No performance metrics recorded.';\n    }\n\n    const uniqueNames = [...new Set(this.metrics.map(m => m.name))];\n    const report = ['\\nüìä Performance Report', '='.repeat(50)];\n\n    uniqueNames.forEach(name => {\n      const stats = this.getStats(name);\n      report.push(\n        `\\nüîç ${name}:`,\n        `   Count: ${stats.count}`,\n        `   Average: ${stats.avg.toFixed(2)}ms`,\n        `   Min: ${stats.min.toFixed(2)}ms`,\n        `   Max: ${stats.max.toFixed(2)}ms`,\n        `   Total: ${stats.total.toFixed(2)}ms`\n      );\n    });\n\n    return report.join('\\n');\n  }\n\n  /**\n   * Enable or disable performance monitoring\n   * @param enabled - Whether to enable monitoring\n   */\n  setEnabled(enabled: boolean): void {\n    this.enabled = enabled;\n  }\n\n  /**\n   * Check if performance monitoring is enabled\n   * @returns True if enabled\n   */\n  isEnabled(): boolean {\n    return this.enabled;\n  }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Export convenience functions\nexport const startTimer = (name: string, metadata?: Record<string, any>) =>\n  performanceMonitor.startTimer(name, metadata);\n\nexport const endTimer = (name: string, metadata?: Record<string, any>) =>\n  performanceMonitor.endTimer(name, metadata);\n\nexport const measureAsync = <T>(\n  name: string,\n  fn: () => Promise<T>,\n  metadata?: Record<string, any>\n) => performanceMonitor.measureAsync(name, fn, metadata);\n\nexport const measureSync = <T>(\n  name: string,\n  fn: () => T,\n  metadata?: Record<string, any>\n) => performanceMonitor.measureSync(name, fn, metadata);\n\n// Export types and classes\nexport type { PerformanceMetric };\nexport { PerformanceMonitor };\n\n// Export singleton instance\nexport const performance = {\n  monitor: performanceMonitor,\n  startTimer,\n  endTimer,\n  measureAsync,\n  measureSync\n};"],"names":["PerformanceMonitor","endTimer","measureAsync","measureSync","performance","performanceMonitor","startTimer","getPerformanceNow","now","hrTime","process","hrtime","name","metadata","enabled","timers","set","console","log","startTime","get","warn","duration","delete","metric","timestamp","Date","metrics","push","color","toFixed","fn","result","success","error","Error","message","getMetrics","getMetricsByName","pattern","regex","RegExp","filter","test","getStats","m","length","count","avg","min","max","total","durations","map","reduce","sum","d","Math","clearMetrics","clear","generateReport","uniqueNames","Set","report","repeat","forEach","stats","join","setEnabled","isEnabled","Map","env","NODE_ENV","monitor"],"mappings":"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"}