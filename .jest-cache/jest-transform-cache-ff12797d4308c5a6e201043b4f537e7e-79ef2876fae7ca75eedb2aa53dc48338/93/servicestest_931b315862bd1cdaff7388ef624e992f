c98d6ebe9347f2097db631a86aa8888b
// Mock the Product model
"use strict";
// Mock the models
jest.mock("@/lib/models/Product", ()=>mockProduct);
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _productService = require("../../src/services/productService");
const _auditService = require("../../src/services/auditService");
const _refreshTokenService = /*#__PURE__*/ _interop_require_wildcard(require("../../src/services/refreshTokenService"));
const _prisma = require("../../src/lib/prisma");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const mockProduct = {
    findAll: jest.fn(),
    findOne: jest.fn(),
    findByPk: jest.fn(),
    create: jest.fn(),
    update: jest.fn(),
    destroy: jest.fn(),
    count: jest.fn()
};
// Get the mocked prisma instance
const mockPrisma = _prisma.prisma;
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Service Layer Tests", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("ProductService", ()=>{
        const mockProductData = {
            id: 1,
            name: "Test Product",
            description: "Test Description",
            price: 99.99,
            costPrice: 50.00,
            sku: "TEST-001",
            isActive: true,
            createdAt: new Date(),
            updatedAt: new Date()
        };
        describe("getAllProducts", ()=>{
            it("should fetch all active products successfully", async ()=>{
                const mockProducts = [
                    mockProductData,
                    {
                        ...mockProductData,
                        id: 2,
                        name: "Product 2"
                    }
                ];
                mockProduct.findAll.mockResolvedValue(mockProducts);
                const result = await _productService.productService.getAllProducts();
                expect(mockProduct.findAll).toHaveBeenCalledWith({
                    where: {
                        isActive: true
                    }
                });
                expect(result).toEqual(mockProducts);
                expect(result).toHaveLength(2);
            });
            it("should handle database errors gracefully", async ()=>{
                const dbError = new Error("Database connection failed");
                mockProduct.findAll.mockRejectedValue(dbError);
                await expect(_productService.productService.getAllProducts()).rejects.toThrow("Database connection failed");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error fetching products:", dbError);
            });
            it("should return empty array when no products found", async ()=>{
                mockProduct.findAll.mockResolvedValue([]);
                const result = await _productService.productService.getAllProducts();
                expect(result).toEqual([]);
                expect(result).toHaveLength(0);
            });
        });
        describe("getProductById", ()=>{
            it("should fetch product by id successfully", async ()=>{
                mockProduct.findOne.mockResolvedValue(mockProductData);
                const result = await _productService.productService.getProductById(1);
                expect(mockProduct.findOne).toHaveBeenCalledWith({
                    where: {
                        id: 1,
                        isActive: true
                    }
                });
                expect(result).toEqual(mockProductData);
            });
            it("should return null for non-existent product", async ()=>{
                mockProduct.findOne.mockResolvedValue(null);
                const result = await _productService.productService.getProductById(999);
                expect(result).toBeNull();
            });
            it("should handle database errors", async ()=>{
                const dbError = new Error("Product not found");
                mockProduct.findOne.mockRejectedValue(dbError);
                await expect(_productService.productService.getProductById(1)).rejects.toThrow("Product not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error fetching product with ID 1:", dbError);
            });
        });
        describe("createProduct", ()=>{
            it("should create a new product successfully", async ()=>{
                const newProductData = {
                    name: "New Product",
                    description: "New Description",
                    price: 149.99,
                    costPrice: 75.00,
                    sku: "NEW-001"
                };
                const createdProduct = {
                    ...mockProductData,
                    ...newProductData,
                    id: 3
                };
                mockProduct.create.mockResolvedValue(createdProduct);
                const result = await _productService.productService.createProduct(newProductData);
                expect(mockProduct.create).toHaveBeenCalledWith(newProductData);
                expect(result).toEqual(createdProduct);
            });
            it("should handle validation errors", async ()=>{
                const validationError = new Error("Validation failed: name is required");
                mockProduct.create.mockRejectedValue(validationError);
                await expect(_productService.productService.createProduct({})).rejects.toThrow("Validation failed: name is required");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error creating product:", validationError);
            });
            it("should handle duplicate SKU errors", async ()=>{
                const duplicateError = new Error("SKU already exists");
                mockProduct.create.mockRejectedValue(duplicateError);
                const duplicateData = {
                    name: "Test",
                    sku: "EXISTING-SKU"
                };
                await expect(_productService.productService.createProduct(duplicateData)).rejects.toThrow("SKU already exists");
            });
        });
        describe("updateProduct", ()=>{
            it("should update product successfully", async ()=>{
                const updateData = {
                    name: "Updated Product",
                    price: 199.99
                };
                const mockProductInstance = {
                    ...mockProductData,
                    update: jest.fn().mockResolvedValue({
                        ...mockProductData,
                        ...updateData
                    })
                };
                mockProduct.findByPk.mockResolvedValue(mockProductInstance);
                const result = await _productService.productService.updateProduct(1, updateData);
                expect(mockProduct.findByPk).toHaveBeenCalledWith(1);
                expect(mockProductInstance.update).toHaveBeenCalledWith(updateData);
                expect(result).toEqual({
                    ...mockProductData,
                    ...updateData
                });
            });
            it("should throw error for non-existent product", async ()=>{
                mockProduct.findByPk.mockResolvedValue(null);
                await expect(_productService.productService.updateProduct(999, {
                    name: "Updated"
                })).rejects.toThrow("Product with ID 999 not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error updating product with ID 999:", expect.any(Error));
            });
            it("should handle database update errors", async ()=>{
                const mockProductInstance = {
                    update: jest.fn().mockRejectedValue(new Error("Update failed"))
                };
                mockProduct.findByPk.mockResolvedValue(mockProductInstance);
                await expect(_productService.productService.updateProduct(1, {
                    name: "Updated"
                })).rejects.toThrow("Update failed");
            });
        });
        describe("deleteProduct", ()=>{
            it("should soft delete product successfully", async ()=>{
                const mockProductInstance = {
                    ...mockProductData,
                    update: jest.fn().mockResolvedValue({
                        ...mockProductData,
                        isActive: false
                    })
                };
                mockProduct.findByPk.mockResolvedValue(mockProductInstance);
                const result = await _productService.productService.deleteProduct(1);
                expect(mockProduct.findByPk).toHaveBeenCalledWith(1);
                expect(mockProductInstance.update).toHaveBeenCalledWith({
                    isActive: false
                });
                expect(result).toEqual({
                    ...mockProductData,
                    isActive: false
                });
            });
            it("should throw error for non-existent product", async ()=>{
                mockProduct.findByPk.mockResolvedValue(null);
                await expect(_productService.productService.deleteProduct(999)).rejects.toThrow("Product with ID 999 not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error deleting product with ID 999:", expect.any(Error));
            });
        });
    });
    describe("AuditService", ()=>{
        const mockAuditData = {
            id: 1,
            userId: 1,
            action: "CREATE",
            entity: "Product",
            entityId: 1,
            details: {
                name: "Test Product"
            },
            createdAt: new Date()
        };
        describe("logAction", ()=>{
            it("should log audit action successfully", async ()=>{
                mockPrisma.auditLog.create.mockResolvedValue(mockAuditData);
                await _auditService.auditService.logAction({
                    userId: 1,
                    action: "CREATE",
                    entity: "Product",
                    entityId: 1,
                    details: {
                        name: "Test Product"
                    }
                });
                expect(mockPrisma.auditLog.create).toHaveBeenCalledWith({
                    data: {
                        userId: 1,
                        action: "CREATE",
                        entity: "Product",
                        entityId: 1,
                        details: {
                            name: "Test Product",
                            originalData: undefined,
                            isDeleted: false,
                            deletedAt: undefined,
                            deletedBy: undefined,
                            canRecover: false,
                            recoveredAt: undefined,
                            recoveredBy: undefined
                        }
                    }
                });
            });
            it("should handle audit logging errors gracefully", async ()=>{
                const auditError = new Error("Audit log failed");
                mockPrisma.auditLog.create.mockRejectedValue(auditError);
                // Should not throw error, just log it
                await _auditService.auditService.logAction({
                    userId: 1,
                    action: "CREATE",
                    entity: "Product"
                });
                expect(consoleSpy.error).toHaveBeenCalledWith("Failed to log audit entry:", auditError);
            });
        });
    // Note: getAuditLogs and cleanupOldLogs methods don't exist in the actual auditService
    // These tests have been removed to match the actual implementation
    });
    describe("RefreshTokenService", ()=>{
        const mockRefreshToken = {
            id: 1,
            token: "refresh-token-123",
            userId: 1,
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
            createdAt: new Date(),
            isRevoked: false
        };
        describe("generateRefreshToken", ()=>{
            it("should generate refresh token successfully", async ()=>{
                mockPrisma.refreshToken.create.mockResolvedValue(mockRefreshToken);
                const result = await _refreshTokenService.generateRefreshToken(1);
                expect(mockPrisma.refreshToken.create).toHaveBeenCalledWith({
                    data: {
                        userId: 1,
                        token: expect.any(String),
                        expiresAt: expect.any(Date)
                    }
                });
                expect(result).toEqual(expect.any(String));
            });
            it("should handle creation errors", async ()=>{
                const createError = new Error("Token creation failed");
                mockPrisma.refreshToken.create.mockRejectedValue(createError);
                await expect(_refreshTokenService.generateRefreshToken(1)).rejects.toThrow("Token creation failed");
            });
        });
        describe("verifyRefreshToken", ()=>{
            it("should verify valid refresh token", async ()=>{
                mockPrisma.refreshToken.findUnique.mockResolvedValue(mockRefreshToken);
                const result = await _refreshTokenService.verifyRefreshToken("refresh-token-123");
                expect(mockPrisma.refreshToken.findUnique).toHaveBeenCalledWith({
                    where: {
                        token: "refresh-token-123"
                    }
                });
                expect(result).toEqual(1);
            });
            it("should return null for invalid token", async ()=>{
                mockPrisma.refreshToken.findUnique.mockResolvedValue(null);
                const result = await _refreshTokenService.verifyRefreshToken("invalid-token");
                expect(result).toBeNull();
            });
            it("should return null for expired token", async ()=>{
                const expiredToken = {
                    ...mockRefreshToken,
                    expiresAt: new Date(Date.now() - 1000)
                };
                mockPrisma.refreshToken.findUnique.mockResolvedValue(expiredToken);
                mockPrisma.refreshToken.update.mockResolvedValue(expiredToken);
                const result = await _refreshTokenService.verifyRefreshToken("expired-token");
                expect(result).toBeNull();
            });
        });
        describe("revokeRefreshToken", ()=>{
            it("should revoke refresh token successfully", async ()=>{
                mockPrisma.refreshToken.updateMany.mockResolvedValue({
                    count: 1
                });
                const result = await _refreshTokenService.revokeRefreshToken("refresh-token-123");
                expect(mockPrisma.refreshToken.updateMany).toHaveBeenCalledWith({
                    where: {
                        token: "refresh-token-123"
                    },
                    data: {
                        isRevoked: true
                    }
                });
                expect(result).toBe(true);
            });
            it("should handle errors gracefully", async ()=>{
                const revokeError = new Error("Database error");
                mockPrisma.refreshToken.updateMany.mockRejectedValue(revokeError);
                const result = await _refreshTokenService.revokeRefreshToken("non-existent");
                expect(result).toBe(false);
            });
        });
        describe("revokeAllUserRefreshTokens", ()=>{
            it("should revoke all tokens for user", async ()=>{
                mockPrisma.refreshToken.updateMany.mockResolvedValue({
                    count: 3
                });
                const result = await _refreshTokenService.revokeAllUserRefreshTokens(1);
                expect(mockPrisma.refreshToken.updateMany).toHaveBeenCalledWith({
                    where: {
                        userId: 1
                    },
                    data: {
                        isRevoked: true
                    }
                });
                expect(result).toBe(true);
            });
        });
        describe("cleanupRefreshTokens", ()=>{
            it("should cleanup expired tokens", async ()=>{
                mockPrisma.refreshToken.deleteMany.mockResolvedValue({
                    count: 10
                });
                await _refreshTokenService.cleanupRefreshTokens();
                expect(mockPrisma.refreshToken.deleteMany).toHaveBeenCalledWith({
                    where: {
                        OR: [
                            {
                                expiresAt: {
                                    lt: expect.any(Date)
                                }
                            },
                            {
                                isRevoked: true
                            }
                        ]
                    }
                });
            });
        });
    });
    describe("Service Integration Tests", ()=>{
        it("should handle service dependencies correctly", async ()=>{
            // Test interaction between services
            const productData = {
                name: "Test Product",
                price: 99.99
            };
            const createdProduct = {
                id: 5,
                name: "Test Product",
                price: 99.99,
                description: "Test description",
                category: "Test Category",
                stock: 10,
                createdAt: new Date(),
                updatedAt: new Date()
            };
            mockProduct.create.mockResolvedValue(createdProduct);
            mockPrisma.auditLog.create.mockResolvedValue({
                id: 1,
                userId: 1,
                action: "CREATE",
                entity: "Product",
                entityId: 5,
                details: productData,
                createdAt: new Date()
            });
            // Create product
            const product = await _productService.productService.createProduct(productData);
            // Log audit action
            await _auditService.auditService.logAction({
                userId: 1,
                action: "CREATE",
                entity: "Product",
                entityId: product.id,
                details: productData
            });
            expect(product).toEqual(createdProduct);
            expect(mockPrisma.auditLog.create).toHaveBeenCalled();
        });
        it("should handle service error propagation", async ()=>{
            const dbError = new Error("Database connection lost");
            mockProduct.findAll.mockRejectedValue(dbError);
            mockPrisma.auditLog.create.mockRejectedValue(dbError);
            // Both services should handle errors independently
            await expect(_productService.productService.getAllProducts()).rejects.toThrow("Database connection lost");
            await _auditService.auditService.logAction({
                userId: 1,
                action: "READ",
                entity: "Product"
            });
            // Audit service handles errors gracefully, so no exception should be thrown
            expect(mockPrisma.auditLog.create).toHaveBeenCalled();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9zZXJ2aWNlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1vY2sgdGhlIFByb2R1Y3QgbW9kZWxcbmNvbnN0IG1vY2tQcm9kdWN0ID0ge1xuICBmaW5kQWxsOiBqZXN0LmZuKCksXG4gIGZpbmRPbmU6IGplc3QuZm4oKSxcbiAgZmluZEJ5UGs6IGplc3QuZm4oKSxcbiAgY3JlYXRlOiBqZXN0LmZuKCksXG4gIHVwZGF0ZTogamVzdC5mbigpLFxuICBkZXN0cm95OiBqZXN0LmZuKCksXG4gIGNvdW50OiBqZXN0LmZuKCksXG59O1xuXG4vLyBNb2NrIHRoZSBtb2RlbHNcbmplc3QubW9jaygnQC9saWIvbW9kZWxzL1Byb2R1Y3QnLCAoKSA9PiBtb2NrUHJvZHVjdCk7XG5cbmltcG9ydCB7IHByb2R1Y3RTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9wcm9kdWN0U2VydmljZSc7XG5pbXBvcnQgeyBhdWRpdFNlcnZpY2UgfSBmcm9tICdAL3NlcnZpY2VzL2F1ZGl0U2VydmljZSc7XG5pbXBvcnQgKiBhcyByZWZyZXNoVG9rZW5TZXJ2aWNlIGZyb20gJ0Avc2VydmljZXMvcmVmcmVzaFRva2VuU2VydmljZSc7XG5pbXBvcnQgeyBwcmlzbWEgfSBmcm9tICdAL2xpYi9wcmlzbWEnO1xuXG4vLyBHZXQgdGhlIG1vY2tlZCBwcmlzbWEgaW5zdGFuY2VcbmNvbnN0IG1vY2tQcmlzbWEgPSBwcmlzbWEgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIHByaXNtYT47XG5cblxuXG4vLyBNb2NrIGNvbnNvbGUgbWV0aG9kc1xuY29uc3QgY29uc29sZVNweSA9IHtcbiAgbG9nOiBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pLFxuICBlcnJvcjogamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pLFxuICB3YXJuOiBqZXN0LnNweU9uKGNvbnNvbGUsICd3YXJuJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbn07XG5cbmRlc2NyaWJlKCdTZXJ2aWNlIExheWVyIFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBjb25zb2xlU3B5LmxvZy5tb2NrQ2xlYXIoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkud2Fybi5tb2NrQ2xlYXIoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJBbGwoKCkgPT4ge1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS5lcnJvci5tb2NrUmVzdG9yZSgpO1xuICAgIGNvbnNvbGVTcHkud2Fybi5tb2NrUmVzdG9yZSgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvZHVjdFNlcnZpY2UnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1Byb2R1Y3REYXRhID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICBuYW1lOiAnVGVzdCBQcm9kdWN0JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBEZXNjcmlwdGlvbicsXG4gICAgICBwcmljZTogOTkuOTksXG4gICAgICBjb3N0UHJpY2U6IDUwLjAwLFxuICAgICAgc2t1OiAnVEVTVC0wMDEnLFxuICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfTtcblxuICAgIGRlc2NyaWJlKCdnZXRBbGxQcm9kdWN0cycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZmV0Y2ggYWxsIGFjdGl2ZSBwcm9kdWN0cyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tQcm9kdWN0cyA9IFttb2NrUHJvZHVjdERhdGEsIHsgLi4ubW9ja1Byb2R1Y3REYXRhLCBpZDogMiwgbmFtZTogJ1Byb2R1Y3QgMicgfV07XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRBbGwubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2R1Y3RzKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5nZXRBbGxQcm9kdWN0cygpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kQWxsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHsgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1Byb2R1Y3RzKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBkYkVycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kQWxsLm1vY2tSZWplY3RlZFZhbHVlKGRiRXJyb3IpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS5nZXRBbGxQcm9kdWN0cygpKS5yZWplY3RzLnRvVGhyb3coJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdHM6JywgZGJFcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZW1wdHkgYXJyYXkgd2hlbiBubyBwcm9kdWN0cyBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja1Byb2R1Y3QuZmluZEFsbC5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZ2V0QWxsUHJvZHVjdHMoKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtdKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZ2V0UHJvZHVjdEJ5SWQnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGZldGNoIHByb2R1Y3QgYnkgaWQgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9kdWN0RGF0YSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZ2V0UHJvZHVjdEJ5SWQoMSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRPbmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB3aGVyZTogeyBpZDogMSwgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1Byb2R1Y3REYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBub24tZXhpc3RlbnQgcHJvZHVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja1Byb2R1Y3QuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5nZXRQcm9kdWN0QnlJZCg5OTkpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBkYkVycm9yID0gbmV3IEVycm9yKCdQcm9kdWN0IG5vdCBmb3VuZCcpO1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kT25lLm1vY2tSZWplY3RlZFZhbHVlKGRiRXJyb3IpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS5nZXRQcm9kdWN0QnlJZCgxKSkucmVqZWN0cy50b1Rocm93KCdQcm9kdWN0IG5vdCBmb3VuZCcpO1xuICAgICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIGZldGNoaW5nIHByb2R1Y3Qgd2l0aCBJRCAxOicsIGRiRXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY3JlYXRlUHJvZHVjdCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IHByb2R1Y3Qgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdQcm9kdWN0RGF0YSA9IHtcbiAgICAgICAgICBuYW1lOiAnTmV3IFByb2R1Y3QnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTmV3IERlc2NyaXB0aW9uJyxcbiAgICAgICAgICBwcmljZTogMTQ5Ljk5LFxuICAgICAgICAgIGNvc3RQcmljZTogNzUuMDAsXG4gICAgICAgICAgc2t1OiAnTkVXLTAwMScsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRQcm9kdWN0ID0geyAuLi5tb2NrUHJvZHVjdERhdGEsIC4uLm5ld1Byb2R1Y3REYXRhLCBpZDogMyB9O1xuICAgICAgICBtb2NrUHJvZHVjdC5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoY3JlYXRlZFByb2R1Y3QpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3QobmV3UHJvZHVjdERhdGEpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG5ld1Byb2R1Y3REYXRhKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChjcmVhdGVkUHJvZHVjdCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmFsaWRhdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IG5ldyBFcnJvcignVmFsaWRhdGlvbiBmYWlsZWQ6IG5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgbW9ja1Byb2R1Y3QuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKHZhbGlkYXRpb25FcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3Qoe30pKS5yZWplY3RzLnRvVGhyb3coJ1ZhbGlkYXRpb24gZmFpbGVkOiBuYW1lIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgY3JlYXRpbmcgcHJvZHVjdDonLCB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGR1cGxpY2F0ZSBTS1UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBkdXBsaWNhdGVFcnJvciA9IG5ldyBFcnJvcignU0tVIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICAgIG1vY2tQcm9kdWN0LmNyZWF0ZS5tb2NrUmVqZWN0ZWRWYWx1ZShkdXBsaWNhdGVFcnJvcik7XG5cbiAgICAgICAgY29uc3QgZHVwbGljYXRlRGF0YSA9IHsgbmFtZTogJ1Rlc3QnLCBza3U6ICdFWElTVElORy1TS1UnIH07XG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS5jcmVhdGVQcm9kdWN0KGR1cGxpY2F0ZURhdGEpKS5yZWplY3RzLnRvVGhyb3coJ1NLVSBhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndXBkYXRlUHJvZHVjdCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHByb2R1Y3Qgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVEYXRhID0geyBuYW1lOiAnVXBkYXRlZCBQcm9kdWN0JywgcHJpY2U6IDE5OS45OSB9O1xuICAgICAgICBjb25zdCBtb2NrUHJvZHVjdEluc3RhbmNlID0ge1xuICAgICAgICAgIC4uLm1vY2tQcm9kdWN0RGF0YSxcbiAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IC4uLm1vY2tQcm9kdWN0RGF0YSwgLi4udXBkYXRlRGF0YSB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgbW9ja1Byb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2R1Y3RJbnN0YW5jZSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UudXBkYXRlUHJvZHVjdCgxLCB1cGRhdGVEYXRhKTtcblxuICAgICAgICBleHBlY3QobW9ja1Byb2R1Y3QuZmluZEJ5UGspLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDEpO1xuICAgICAgICBleHBlY3QobW9ja1Byb2R1Y3RJbnN0YW5jZS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHVwZGF0ZURhdGEpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgLi4ubW9ja1Byb2R1Y3REYXRhLCAuLi51cGRhdGVEYXRhIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIG5vbi1leGlzdGVudCBwcm9kdWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UudXBkYXRlUHJvZHVjdCg5OTksIHsgbmFtZTogJ1VwZGF0ZWQnIH0pKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgICAgJ1Byb2R1Y3Qgd2l0aCBJRCA5OTkgbm90IGZvdW5kJ1xuICAgICAgICApO1xuICAgICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgJ0Vycm9yIHVwZGF0aW5nIHByb2R1Y3Qgd2l0aCBJRCA5OTk6JyxcbiAgICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIHVwZGF0ZSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tQcm9kdWN0SW5zdGFuY2UgPSB7XG4gICAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdVcGRhdGUgZmFpbGVkJykpLFxuICAgICAgICB9O1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvZHVjdEluc3RhbmNlKTtcblxuICAgICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UudXBkYXRlUHJvZHVjdCgxLCB7IG5hbWU6ICdVcGRhdGVkJyB9KSkucmVqZWN0cy50b1Rocm93KCdVcGRhdGUgZmFpbGVkJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdkZWxldGVQcm9kdWN0JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBzb2Z0IGRlbGV0ZSBwcm9kdWN0IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1Byb2R1Y3RJbnN0YW5jZSA9IHtcbiAgICAgICAgICAuLi5tb2NrUHJvZHVjdERhdGEsXG4gICAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyAuLi5tb2NrUHJvZHVjdERhdGEsIGlzQWN0aXZlOiBmYWxzZSB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgbW9ja1Byb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2R1Y3RJbnN0YW5jZSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZGVsZXRlUHJvZHVjdCgxKTtcblxuICAgICAgICBleHBlY3QobW9ja1Byb2R1Y3QuZmluZEJ5UGspLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDEpO1xuICAgICAgICBleHBlY3QobW9ja1Byb2R1Y3RJbnN0YW5jZS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgaXNBY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgLi4ubW9ja1Byb2R1Y3REYXRhLCBpc0FjdGl2ZTogZmFsc2UgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3Igbm9uLWV4aXN0ZW50IHByb2R1Y3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS5kZWxldGVQcm9kdWN0KDk5OSkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgICAnUHJvZHVjdCB3aXRoIElEIDk5OSBub3QgZm91bmQnXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnRXJyb3IgZGVsZXRpbmcgcHJvZHVjdCB3aXRoIElEIDk5OTonLFxuICAgICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F1ZGl0U2VydmljZScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrQXVkaXREYXRhID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICB1c2VySWQ6IDEsXG4gICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICBlbnRpdHlJZDogMSxcbiAgICAgIGRldGFpbHM6IHsgbmFtZTogJ1Rlc3QgUHJvZHVjdCcgfSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9O1xuXG4gICAgZGVzY3JpYmUoJ2xvZ0FjdGlvbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgbG9nIGF1ZGl0IGFjdGlvbiBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIChtb2NrUHJpc21hLmF1ZGl0TG9nLmNyZWF0ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tBdWRpdERhdGEpO1xuXG4gICAgICAgIGF3YWl0IGF1ZGl0U2VydmljZS5sb2dBY3Rpb24oe1xuICAgICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICAgIGVudGl0eTogJ1Byb2R1Y3QnLFxuICAgICAgICAgIGVudGl0eUlkOiAxLFxuICAgICAgICAgIGRldGFpbHM6IHsgbmFtZTogJ1Rlc3QgUHJvZHVjdCcgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcmlzbWEuYXVkaXRMb2cuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICAgICAgYWN0aW9uOiAnQ1JFQVRFJyxcbiAgICAgICAgICAgIGVudGl0eTogJ1Byb2R1Y3QnLFxuICAgICAgICAgICAgZW50aXR5SWQ6IDEsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIG5hbWU6ICdUZXN0IFByb2R1Y3QnLFxuICAgICAgICAgICAgICBvcmlnaW5hbERhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgaXNEZWxldGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgZGVsZXRlZEF0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGRlbGV0ZWRCeTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjYW5SZWNvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVjb3ZlcmVkQXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgcmVjb3ZlcmVkQnk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXVkaXQgbG9nZ2luZyBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgYXVkaXRFcnJvciA9IG5ldyBFcnJvcignQXVkaXQgbG9nIGZhaWxlZCcpO1xuICAgICAgICAobW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShhdWRpdEVycm9yKTtcblxuICAgICAgICAvLyBTaG91bGQgbm90IHRocm93IGVycm9yLCBqdXN0IGxvZyBpdFxuICAgICAgICBhd2FpdCBhdWRpdFNlcnZpY2UubG9nQWN0aW9uKHtcbiAgICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgICAgYWN0aW9uOiAnQ1JFQVRFJyxcbiAgICAgICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdGYWlsZWQgdG8gbG9nIGF1ZGl0IGVudHJ5OicsIGF1ZGl0RXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiBnZXRBdWRpdExvZ3MgYW5kIGNsZWFudXBPbGRMb2dzIG1ldGhvZHMgZG9uJ3QgZXhpc3QgaW4gdGhlIGFjdHVhbCBhdWRpdFNlcnZpY2VcbiAgICAvLyBUaGVzZSB0ZXN0cyBoYXZlIGJlZW4gcmVtb3ZlZCB0byBtYXRjaCB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uXG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZWZyZXNoVG9rZW5TZXJ2aWNlJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tSZWZyZXNoVG9rZW4gPSB7XG4gICAgICBpZDogMSxcbiAgICAgIHRva2VuOiAncmVmcmVzaC10b2tlbi0xMjMnLFxuICAgICAgdXNlcklkOiAxLFxuICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLCAvLyA3IGRheXNcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIGlzUmV2b2tlZDogZmFsc2UsXG4gICAgfTtcblxuICAgIGRlc2NyaWJlKCdnZW5lcmF0ZVJlZnJlc2hUb2tlbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgcmVmcmVzaCB0b2tlbiBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUmVmcmVzaFRva2VuKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLmdlbmVyYXRlUmVmcmVzaFRva2VuKDEpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgICAgICB0b2tlbjogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgZXhwaXJlc0F0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGV4cGVjdC5hbnkoU3RyaW5nKSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgY3JlYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjcmVhdGVFcnJvciA9IG5ldyBFcnJvcignVG9rZW4gY3JlYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShjcmVhdGVFcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHJlZnJlc2hUb2tlblNlcnZpY2UuZ2VuZXJhdGVSZWZyZXNoVG9rZW4oMSkpLnJlamVjdHMudG9UaHJvdygnVG9rZW4gY3JlYXRpb24gZmFpbGVkJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd2ZXJpZnlSZWZyZXNoVG9rZW4nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZlcmlmeSB2YWxpZCByZWZyZXNoIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uZmluZFVuaXF1ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tSZWZyZXNoVG9rZW4pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hUb2tlblNlcnZpY2UudmVyaWZ5UmVmcmVzaFRva2VuKCdyZWZyZXNoLXRva2VuLTEyMycpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5maW5kVW5pcXVlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHsgdG9rZW46ICdyZWZyZXNoLXRva2VuLTEyMycgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoMSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgaW52YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmZpbmRVbmlxdWUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLnZlcmlmeVJlZnJlc2hUb2tlbignaW52YWxpZC10b2tlbicpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgZXhwaXJlZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXhwaXJlZFRva2VuID0ge1xuICAgICAgICAgIC4uLm1vY2tSZWZyZXNoVG9rZW4sXG4gICAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTAwMCksIC8vIEV4cGlyZWRcbiAgICAgICAgfTtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmZpbmRVbmlxdWUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShleHBpcmVkVG9rZW4pO1xuICAgICAgICAobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4udXBkYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoZXhwaXJlZFRva2VuKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLnZlcmlmeVJlZnJlc2hUb2tlbignZXhwaXJlZC10b2tlbicpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdyZXZva2VSZWZyZXNoVG9rZW4nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHJldm9rZSByZWZyZXNoIHRva2VuIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLnVwZGF0ZU1hbnkgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGNvdW50OiAxIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hUb2tlblNlcnZpY2UucmV2b2tlUmVmcmVzaFRva2VuKCdyZWZyZXNoLXRva2VuLTEyMycpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi51cGRhdGVNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHsgdG9rZW46ICdyZWZyZXNoLXRva2VuLTEyMycgfSxcbiAgICAgICAgICBkYXRhOiB7IGlzUmV2b2tlZDogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmV2b2tlRXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGVycm9yJyk7XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi51cGRhdGVNYW55IGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUocmV2b2tlRXJyb3IpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hUb2tlblNlcnZpY2UucmV2b2tlUmVmcmVzaFRva2VuKCdub24tZXhpc3RlbnQnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdyZXZva2VBbGxVc2VyUmVmcmVzaFRva2VucycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmV2b2tlIGFsbCB0b2tlbnMgZm9yIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi51cGRhdGVNYW55IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoeyBjb3VudDogMyB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLnJldm9rZUFsbFVzZXJSZWZyZXNoVG9rZW5zKDEpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi51cGRhdGVNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHsgdXNlcklkOiAxIH0sXG4gICAgICAgICAgZGF0YTogeyBpc1Jldm9rZWQ6IHRydWUgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdjbGVhbnVwUmVmcmVzaFRva2VucycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY2xlYW51cCBleHBpcmVkIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmRlbGV0ZU1hbnkgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGNvdW50OiAxMCB9KTtcblxuICAgICAgICBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLmNsZWFudXBSZWZyZXNoVG9rZW5zKCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmRlbGV0ZU1hbnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgT1I6IFtcbiAgICAgICAgICAgICAgeyBleHBpcmVzQXQ6IHsgbHQ6IGV4cGVjdC5hbnkoRGF0ZSkgfSB9LFxuICAgICAgICAgICAgICB7IGlzUmV2b2tlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2VydmljZSBJbnRlZ3JhdGlvbiBUZXN0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXJ2aWNlIGRlcGVuZGVuY2llcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IGludGVyYWN0aW9uIGJldHdlZW4gc2VydmljZXNcbiAgICAgIGNvbnN0IHByb2R1Y3REYXRhID0geyBuYW1lOiAnVGVzdCBQcm9kdWN0JywgcHJpY2U6IDk5Ljk5IH07XG4gICAgICBjb25zdCBjcmVhdGVkUHJvZHVjdCA9IHsgXG4gICAgICAgIGlkOiA1LCBcbiAgICAgICAgbmFtZTogJ1Rlc3QgUHJvZHVjdCcsIFxuICAgICAgICBwcmljZTogOTkuOTksIFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgZGVzY3JpcHRpb24nLFxuICAgICAgICBjYXRlZ29yeTogJ1Rlc3QgQ2F0ZWdvcnknLFxuICAgICAgICBzdG9jazogMTAsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuICAgICAgXG4gICAgICAobW9ja1Byb2R1Y3QuY3JlYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoY3JlYXRlZFByb2R1Y3QpO1xuICAgICAgKG1vY2tQcmlzbWEuYXVkaXRMb2cuY3JlYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpZDogMSxcbiAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgICAgZW50aXR5SWQ6IDUsXG4gICAgICAgIGRldGFpbHM6IHByb2R1Y3REYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIHByb2R1Y3RcbiAgICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5jcmVhdGVQcm9kdWN0KHByb2R1Y3REYXRhKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIGF1ZGl0IGFjdGlvblxuICAgICAgYXdhaXQgYXVkaXRTZXJ2aWNlLmxvZ0FjdGlvbih7XG4gICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgYWN0aW9uOiAnQ1JFQVRFJyxcbiAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICAgIGVudGl0eUlkOiBwcm9kdWN0LmlkLFxuICAgICAgICBkZXRhaWxzOiBwcm9kdWN0RGF0YSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocHJvZHVjdCkudG9FcXVhbChjcmVhdGVkUHJvZHVjdCk7XG4gICAgICBleHBlY3QobW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcnZpY2UgZXJyb3IgcHJvcGFnYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYkVycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGxvc3QnKTtcbiAgICAgIChtb2NrUHJvZHVjdC5maW5kQWxsIGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUoZGJFcnJvcik7XG4gICAgICAobW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShkYkVycm9yKTtcblxuICAgICAgLy8gQm90aCBzZXJ2aWNlcyBzaG91bGQgaGFuZGxlIGVycm9ycyBpbmRlcGVuZGVudGx5XG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuZ2V0QWxsUHJvZHVjdHMoKSkucmVqZWN0cy50b1Rocm93KCdEYXRhYmFzZSBjb25uZWN0aW9uIGxvc3QnKTtcbiAgICAgIFxuICAgICAgYXdhaXQgYXVkaXRTZXJ2aWNlLmxvZ0FjdGlvbih7XG4gICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgYWN0aW9uOiAnUkVBRCcsXG4gICAgICAgIGVudGl0eTogJ1Byb2R1Y3QnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEF1ZGl0IHNlcnZpY2UgaGFuZGxlcyBlcnJvcnMgZ3JhY2VmdWxseSwgc28gbm8gZXhjZXB0aW9uIHNob3VsZCBiZSB0aHJvd25cbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLmF1ZGl0TG9nLmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tQcm9kdWN0IiwiZmluZEFsbCIsImZuIiwiZmluZE9uZSIsImZpbmRCeVBrIiwiY3JlYXRlIiwidXBkYXRlIiwiZGVzdHJveSIsImNvdW50IiwibW9ja1ByaXNtYSIsInByaXNtYSIsImNvbnNvbGVTcHkiLCJsb2ciLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJlcnJvciIsIndhcm4iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja0NsZWFyIiwiYWZ0ZXJBbGwiLCJtb2NrUmVzdG9yZSIsIm1vY2tQcm9kdWN0RGF0YSIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwicHJpY2UiLCJjb3N0UHJpY2UiLCJza3UiLCJpc0FjdGl2ZSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ1cGRhdGVkQXQiLCJpdCIsIm1vY2tQcm9kdWN0cyIsIm1vY2tSZXNvbHZlZFZhbHVlIiwicmVzdWx0IiwicHJvZHVjdFNlcnZpY2UiLCJnZXRBbGxQcm9kdWN0cyIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwid2hlcmUiLCJ0b0VxdWFsIiwidG9IYXZlTGVuZ3RoIiwiZGJFcnJvciIsIkVycm9yIiwibW9ja1JlamVjdGVkVmFsdWUiLCJyZWplY3RzIiwidG9UaHJvdyIsImdldFByb2R1Y3RCeUlkIiwidG9CZU51bGwiLCJuZXdQcm9kdWN0RGF0YSIsImNyZWF0ZWRQcm9kdWN0IiwiY3JlYXRlUHJvZHVjdCIsInZhbGlkYXRpb25FcnJvciIsImR1cGxpY2F0ZUVycm9yIiwiZHVwbGljYXRlRGF0YSIsInVwZGF0ZURhdGEiLCJtb2NrUHJvZHVjdEluc3RhbmNlIiwidXBkYXRlUHJvZHVjdCIsImFueSIsImRlbGV0ZVByb2R1Y3QiLCJtb2NrQXVkaXREYXRhIiwidXNlcklkIiwiYWN0aW9uIiwiZW50aXR5IiwiZW50aXR5SWQiLCJkZXRhaWxzIiwiYXVkaXRMb2ciLCJhdWRpdFNlcnZpY2UiLCJsb2dBY3Rpb24iLCJkYXRhIiwib3JpZ2luYWxEYXRhIiwidW5kZWZpbmVkIiwiaXNEZWxldGVkIiwiZGVsZXRlZEF0IiwiZGVsZXRlZEJ5IiwiY2FuUmVjb3ZlciIsInJlY292ZXJlZEF0IiwicmVjb3ZlcmVkQnkiLCJhdWRpdEVycm9yIiwibW9ja1JlZnJlc2hUb2tlbiIsInRva2VuIiwiZXhwaXJlc0F0Iiwibm93IiwiaXNSZXZva2VkIiwicmVmcmVzaFRva2VuIiwicmVmcmVzaFRva2VuU2VydmljZSIsImdlbmVyYXRlUmVmcmVzaFRva2VuIiwiU3RyaW5nIiwiY3JlYXRlRXJyb3IiLCJmaW5kVW5pcXVlIiwidmVyaWZ5UmVmcmVzaFRva2VuIiwiZXhwaXJlZFRva2VuIiwidXBkYXRlTWFueSIsInJldm9rZVJlZnJlc2hUb2tlbiIsInRvQmUiLCJyZXZva2VFcnJvciIsInJldm9rZUFsbFVzZXJSZWZyZXNoVG9rZW5zIiwiZGVsZXRlTWFueSIsImNsZWFudXBSZWZyZXNoVG9rZW5zIiwiT1IiLCJsdCIsInByb2R1Y3REYXRhIiwiY2F0ZWdvcnkiLCJzdG9jayIsInByb2R1Y3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIl0sIm1hcHBpbmdzIjoiQUFBQSx5QkFBeUI7O0FBV3pCLGtCQUFrQjtBQUNsQkEsS0FBS0MsSUFBSSxDQUFDLHdCQUF3QixJQUFNQzs7OztnQ0FFVDs4QkFDRjs2RUFDUTt3QkFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaEJ2QixNQUFNQSxjQUFjO0lBQ2xCQyxTQUFTSCxLQUFLSSxFQUFFO0lBQ2hCQyxTQUFTTCxLQUFLSSxFQUFFO0lBQ2hCRSxVQUFVTixLQUFLSSxFQUFFO0lBQ2pCRyxRQUFRUCxLQUFLSSxFQUFFO0lBQ2ZJLFFBQVFSLEtBQUtJLEVBQUU7SUFDZkssU0FBU1QsS0FBS0ksRUFBRTtJQUNoQk0sT0FBT1YsS0FBS0ksRUFBRTtBQUNoQjtBQVVBLGlDQUFpQztBQUNqQyxNQUFNTyxhQUFhQyxjQUFNO0FBSXpCLHVCQUF1QjtBQUN2QixNQUFNQyxhQUFhO0lBQ2pCQyxLQUFLZCxLQUFLZSxLQUFLLENBQUNDLFNBQVMsT0FBT0Msa0JBQWtCLENBQUMsS0FBTztJQUMxREMsT0FBT2xCLEtBQUtlLEtBQUssQ0FBQ0MsU0FBUyxTQUFTQyxrQkFBa0IsQ0FBQyxLQUFPO0lBQzlERSxNQUFNbkIsS0FBS2UsS0FBSyxDQUFDQyxTQUFTLFFBQVFDLGtCQUFrQixDQUFDLEtBQU87QUFDOUQ7QUFFQUcsU0FBUyx1QkFBdUI7SUFDOUJDLFdBQVc7UUFDVHJCLEtBQUtzQixhQUFhO1FBQ2xCVCxXQUFXQyxHQUFHLENBQUNTLFNBQVM7UUFDeEJWLFdBQVdLLEtBQUssQ0FBQ0ssU0FBUztRQUMxQlYsV0FBV00sSUFBSSxDQUFDSSxTQUFTO0lBQzNCO0lBRUFDLFNBQVM7UUFDUFgsV0FBV0MsR0FBRyxDQUFDVyxXQUFXO1FBQzFCWixXQUFXSyxLQUFLLENBQUNPLFdBQVc7UUFDNUJaLFdBQVdNLElBQUksQ0FBQ00sV0FBVztJQUM3QjtJQUVBTCxTQUFTLGtCQUFrQjtRQUN6QixNQUFNTSxrQkFBa0I7WUFDdEJDLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxhQUFhO1lBQ2JDLE9BQU87WUFDUEMsV0FBVztZQUNYQyxLQUFLO1lBQ0xDLFVBQVU7WUFDVkMsV0FBVyxJQUFJQztZQUNmQyxXQUFXLElBQUlEO1FBQ2pCO1FBRUFmLFNBQVMsa0JBQWtCO1lBQ3pCaUIsR0FBRyxpREFBaUQ7Z0JBQ2xELE1BQU1DLGVBQWU7b0JBQUNaO29CQUFpQjt3QkFBRSxHQUFHQSxlQUFlO3dCQUFFQyxJQUFJO3dCQUFHQyxNQUFNO29CQUFZO2lCQUFFO2dCQUN4RjFCLFlBQVlDLE9BQU8sQ0FBQ29DLGlCQUFpQixDQUFDRDtnQkFFdEMsTUFBTUUsU0FBUyxNQUFNQyw4QkFBYyxDQUFDQyxjQUFjO2dCQUVsREMsT0FBT3pDLFlBQVlDLE9BQU8sRUFBRXlDLG9CQUFvQixDQUFDO29CQUMvQ0MsT0FBTzt3QkFBRVosVUFBVTtvQkFBSztnQkFDMUI7Z0JBQ0FVLE9BQU9ILFFBQVFNLE9BQU8sQ0FBQ1I7Z0JBQ3ZCSyxPQUFPSCxRQUFRTyxZQUFZLENBQUM7WUFDOUI7WUFFQVYsR0FBRyw0Q0FBNEM7Z0JBQzdDLE1BQU1XLFVBQVUsSUFBSUMsTUFBTTtnQkFDMUIvQyxZQUFZQyxPQUFPLENBQUMrQyxpQkFBaUIsQ0FBQ0Y7Z0JBRXRDLE1BQU1MLE9BQU9GLDhCQUFjLENBQUNDLGNBQWMsSUFBSVMsT0FBTyxDQUFDQyxPQUFPLENBQUM7Z0JBQzlEVCxPQUFPOUIsV0FBV0ssS0FBSyxFQUFFMEIsb0JBQW9CLENBQUMsNEJBQTRCSTtZQUM1RTtZQUVBWCxHQUFHLG9EQUFvRDtnQkFDckRuQyxZQUFZQyxPQUFPLENBQUNvQyxpQkFBaUIsQ0FBQyxFQUFFO2dCQUV4QyxNQUFNQyxTQUFTLE1BQU1DLDhCQUFjLENBQUNDLGNBQWM7Z0JBRWxEQyxPQUFPSCxRQUFRTSxPQUFPLENBQUMsRUFBRTtnQkFDekJILE9BQU9ILFFBQVFPLFlBQVksQ0FBQztZQUM5QjtRQUNGO1FBRUEzQixTQUFTLGtCQUFrQjtZQUN6QmlCLEdBQUcsMkNBQTJDO2dCQUM1Q25DLFlBQVlHLE9BQU8sQ0FBQ2tDLGlCQUFpQixDQUFDYjtnQkFFdEMsTUFBTWMsU0FBUyxNQUFNQyw4QkFBYyxDQUFDWSxjQUFjLENBQUM7Z0JBRW5EVixPQUFPekMsWUFBWUcsT0FBTyxFQUFFdUMsb0JBQW9CLENBQUM7b0JBQy9DQyxPQUFPO3dCQUFFbEIsSUFBSTt3QkFBR00sVUFBVTtvQkFBSztnQkFDakM7Z0JBQ0FVLE9BQU9ILFFBQVFNLE9BQU8sQ0FBQ3BCO1lBQ3pCO1lBRUFXLEdBQUcsK0NBQStDO2dCQUNoRG5DLFlBQVlHLE9BQU8sQ0FBQ2tDLGlCQUFpQixDQUFDO2dCQUV0QyxNQUFNQyxTQUFTLE1BQU1DLDhCQUFjLENBQUNZLGNBQWMsQ0FBQztnQkFFbkRWLE9BQU9ILFFBQVFjLFFBQVE7WUFDekI7WUFFQWpCLEdBQUcsaUNBQWlDO2dCQUNsQyxNQUFNVyxVQUFVLElBQUlDLE1BQU07Z0JBQzFCL0MsWUFBWUcsT0FBTyxDQUFDNkMsaUJBQWlCLENBQUNGO2dCQUV0QyxNQUFNTCxPQUFPRiw4QkFBYyxDQUFDWSxjQUFjLENBQUMsSUFBSUYsT0FBTyxDQUFDQyxPQUFPLENBQUM7Z0JBQy9EVCxPQUFPOUIsV0FBV0ssS0FBSyxFQUFFMEIsb0JBQW9CLENBQUMscUNBQXFDSTtZQUNyRjtRQUNGO1FBRUE1QixTQUFTLGlCQUFpQjtZQUN4QmlCLEdBQUcsNENBQTRDO2dCQUM3QyxNQUFNa0IsaUJBQWlCO29CQUNyQjNCLE1BQU07b0JBQ05DLGFBQWE7b0JBQ2JDLE9BQU87b0JBQ1BDLFdBQVc7b0JBQ1hDLEtBQUs7Z0JBQ1A7Z0JBQ0EsTUFBTXdCLGlCQUFpQjtvQkFBRSxHQUFHOUIsZUFBZTtvQkFBRSxHQUFHNkIsY0FBYztvQkFBRTVCLElBQUk7Z0JBQUU7Z0JBQ3RFekIsWUFBWUssTUFBTSxDQUFDZ0MsaUJBQWlCLENBQUNpQjtnQkFFckMsTUFBTWhCLFNBQVMsTUFBTUMsOEJBQWMsQ0FBQ2dCLGFBQWEsQ0FBQ0Y7Z0JBRWxEWixPQUFPekMsWUFBWUssTUFBTSxFQUFFcUMsb0JBQW9CLENBQUNXO2dCQUNoRFosT0FBT0gsUUFBUU0sT0FBTyxDQUFDVTtZQUN6QjtZQUVBbkIsR0FBRyxtQ0FBbUM7Z0JBQ3BDLE1BQU1xQixrQkFBa0IsSUFBSVQsTUFBTTtnQkFDbEMvQyxZQUFZSyxNQUFNLENBQUMyQyxpQkFBaUIsQ0FBQ1E7Z0JBRXJDLE1BQU1mLE9BQU9GLDhCQUFjLENBQUNnQixhQUFhLENBQUMsQ0FBQyxJQUFJTixPQUFPLENBQUNDLE9BQU8sQ0FBQztnQkFDL0RULE9BQU85QixXQUFXSyxLQUFLLEVBQUUwQixvQkFBb0IsQ0FBQywyQkFBMkJjO1lBQzNFO1lBRUFyQixHQUFHLHNDQUFzQztnQkFDdkMsTUFBTXNCLGlCQUFpQixJQUFJVixNQUFNO2dCQUNqQy9DLFlBQVlLLE1BQU0sQ0FBQzJDLGlCQUFpQixDQUFDUztnQkFFckMsTUFBTUMsZ0JBQWdCO29CQUFFaEMsTUFBTTtvQkFBUUksS0FBSztnQkFBZTtnQkFDMUQsTUFBTVcsT0FBT0YsOEJBQWMsQ0FBQ2dCLGFBQWEsQ0FBQ0csZ0JBQWdCVCxPQUFPLENBQUNDLE9BQU8sQ0FBQztZQUM1RTtRQUNGO1FBRUFoQyxTQUFTLGlCQUFpQjtZQUN4QmlCLEdBQUcsc0NBQXNDO2dCQUN2QyxNQUFNd0IsYUFBYTtvQkFBRWpDLE1BQU07b0JBQW1CRSxPQUFPO2dCQUFPO2dCQUM1RCxNQUFNZ0Msc0JBQXNCO29CQUMxQixHQUFHcEMsZUFBZTtvQkFDbEJsQixRQUFRUixLQUFLSSxFQUFFLEdBQUdtQyxpQkFBaUIsQ0FBQzt3QkFBRSxHQUFHYixlQUFlO3dCQUFFLEdBQUdtQyxVQUFVO29CQUFDO2dCQUMxRTtnQkFDQTNELFlBQVlJLFFBQVEsQ0FBQ2lDLGlCQUFpQixDQUFDdUI7Z0JBRXZDLE1BQU10QixTQUFTLE1BQU1DLDhCQUFjLENBQUNzQixhQUFhLENBQUMsR0FBR0Y7Z0JBRXJEbEIsT0FBT3pDLFlBQVlJLFFBQVEsRUFBRXNDLG9CQUFvQixDQUFDO2dCQUNsREQsT0FBT21CLG9CQUFvQnRELE1BQU0sRUFBRW9DLG9CQUFvQixDQUFDaUI7Z0JBQ3hEbEIsT0FBT0gsUUFBUU0sT0FBTyxDQUFDO29CQUFFLEdBQUdwQixlQUFlO29CQUFFLEdBQUdtQyxVQUFVO2dCQUFDO1lBQzdEO1lBRUF4QixHQUFHLCtDQUErQztnQkFDaERuQyxZQUFZSSxRQUFRLENBQUNpQyxpQkFBaUIsQ0FBQztnQkFFdkMsTUFBTUksT0FBT0YsOEJBQWMsQ0FBQ3NCLGFBQWEsQ0FBQyxLQUFLO29CQUFFbkMsTUFBTTtnQkFBVSxJQUFJdUIsT0FBTyxDQUFDQyxPQUFPLENBQ2xGO2dCQUVGVCxPQUFPOUIsV0FBV0ssS0FBSyxFQUFFMEIsb0JBQW9CLENBQzNDLHVDQUNBRCxPQUFPcUIsR0FBRyxDQUFDZjtZQUVmO1lBRUFaLEdBQUcsd0NBQXdDO2dCQUN6QyxNQUFNeUIsc0JBQXNCO29CQUMxQnRELFFBQVFSLEtBQUtJLEVBQUUsR0FBRzhDLGlCQUFpQixDQUFDLElBQUlELE1BQU07Z0JBQ2hEO2dCQUNBL0MsWUFBWUksUUFBUSxDQUFDaUMsaUJBQWlCLENBQUN1QjtnQkFFdkMsTUFBTW5CLE9BQU9GLDhCQUFjLENBQUNzQixhQUFhLENBQUMsR0FBRztvQkFBRW5DLE1BQU07Z0JBQVUsSUFBSXVCLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO1lBQ3JGO1FBQ0Y7UUFFQWhDLFNBQVMsaUJBQWlCO1lBQ3hCaUIsR0FBRywyQ0FBMkM7Z0JBQzVDLE1BQU15QixzQkFBc0I7b0JBQzFCLEdBQUdwQyxlQUFlO29CQUNsQmxCLFFBQVFSLEtBQUtJLEVBQUUsR0FBR21DLGlCQUFpQixDQUFDO3dCQUFFLEdBQUdiLGVBQWU7d0JBQUVPLFVBQVU7b0JBQU07Z0JBQzVFO2dCQUNBL0IsWUFBWUksUUFBUSxDQUFDaUMsaUJBQWlCLENBQUN1QjtnQkFFdkMsTUFBTXRCLFNBQVMsTUFBTUMsOEJBQWMsQ0FBQ3dCLGFBQWEsQ0FBQztnQkFFbER0QixPQUFPekMsWUFBWUksUUFBUSxFQUFFc0Msb0JBQW9CLENBQUM7Z0JBQ2xERCxPQUFPbUIsb0JBQW9CdEQsTUFBTSxFQUFFb0Msb0JBQW9CLENBQUM7b0JBQUVYLFVBQVU7Z0JBQU07Z0JBQzFFVSxPQUFPSCxRQUFRTSxPQUFPLENBQUM7b0JBQUUsR0FBR3BCLGVBQWU7b0JBQUVPLFVBQVU7Z0JBQU07WUFDL0Q7WUFFQUksR0FBRywrQ0FBK0M7Z0JBQ2hEbkMsWUFBWUksUUFBUSxDQUFDaUMsaUJBQWlCLENBQUM7Z0JBRXZDLE1BQU1JLE9BQU9GLDhCQUFjLENBQUN3QixhQUFhLENBQUMsTUFBTWQsT0FBTyxDQUFDQyxPQUFPLENBQzdEO2dCQUVGVCxPQUFPOUIsV0FBV0ssS0FBSyxFQUFFMEIsb0JBQW9CLENBQzNDLHVDQUNBRCxPQUFPcUIsR0FBRyxDQUFDZjtZQUVmO1FBQ0Y7SUFDRjtJQUVBN0IsU0FBUyxnQkFBZ0I7UUFDdkIsTUFBTThDLGdCQUFnQjtZQUNwQnZDLElBQUk7WUFDSndDLFFBQVE7WUFDUkMsUUFBUTtZQUNSQyxRQUFRO1lBQ1JDLFVBQVU7WUFDVkMsU0FBUztnQkFBRTNDLE1BQU07WUFBZTtZQUNoQ00sV0FBVyxJQUFJQztRQUNqQjtRQUVBZixTQUFTLGFBQWE7WUFDcEJpQixHQUFHLHdDQUF3QztnQkFDeEMxQixXQUFXNkQsUUFBUSxDQUFDakUsTUFBTSxDQUFlZ0MsaUJBQWlCLENBQUMyQjtnQkFFNUQsTUFBTU8sMEJBQVksQ0FBQ0MsU0FBUyxDQUFDO29CQUMzQlAsUUFBUTtvQkFDUkMsUUFBUTtvQkFDUkMsUUFBUTtvQkFDUkMsVUFBVTtvQkFDVkMsU0FBUzt3QkFBRTNDLE1BQU07b0JBQWU7Z0JBQ2xDO2dCQUVBZSxPQUFPaEMsV0FBVzZELFFBQVEsQ0FBQ2pFLE1BQU0sRUFBRXFDLG9CQUFvQixDQUFDO29CQUN0RCtCLE1BQU07d0JBQ0pSLFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLFVBQVU7d0JBQ1ZDLFNBQVM7NEJBQ1AzQyxNQUFNOzRCQUNOZ0QsY0FBY0M7NEJBQ2RDLFdBQVc7NEJBQ1hDLFdBQVdGOzRCQUNYRyxXQUFXSDs0QkFDWEksWUFBWTs0QkFDWkMsYUFBYUw7NEJBQ2JNLGFBQWFOO3dCQUNmO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQXhDLEdBQUcsaURBQWlEO2dCQUNsRCxNQUFNK0MsYUFBYSxJQUFJbkMsTUFBTTtnQkFDNUJ0QyxXQUFXNkQsUUFBUSxDQUFDakUsTUFBTSxDQUFlMkMsaUJBQWlCLENBQUNrQztnQkFFNUQsc0NBQXNDO2dCQUN0QyxNQUFNWCwwQkFBWSxDQUFDQyxTQUFTLENBQUM7b0JBQzNCUCxRQUFRO29CQUNSQyxRQUFRO29CQUNSQyxRQUFRO2dCQUNWO2dCQUVBMUIsT0FBTzlCLFdBQVdLLEtBQUssRUFBRTBCLG9CQUFvQixDQUFDLDhCQUE4QndDO1lBQzlFO1FBQ0Y7SUFFQSx1RkFBdUY7SUFDdkYsbUVBQW1FO0lBQ3JFO0lBRUFoRSxTQUFTLHVCQUF1QjtRQUM5QixNQUFNaUUsbUJBQW1CO1lBQ3ZCMUQsSUFBSTtZQUNKMkQsT0FBTztZQUNQbkIsUUFBUTtZQUNSb0IsV0FBVyxJQUFJcEQsS0FBS0EsS0FBS3FELEdBQUcsS0FBSyxJQUFJLEtBQUssS0FBSyxLQUFLO1lBQ3BEdEQsV0FBVyxJQUFJQztZQUNmc0QsV0FBVztRQUNiO1FBRUFyRSxTQUFTLHdCQUF3QjtZQUMvQmlCLEdBQUcsOENBQThDO2dCQUM5QzFCLFdBQVcrRSxZQUFZLENBQUNuRixNQUFNLENBQWVnQyxpQkFBaUIsQ0FBQzhDO2dCQUVoRSxNQUFNN0MsU0FBUyxNQUFNbUQscUJBQW9CQyxvQkFBb0IsQ0FBQztnQkFFOURqRCxPQUFPaEMsV0FBVytFLFlBQVksQ0FBQ25GLE1BQU0sRUFBRXFDLG9CQUFvQixDQUFDO29CQUMxRCtCLE1BQU07d0JBQ0pSLFFBQVE7d0JBQ1JtQixPQUFPM0MsT0FBT3FCLEdBQUcsQ0FBQzZCO3dCQUNsQk4sV0FBVzVDLE9BQU9xQixHQUFHLENBQUM3QjtvQkFDeEI7Z0JBQ0Y7Z0JBQ0FRLE9BQU9ILFFBQVFNLE9BQU8sQ0FBQ0gsT0FBT3FCLEdBQUcsQ0FBQzZCO1lBQ3BDO1lBRUF4RCxHQUFHLGlDQUFpQztnQkFDbEMsTUFBTXlELGNBQWMsSUFBSTdDLE1BQU07Z0JBQzdCdEMsV0FBVytFLFlBQVksQ0FBQ25GLE1BQU0sQ0FBZTJDLGlCQUFpQixDQUFDNEM7Z0JBRWhFLE1BQU1uRCxPQUFPZ0QscUJBQW9CQyxvQkFBb0IsQ0FBQyxJQUFJekMsT0FBTyxDQUFDQyxPQUFPLENBQUM7WUFDNUU7UUFDRjtRQUVBaEMsU0FBUyxzQkFBc0I7WUFDN0JpQixHQUFHLHFDQUFxQztnQkFDckMxQixXQUFXK0UsWUFBWSxDQUFDSyxVQUFVLENBQWV4RCxpQkFBaUIsQ0FBQzhDO2dCQUVwRSxNQUFNN0MsU0FBUyxNQUFNbUQscUJBQW9CSyxrQkFBa0IsQ0FBQztnQkFFNURyRCxPQUFPaEMsV0FBVytFLFlBQVksQ0FBQ0ssVUFBVSxFQUFFbkQsb0JBQW9CLENBQUM7b0JBQzlEQyxPQUFPO3dCQUFFeUMsT0FBTztvQkFBb0I7Z0JBQ3RDO2dCQUNBM0MsT0FBT0gsUUFBUU0sT0FBTyxDQUFDO1lBQ3pCO1lBRUFULEdBQUcsd0NBQXdDO2dCQUN4QzFCLFdBQVcrRSxZQUFZLENBQUNLLFVBQVUsQ0FBZXhELGlCQUFpQixDQUFDO2dCQUVwRSxNQUFNQyxTQUFTLE1BQU1tRCxxQkFBb0JLLGtCQUFrQixDQUFDO2dCQUU1RHJELE9BQU9ILFFBQVFjLFFBQVE7WUFDekI7WUFFQWpCLEdBQUcsd0NBQXdDO2dCQUN6QyxNQUFNNEQsZUFBZTtvQkFDbkIsR0FBR1osZ0JBQWdCO29CQUNuQkUsV0FBVyxJQUFJcEQsS0FBS0EsS0FBS3FELEdBQUcsS0FBSztnQkFDbkM7Z0JBQ0M3RSxXQUFXK0UsWUFBWSxDQUFDSyxVQUFVLENBQWV4RCxpQkFBaUIsQ0FBQzBEO2dCQUNuRXRGLFdBQVcrRSxZQUFZLENBQUNsRixNQUFNLENBQWUrQixpQkFBaUIsQ0FBQzBEO2dCQUVoRSxNQUFNekQsU0FBUyxNQUFNbUQscUJBQW9CSyxrQkFBa0IsQ0FBQztnQkFFNURyRCxPQUFPSCxRQUFRYyxRQUFRO1lBQ3pCO1FBQ0Y7UUFFQWxDLFNBQVMsc0JBQXNCO1lBQzdCaUIsR0FBRyw0Q0FBNEM7Z0JBQzVDMUIsV0FBVytFLFlBQVksQ0FBQ1EsVUFBVSxDQUFlM0QsaUJBQWlCLENBQUM7b0JBQUU3QixPQUFPO2dCQUFFO2dCQUUvRSxNQUFNOEIsU0FBUyxNQUFNbUQscUJBQW9CUSxrQkFBa0IsQ0FBQztnQkFFNUR4RCxPQUFPaEMsV0FBVytFLFlBQVksQ0FBQ1EsVUFBVSxFQUFFdEQsb0JBQW9CLENBQUM7b0JBQzlEQyxPQUFPO3dCQUFFeUMsT0FBTztvQkFBb0I7b0JBQ3BDWCxNQUFNO3dCQUFFYyxXQUFXO29CQUFLO2dCQUMxQjtnQkFDQTlDLE9BQU9ILFFBQVE0RCxJQUFJLENBQUM7WUFDdEI7WUFFQS9ELEdBQUcsbUNBQW1DO2dCQUNwQyxNQUFNZ0UsY0FBYyxJQUFJcEQsTUFBTTtnQkFDN0J0QyxXQUFXK0UsWUFBWSxDQUFDUSxVQUFVLENBQWVoRCxpQkFBaUIsQ0FBQ21EO2dCQUVwRSxNQUFNN0QsU0FBUyxNQUFNbUQscUJBQW9CUSxrQkFBa0IsQ0FBQztnQkFDNUR4RCxPQUFPSCxRQUFRNEQsSUFBSSxDQUFDO1lBQ3RCO1FBQ0Y7UUFFQWhGLFNBQVMsOEJBQThCO1lBQ3JDaUIsR0FBRyxxQ0FBcUM7Z0JBQ3JDMUIsV0FBVytFLFlBQVksQ0FBQ1EsVUFBVSxDQUFlM0QsaUJBQWlCLENBQUM7b0JBQUU3QixPQUFPO2dCQUFFO2dCQUUvRSxNQUFNOEIsU0FBUyxNQUFNbUQscUJBQW9CVywwQkFBMEIsQ0FBQztnQkFFcEUzRCxPQUFPaEMsV0FBVytFLFlBQVksQ0FBQ1EsVUFBVSxFQUFFdEQsb0JBQW9CLENBQUM7b0JBQzlEQyxPQUFPO3dCQUFFc0IsUUFBUTtvQkFBRTtvQkFDbkJRLE1BQU07d0JBQUVjLFdBQVc7b0JBQUs7Z0JBQzFCO2dCQUNBOUMsT0FBT0gsUUFBUTRELElBQUksQ0FBQztZQUN0QjtRQUNGO1FBRUFoRixTQUFTLHdCQUF3QjtZQUMvQmlCLEdBQUcsaUNBQWlDO2dCQUNqQzFCLFdBQVcrRSxZQUFZLENBQUNhLFVBQVUsQ0FBZWhFLGlCQUFpQixDQUFDO29CQUFFN0IsT0FBTztnQkFBRztnQkFFaEYsTUFBTWlGLHFCQUFvQmEsb0JBQW9CO2dCQUU5QzdELE9BQU9oQyxXQUFXK0UsWUFBWSxDQUFDYSxVQUFVLEVBQUUzRCxvQkFBb0IsQ0FBQztvQkFDOURDLE9BQU87d0JBQ0w0RCxJQUFJOzRCQUNGO2dDQUFFbEIsV0FBVztvQ0FBRW1CLElBQUkvRCxPQUFPcUIsR0FBRyxDQUFDN0I7Z0NBQU07NEJBQUU7NEJBQ3RDO2dDQUFFc0QsV0FBVzs0QkFBSzt5QkFDbkI7b0JBQ0g7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQXJFLFNBQVMsNkJBQTZCO1FBQ3BDaUIsR0FBRyxnREFBZ0Q7WUFDakQsb0NBQW9DO1lBQ3BDLE1BQU1zRSxjQUFjO2dCQUFFL0UsTUFBTTtnQkFBZ0JFLE9BQU87WUFBTTtZQUN6RCxNQUFNMEIsaUJBQWlCO2dCQUNyQjdCLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05FLE9BQU87Z0JBQ1BELGFBQWE7Z0JBQ2IrRSxVQUFVO2dCQUNWQyxPQUFPO2dCQUNQM0UsV0FBVyxJQUFJQztnQkFDZkMsV0FBVyxJQUFJRDtZQUNqQjtZQUVDakMsWUFBWUssTUFBTSxDQUFlZ0MsaUJBQWlCLENBQUNpQjtZQUNuRDdDLFdBQVc2RCxRQUFRLENBQUNqRSxNQUFNLENBQWVnQyxpQkFBaUIsQ0FBQztnQkFDMURaLElBQUk7Z0JBQ0p3QyxRQUFRO2dCQUNSQyxRQUFRO2dCQUNSQyxRQUFRO2dCQUNSQyxVQUFVO2dCQUNWQyxTQUFTb0M7Z0JBQ1R6RSxXQUFXLElBQUlDO1lBQ2pCO1lBRUEsaUJBQWlCO1lBQ2pCLE1BQU0yRSxVQUFVLE1BQU1yRSw4QkFBYyxDQUFDZ0IsYUFBYSxDQUFDa0Q7WUFFbkQsbUJBQW1CO1lBQ25CLE1BQU1sQywwQkFBWSxDQUFDQyxTQUFTLENBQUM7Z0JBQzNCUCxRQUFRO2dCQUNSQyxRQUFRO2dCQUNSQyxRQUFRO2dCQUNSQyxVQUFVd0MsUUFBUW5GLEVBQUU7Z0JBQ3BCNEMsU0FBU29DO1lBQ1g7WUFFQWhFLE9BQU9tRSxTQUFTaEUsT0FBTyxDQUFDVTtZQUN4QmIsT0FBT2hDLFdBQVc2RCxRQUFRLENBQUNqRSxNQUFNLEVBQUV3RyxnQkFBZ0I7UUFDckQ7UUFFQTFFLEdBQUcsMkNBQTJDO1lBQzVDLE1BQU1XLFVBQVUsSUFBSUMsTUFBTTtZQUN6Qi9DLFlBQVlDLE9BQU8sQ0FBZStDLGlCQUFpQixDQUFDRjtZQUNwRHJDLFdBQVc2RCxRQUFRLENBQUNqRSxNQUFNLENBQWUyQyxpQkFBaUIsQ0FBQ0Y7WUFFNUQsbURBQW1EO1lBQ25ELE1BQU1MLE9BQU9GLDhCQUFjLENBQUNDLGNBQWMsSUFBSVMsT0FBTyxDQUFDQyxPQUFPLENBQUM7WUFFOUQsTUFBTXFCLDBCQUFZLENBQUNDLFNBQVMsQ0FBQztnQkFDM0JQLFFBQVE7Z0JBQ1JDLFFBQVE7Z0JBQ1JDLFFBQVE7WUFDVjtZQUVBLDRFQUE0RTtZQUM1RTFCLE9BQU9oQyxXQUFXNkQsUUFBUSxDQUFDakUsTUFBTSxFQUFFd0csZ0JBQWdCO1FBQ3JEO0lBQ0Y7QUFDRiJ9