{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/__tests__/e2e/audit-trail.spec.ts"],"sourcesContent":["import { test, expect, Page } from '@playwright/test';\n\n// Helper function to login (assuming you have a login flow)\nasync function login(page: Page) {\n  // Navigate to login page\n  await page.goto('/login');\n  \n  // Fill in credentials (adjust selectors based on your login form)\n  await page.fill('[data-testid=\"email\"]', 'test@example.com');\n  await page.fill('[data-testid=\"password\"]', 'password123');\n  \n  // Submit login form\n  await page.click('[data-testid=\"login-button\"]');\n  \n  // Wait for redirect to dashboard or home page\n  await page.waitForURL('**/dashboard');\n}\n\ntest.describe('Audit Trail E2E Tests', () => {\n  test.beforeEach(async ({ page }) => {\n    // Login before each test\n    await login(page);\n    \n    // Navigate to audit trail page\n    await page.goto('/audit-trail');\n    \n    // Wait for the page to load\n    await expect(page.locator('h1')).toContainText('Audit Trail');\n  });\n\n  test('should display audit trail page with filters', async ({ page }) => {\n    // Check if main elements are present\n    await expect(page.locator('[role=\"tab\"]').filter({ hasText: 'Recycle Bin' })).toBeVisible();\n    await expect(page.locator('[role=\"tab\"]').filter({ hasText: 'Audit History' })).toBeVisible();\n    \n    // Check if filter controls are present\n    await expect(page.locator('input[placeholder*=\"Search\"]')).toBeVisible();\n    await expect(page.locator('text=Entity Type')).toBeVisible();\n    await expect(page.locator('text=From Date')).toBeVisible();\n    await expect(page.locator('text=To Date')).toBeVisible();\n  });\n\n  test('should filter by entity type', async ({ page }) => {\n    // Wait for initial data to load\n    await page.waitForLoadState('networkidle');\n    \n    // Click on entity filter dropdown\n    await page.click('[role=\"combobox\"]');\n    \n    // Select 'product' option\n    await page.click('[role=\"option\"]', { hasText: 'Product' });\n    \n    // Wait for the API call to complete\n    await page.waitForResponse(response => \n      response.url().includes('/api/audit-trail') && \n      response.url().includes('entity=product')\n    );\n    \n    // Verify that the filter is applied by checking the URL or table content\n    // This depends on your implementation - you might check if only product entries are shown\n    const tableRows = page.locator('table tbody tr');\n    const rowCount = await tableRows.count();\n    \n    if (rowCount > 0) {\n      // Check if all visible rows are product entities\n      for (let i = 0; i < rowCount; i++) {\n        const entityCell = tableRows.nth(i).locator('td').first();\n        await expect(entityCell).toContainText('Product', { ignoreCase: true });\n      }\n    }\n  });\n\n  test('should filter by date range', async ({ page }) => {\n    // Wait for initial data to load\n    await page.waitForLoadState('networkidle');\n    \n    // Click on \"From Date\" button\n    await page.click('button:has-text(\"From Date\")');\n    \n    // Select a date from the calendar (this is a simplified approach)\n    // In a real scenario, you'd interact with the calendar component\n    await page.click('[role=\"gridcell\"]:has-text(\"15\")');\n    \n    // Click on \"To Date\" button\n    await page.click('button:has-text(\"To Date\")');\n    \n    // Select an end date\n    await page.click('[role=\"gridcell\"]:has-text(\"20\")');\n    \n    // Wait for the API call with date parameters\n    await page.waitForResponse(response => \n      response.url().includes('/api/audit-trail') && \n      response.url().includes('dateFrom=')\n    );\n    \n    // Verify that the clear button is now visible\n    await expect(page.locator('button:has-text(\"Clear\")')).toBeVisible();\n  });\n\n  test('should clear date filters', async ({ page }) => {\n    // First set some date filters (simplified)\n    await page.click('button:has-text(\"From Date\")');\n    await page.click('[role=\"gridcell\"]:has-text(\"15\")');\n    \n    await page.click('button:has-text(\"To Date\")');\n    await page.click('[role=\"gridcell\"]:has-text(\"20\")');\n    \n    // Wait for the filters to be applied\n    await page.waitForResponse(response => \n      response.url().includes('/api/audit-trail') && \n      response.url().includes('dateFrom=')\n    );\n    \n    // Click the clear button\n    await page.click('button:has-text(\"Clear\")');\n    \n    // Wait for the API call without date parameters\n    await page.waitForResponse(response => \n      response.url().includes('/api/audit-trail') && \n      !response.url().includes('dateFrom=')\n    );\n    \n    // Verify that the date buttons are reset\n    await expect(page.locator('button:has-text(\"From Date\")')).toBeVisible();\n    await expect(page.locator('button:has-text(\"To Date\")')).toBeVisible();\n  });\n\n  test('should combine entity and date filters', async ({ page }) => {\n    // Wait for initial data to load\n    await page.waitForLoadState('networkidle');\n    \n    // Set entity filter\n    await page.click('[role=\"combobox\"]');\n    await page.click('[role=\"option\"]', { hasText: 'Customer' });\n    \n    // Set date filter\n    await page.click('button:has-text(\"From Date\")');\n    await page.click('[role=\"gridcell\"]:has-text(\"10\")');\n    \n    // Wait for API call with both filters\n    await page.waitForResponse(response => \n      response.url().includes('/api/audit-trail') && \n      response.url().includes('entity=customer') &&\n      response.url().includes('dateFrom=')\n    );\n    \n    // Verify that both filters are applied\n    const tableRows = page.locator('table tbody tr');\n    const rowCount = await tableRows.count();\n    \n    if (rowCount > 0) {\n      // Check if all visible rows are customer entities\n      for (let i = 0; i < rowCount; i++) {\n        const entityCell = tableRows.nth(i).locator('td').first();\n        await expect(entityCell).toContainText('Customer', { ignoreCase: true });\n      }\n    }\n  });\n\n  test('should switch between tabs and maintain filters', async ({ page }) => {\n    // Set a filter on the recycle bin tab\n    await page.click('[role=\"combobox\"]');\n    await page.click('[role=\"option\"]', { hasText: 'Product' });\n    \n    // Wait for the filter to be applied\n    await page.waitForResponse(response => \n      response.url().includes('/api/audit-trail') && \n      response.url().includes('entity=product') &&\n      response.url().includes('type=deleted')\n    );\n    \n    // Switch to audit history tab\n    await page.click('[role=\"tab\"]', { hasText: 'Audit History' });\n    \n    // Wait for audit history data to load with the same filter\n    await page.waitForResponse(response => \n      response.url().includes('/api/audit-trail') && \n      response.url().includes('entity=product') &&\n      response.url().includes('type=all')\n    );\n    \n    // Verify that the entity filter is still applied\n    await expect(page.locator('[role=\"combobox\"]')).toContainText('Product');\n  });\n\n  test('should handle pagination with filters', async ({ page }) => {\n    // Set filters\n    await page.click('[role=\"combobox\"]');\n    await page.click('[role=\"option\"]', { hasText: 'Invoice' });\n    \n    // Wait for filtered data\n    await page.waitForResponse(response => \n      response.url().includes('/api/audit-trail') && \n      response.url().includes('entity=invoice')\n    );\n    \n    // Check if pagination controls are present (if there's enough data)\n    const nextButton = page.locator('button:has-text(\"Next\")');\n    if (await nextButton.isVisible()) {\n      await nextButton.click();\n      \n      // Wait for the next page with filters maintained\n      await page.waitForResponse(response => \n        response.url().includes('/api/audit-trail') && \n        response.url().includes('entity=invoice') &&\n        response.url().includes('offset=')\n      );\n    }\n  });\n\n  test('should display error message for invalid date range', async ({ page }) => {\n    // Set \"To Date\" before \"From Date\" (invalid range)\n    await page.click('button:has-text(\"To Date\")');\n    await page.click('[role=\"gridcell\"]:has-text(\"10\")');\n    \n    await page.click('button:has-text(\"From Date\")');\n    await page.click('[role=\"gridcell\"]:has-text(\"20\")');\n    \n    // Check if an error message or validation appears\n    // This depends on your validation implementation\n    // You might check for a toast notification or inline error\n    await expect(page.locator('[role=\"alert\"]')).toBeVisible();\n  });\n\n  test('should recover items from recycle bin', async ({ page }) => {\n    // Ensure we're on the recycle bin tab\n    await page.click('[role=\"tab\"]', { hasText: 'Recycle Bin' });\n    \n    // Wait for data to load\n    await page.waitForLoadState('networkidle');\n    \n    // Check if there are any recoverable items\n    const recoverButtons = page.locator('button:has-text(\"Recover\")');\n    const buttonCount = await recoverButtons.count();\n    \n    if (buttonCount > 0) {\n      // Click the first recover button\n      await recoverButtons.first().click();\n      \n      // Confirm the recovery in the dialog\n      await page.click('button:has-text(\"Confirm\")');\n      \n      // Wait for the recovery API call\n      await page.waitForResponse(response => \n        response.url().includes('/api/audit-trail') && \n        response.request().method() === 'POST'\n      );\n      \n      // Verify success message\n      await expect(page.locator('text=successfully recovered')).toBeVisible();\n    }\n  });\n\n  test('should search within filtered results', async ({ page }) => {\n    // Set entity filter\n    await page.click('[role=\"combobox\"]');\n    await page.click('[role=\"option\"]', { hasText: 'Product' });\n    \n    // Wait for filtered data\n    await page.waitForLoadState('networkidle');\n    \n    // Enter search term\n    await page.fill('input[placeholder*=\"Search\"]', 'test');\n    \n    // Wait for search to be applied (this might be debounced)\n    await page.waitForTimeout(500);\n    \n    // Verify that both entity filter and search are applied\n    const tableRows = page.locator('table tbody tr');\n    const rowCount = await tableRows.count();\n    \n    if (rowCount > 0) {\n      // Check if results contain the search term and are of the correct entity type\n      for (let i = 0; i < rowCount; i++) {\n        const row = tableRows.nth(i);\n        const entityCell = row.locator('td').first();\n        await expect(entityCell).toContainText('Product', { ignoreCase: true });\n        \n        // Check if the row contains the search term somewhere\n        await expect(row).toContainText('test', { ignoreCase: true });\n      }\n    }\n  });\n});"],"names":["login","page","goto","fill","click","waitForURL","test","describe","beforeEach","expect","locator","toContainText","filter","hasText","toBeVisible","waitForLoadState","waitForResponse","response","url","includes","tableRows","rowCount","count","i","entityCell","nth","first","ignoreCase","nextButton","isVisible","recoverButtons","buttonCount","request","method","waitForTimeout","row"],"mappings":"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"}