{"version":3,"sources":["/Users/sachin/Documents/md-sports-/tests/api/bulkImportSimple.test.ts"],"sourcesContent":["import * as XLSX from 'xlsx';\n\n// Mock the authentication and database modules\njest.mock('@/lib/auth', () => ({\n  validateTokenPermission: jest.fn(),\n}));\n\njest.mock('@/lib/prisma', () => ({\n  prisma: {\n    product: {\n      findUnique: jest.fn(),\n      create: jest.fn(),\n      findMany: jest.fn(),\n    },\n    category: {\n      findFirst: jest.fn(),\n    },\n    shop: {\n      findFirst: jest.fn(),\n      findMany: jest.fn(),\n    },\n    inventoryItem: {\n      create: jest.fn(),\n    },\n    $transaction: jest.fn(),\n  },\n}));\n\ndescribe('Bulk Import Business Logic Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Excel File Processing', () => {\n    const createTestExcelBuffer = (data: any[]) => {\n      const ws = XLSX.utils.json_to_sheet(data);\n      const wb = XLSX.utils.book_new();\n      XLSX.utils.book_append_sheet(wb, ws, 'Products');\n      return XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });\n    };\n\n    it('should parse Excel file correctly', () => {\n      const testData = [\n        {\n          Name: 'Test Product',\n          SKU: 'TP001',\n          RetailPrice: 100,\n          CostPrice: 80,\n        },\n      ];\n\n      const buffer = createTestExcelBuffer(testData);\n      const workbook = XLSX.read(buffer, { type: 'buffer' });\n      const sheetName = workbook.SheetNames[0];\n      const worksheet = workbook.Sheets[sheetName];\n      const jsonData = XLSX.utils.sheet_to_json(worksheet);\n\n      expect(jsonData).toHaveLength(1);\n      expect(jsonData[0]).toEqual(expect.objectContaining({\n        Name: 'Test Product',\n        SKU: 'TP001',\n        RetailPrice: 100,\n        CostPrice: 80,\n      }));\n    });\n\n    it('should handle empty Excel files', () => {\n      const testData: any[] = [];\n      const buffer = createTestExcelBuffer(testData);\n      const workbook = XLSX.read(buffer, { type: 'buffer' });\n      const sheetName = workbook.SheetNames[0];\n      const worksheet = workbook.Sheets[sheetName];\n      const jsonData = XLSX.utils.sheet_to_json(worksheet);\n\n      expect(jsonData).toHaveLength(0);\n    });\n\n    it('should parse different data types correctly', () => {\n      const testData = [\n        {\n          Name: 'Product 1',\n          SKU: 'P001',\n          RetailPrice: '100.50', // String number\n          CostPrice: 80.25,      // Actual number\n          InitialQuantity: '25', // String number\n        },\n      ];\n\n      const buffer = createTestExcelBuffer(testData);\n      const workbook = XLSX.read(buffer, { type: 'buffer' });\n      const sheetName = workbook.SheetNames[0];\n      const worksheet = workbook.Sheets[sheetName];\n      const jsonData = XLSX.utils.sheet_to_json(worksheet);\n\n      const product = jsonData[0] as any;\n      expect(parseFloat(String(product.RetailPrice))).toBe(100.5);\n      expect(product.CostPrice).toBe(80.25);\n      expect(parseInt(String(product.InitialQuantity))).toBe(25);\n    });\n  });\n\n  describe('Data Validation Logic', () => {\n    const validateProduct = (product: any) => {\n      const errors: string[] = [];\n\n      // Name validation\n      if (!product.Name?.trim()) {\n        errors.push('Product Name is required');\n      }\n\n      // Price validation\n      const price = parseFloat(String(product.RetailPrice));\n      if (!product.RetailPrice || isNaN(price) || price < 0) {\n        errors.push('Invalid or missing Retail Price');\n      }\n\n      // SKU validation\n      if (product.SKU && typeof product.SKU !== 'string') {\n        errors.push('SKU must be a string');\n      }\n\n      // Initial quantity and shop validation\n      const initialQuantity = product.InitialQuantity ? parseInt(String(product.InitialQuantity)) : 0;\n      if (initialQuantity > 0 && !product.ShopName?.trim()) {\n        errors.push('Shop Name is required when Initial Quantity is greater than 0');\n      }\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n        parsedData: {\n          name: product.Name?.trim(),\n          sku: product.SKU?.trim() || null,\n          price,\n          initialQuantity,\n          shopName: product.ShopName?.trim() || null,\n        },\n      };\n    };\n\n    it('should validate required fields correctly', () => {\n      const validProduct = {\n        Name: 'Valid Product',\n        RetailPrice: 100,\n      };\n\n      const invalidProduct = {\n        Name: '',\n        RetailPrice: 'invalid',\n      };\n\n      const validResult = validateProduct(validProduct);\n      const invalidResult = validateProduct(invalidProduct);\n\n      expect(validResult.isValid).toBe(true);\n      expect(validResult.errors).toHaveLength(0);\n\n      expect(invalidResult.isValid).toBe(false);\n      expect(invalidResult.errors).toContain('Product Name is required');\n      expect(invalidResult.errors).toContain('Invalid or missing Retail Price');\n    });\n\n    it('should validate InitialQuantity and ShopName relationship', () => {\n      const productWithQuantityNoShop = {\n        Name: 'Test Product',\n        RetailPrice: 100,\n        InitialQuantity: 50,\n        ShopName: '',\n      };\n\n      const productWithQuantityAndShop = {\n        Name: 'Test Product',\n        RetailPrice: 100,\n        InitialQuantity: 50,\n        ShopName: 'Test Shop',\n      };\n\n      const result1 = validateProduct(productWithQuantityNoShop);\n      const result2 = validateProduct(productWithQuantityAndShop);\n\n      expect(result1.isValid).toBe(false);\n      expect(result1.errors).toContain('Shop Name is required when Initial Quantity is greater than 0');\n\n      expect(result2.isValid).toBe(true);\n      expect(result2.errors).toHaveLength(0);\n    });\n\n    it('should handle numeric string parsing', () => {\n      const product = {\n        Name: 'Test Product',\n        RetailPrice: '123.45',\n        CostPrice: '67.89',\n        InitialQuantity: '10',\n        ShopName: 'Test Shop', // Required since InitialQuantity > 0\n      };\n\n      const result = validateProduct(product);\n\n      expect(result.isValid).toBe(true);\n      expect(result.parsedData.price).toBe(123.45);\n      expect(result.parsedData.initialQuantity).toBe(10);\n    });\n  });\n\n  describe('Duplicate Detection Logic', () => {\n    const detectDuplicateSKUs = (products: any[]) => {\n      const skuMap = new Map<string, number[]>();\n      const duplicates: { sku: string; rows: number[] }[] = [];\n\n      products.forEach((product, index) => {\n        const sku = product.SKU?.trim();\n        if (sku) {\n          if (!skuMap.has(sku)) {\n            skuMap.set(sku, []);\n          }\n          skuMap.get(sku)!.push(index + 2); // +2 for Excel row numbering (header + 1-based)\n        }\n      });\n\n      skuMap.forEach((rows, sku) => {\n        if (rows.length > 1) {\n          duplicates.push({ sku, rows });\n        }\n      });\n\n      return duplicates;\n    };\n\n    it('should detect duplicate SKUs within batch', () => {\n      const products = [\n        { Name: 'Product 1', SKU: 'P001', RetailPrice: 100 },\n        { Name: 'Product 2', SKU: 'P002', RetailPrice: 200 },\n        { Name: 'Product 3', SKU: 'P001', RetailPrice: 300 }, // Duplicate\n        { Name: 'Product 4', SKU: 'P003', RetailPrice: 400 },\n        { Name: 'Product 5', SKU: 'P002', RetailPrice: 500 }, // Duplicate\n      ];\n\n      const duplicates = detectDuplicateSKUs(products);\n\n      expect(duplicates).toHaveLength(2);\n      expect(duplicates.find(d => d.sku === 'P001')?.rows).toEqual([2, 4]);\n      expect(duplicates.find(d => d.sku === 'P002')?.rows).toEqual([3, 6]);\n    });\n\n    it('should handle products without SKUs', () => {\n      const products = [\n        { Name: 'Product 1', RetailPrice: 100 }, // No SKU\n        { Name: 'Product 2', SKU: 'P002', RetailPrice: 200 },\n        { Name: 'Product 3', SKU: '', RetailPrice: 300 }, // Empty SKU\n      ];\n\n      const duplicates = detectDuplicateSKUs(products);\n\n      expect(duplicates).toHaveLength(0);\n    });\n  });\n\n  describe('Batch Processing Logic', () => {\n    const processBatch = async (products: any[]) => {\n      const results: Array<{ index: number; success: boolean; message: string; productName?: string }> = [];\n      let successCount = 0;\n\n      for (let i = 0; i < products.length; i++) {\n        const product = products[i];\n        const rowIndex = i + 2; // Excel row numbering\n\n        try {\n          // Simulate validation\n          if (!product.Name || !product.RetailPrice) {\n            throw new Error('Missing required fields');\n          }\n\n          // Simulate successful processing\n          results.push({\n            index: rowIndex,\n            success: true,\n            message: 'Product processed successfully',\n            productName: product.Name,\n          });\n          successCount++;\n        } catch (error) {\n          results.push({\n            index: rowIndex,\n            success: false,\n            message: error instanceof Error ? error.message : 'Unknown error',\n            productName: product.Name,\n          });\n        }\n      }\n\n      return {\n        success: successCount > 0,\n        totalProcessed: products.length,\n        successCount,\n        failureCount: products.length - successCount,\n        results,\n      };\n    };\n\n    it('should process mixed valid and invalid products', async () => {\n      const products = [\n        { Name: 'Valid Product 1', RetailPrice: 100 },\n        { Name: '', RetailPrice: 200 }, // Invalid: no name\n        { Name: 'Valid Product 2', RetailPrice: 300 },\n        { Name: 'Invalid Product', RetailPrice: null }, // Invalid: no price\n      ];\n\n      const result = await processBatch(products);\n\n      expect(result.success).toBe(true);\n      expect(result.totalProcessed).toBe(4);\n      expect(result.successCount).toBe(2);\n      expect(result.failureCount).toBe(2);\n      expect(result.results).toHaveLength(4);\n\n      const successfulResults = result.results.filter(r => r.success);\n      const failedResults = result.results.filter(r => !r.success);\n\n      expect(successfulResults).toHaveLength(2);\n      expect(failedResults).toHaveLength(2);\n    });\n\n    it('should handle empty batch', async () => {\n      const result = await processBatch([]);\n\n      expect(result.success).toBe(false);\n      expect(result.totalProcessed).toBe(0);\n      expect(result.successCount).toBe(0);\n      expect(result.failureCount).toBe(0);\n      expect(result.results).toHaveLength(0);\n    });\n  });\n\n  describe('File Type Validation', () => {\n    const validateFileType = (fileName: string, fileType: string) => {\n      const allowedTypes = [\n        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // .xlsx\n        'application/vnd.ms-excel', // .xls\n        'text/csv', // .csv\n      ];\n\n      const allowedExtensions = ['.xlsx', '.xls', '.csv'];\n      const extension = fileName.toLowerCase().split('.').pop();\n\n      return {\n        isValidType: allowedTypes.includes(fileType),\n        isValidExtension: allowedExtensions.includes(`.${extension}`),\n        isValid: allowedTypes.includes(fileType) && allowedExtensions.includes(`.${extension}`),\n      };\n    };\n\n    it('should validate Excel file types', () => {\n      const xlsxResult = validateFileType(\n        'products.xlsx',\n        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n      );\n      const xlsResult = validateFileType(\n        'products.xls',\n        'application/vnd.ms-excel'\n      );\n      const csvResult = validateFileType(\n        'products.csv',\n        'text/csv'\n      );\n\n      expect(xlsxResult.isValid).toBe(true);\n      expect(xlsResult.isValid).toBe(true);\n      expect(csvResult.isValid).toBe(true);\n    });\n\n    it('should reject invalid file types', () => {\n      const txtResult = validateFileType('products.txt', 'text/plain');\n      const pdfResult = validateFileType('products.pdf', 'application/pdf');\n\n      expect(txtResult.isValid).toBe(false);\n      expect(pdfResult.isValid).toBe(false);\n    });\n  });\n}); "],"names":["jest","mock","validateTokenPermission","fn","prisma","product","findUnique","create","findMany","category","findFirst","shop","inventoryItem","$transaction","describe","beforeEach","clearAllMocks","createTestExcelBuffer","data","ws","XLSX","utils","json_to_sheet","wb","book_new","book_append_sheet","write","type","bookType","it","testData","Name","SKU","RetailPrice","CostPrice","buffer","workbook","read","sheetName","SheetNames","worksheet","Sheets","jsonData","sheet_to_json","expect","toHaveLength","toEqual","objectContaining","InitialQuantity","parseFloat","String","toBe","parseInt","validateProduct","errors","trim","push","price","isNaN","initialQuantity","ShopName","isValid","length","parsedData","name","sku","shopName","validProduct","invalidProduct","validResult","invalidResult","toContain","productWithQuantityNoShop","productWithQuantityAndShop","result1","result2","result","detectDuplicateSKUs","products","skuMap","Map","duplicates","forEach","index","has","set","get","rows","find","d","processBatch","results","successCount","i","rowIndex","Error","success","message","productName","error","totalProcessed","failureCount","successfulResults","filter","r","failedResults","validateFileType","fileName","fileType","allowedTypes","allowedExtensions","extension","toLowerCase","split","pop","isValidType","includes","isValidExtension","xlsxResult","xlsResult","csvResult","txtResult","pdfResult"],"mappings":"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"}