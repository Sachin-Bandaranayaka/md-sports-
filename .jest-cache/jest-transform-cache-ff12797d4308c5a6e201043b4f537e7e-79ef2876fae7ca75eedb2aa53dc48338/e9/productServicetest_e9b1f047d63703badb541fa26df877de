fb82ac7cfb08c771f36e991c0305e385
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _productService = require("../../src/services/productService");
// Mock the Product model
const mockProduct = {
    findAll: _globals.jest.fn(),
    findOne: _globals.jest.fn(),
    findByPk: _globals.jest.fn(),
    create: _globals.jest.fn(),
    update: _globals.jest.fn()
};
// Mock the Product import
_globals.jest.mock("@/lib/models/Product", ()=>mockProduct);
(0, _globals.describe)("ProductService", ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.afterEach)(()=>{
        _globals.jest.resetAllMocks();
    });
    (0, _globals.describe)("getAllProducts", ()=>{
        (0, _globals.it)("should return all active products", async ()=>{
            const mockProducts = [
                {
                    id: 1,
                    name: "Product 1",
                    isActive: true
                },
                {
                    id: 2,
                    name: "Product 2",
                    isActive: true
                }
            ];
            mockProduct.findAll.mockResolvedValue(mockProducts);
            const result = await _productService.productService.getAllProducts();
            (0, _globals.expect)(result).toEqual(mockProducts);
            (0, _globals.expect)(mockProduct.findAll).toHaveBeenCalledWith({
                where: {
                    isActive: true
                }
            });
        });
        (0, _globals.it)("should handle database errors", async ()=>{
            const error = new Error("Database connection failed");
            mockProduct.findAll.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.getAllProducts()).rejects.toThrow("Database connection failed");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error fetching products:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should return empty array when no products found", async ()=>{
            mockProduct.findAll.mockResolvedValue([]);
            const result = await _productService.productService.getAllProducts();
            (0, _globals.expect)(result).toEqual([]);
            (0, _globals.expect)(mockProduct.findAll).toHaveBeenCalledWith({
                where: {
                    isActive: true
                }
            });
        });
    });
    (0, _globals.describe)("getProductById", ()=>{
        (0, _globals.it)("should return a product by ID", async ()=>{
            const mockProduct_data = {
                id: 1,
                name: "Test Product",
                isActive: true
            };
            mockProduct.findOne.mockResolvedValue(mockProduct_data);
            const result = await _productService.productService.getProductById(1);
            (0, _globals.expect)(result).toEqual(mockProduct_data);
            (0, _globals.expect)(mockProduct.findOne).toHaveBeenCalledWith({
                where: {
                    id: 1,
                    isActive: true
                }
            });
        });
        (0, _globals.it)("should return null when product not found", async ()=>{
            mockProduct.findOne.mockResolvedValue(null);
            const result = await _productService.productService.getProductById(999);
            (0, _globals.expect)(result).toBeNull();
            (0, _globals.expect)(mockProduct.findOne).toHaveBeenCalledWith({
                where: {
                    id: 999,
                    isActive: true
                }
            });
        });
        (0, _globals.it)("should handle database errors", async ()=>{
            const error = new Error("Database error");
            mockProduct.findOne.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.getProductById(1)).rejects.toThrow("Database error");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error fetching product with ID 1:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle invalid ID types", async ()=>{
            const error = new Error("Invalid ID");
            mockProduct.findOne.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.getProductById(NaN)).rejects.toThrow("Invalid ID");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error fetching product with ID NaN:", error);
            consoleSpy.mockRestore();
        });
    });
    (0, _globals.describe)("createProduct", ()=>{
        (0, _globals.it)("should create a new product successfully", async ()=>{
            const productData = {
                name: "New Product",
                price: 99.99,
                description: "A new product",
                isActive: true
            };
            const createdProduct = {
                id: 1,
                ...productData
            };
            mockProduct.create.mockResolvedValue(createdProduct);
            const result = await _productService.productService.createProduct(productData);
            (0, _globals.expect)(result).toEqual(createdProduct);
            (0, _globals.expect)(mockProduct.create).toHaveBeenCalledWith(productData);
        });
        (0, _globals.it)("should handle validation errors", async ()=>{
            const productData = {
                name: ""
            }; // Invalid data
            const error = new Error("Validation failed");
            mockProduct.create.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.createProduct(productData)).rejects.toThrow("Validation failed");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error creating product:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle database constraint errors", async ()=>{
            const productData = {
                name: "Duplicate Product"
            };
            const error = new Error("Unique constraint violation");
            mockProduct.create.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.createProduct(productData)).rejects.toThrow("Unique constraint violation");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error creating product:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should create product with minimal required fields", async ()=>{
            const productData = {
                name: "Minimal Product"
            };
            const createdProduct = {
                id: 1,
                ...productData
            };
            mockProduct.create.mockResolvedValue(createdProduct);
            const result = await _productService.productService.createProduct(productData);
            (0, _globals.expect)(result).toEqual(createdProduct);
            (0, _globals.expect)(mockProduct.create).toHaveBeenCalledWith(productData);
        });
    });
    (0, _globals.describe)("updateProduct", ()=>{
        (0, _globals.it)("should update an existing product successfully", async ()=>{
            const productData = {
                name: "Updated Product",
                price: 149.99
            };
            const existingProduct = {
                id: 1,
                name: "Old Product",
                price: 99.99,
                update: _globals.jest.fn().mockResolvedValue({
                    id: 1,
                    ...productData
                })
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const result = await _productService.productService.updateProduct(1, productData);
            (0, _globals.expect)(result).toEqual({
                id: 1,
                ...productData
            });
            (0, _globals.expect)(mockProduct.findByPk).toHaveBeenCalledWith(1);
            (0, _globals.expect)(existingProduct.update).toHaveBeenCalledWith(productData);
        });
        (0, _globals.it)("should throw error when product not found", async ()=>{
            const productData = {
                name: "Updated Product"
            };
            mockProduct.findByPk.mockResolvedValue(null);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.updateProduct(999, productData)).rejects.toThrow("Product with ID 999 not found");
            (0, _globals.expect)(mockProduct.findByPk).toHaveBeenCalledWith(999);
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error updating product with ID 999:", _globals.expect.any(Error));
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle update validation errors", async ()=>{
            const productData = {
                price: -10
            }; // Invalid price
            const existingProduct = {
                id: 1,
                update: _globals.jest.fn().mockRejectedValue(new Error("Invalid price"))
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.updateProduct(1, productData)).rejects.toThrow("Invalid price");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error updating product with ID 1:", _globals.expect.any(Error));
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle database errors during update", async ()=>{
            const productData = {
                name: "Updated Product"
            };
            const error = new Error("Database connection lost");
            mockProduct.findByPk.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.updateProduct(1, productData)).rejects.toThrow("Database connection lost");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error updating product with ID 1:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should update only provided fields", async ()=>{
            const productData = {
                name: "Updated Name Only"
            };
            const existingProduct = {
                id: 1,
                name: "Old Name",
                price: 99.99,
                description: "Old Description",
                update: _globals.jest.fn().mockResolvedValue({
                    id: 1,
                    name: "Updated Name Only",
                    price: 99.99,
                    description: "Old Description"
                })
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const result = await _productService.productService.updateProduct(1, productData);
            (0, _globals.expect)(existingProduct.update).toHaveBeenCalledWith(productData);
            (0, _globals.expect)(result.name).toBe("Updated Name Only");
            (0, _globals.expect)(result.price).toBe(99.99); // Should remain unchanged
        });
    });
    (0, _globals.describe)("deleteProduct", ()=>{
        (0, _globals.it)("should soft delete a product successfully", async ()=>{
            const existingProduct = {
                id: 1,
                name: "Product to Delete",
                isActive: true,
                update: _globals.jest.fn().mockResolvedValue({
                    id: 1,
                    name: "Product to Delete",
                    isActive: false
                })
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const result = await _productService.productService.deleteProduct(1);
            (0, _globals.expect)(result).toEqual({
                id: 1,
                name: "Product to Delete",
                isActive: false
            });
            (0, _globals.expect)(mockProduct.findByPk).toHaveBeenCalledWith(1);
            (0, _globals.expect)(existingProduct.update).toHaveBeenCalledWith({
                isActive: false
            });
        });
        (0, _globals.it)("should throw error when product not found for deletion", async ()=>{
            mockProduct.findByPk.mockResolvedValue(null);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.deleteProduct(999)).rejects.toThrow("Product with ID 999 not found");
            (0, _globals.expect)(mockProduct.findByPk).toHaveBeenCalledWith(999);
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error deleting product with ID 999:", _globals.expect.any(Error));
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle database errors during deletion", async ()=>{
            const error = new Error("Database error during deletion");
            mockProduct.findByPk.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.deleteProduct(1)).rejects.toThrow("Database error during deletion");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error deleting product with ID 1:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle update errors during soft delete", async ()=>{
            const existingProduct = {
                id: 1,
                update: _globals.jest.fn().mockRejectedValue(new Error("Update failed"))
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.deleteProduct(1)).rejects.toThrow("Update failed");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error deleting product with ID 1:", _globals.expect.any(Error));
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should not affect already deleted products", async ()=>{
            // Reset the mock explicitly
            mockProduct.findByPk.mockReset();
            const existingProduct = {
                id: 1,
                name: "Already Deleted Product",
                isActive: false,
                update: _globals.jest.fn().mockResolvedValue({
                    id: 1,
                    name: "Already Deleted Product",
                    isActive: false
                })
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const result = await _productService.productService.deleteProduct(1);
            (0, _globals.expect)(result.isActive).toBe(false);
            (0, _globals.expect)(existingProduct.update).toHaveBeenCalledWith({
                isActive: false
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9wcm9kdWN0U2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IHByb2R1Y3RTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9wcm9kdWN0U2VydmljZSc7XG5cbi8vIE1vY2sgdGhlIFByb2R1Y3QgbW9kZWxcbmNvbnN0IG1vY2tQcm9kdWN0ID0ge1xuICBmaW5kQWxsOiBqZXN0LmZuKCksXG4gIGZpbmRPbmU6IGplc3QuZm4oKSxcbiAgZmluZEJ5UGs6IGplc3QuZm4oKSxcbiAgY3JlYXRlOiBqZXN0LmZuKCksXG4gIHVwZGF0ZTogamVzdC5mbigpLFxufTtcblxuLy8gTW9jayB0aGUgUHJvZHVjdCBpbXBvcnRcbmplc3QubW9jaygnQC9saWIvbW9kZWxzL1Byb2R1Y3QnLCAoKSA9PiBtb2NrUHJvZHVjdCk7XG5cbmRlc2NyaWJlKCdQcm9kdWN0U2VydmljZScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5yZXNldEFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRBbGxQcm9kdWN0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBhbGwgYWN0aXZlIHByb2R1Y3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Byb2R1Y3RzID0gW1xuICAgICAgICB7IGlkOiAxLCBuYW1lOiAnUHJvZHVjdCAxJywgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgICAgeyBpZDogMiwgbmFtZTogJ1Byb2R1Y3QgMicsIGlzQWN0aXZlOiB0cnVlIH0sXG4gICAgICBdO1xuXG4gICAgICBtb2NrUHJvZHVjdC5maW5kQWxsLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9kdWN0cyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1Byb2R1Y3RzKTtcbiAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kQWxsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7IGlzQWN0aXZlOiB0cnVlIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgbW9ja1Byb2R1Y3QuZmluZEFsbC5tb2NrUmVqZWN0ZWRWYWx1ZShlcnJvcik7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCkpLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdHM6JywgZXJyb3IpO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIG5vIHByb2R1Y3RzIGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1Byb2R1Y3QuZmluZEFsbC5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRBbGwpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHsgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0UHJvZHVjdEJ5SWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gYSBwcm9kdWN0IGJ5IElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Byb2R1Y3RfZGF0YSA9IHsgaWQ6IDEsIG5hbWU6ICdUZXN0IFByb2R1Y3QnLCBpc0FjdGl2ZTogdHJ1ZSB9O1xuICAgICAgbW9ja1Byb2R1Y3QuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvZHVjdF9kYXRhKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZ2V0UHJvZHVjdEJ5SWQoMSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1Byb2R1Y3RfZGF0YSk7XG4gICAgICBleHBlY3QobW9ja1Byb2R1Y3QuZmluZE9uZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZTogeyBpZDogMSwgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCB3aGVuIHByb2R1Y3Qgbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1Byb2R1Y3QuZmluZE9uZS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZ2V0UHJvZHVjdEJ5SWQoOTk5KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kT25lKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiA5OTksIGlzQWN0aXZlOiB0cnVlIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBlcnJvcicpO1xuICAgICAgbW9ja1Byb2R1Y3QuZmluZE9uZS5tb2NrUmVqZWN0ZWRWYWx1ZShlcnJvcik7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmdldFByb2R1Y3RCeUlkKDEpKS5yZWplY3RzLnRvVGhyb3coJ0RhdGFiYXNlIGVycm9yJyk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIGZldGNoaW5nIHByb2R1Y3Qgd2l0aCBJRCAxOicsIGVycm9yKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW52YWxpZCBJRCB0eXBlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIElEJyk7XG4gICAgICBtb2NrUHJvZHVjdC5maW5kT25lLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuZ2V0UHJvZHVjdEJ5SWQoTmFOKSkucmVqZWN0cy50b1Rocm93KCdJbnZhbGlkIElEJyk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIGZldGNoaW5nIHByb2R1Y3Qgd2l0aCBJRCBOYU46JywgZXJyb3IpO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjcmVhdGVQcm9kdWN0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IHByb2R1Y3Qgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSB7XG4gICAgICAgIG5hbWU6ICdOZXcgUHJvZHVjdCcsXG4gICAgICAgIHByaWNlOiA5OS45OSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdBIG5ldyBwcm9kdWN0JyxcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICB9O1xuICAgICAgY29uc3QgY3JlYXRlZFByb2R1Y3QgPSB7IGlkOiAxLCAuLi5wcm9kdWN0RGF0YSB9O1xuXG4gICAgICBtb2NrUHJvZHVjdC5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoY3JlYXRlZFByb2R1Y3QpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5jcmVhdGVQcm9kdWN0KHByb2R1Y3REYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChjcmVhdGVkUHJvZHVjdCk7XG4gICAgICBleHBlY3QobW9ja1Byb2R1Y3QuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwcm9kdWN0RGF0YSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB2YWxpZGF0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb2R1Y3REYXRhID0geyBuYW1lOiAnJyB9OyAvLyBJbnZhbGlkIGRhdGFcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdWYWxpZGF0aW9uIGZhaWxlZCcpO1xuICAgICAgbW9ja1Byb2R1Y3QuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuY3JlYXRlUHJvZHVjdChwcm9kdWN0RGF0YSkpLnJlamVjdHMudG9UaHJvdygnVmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgY3JlYXRpbmcgcHJvZHVjdDonLCBlcnJvcik7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGNvbnN0cmFpbnQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSB7IG5hbWU6ICdEdXBsaWNhdGUgUHJvZHVjdCcgfTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdVbmlxdWUgY29uc3RyYWludCB2aW9sYXRpb24nKTtcbiAgICAgIG1vY2tQcm9kdWN0LmNyZWF0ZS5tb2NrUmVqZWN0ZWRWYWx1ZShlcnJvcik7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3QocHJvZHVjdERhdGEpKS5yZWplY3RzLnRvVGhyb3coJ1VuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvbicpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBjcmVhdGluZyBwcm9kdWN0OicsIGVycm9yKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgcHJvZHVjdCB3aXRoIG1pbmltYWwgcmVxdWlyZWQgZmllbGRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSB7IG5hbWU6ICdNaW5pbWFsIFByb2R1Y3QnIH07XG4gICAgICBjb25zdCBjcmVhdGVkUHJvZHVjdCA9IHsgaWQ6IDEsIC4uLnByb2R1Y3REYXRhIH07XG5cbiAgICAgIG1vY2tQcm9kdWN0LmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShjcmVhdGVkUHJvZHVjdCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3QocHJvZHVjdERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGNyZWF0ZWRQcm9kdWN0KTtcbiAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHByb2R1Y3REYXRhKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3VwZGF0ZVByb2R1Y3QnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgYW4gZXhpc3RpbmcgcHJvZHVjdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHsgbmFtZTogJ1VwZGF0ZWQgUHJvZHVjdCcsIHByaWNlOiAxNDkuOTkgfTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUHJvZHVjdCA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdPbGQgUHJvZHVjdCcsXG4gICAgICAgIHByaWNlOiA5OS45OSxcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpZDogMSwgLi4ucHJvZHVjdERhdGEgfSksXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShleGlzdGluZ1Byb2R1Y3QpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDEsIHByb2R1Y3REYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IGlkOiAxLCAuLi5wcm9kdWN0RGF0YSB9KTtcbiAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kQnlQaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMSk7XG4gICAgICBleHBlY3QoZXhpc3RpbmdQcm9kdWN0LnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgocHJvZHVjdERhdGEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciB3aGVuIHByb2R1Y3Qgbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSB7IG5hbWU6ICdVcGRhdGVkIFByb2R1Y3QnIH07XG4gICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UudXBkYXRlUHJvZHVjdCg5OTksIHByb2R1Y3REYXRhKSkucmVqZWN0cy50b1Rocm93KCdQcm9kdWN0IHdpdGggSUQgOTk5IG5vdCBmb3VuZCcpO1xuICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRCeVBrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg5OTkpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciB1cGRhdGluZyBwcm9kdWN0IHdpdGggSUQgOTk5OicsIGV4cGVjdC5hbnkoRXJyb3IpKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdXBkYXRlIHZhbGlkYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSB7IHByaWNlOiAtMTAgfTsgLy8gSW52YWxpZCBwcmljZVxuICAgICAgY29uc3QgZXhpc3RpbmdQcm9kdWN0ID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdJbnZhbGlkIHByaWNlJykpLFxuICAgICAgfTtcblxuICAgICAgbW9ja1Byb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUoZXhpc3RpbmdQcm9kdWN0KTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UudXBkYXRlUHJvZHVjdCgxLCBwcm9kdWN0RGF0YSkpLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCBwcmljZScpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciB1cGRhdGluZyBwcm9kdWN0IHdpdGggSUQgMTonLCBleHBlY3QuYW55KEVycm9yKSk7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycyBkdXJpbmcgdXBkYXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSB7IG5hbWU6ICdVcGRhdGVkIFByb2R1Y3QnIH07XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBsb3N0Jyk7XG4gICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVqZWN0ZWRWYWx1ZShlcnJvcik7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLnVwZGF0ZVByb2R1Y3QoMSwgcHJvZHVjdERhdGEpKS5yZWplY3RzLnRvVGhyb3coJ0RhdGFiYXNlIGNvbm5lY3Rpb24gbG9zdCcpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciB1cGRhdGluZyBwcm9kdWN0IHdpdGggSUQgMTonLCBlcnJvcik7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXBkYXRlIG9ubHkgcHJvdmlkZWQgZmllbGRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSB7IG5hbWU6ICdVcGRhdGVkIE5hbWUgT25seScgfTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUHJvZHVjdCA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdPbGQgTmFtZScsXG4gICAgICAgIHByaWNlOiA5OS45OSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdPbGQgRGVzY3JpcHRpb24nLFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGlkOiAxLCBuYW1lOiAnVXBkYXRlZCBOYW1lIE9ubHknLCBwcmljZTogOTkuOTksIGRlc2NyaXB0aW9uOiAnT2xkIERlc2NyaXB0aW9uJyB9KSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKGV4aXN0aW5nUHJvZHVjdCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLnVwZGF0ZVByb2R1Y3QoMSwgcHJvZHVjdERhdGEpO1xuXG4gICAgICBleHBlY3QoZXhpc3RpbmdQcm9kdWN0LnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgocHJvZHVjdERhdGEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5uYW1lKS50b0JlKCdVcGRhdGVkIE5hbWUgT25seScpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wcmljZSkudG9CZSg5OS45OSk7IC8vIFNob3VsZCByZW1haW4gdW5jaGFuZ2VkXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdkZWxldGVQcm9kdWN0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc29mdCBkZWxldGUgYSBwcm9kdWN0IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUHJvZHVjdCA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdQcm9kdWN0IHRvIERlbGV0ZScsXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGlkOiAxLCBuYW1lOiAnUHJvZHVjdCB0byBEZWxldGUnLCBpc0FjdGl2ZTogZmFsc2UgfSksXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShleGlzdGluZ1Byb2R1Y3QpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5kZWxldGVQcm9kdWN0KDEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgaWQ6IDEsIG5hbWU6ICdQcm9kdWN0IHRvIERlbGV0ZScsIGlzQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kQnlQaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMSk7XG4gICAgICBleHBlY3QoZXhpc3RpbmdQcm9kdWN0LnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBpc0FjdGl2ZTogZmFsc2UgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIHdoZW4gcHJvZHVjdCBub3QgZm91bmQgZm9yIGRlbGV0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1Byb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmRlbGV0ZVByb2R1Y3QoOTk5KSkucmVqZWN0cy50b1Rocm93KCdQcm9kdWN0IHdpdGggSUQgOTk5IG5vdCBmb3VuZCcpO1xuICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRCeVBrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg5OTkpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBkZWxldGluZyBwcm9kdWN0IHdpdGggSUQgOTk5OicsIGV4cGVjdC5hbnkoRXJyb3IpKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIGR1cmluZyBkZWxldGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBlcnJvciBkdXJpbmcgZGVsZXRpb24nKTtcbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuZGVsZXRlUHJvZHVjdCgxKSkucmVqZWN0cy50b1Rocm93KCdEYXRhYmFzZSBlcnJvciBkdXJpbmcgZGVsZXRpb24nKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgZGVsZXRpbmcgcHJvZHVjdCB3aXRoIElEIDE6JywgZXJyb3IpO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1cGRhdGUgZXJyb3JzIGR1cmluZyBzb2Z0IGRlbGV0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUHJvZHVjdCA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignVXBkYXRlIGZhaWxlZCcpKSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKGV4aXN0aW5nUHJvZHVjdCk7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmRlbGV0ZVByb2R1Y3QoMSkpLnJlamVjdHMudG9UaHJvdygnVXBkYXRlIGZhaWxlZCcpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBkZWxldGluZyBwcm9kdWN0IHdpdGggSUQgMTonLCBleHBlY3QuYW55KEVycm9yKSk7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGFmZmVjdCBhbHJlYWR5IGRlbGV0ZWQgcHJvZHVjdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBSZXNldCB0aGUgbW9jayBleHBsaWNpdGx5XG4gICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzZXQoKTtcbiAgICAgIFxuICAgICAgY29uc3QgZXhpc3RpbmdQcm9kdWN0ID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ0FscmVhZHkgRGVsZXRlZCBQcm9kdWN0JyxcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGlkOiAxLCBuYW1lOiAnQWxyZWFkeSBEZWxldGVkIFByb2R1Y3QnLCBpc0FjdGl2ZTogZmFsc2UgfSksXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShleGlzdGluZ1Byb2R1Y3QpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5kZWxldGVQcm9kdWN0KDEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmlzQWN0aXZlKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChleGlzdGluZ1Byb2R1Y3QudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGlzQWN0aXZlOiBmYWxzZSB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsibW9ja1Byb2R1Y3QiLCJmaW5kQWxsIiwiamVzdCIsImZuIiwiZmluZE9uZSIsImZpbmRCeVBrIiwiY3JlYXRlIiwidXBkYXRlIiwibW9jayIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJhZnRlckVhY2giLCJyZXNldEFsbE1vY2tzIiwiaXQiLCJtb2NrUHJvZHVjdHMiLCJpZCIsIm5hbWUiLCJpc0FjdGl2ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwicmVzdWx0IiwicHJvZHVjdFNlcnZpY2UiLCJnZXRBbGxQcm9kdWN0cyIsImV4cGVjdCIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIndoZXJlIiwiZXJyb3IiLCJFcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlIiwiY29uc29sZVNweSIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsInJlamVjdHMiLCJ0b1Rocm93IiwibW9ja1Jlc3RvcmUiLCJtb2NrUHJvZHVjdF9kYXRhIiwiZ2V0UHJvZHVjdEJ5SWQiLCJ0b0JlTnVsbCIsIk5hTiIsInByb2R1Y3REYXRhIiwicHJpY2UiLCJkZXNjcmlwdGlvbiIsImNyZWF0ZWRQcm9kdWN0IiwiY3JlYXRlUHJvZHVjdCIsImV4aXN0aW5nUHJvZHVjdCIsInVwZGF0ZVByb2R1Y3QiLCJhbnkiLCJ0b0JlIiwiZGVsZXRlUHJvZHVjdCIsIm1vY2tSZXNldCJdLCJtYXBwaW5ncyI6Ijs7Ozt5QkFBa0U7Z0NBQ25DO0FBRS9CLHlCQUF5QjtBQUN6QixNQUFNQSxjQUFjO0lBQ2xCQyxTQUFTQyxhQUFJLENBQUNDLEVBQUU7SUFDaEJDLFNBQVNGLGFBQUksQ0FBQ0MsRUFBRTtJQUNoQkUsVUFBVUgsYUFBSSxDQUFDQyxFQUFFO0lBQ2pCRyxRQUFRSixhQUFJLENBQUNDLEVBQUU7SUFDZkksUUFBUUwsYUFBSSxDQUFDQyxFQUFFO0FBQ2pCO0FBRUEsMEJBQTBCO0FBQzFCRCxhQUFJLENBQUNNLElBQUksQ0FBQyx3QkFBd0IsSUFBTVI7QUFFeENTLElBQUFBLGlCQUFRLEVBQUMsa0JBQWtCO0lBQ3pCQyxJQUFBQSxtQkFBVSxFQUFDO1FBQ1RSLGFBQUksQ0FBQ1MsYUFBYTtJQUNwQjtJQUVBQyxJQUFBQSxrQkFBUyxFQUFDO1FBQ1JWLGFBQUksQ0FBQ1csYUFBYTtJQUNwQjtJQUVBSixJQUFBQSxpQkFBUSxFQUFDLGtCQUFrQjtRQUN6QkssSUFBQUEsV0FBRSxFQUFDLHFDQUFxQztZQUN0QyxNQUFNQyxlQUFlO2dCQUNuQjtvQkFBRUMsSUFBSTtvQkFBR0MsTUFBTTtvQkFBYUMsVUFBVTtnQkFBSztnQkFDM0M7b0JBQUVGLElBQUk7b0JBQUdDLE1BQU07b0JBQWFDLFVBQVU7Z0JBQUs7YUFDNUM7WUFFRGxCLFlBQVlDLE9BQU8sQ0FBQ2tCLGlCQUFpQixDQUFDSjtZQUV0QyxNQUFNSyxTQUFTLE1BQU1DLDhCQUFjLENBQUNDLGNBQWM7WUFFbERDLElBQUFBLGVBQU0sRUFBQ0gsUUFBUUksT0FBTyxD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