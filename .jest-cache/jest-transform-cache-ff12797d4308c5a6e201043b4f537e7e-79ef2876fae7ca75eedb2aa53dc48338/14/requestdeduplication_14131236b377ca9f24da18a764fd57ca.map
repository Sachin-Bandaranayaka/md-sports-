{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/lib/request-deduplication.ts"],"sourcesContent":["/**\n * Request Deduplication Utility\n * \n * Prevents duplicate API requests by caching ongoing requests\n * and returning the same promise for identical requests.\n */\n\nimport { PerformanceMonitor } from './performance';\n\nconst monitor = new PerformanceMonitor();\n\n// Store for ongoing requests\nconst ongoingRequests = new Map<string, Promise<any>>();\n\n// Store for request metadata\ninterface RequestMetadata {\n    timestamp: number;\n    count: number;\n    lastAccess: number;\n}\n\nconst requestMetadata = new Map<string, RequestMetadata>();\n\n// Configuration\nconst DEDUPLICATION_CONFIG = {\n    // How long to keep a request in the deduplication cache (ms)\n    maxAge: 30 * 1000, // 30 seconds\n\n    // Maximum number of concurrent requests to track\n    maxConcurrentRequests: 100,\n\n    // Cleanup interval for expired requests\n    cleanupInterval: 60 * 1000, // 1 minute\n\n    // Enable logging for debugging\n    enableLogging: process.env.NODE_ENV === 'development'\n};\n\n/**\n * Generate a unique key for a request\n */\nfunction generateRequestKey(\n    url: string,\n    method: string = 'GET',\n    body?: any,\n    headers?: Record<string, string>\n): string {\n    const normalizedUrl = url.toLowerCase();\n    const normalizedMethod = method.toUpperCase();\n\n    // Include relevant headers in the key (excluding auth tokens for security)\n    const relevantHeaders = headers ? Object.entries(headers)\n        .filter(([key]) => !key.toLowerCase().includes('authorization'))\n        .sort(([a], [b]) => a.localeCompare(b))\n        .map(([key, value]) => `${key}:${value}`)\n        .join('|') : '';\n\n    const bodyString = body ? JSON.stringify(body) : '';\n\n    return `${normalizedMethod}:${normalizedUrl}:${bodyString}:${relevantHeaders}`;\n}\n\n/**\n * Clean up expired requests\n */\nfunction cleanupExpiredRequests(): void {\n    const now = Date.now();\n    const expiredKeys: string[] = [];\n\n    for (const [key, metadata] of requestMetadata.entries()) {\n        if (now - metadata.lastAccess > DEDUPLICATION_CONFIG.maxAge) {\n            expiredKeys.push(key);\n        }\n    }\n\n    for (const key of expiredKeys) {\n        ongoingRequests.delete(key);\n        requestMetadata.delete(key);\n    }\n\n    if (DEDUPLICATION_CONFIG.enableLogging && expiredKeys.length > 0) {\n        console.log(`🧹 Cleaned up ${expiredKeys.length} expired request deduplication entries`);\n    }\n}\n\n/**\n * Check if we're at the concurrent request limit\n */\nfunction isAtConcurrentLimit(): boolean {\n    return ongoingRequests.size >= DEDUPLICATION_CONFIG.maxConcurrentRequests;\n}\n\n/**\n * Deduplicate a request\n */\nexport async function deduplicateRequest<T>(\n    requestFn: () => Promise<T>,\n    url: string,\n    method: string = 'GET',\n    body?: any,\n    headers?: Record<string, string>\n): Promise<T> {\n    const requestKey = generateRequestKey(url, method, body, headers);\n    const now = Date.now();\n\n    // Check if we already have this request ongoing\n    const existingRequest = ongoingRequests.get(requestKey);\n    if (existingRequest) {\n        // Update metadata\n        const metadata = requestMetadata.get(requestKey);\n        if (metadata) {\n            metadata.count++;\n            metadata.lastAccess = now;\n        }\n\n        if (DEDUPLICATION_CONFIG.enableLogging) {\n            console.log(`🔄 Deduplicating request: ${method} ${url} (${metadata?.count || 1} total)`);\n        }\n\n        return existingRequest;\n    }\n\n    // Clean up if we're at the limit\n    if (isAtConcurrentLimit()) {\n        cleanupExpiredRequests();\n\n        // If still at limit, proceed without deduplication\n        if (isAtConcurrentLimit()) {\n            if (DEDUPLICATION_CONFIG.enableLogging) {\n                console.warn(`⚠️ Request deduplication limit reached, proceeding without deduplication: ${method} ${url}`);\n            }\n            return requestFn();\n        }\n    }\n\n    // Create new request\n    const timer = monitor.startTimer('request-deduplication');\n\n    const requestPromise = requestFn()\n        .finally(() => {\n            // Clean up after request completes\n            ongoingRequests.delete(requestKey);\n            monitor.endTimer(timer);\n        });\n\n    // Store the request\n    ongoingRequests.set(requestKey, requestPromise);\n    requestMetadata.set(requestKey, {\n        timestamp: now,\n        count: 1,\n        lastAccess: now\n    });\n\n    if (DEDUPLICATION_CONFIG.enableLogging) {\n        console.log(`🚀 Starting new request: ${method} ${url}`);\n    }\n\n    return requestPromise;\n}\n\n/**\n * Deduplicate a fetch request\n */\nexport async function deduplicatedFetch(\n    url: string,\n    options: RequestInit = {}\n): Promise<Response> {\n    const method = options.method || 'GET';\n    const headers = options.headers as Record<string, string> || {};\n    const body = options.body;\n\n    return deduplicateRequest(\n        () => fetch(url, options),\n        url,\n        method,\n        body,\n        headers\n    );\n}\n\n/**\n * Deduplicate a JSON fetch request\n */\nexport async function deduplicatedFetchJson<T>(\n    url: string,\n    options: RequestInit = {}\n): Promise<T> {\n    const response = await deduplicatedFetch(url, options);\n\n    if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    return response.json();\n}\n\n/**\n * Clear all ongoing requests (useful for testing or manual cleanup)\n */\nexport function clearAllRequests(): void {\n    ongoingRequests.clear();\n    requestMetadata.clear();\n\n    if (DEDUPLICATION_CONFIG.enableLogging) {\n        console.log('🧹 Cleared all request deduplication entries');\n    }\n}\n\n/**\n * Get statistics about request deduplication\n */\nexport function getDeduplicationStats(): {\n    ongoingRequests: number;\n    totalRequests: number;\n    averageRequestCount: number;\n    oldestRequest: number | null;\n} {\n    const now = Date.now();\n    let totalRequests = 0;\n    let oldestTimestamp = Infinity;\n\n    for (const metadata of requestMetadata.values()) {\n        totalRequests += metadata.count;\n        if (metadata.timestamp < oldestTimestamp) {\n            oldestTimestamp = metadata.timestamp;\n        }\n    }\n\n    return {\n        ongoingRequests: ongoingRequests.size,\n        totalRequests,\n        averageRequestCount: requestMetadata.size > 0 ? totalRequests / requestMetadata.size : 0,\n        oldestRequest: oldestTimestamp === Infinity ? null : now - oldestTimestamp\n    };\n}\n\n/**\n * Force cleanup of expired requests\n */\nexport function forceCleanup(): void {\n    cleanupExpiredRequests();\n}\n\n// Start automatic cleanup\nsetInterval(cleanupExpiredRequests, DEDUPLICATION_CONFIG.cleanupInterval);\n\n// Export configuration for testing\nexport { DEDUPLICATION_CONFIG };\n\n/**\n * React hook for deduplicating API calls\n */\nexport function useDeduplicatedFetch() {\n    return {\n        fetch: deduplicatedFetch,\n        fetchJson: deduplicatedFetchJson,\n        getStats: getDeduplicationStats,\n        clearAll: clearAllRequests\n    };\n}"],"names":["DEDUPLICATION_CONFIG","clearAllRequests","deduplicateRequest","deduplicatedFetch","deduplicatedFetchJson","forceCleanup","getDeduplicationStats","useDeduplicatedFetch","monitor","PerformanceMonitor","ongoingRequests","Map","requestMetadata","maxAge","maxConcurrentRequests","cleanupInterval","enableLogging","process","env","NODE_ENV","generateRequestKey","url","method","body","headers","normalizedUrl","toLowerCase","normalizedMethod","toUpperCase","relevantHeaders","Object","entries","filter","key","includes","sort","a","b","localeCompare","map","value","join","bodyString","JSON","stringify","cleanupExpiredRequests","now","Date","expiredKeys","metadata","lastAccess","push","delete","length","console","log","isAtConcurrentLimit","size","requestFn","requestKey","existingRequest","get","count","warn","timer","startTimer","requestPromise","finally","endTimer","set","timestamp","options","fetch","response","ok","Error","status","statusText","json","clear","totalRequests","oldestTimestamp","Infinity","values","averageRequestCount","oldestRequest","setInterval","fetchJson","getStats","clearAll"],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;IAkPQA,oBAAoB;eAApBA;;IAhDOC,gBAAgB;eAAhBA;;IAxGMC,kBAAkB;eAAlBA;;IAoEAC,iBAAiB;eAAjBA;;IAoBAC,qBAAqB;eAArBA;;IAwDNC,YAAY;eAAZA;;IA5BAC,qBAAqB;eAArBA;;IAyCAC,oBAAoB;eAApBA;;;6BArPmB;AAEnC,MAAMC,UAAU,IAAIC,+BAAkB;AAEtC,6BAA6B;AAC7B,MAAMC,kBAAkB,IAAIC;AAS5B,MAAMC,kBAAkB,IAAID;AAE5B,gBAAgB;AAChB,MAAMX,uBAAuB;IACzB,6DAA6D;IAC7Da,QAAQ,KAAK;IAEb,iDAAiD;IACjDC,uBAAuB;IAEvB,wCAAwC;IACxCC,iBAAiB,KAAK;IAEtB,+BAA+B;IAC/BC,eAAeC,QAAQC,GAAG,CAACC,QAAQ,KAAK;AAC5C;AAEA;;CAEC,GACD,SAASC,mBACLC,GAAW,EACXC,SAAiB,KAAK,EACtBC,IAAU,EACVC,OAAgC;IAEhC,MAAMC,gBAAgBJ,IAAIK,WAAW;IACrC,MAAMC,mBAAmBL,OAAOM,WAAW;IAE3C,2EAA2E;IAC3E,MAAMC,kBAAkBL,UAAUM,OAAOC,OAAO,CAACP,SAC5CQ,MAAM,CAAC,CAAC,CAACC,IAAI,GAAK,CAACA,IAAIP,WAAW,GAAGQ,QAAQ,CAAC,kBAC9CC,IAAI,CAAC,CAAC,CAACC,EAAE,EAAE,CAACC,EAAE,GAAKD,EAAEE,aAAa,CAACD,IACnCE,GAAG,CAAC,CAAC,CAACN,KAAKO,MAAM,GAAK,CAAC,EAAEP,IAAI,CAAC,EAAEO,MAAM,CAAC,EACvCC,IAAI,CAAC,OAAO;IAEjB,MAAMC,aAAanB,OAAOoB,KAAKC,SAAS,CAACrB,QAAQ;IAEjD,OAAO,CAAC,EAAEI,iBAAiB,CAAC,EAAEF,cAAc,CAAC,EAAEiB,WAAW,CAAC,EAAEb,gBAAgB,CAAC;AAClF;AAEA;;CAEC,GACD,SAASgB;IACL,MAAMC,MAAMC,KAAKD,GAAG;IACpB,MAAME,cAAwB,EAAE;IAEhC,KAAK,MAAM,CAACf,KAAKgB,SAAS,IAAIrC,gBAAgBmB,OAAO,GAAI;QACrD,IAAIe,MAAMG,SAASC,UAAU,GAAGlD,qBAAqBa,MAAM,EAAE;YACzDmC,YAAYG,IAAI,CAAClB;QACrB;IACJ;IAEA,KAAK,MAAMA,OAAOe,YAAa;QAC3BtC,gBAAgB0C,MAAM,CAACnB;QACvBrB,gBAAgBwC,MAAM,CAACnB;IAC3B;IAEA,IAAIjC,qBAAqBgB,aAAa,IAAIgC,YAAYK,MAAM,GAAG,GAAG;QAC9DC,QAAQC,GAAG,CAAC,CAAC,cAAc,EAAEP,YAAYK,MAAM,CAAC,sCAAsC,CAAC;IAC3F;AACJ;AAEA;;CAEC,GACD,SAASG;IACL,OAAO9C,gBAAgB+C,IAAI,IAAIzD,qBAAqBc,qBAAqB;AAC7E;AAKO,eAAeZ,mBAClBwD,SAA2B,EAC3BrC,GAAW,EACXC,SAAiB,KAAK,EACtBC,IAAU,EACVC,OAAgC;IAEhC,MAAMmC,aAAavC,mBAAmBC,KAAKC,QAAQC,MAAMC;IACzD,MAAMsB,MAAMC,KAAKD,GAAG;IAEpB,gDAAgD;IAChD,MAAMc,kBAAkBlD,gBAAgBmD,GAAG,CAACF;IAC5C,IAAIC,iBAAiB;QACjB,kBAAkB;QAClB,MAAMX,WAAWrC,gBAAgBiD,GAAG,CAACF;QACrC,IAAIV,UAAU;YACVA,SAASa,KAAK;YACdb,SAASC,UAAU,GAAGJ;QAC1B;QAEA,IAAI9C,qBAAqBgB,aAAa,EAAE;YACpCsC,QAAQC,GAAG,CAAC,CAAC,0BAA0B,EAAEjC,OAAO,CAAC,EAAED,IAAI,EAAE,EAAE4B,UAAUa,SAAS,EAAE,OAAO,CAAC;QAC5F;QAEA,OAAOF;IACX;IAEA,iCAAiC;IACjC,IAAIJ,uBAAuB;QACvBX;QAEA,mDAAmD;QACnD,IAAIW,uBAAuB;YACvB,IAAIxD,qBAAqBgB,aAAa,EAAE;gBACpCsC,QAAQS,IAAI,CAAC,CAAC,0EAA0E,EAAEzC,OAAO,CAAC,EAAED,IAAI,CAAC;YAC7G;YACA,OAAOqC;QACX;IACJ;IAEA,qBAAqB;IACrB,MAAMM,QAAQxD,QAAQyD,UAAU,CAAC;IAEjC,MAAMC,iBAAiBR,YAClBS,OAAO,CAAC;QACL,mCAAmC;QACnCzD,gBAAgB0C,MAAM,CAACO;QACvBnD,QAAQ4D,QAAQ,CAACJ;IACrB;IAEJ,oBAAoB;IACpBtD,gBAAgB2D,GAAG,CAACV,YAAYO;IAChCtD,gBAAgByD,GAAG,CAACV,YAAY;QAC5BW,WAAWxB;QACXgB,OAAO;QACPZ,YAAYJ;IAChB;IAEA,IAAI9C,qBAAqBgB,aAAa,EAAE;QACpCsC,QAAQC,GAAG,CAAC,CAAC,yBAAyB,EAAEjC,OAAO,CAAC,EAAED,IAAI,CAAC;IAC3D;IAEA,OAAO6C;AACX;AAKO,eAAe/D,kBAClBkB,GAAW,EACXkD,UAAuB,CAAC,CAAC;IAEzB,MAAMjD,SAASiD,QAAQjD,MAAM,IAAI;IACjC,MAAME,UAAU+C,QAAQ/C,OAAO,IAA8B,CAAC;IAC9D,MAAMD,OAAOgD,QAAQhD,IAAI;IAEzB,OAAOrB,mBACH,IAAMsE,MAAMnD,KAAKkD,UACjBlD,KACAC,QACAC,MACAC;AAER;AAKO,eAAepB,sBAClBiB,GAAW,EACXkD,UAAuB,CAAC,CAAC;IAEzB,MAAME,WAAW,MAAMtE,kBAAkBkB,KAAKkD;IAE9C,IAAI,CAACE,SAASC,EAAE,EAAE;QACd,MAAM,IAAIC,MAAM,CAAC,KAAK,EAAEF,SAASG,MAAM,CAAC,EAAE,EAAEH,SAASI,UAAU,CAAC,CAAC;IACrE;IAEA,OAAOJ,SAASK,IAAI;AACxB;AAKO,SAAS7E;IACZS,gBAAgBqE,KAAK;IACrBnE,gBAAgBmE,KAAK;IAErB,IAAI/E,qBAAqBgB,aAAa,EAAE;QACpCsC,QAAQC,GAAG,CAAC;IAChB;AACJ;AAKO,SAASjD;IAMZ,MAAMwC,MAAMC,KAAKD,GAAG;IACpB,IAAIkC,gBAAgB;IACpB,IAAIC,kBAAkBC;IAEtB,KAAK,MAAMjC,YAAYrC,gBAAgBuE,MAAM,GAAI;QAC7CH,iBAAiB/B,SAASa,KAAK;QAC/B,IAAIb,SAASqB,SAAS,GAAGW,iBAAiB;YACtCA,kBAAkBhC,SAASqB,SAAS;QACxC;IACJ;IAEA,OAAO;QACH5D,iBAAiBA,gBAAgB+C,IAAI;QACrCuB;QACAI,qBAAqBxE,gBAAgB6C,IAAI,GAAG,IAAIuB,gBAAgBpE,gBAAgB6C,IAAI,GAAG;QACvF4B,eAAeJ,oBAAoBC,WAAW,OAAOpC,MAAMmC;IAC/D;AACJ;AAKO,SAAS5E;IACZwC;AACJ;AAEA,0BAA0B;AAC1ByC,YAAYzC,wBAAwB7C,qBAAqBe,eAAe;AAQjE,SAASR;IACZ,OAAO;QACHiE,OAAOrE;QACPoF,WAAWnF;QACXoF,UAAUlF;QACVmF,UAAUxF;IACd;AACJ"}