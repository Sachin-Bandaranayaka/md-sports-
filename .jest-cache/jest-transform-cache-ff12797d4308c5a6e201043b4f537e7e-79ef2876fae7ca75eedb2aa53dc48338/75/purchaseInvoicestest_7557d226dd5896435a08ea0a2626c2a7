7d36d64b6caf2c2d959bbe9d4245a530
/**
 * @jest-environment node
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _client = require("@prisma/client");
const _route = require("../../src/app/api/purchases/route");
const _route1 = require("../../src/app/api/purchases/[id]/route");
// Helper function to create mock NextRequest
const createMockNextRequest = (url, options = {})=>{
    const { method = "GET", body, headers = {} } = options;
    return {
        method,
        url,
        headers: new Headers(headers),
        json: async ()=>body ? typeof body === "string" ? JSON.parse(body) : body : {},
        text: async ()=>body ? typeof body === "string" ? body : JSON.stringify(body) : ""
    };
};
const prisma = new _client.PrismaClient();
describe("Purchase Invoice API Integration Tests", ()=>{
    let createdShopId;
    let createdSupplierId;
    let createdProductId;
    beforeAll(async ()=>{
    // Seed initial data if necessary, e.g., a default supplier or shop
    // For now, we'll create them in beforeEach or specific tests
    });
    beforeEach(async ()=>{
        // Clean up database tables to ensure test isolation
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        // Create a shop for testing
        const shop = await prisma.shop.create({
            data: {
                name: "Test Shop Local",
                location: "Test Location"
            }
        });
        createdShopId = shop.id;
        // Create a supplier for testing
        const supplier = await prisma.supplier.create({
            data: {
                name: "Test Supplier Local"
            }
        });
        createdSupplierId = supplier.id;
        // Create a product for testing updates/deletes (not for create new product test)
        const product = await prisma.product.create({
            data: {
                name: "Existing Product",
                price: 100,
                sku: "EXISTING001",
                shopId: createdShopId
            }
        });
        createdProductId = product.id;
    });
    afterAll(async ()=>{
        // Clean up database after all tests
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        await prisma.$disconnect();
    });
    describe("POST /api/purchases (Create Purchase Invoice)", ()=>{
        it("should create a purchase invoice for a new product, update inventory, and set WAC", async ()=>{
            // 1. Define data for a new product
            const newProductName = "Brand New Racket";
            const newProductSku = "NEWB001";
            const purchasePrice = 150;
            const purchaseQuantity = 10;
            // Create product first (as API expects productId)
            // In a real scenario, the UI might create product then purchase, or purchase API handles product creation
            // For this test, assume product is created just before, or API implies its creation from purchase (not current API)
            // Let's assume for now product must exist, if API doesn't create it from purchase items.
            // The current API's POST /api/purchases expects item.productId, implying product exists.
            const newTestProduct = await prisma.product.create({
                data: {
                    name: newProductName,
                    sku: newProductSku,
                    price: 250,
                    shopId: createdShopId // Optional default shop association
                }
            });
            const newTestProductId = newTestProduct.id;
            // 2. Prepare the request body for POST /api/purchases
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // 3. Construct a NextRequest instance
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: purchaseInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate the API call
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201); // Or 200 depending on your API's success response for POST
            expect(responseBody.data).toHaveProperty("id");
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice).not.toBeNull();
            expect(dbInvoice?.supplierId).toBe(createdSupplierId);
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(newTestProductId);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice);
            // Verify InventoryItem in DB
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newTestProductId,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem).not.toBeNull();
            expect(dbInventoryItem?.quantity).toBe(purchaseQuantity);
            // The POST route seems to calculate shopSpecificCost too.
            // WAC = (Current Total Value + New Purchase Value) / (Current Quantity + New Quantity)
            // For new item, existing shopSpecificCost is 0, currentQuantity is 0.
            // So newShopSpecificCost should be newCost (purchasePrice)
            expect(dbInventoryItem?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC in DB
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: newTestProductId
                }
            });
            expect(dbProduct).not.toBeNull();
            // For a new product, WAC should be equal to the purchase price of this first batch
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should create a purchase for an existing product, update inventory, and recalculate WACs", async ()=>{
            // 0. Initial state: Product exists, potentially with some inventory and WAC
            const initialPurchasePrice = 120;
            const initialPurchaseQuantity = 5;
            const existingProductId = createdProductId; // From beforeEach
            // Create an initial purchase to set up existing inventory and WAC
            const initialPayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const initialReq = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(initialPayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route.POST)(initialReq);
            const productBeforeNewPurchase = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            const inventoryBeforeNewPurchase = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            expect(productBeforeNewPurchase?.weightedAverageCost).toBe(initialPurchasePrice);
            expect(inventoryBeforeNewPurchase?.quantity).toBe(initialPurchaseQuantity);
            expect(inventoryBeforeNewPurchase?.shopSpecificCost).toBe(initialPurchasePrice);
            // 1. Define data for the new purchase of the existing product
            const newPurchasePrice = 100;
            const newPurchaseQuantity = 8;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: newPurchaseQuantity,
                        price: newPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newPurchaseQuantity
                    }
                ],
                totalAmount: newPurchaseQuantity * newPurchasePrice,
                status: "paid"
            };
            // 3. Simulate API call
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify InventoryItem
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            const expectedTotalQuantity = initialPurchaseQuantity + newPurchaseQuantity;
            expect(dbInventoryItem?.quantity).toBe(expectedTotalQuantity);
            // Verify shopSpecificCost recalculation
            // SSC = ((oldQty * oldSSC) + (newQty * newPrice)) / (oldQty + newQty)
            const expectedShopSpecificCost = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            expect(dbInventoryItem?.shopSpecificCost).toBeCloseTo(expectedShopSpecificCost);
            // Verify Product WAC recalculation
            // WAC = ((oldTotalQty * oldWAC) + (newPurchaseQty * newPurchasePrice)) / (newTotalQty + newPurchaseQty)
            // In this case, product WAC was initialPurchasePrice for initialPurchaseQuantity.
            const expectedProductWAC = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            expect(dbProduct?.weightedAverageCost).toBeCloseTo(expectedProductWAC);
        }, 15000); // Increased timeout
        it("should create a purchase with multiple items and update inventory/WAC for each", async ()=>{
            // 1. Create two distinct products for this test
            const product1Data = {
                name: "MultiItem Product A",
                sku: "MULTI001",
                price: 50,
                shopId: createdShopId
            };
            const product2Data = {
                name: "MultiItem Product B",
                sku: "MULTI002",
                price: 75,
                shopId: createdShopId
            };
            const product1 = await prisma.product.create({
                data: product1Data
            });
            const product2 = await prisma.product.create({
                data: product2Data
            });
            const purchasePrice1 = 40;
            const purchaseQuantity1 = 5;
            const purchasePrice2 = 60;
            const purchaseQuantity2 = 3;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product1.id.toString(),
                        quantity: purchaseQuantity1,
                        price: purchasePrice1
                    },
                    {
                        productId: product2.id.toString(),
                        quantity: purchaseQuantity2,
                        price: purchasePrice2
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity1
                    },
                    {
                        [createdShopId]: purchaseQuantity2
                    } // Distribution for item 2
                ],
                totalAmount: purchaseQuantity1 * purchasePrice1 + purchaseQuantity2 * purchasePrice2,
                status: "pending"
            };
            // 3. Simulate API call
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice and its items
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                } // Order to ensure consistent assertion
            });
            expect(dbInvoice?.items.length).toBe(2);
            // Assuming product1.id < product2.id due to creation order for consistent checks
            const sortedProducts = [
                product1,
                product2
            ].sort((a, b)=>a.id - b.id);
            expect(dbInvoice?.items[0].productId).toBe(sortedProducts[0].id);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity1);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice1);
            expect(dbInvoice?.items[1].productId).toBe(sortedProducts[1].id);
            expect(dbInvoice?.items[1].quantity).toBe(purchaseQuantity2);
            expect(dbInvoice?.items[1].price).toBe(purchasePrice2);
            // Verify InventoryItem and Product WAC for Product 1
            const dbInventoryItem1 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product1.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem1?.quantity).toBe(purchaseQuantity1);
            expect(dbInventoryItem1?.shopSpecificCost).toBe(purchasePrice1);
            const dbProduct1 = await prisma.product.findUnique({
                where: {
                    id: product1.id
                }
            });
            expect(dbProduct1?.weightedAverageCost).toBe(purchasePrice1);
            // Verify InventoryItem and Product WAC for Product 2
            const dbInventoryItem2 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product2.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem2?.quantity).toBe(purchaseQuantity2);
            expect(dbInventoryItem2?.shopSpecificCost).toBe(purchasePrice2);
            const dbProduct2 = await prisma.product.findUnique({
                where: {
                    id: product2.id
                }
            });
            expect(dbProduct2?.weightedAverageCost).toBe(purchasePrice2);
        }, 15000); // Increased timeout
        it("should distribute a single purchase item to multiple shops", async ()=>{
            // 1. Create two new shops for this test
            const shopA = await prisma.shop.create({
                data: {
                    name: "Test Shop A",
                    location: "Loc A"
                }
            });
            const shopB = await prisma.shop.create({
                data: {
                    name: "Test Shop B",
                    location: "Loc B"
                }
            });
            // 2. Create a new product
            const product = await prisma.product.create({
                data: {
                    name: "Split Product",
                    sku: "SPLIT001",
                    price: 200
                }
            });
            const purchasePrice = 180;
            const totalQuantity = 10;
            const quantityForShopA = 6;
            const quantityForShopB = 4;
            expect(quantityForShopA + quantityForShopB).toBe(totalQuantity); // Sanity check
            // 3. Prepare request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product.id.toString(),
                        quantity: totalQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [shopA.id]: quantityForShopA,
                        [shopB.id]: quantityForShopB
                    }
                ],
                totalAmount: totalQuantity * purchasePrice,
                status: "paid"
            };
            // 4. Simulate API call
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 5. Assertions
            expect(response.status).toBe(201);
            // Verify InventoryItem for Shop A
            const invItemA = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopA.id
                }
            });
            expect(invItemA).not.toBeNull();
            expect(invItemA?.quantity).toBe(quantityForShopA);
            expect(invItemA?.shopSpecificCost).toBe(purchasePrice);
            // Verify InventoryItem for Shop B
            const invItemB = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopB.id
                }
            });
            expect(invItemB).not.toBeNull();
            expect(invItemB?.quantity).toBe(quantityForShopB);
            expect(invItemB?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC (should be the purchase price as it's all new stock)
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: product.id
                }
            });
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a productId does not exist", async ()=>{
            const nonExistentProductId = 999999; // Assuming this ID won't exist
            const purchasePrice = 100;
            const purchaseQuantity = 5;
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: nonExistentProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            // Expect a client error (e.g., 400 or 404) or potentially 500 if not handled gracefully
            // For robust error handling, API should return specific error code.
            // Prisma will throw an error if a related record (product) is not found for foreign key.
            // This will likely result in a 500 if not caught and handled by the API route.
            // Let's aim for the API to catch this and return a more specific client error.
            // For now, we'll check if it's NOT a success (201).
            // A more precise check would be for 400/404/422 depending on planned error handling.
            expect(response.status).toBe(500); // Or 400/404 if you implement specific error handling
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        // Optionally, check for a specific error message or code if your API provides one.
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a supplierId does not exist", async ()=>{
            const newTestProduct = await prisma.product.create({
                data: {
                    name: "Product For Invalid Supplier Test",
                    sku: "INV SUP001",
                    price: 100
                }
            });
            const purchasePrice = 80;
            const purchaseQuantity = 5;
            const nonExistentSupplierId = 999999; // Assuming this ID won't exist
            const purchaseInvoicePayload = {
                supplierId: nonExistentSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            expect(response.status).toBe(500); // Expecting 500 as Prisma throws P2003
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        });
    });
    describe("PUT /api/purchases/:id (Update Purchase Invoice)", ()=>{
        let existingInvoiceId;
        let productForUpdateTestsId;
        const initialPurchasePrice = 50;
        const initialPurchaseQuantity = 10;
        beforeEach(async ()=>{
            // Create a product specifically for these update/delete tests if not already created
            // The global createdProductId can be used if it fits, or make a new one.
            // Let's use the global one for simplicity, assuming beforeEach cleans it up.
            productForUpdateTestsId = createdProductId;
            // Create an initial purchase invoice to be updated or deleted in tests
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: initialInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            existingInvoiceId = body.data.id;
            // Sanity check: verify initial state
            const initialProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(initialProduct?.weightedAverageCost).toBe(initialPurchasePrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(initialPurchasePrice);
        });
        it("should update item quantity (increase), recalculate stock and WACs", async ()=>{
            const quantityIncrease = 5;
            const newQuantity = initialPurchaseQuantity + quantityIncrease;
            // Price remains the same for this item in this update scenario
            const updatedPriceForItem = initialPurchasePrice;
            const updatePayload = {
                // We need to send the complete structure expected by the PUT route
                // This includes all items, even if only one is changing.
                // The PUT route logic might compare with existing items to see what changed.
                items: [
                    {
                        // If the item had an ID (PurchaseInvoiceItem id), it might be needed.
                        // Let's assume for now the PUT matches items based on productId if not item ID.
                        // Based on current PUT route, it expects productId.
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    // The distributions in PUT might need to reflect the *new total* for the item
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate API call - updatePurchaseInvoice(req, { params: { id: existingInvoiceId } })
            // This is how you call it if you are testing the handler directly in Jest with context
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // WAC calculation: ((oldQty * oldSSC) + (addedQty * priceOfAddedQty)) / (newTotalQty)
            // In this specific update, the PUT route reverses the old item and adds the new one as if it's a new purchase line for WAC calcs.
            // So, the old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // However, the current PUT logic first reverses *all* old items based on their *original* recorded cost.
            // Then it adds *all* new items based on their *new* cost.
            // So for the product WAC: (TotalValueBefore - OldItemValue + NewItemValue) / (TotalStockBefore - OldItemQty + NewItemQty)
            // And for shop specific WAC: (ShopValueBefore - OldItemValueInShop + NewItemValueInShop) / (ShopStockBefore - OldItemQtyInShop + NewItemQtyInShop)
            // Let's check the logic from src/app/api/purchases/[id]/route.ts
            // 1. It fetches the old invoice.
            // 2. It reverses inventory adjustments for ALL old items (decrease stock, WAC updated).
            // 3. It processes ALL new/updated items as if they are new purchases (increase stock, WAC updated).
            // So, after reversal of initialPurchaseQuantity at initialPurchasePrice:
            // Product WAC and ShopSpecificCost would be effectively 0 if this were the only product/stock.
            // Then, adding newQuantity at updatedPriceForItem:
            // The new WACs should become updatedPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB reflects the change
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item quantity (decrease), recalculate stock and WACs", async ()=>{
            const quantityDecrease = 3;
            const newQuantity = initialPurchaseQuantity - quantityDecrease;
            expect(newQuantity).toBeGreaterThanOrEqual(0); // Ensure we don't go negative for this test logic
            const updatedPriceForItem = initialPurchasePrice; // Price remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // Due to the reversal and re-addition logic of the PUT route:
            // The old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // So, new WACs should become updatedPriceForItem (which is initialPurchasePrice).
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item price, recalculate stock and WACs", async ()=>{
            const newPriceForItem = initialPurchasePrice + 25; // New price, e.g., 50 + 25 = 75
            const quantityUnchanged = initialPurchaseQuantity; // Quantity remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: quantityUnchanged,
                        price: newPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityUnchanged
                    }
                ]
            };
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock (should be unchanged) and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(quantityUnchanged);
            // WAC logic in PUT: reverses old, adds new. So shopSpecificCost should reflect newPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(newPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(newPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(quantityUnchanged);
            expect(dbInvoice?.items[0].price).toBe(newPriceForItem);
            expect(dbInvoice?.total).toBe(quantityUnchanged * newPriceForItem);
        }, 15000); // Increased timeout
        it("should add a new item to an existing invoice, update stock and WACs", async ()=>{
            // 1. Define a new product for the new item
            const newItemProduct = await prisma.product.create({
                data: {
                    name: "Newly Added Product for PUT",
                    sku: "PUTNEW001",
                    price: 200
                }
            });
            const newItemProductId = newItemProduct.id;
            const newItemQuantity = 7;
            const newItemPrice = 120;
            // Original item details (from beforeEach setup)
            const originalItemProductId = productForUpdateTestsId;
            const originalItemQuantity = initialPurchaseQuantity;
            const originalItemPrice = initialPurchasePrice;
            // 2. Prepare the update payload with both original and new item
            const updatePayload = {
                items: [
                    {
                        productId: originalItemProductId.toString(),
                        quantity: originalItemQuantity,
                        price: originalItemPrice
                    },
                    {
                        productId: newItemProductId.toString(),
                        quantity: newItemQuantity,
                        price: newItemPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: originalItemQuantity
                    },
                    {
                        [createdShopId]: newItemQuantity
                    } // Distribution for new item
                ]
            };
            // 3. Simulate API call
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                }
            });
            expect(dbInvoice?.items.length).toBe(2);
            const expectedTotal = originalItemQuantity * originalItemPrice + newItemQuantity * newItemPrice;
            expect(dbInvoice?.total).toBe(expectedTotal);
            // Find the items in the response (order might vary, so find by productId)
            const dbOriginalItem = dbInvoice?.items.find((item)=>item.productId === originalItemProductId);
            const dbNewItem = dbInvoice?.items.find((item)=>item.productId === newItemProductId);
            expect(dbOriginalItem).toBeDefined();
            expect(dbOriginalItem?.quantity).toBe(originalItemQuantity);
            expect(dbOriginalItem?.price).toBe(originalItemPrice);
            expect(dbNewItem).toBeDefined();
            expect(dbNewItem?.quantity).toBe(newItemQuantity);
            expect(dbNewItem?.price).toBe(newItemPrice);
            // Verify InventoryItem and Product WAC for the original item
            // (Due to PUT logic of reverse & re-add, WACs should reflect its current price)
            const originalInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: originalItemProductId,
                    shopId: createdShopId
                }
            });
            expect(originalInventory?.quantity).toBe(originalItemQuantity);
            expect(originalInventory?.shopSpecificCost).toBeCloseTo(originalItemPrice);
            const originalProduct = await prisma.product.findUnique({
                where: {
                    id: originalItemProductId
                }
            });
            expect(originalProduct?.weightedAverageCost).toBeCloseTo(originalItemPrice);
            // Verify InventoryItem and Product WAC for the NEW item
            const newInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newItemProductId,
                    shopId: createdShopId
                }
            });
            expect(newInventory?.quantity).toBe(newItemQuantity);
            expect(newInventory?.shopSpecificCost).toBeCloseTo(newItemPrice);
            const newProductDb = await prisma.product.findUnique({
                where: {
                    id: newItemProductId
                }
            });
            expect(newProductDb?.weightedAverageCost).toBeCloseTo(newItemPrice);
        }, 15000); // Increased timeout
        it("should remove an item from an existing invoice, update stock and WACs", async ()=>{
            // 1. Setup: Ensure an invoice with at least two items exists.
            // We'll use the existing `productForUpdateTestsId` and create one more product and item.
            const productToRemove = await prisma.product.create({
                data: {
                    name: "Product To Be Removed",
                    sku: "PUTRMV001",
                    price: 300
                }
            });
            const productToRemoveId = productToRemove.id;
            const productToRemoveQuantity = 4;
            const productToRemovePrice = 40;
            // Update the existing invoice (created in global beforeEach for PUT) to include this second item first.
            const addSecondItemPayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    },
                    {
                        productId: productToRemoveId.toString(),
                        quantity: productToRemoveQuantity,
                        price: productToRemovePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    },
                    {
                        [createdShopId]: productToRemoveQuantity
                    }
                ]
            };
            const addReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(addSecondItemPayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route1.PUT)(addReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            // Sanity check: Invoice should have 2 items
            let invoiceWithTwoItems = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(invoiceWithTwoItems?.items.length).toBe(2);
            // 2. Prepare the update payload that only contains the item we want to keep.
            const updatePayloadToRemoveItem = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    } // Distribution for the kept item
                ]
            };
            // 3. Simulate API call to remove the item
            const removeReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayloadToRemoveItem),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(removeReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB - should now have only 1 item
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(productForUpdateTestsId);
            expect(dbInvoice?.items[0].quantity).toBe(initialPurchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(initialPurchasePrice);
            expect(dbInvoice?.total).toBe(initialPurchaseQuantity * initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the KEPT item
            const keptInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(keptInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(keptInventory?.shopSpecificCost).toBeCloseTo(initialPurchasePrice);
            const keptProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(keptProduct?.weightedAverageCost).toBeCloseTo(initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the REMOVED item
            // Stock should be zero or the item might be gone from inventory if it was the only purchase
            // WAC on product should be 0 if no other purchases exist.
            const removedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productToRemoveId,
                    shopId: createdShopId
                }
            });
            // The PUT logic reverses stock. If this was the only stock, it becomes 0.
            expect(removedInventory?.quantity).toBe(0);
            // ShopSpecificCost might become 0 or NaN if quantity is 0. The API sets it to 0 for safety.
            expect(removedInventory?.shopSpecificCost).toBeCloseTo(0);
            const removedProductDb = await prisma.product.findUnique({
                where: {
                    id: productToRemoveId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfRemovedItem = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productToRemoveId
                }
            });
            if (otherPurchasesOfRemovedItem === 0) {
                expect(removedProductDb?.weightedAverageCost).toBeCloseTo(0);
            } // Else, it would be based on other purchases, which this test doesn't set up.
        }, 15000); // Increased timeout
    });
    describe("DELETE /api/purchases/:id (Delete Purchase Invoice)", ()=>{
        let invoiceToDeleteId;
        let productForDeleteTestId;
        const deleteTestInitialPrice = 60;
        const deleteTestInitialQuantity = 12;
        beforeEach(async ()=>{
            // Ensure product exists for the test
            const product = await prisma.product.create({
                data: {
                    name: "Product For Delete Test",
                    sku: "DELPROD001",
                    price: 100
                }
            });
            productForDeleteTestId = product.id;
            // Create an initial purchase invoice to be deleted
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productForDeleteTestId.toString(),
                        quantity: deleteTestInitialQuantity,
                        price: deleteTestInitialPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: deleteTestInitialQuantity
                    } // Explicit distribution
                ],
                totalAmount: deleteTestInitialQuantity * deleteTestInitialPrice,
                status: "paid"
            };
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(initialInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            invoiceToDeleteId = body.data.id;
            // Sanity check: verify initial state after creation
            const initialProductDB = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            expect(initialProductDB?.weightedAverageCost).toBe(deleteTestInitialPrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(deleteTestInitialQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(deleteTestInitialPrice);
        });
        it("should delete a purchase invoice and correctly reverse stock and WACs for a single-item invoice with explicit distribution", async ()=>{
            // 1. Call the DELETE endpoint
            const deleteReq = new NextRequest(`http://localhost/api/purchases/${invoiceToDeleteId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceToDeleteId
                }
            });
            // 2. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 3. Verify PurchaseInvoice is deleted from DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceToDeleteId
                }
            });
            expect(dbInvoice).toBeNull();
            // 4. Verify PurchaseInvoiceItems are deleted
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceToDeleteId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock is reversed
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            // Assuming this was the only purchase, stock should be 0
            expect(updatedInventory?.quantity).toBe(0);
            // ShopSpecificCost should also be 0 if stock is 0
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated (should be 0 if this was the only purchase)
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfProduct = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productForDeleteTestId
                }
            });
            if (otherPurchasesOfProduct === 0) {
                expect(updatedProduct?.weightedAverageCost).toBeCloseTo(0);
            }
        });
        it("should delete a purchase and reverse stock/WAC when product is in a single inferred shop", async ()=>{
            // 1. Setup: Create dedicated entities for this test to ensure isolation.
            const testShop = await prisma.shop.create({
                data: {
                    name: "Inferred Delete Test Shop",
                    location: "Loc X"
                }
            });
            const testSupplier = await prisma.supplier.create({
                data: {
                    name: "Inferred Delete Test Supplier"
                }
            });
            const testProduct = await prisma.product.create({
                data: {
                    name: "Product for Inferred Delete",
                    sku: "INFDEL001",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            // Create an inventory item for this product in the test shop.
            // This makes it the "single inferred shop".
            await prisma.inventoryItem.create({
                data: {
                    productId: testProduct.id,
                    shopId: testShop.id,
                    quantity: 0,
                    shopSpecificCost: 0
                }
            });
            const purchaseQuantity = 12;
            const purchasePrice = 60;
            const inferredShopInvoicePayload = {
                supplierId: testSupplier.id.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: testProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                // NO distributions property here for inference to kick in on POST
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // Create the purchase invoice (this is where the failure was happening)
            const createReq = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(inferredShopInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201); // Assert successful creation
            const createBody = await createResponse.json();
            const invoiceIdForInferredDelete = createBody.data.id;
            // Sanity check: Verify stock and WAC after creation
            const inventoryAfterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(inventoryAfterCreate?.quantity).toBe(purchaseQuantity);
            expect(inventoryAfterCreate?.shopSpecificCost).toBeCloseTo(purchasePrice);
            const productAfterCreate = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(productAfterCreate?.weightedAverageCost).toBeCloseTo(purchasePrice);
            // 2. Call the DELETE endpoint
            const deleteReq = new NextRequest(`http://localhost/api/purchases/${invoiceIdForInferredDelete}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceIdForInferredDelete
                }
            });
            // 3. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 4. Verify PurchaseInvoice and Items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock and shopSpecificCost are reversed in the inferred shop
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(updatedInventory?.quantity).toBe(0);
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated to 0
            const updatedProductDB = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(updatedProductDB?.weightedAverageCost).toBeCloseTo(0);
            // Cleanup dedicated entities for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: testProduct.id
                }
            });
            await prisma.product.delete({
                where: {
                    id: testProduct.id
                }
            });
            await prisma.supplier.delete({
                where: {
                    id: testSupplier.id
                }
            });
            await prisma.shop.delete({
                where: {
                    id: testShop.id
                }
            });
        }, 15000); // Added a longer timeout as a precaution
        it("should delete an invoice with multiple items, reversing stock/WAC for each", async ()=>{
            // 1. Setup: Create multiple products and an invoice with items from these products.
            // For simplicity, distribute each to the main createdShopId from global beforeEach.
            const productA = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod A",
                    sku: "MDEL00A",
                    price: 100,
                    weightedAverageCost: 0
                }
            });
            const productB = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod B",
                    sku: "MDEL00B",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            const quantityA = 5;
            const priceA = 50;
            const quantityB = 3;
            const priceB = 120;
            const multiItemInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productA.id.toString(),
                        quantity: quantityA,
                        price: priceA
                    },
                    {
                        productId: productB.id.toString(),
                        quantity: quantityB,
                        price: priceB
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityA
                    },
                    {
                        [createdShopId]: quantityB
                    } // Item B to main shop
                ],
                totalAmount: quantityA * priceA + quantityB * priceB,
                status: "paid"
            };
            const createReq = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(multiItemInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201);
            const createBody = await createResponse.json();
            const multiItemInvoiceId = createBody.data.id;
            // Sanity check inventory and WAC after creation
            const invA_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterCreate?.quantity).toBe(quantityA);
            expect(invA_afterCreate?.shopSpecificCost).toBe(priceA);
            const prodA_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterCreate?.weightedAverageCost).toBe(priceA);
            const invB_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterCreate?.quantity).toBe(quantityB);
            expect(invB_afterCreate?.shopSpecificCost).toBe(priceB);
            const prodB_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterCreate?.weightedAverageCost).toBe(priceB);
            // 2. Call DELETE endpoint
            const deleteReq = new NextRequest(`http://localhost/api/purchases/${multiItemInvoiceId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: multiItemInvoiceId
                }
            });
            expect(deleteResponse.status).toBe(200);
            // 3. Verify invoice and items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: multiItemInvoiceId
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: multiItemInvoiceId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 4. Verify stock and WAC for Product A are reversed
            const invA_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterDelete?.quantity).toBe(0);
            expect(invA_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodA_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // 5. Verify stock and WAC for Product B are reversed
            const invB_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterDelete?.quantity).toBe(0);
            expect(invB_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodB_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // Clean up products and their inventory items created for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
            await prisma.product.deleteMany({
                where: {
                    id: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
        }, 15000); // Timeout for safety
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvaW50ZWdyYXRpb24vcHVyY2hhc2VJbnZvaWNlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGplc3QtZW52aXJvbm1lbnQgbm9kZVxuICovXG5pbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tICdAcHJpc21hL2NsaWVudCc7XG5pbXBvcnQgeyBQT1NUIGFzIGNyZWF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvcm91dGUnOyAvLyBBZGp1c3QgaWYgZGlyZWN0IGltcG9ydCBpc24ndCBmZWFzaWJsZVxuaW1wb3J0IHsgUFVUIGFzIHVwZGF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuaW1wb3J0IHsgREVMRVRFIGFzIGRlbGV0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuLy8gTW9jayBOZXh0UmVxdWVzdCBpbnRlcmZhY2VcbmludGVyZmFjZSBOZXh0UmVxdWVzdCB7XG4gIG1ldGhvZDogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgaGVhZGVyczogSGVhZGVycztcbiAganNvbigpOiBQcm9taXNlPGFueT47XG4gIHRleHQoKTogUHJvbWlzZTxzdHJpbmc+O1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2sgTmV4dFJlcXVlc3RcbmNvbnN0IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCA9ICh1cmw6IHN0cmluZywgb3B0aW9uczoge1xuICBtZXRob2Q/OiBzdHJpbmc7XG4gIGJvZHk/OiBhbnk7XG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSA9IHt9KTogTmV4dFJlcXVlc3QgPT4ge1xuICBjb25zdCB7IG1ldGhvZCA9ICdHRVQnLCBib2R5LCBoZWFkZXJzID0ge30gfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIHVybCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICBqc29uOiBhc3luYyAoKSA9PiBib2R5ID8gKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoYm9keSkgOiBib2R5KSA6IHt9LFxuICAgIHRleHQ6IGFzeW5jICgpID0+IGJvZHkgPyAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnID8gYm9keSA6IEpTT04uc3RyaW5naWZ5KGJvZHkpKSA6ICcnLFxuICB9IGFzIE5leHRSZXF1ZXN0O1xufTtcblxuaW1wb3J0IHsgY3JlYXRlTW9ja3MgfSBmcm9tICdub2RlLW1vY2tzLWh0dHAnOyAvLyBPciBhbnkgb3RoZXIgd2F5IHRvIG1vY2sgTmV4dFJlcXVlc3QvUmVzcG9uc2VcblxuY29uc3QgcHJpc21hID0gbmV3IFByaXNtYUNsaWVudCgpO1xuXG5kZXNjcmliZSgnUHVyY2hhc2UgSW52b2ljZSBBUEkgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gICAgbGV0IGNyZWF0ZWRTaG9wSWQ6IHN0cmluZztcbiAgICBsZXQgY3JlYXRlZFN1cHBsaWVySWQ6IG51bWJlcjtcbiAgICBsZXQgY3JlYXRlZFByb2R1Y3RJZDogbnVtYmVyO1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gU2VlZCBpbml0aWFsIGRhdGEgaWYgbmVjZXNzYXJ5LCBlLmcuLCBhIGRlZmF1bHQgc3VwcGxpZXIgb3Igc2hvcFxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBjcmVhdGUgdGhlbSBpbiBiZWZvcmVFYWNoIG9yIHNwZWNpZmljIHRlc3RzXG4gICAgfSk7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgZGF0YWJhc2UgdGFibGVzIHRvIGVuc3VyZSB0ZXN0IGlzb2xhdGlvblxuICAgICAgICBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5wcm9kdWN0LmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5zaG9wLmRlbGV0ZU1hbnkoe30pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHNob3AgZm9yIHRlc3RpbmdcbiAgICAgICAgY29uc3Qgc2hvcCA9IGF3YWl0IHByaXNtYS5zaG9wLmNyZWF0ZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgU2hvcCBMb2NhbCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdUZXN0IExvY2F0aW9uJyxcbiAgICAgICAgICAgICAgICAvLyBBZGQgb3RoZXIgcmVxdWlyZWQgZmllbGRzIGlmIGFueVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNyZWF0ZWRTaG9wSWQgPSBzaG9wLmlkO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHN1cHBsaWVyIGZvciB0ZXN0aW5nXG4gICAgICAgIGNvbnN0IHN1cHBsaWVyID0gYXdhaXQgcHJpc21hLnN1cHBsaWVyLmNyZWF0ZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgU3VwcGxpZXIgTG9jYWwnLFxuICAgICAgICAgICAgICAgIC8vIEFkZCBvdGhlciByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjcmVhdGVkU3VwcGxpZXJJZCA9IHN1cHBsaWVyLmlkO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHByb2R1Y3QgZm9yIHRlc3RpbmcgdXBkYXRlcy9kZWxldGVzIChub3QgZm9yIGNyZWF0ZSBuZXcgcHJvZHVjdCB0ZXN0KVxuICAgICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXhpc3RpbmcgUHJvZHVjdCcsXG4gICAgICAgICAgICAgICAgcHJpY2U6IDEwMCwgLy8gcmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgc2t1OiAnRVhJU1RJTkcwMDEnLFxuICAgICAgICAgICAgICAgIHNob3BJZDogY3JlYXRlZFNob3BJZCwgLy8gT3B0aW9uYWw6IGFzc29jaWF0ZSB3aXRoIGEgc2hvcCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gd2VpZ2h0ZWRBdmVyYWdlQ29zdCB3aWxsIGJlIHNldCBieSBwdXJjaGFzZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNyZWF0ZWRQcm9kdWN0SWQgPSBwcm9kdWN0LmlkO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBDbGVhbiB1cCBkYXRhYmFzZSBhZnRlciBhbGwgdGVzdHNcbiAgICAgICAgYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEucHJvZHVjdC5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnN1cHBsaWVyLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuc2hvcC5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLiRkaXNjb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnUE9TVCAvYXBpL3B1cmNoYXNlcyAoQ3JlYXRlIFB1cmNoYXNlIEludm9pY2UpJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhIHB1cmNoYXNlIGludm9pY2UgZm9yIGEgbmV3IHByb2R1Y3QsIHVwZGF0ZSBpbnZlbnRvcnksIGFuZCBzZXQgV0FDJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gRGVmaW5lIGRhdGEgZm9yIGEgbmV3IHByb2R1Y3RcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb2R1Y3ROYW1lID0gJ0JyYW5kIE5ldyBSYWNrZXQnO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvZHVjdFNrdSA9ICdORVdCMDAxJztcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUHJpY2UgPSAxNTA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gMTA7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcm9kdWN0IGZpcnN0IChhcyBBUEkgZXhwZWN0cyBwcm9kdWN0SWQpXG4gICAgICAgICAgICAvLyBJbiBhIHJlYWwgc2NlbmFyaW8sIHRoZSBVSSBtaWdodCBjcmVhdGUgcHJvZHVjdCB0aGVuIHB1cmNoYXNlLCBvciBwdXJjaGFzZSBBUEkgaGFuZGxlcyBwcm9kdWN0IGNyZWF0aW9uXG4gICAgICAgICAgICAvLyBGb3IgdGhpcyB0ZXN0LCBhc3N1bWUgcHJvZHVjdCBpcyBjcmVhdGVkIGp1c3QgYmVmb3JlLCBvciBBUEkgaW1wbGllcyBpdHMgY3JlYXRpb24gZnJvbSBwdXJjaGFzZSAobm90IGN1cnJlbnQgQVBJKVxuICAgICAgICAgICAgLy8gTGV0J3MgYXNzdW1lIGZvciBub3cgcHJvZHVjdCBtdXN0IGV4aXN0LCBpZiBBUEkgZG9lc24ndCBjcmVhdGUgaXQgZnJvbSBwdXJjaGFzZSBpdGVtcy5cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IEFQSSdzIFBPU1QgL2FwaS9wdXJjaGFzZXMgZXhwZWN0cyBpdGVtLnByb2R1Y3RJZCwgaW1wbHlpbmcgcHJvZHVjdCBleGlzdHMuXG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1Rlc3RQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5ld1Byb2R1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBza3U6IG5ld1Byb2R1Y3RTa3UsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAyNTAsIC8vIFJldGFpbCBwcmljZVxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgLy8gT3B0aW9uYWwgZGVmYXVsdCBzaG9wIGFzc29jaWF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXN0UHJvZHVjdElkID0gbmV3VGVzdFByb2R1Y3QuaWQ7XG5cbiAgICAgICAgICAgIC8vIDIuIFByZXBhcmUgdGhlIHJlcXVlc3QgYm9keSBmb3IgUE9TVCAvYXBpL3B1cmNoYXNlc1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IG5ld1Rlc3RQcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbIC8vIEV4cGxpY2l0IGRpc3RyaWJ1dGlvbiBpcyBjcnVjaWFsIGJhc2VkIG9uIGN1cnJlbnQgUE9TVCBBUElcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2NyZWF0ZWRTaG9wSWRdOiBwdXJjaGFzZVF1YW50aXR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBwdXJjaGFzZVF1YW50aXR5ICogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIENvbnN0cnVjdCBhIE5leHRSZXF1ZXN0IGluc3RhbmNlXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBwdXJjaGFzZUludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHRoZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpOyAvLyBPciAyMDAgZGVwZW5kaW5nIG9uIHlvdXIgQVBJJ3Mgc3VjY2VzcyByZXNwb25zZSBmb3IgUE9TVFxuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogY3JlYXRlZEludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5zdXBwbGllcklkKS50b0JlKGNyZWF0ZWRTdXBwbGllcklkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShuZXdUZXN0UHJvZHVjdElkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGluIERCXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0gPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcElkOiBjcmVhdGVkU2hvcElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0pLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8ucXVhbnRpdHkpLnRvQmUocHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICAvLyBUaGUgUE9TVCByb3V0ZSBzZWVtcyB0byBjYWxjdWxhdGUgc2hvcFNwZWNpZmljQ29zdCB0b28uXG4gICAgICAgICAgICAvLyBXQUMgPSAoQ3VycmVudCBUb3RhbCBWYWx1ZSArIE5ldyBQdXJjaGFzZSBWYWx1ZSkgLyAoQ3VycmVudCBRdWFudGl0eSArIE5ldyBRdWFudGl0eSlcbiAgICAgICAgICAgIC8vIEZvciBuZXcgaXRlbSwgZXhpc3Rpbmcgc2hvcFNwZWNpZmljQ29zdCBpcyAwLCBjdXJyZW50UXVhbnRpdHkgaXMgMC5cbiAgICAgICAgICAgIC8vIFNvIG5ld1Nob3BTcGVjaWZpY0Nvc3Qgc2hvdWxkIGJlIG5ld0Nvc3QgKHB1cmNoYXNlUHJpY2UpXG4gICAgICAgICAgICBleHBlY3QoZGJJbnZlbnRvcnlJdGVtPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UpO1xuXG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQcm9kdWN0IFdBQyBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IG5ld1Rlc3RQcm9kdWN0SWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICAvLyBGb3IgYSBuZXcgcHJvZHVjdCwgV0FDIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgcHVyY2hhc2UgcHJpY2Ugb2YgdGhpcyBmaXJzdCBiYXRjaFxuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgcHVyY2hhc2UgZm9yIGFuIGV4aXN0aW5nIHByb2R1Y3QsIHVwZGF0ZSBpbnZlbnRvcnksIGFuZCByZWNhbGN1bGF0ZSBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMC4gSW5pdGlhbCBzdGF0ZTogUHJvZHVjdCBleGlzdHMsIHBvdGVudGlhbGx5IHdpdGggc29tZSBpbnZlbnRvcnkgYW5kIFdBQ1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFB1cmNoYXNlUHJpY2UgPSAxMjA7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDU7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3RJZCA9IGNyZWF0ZWRQcm9kdWN0SWQ7IC8vIEZyb20gYmVmb3JlRWFjaFxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gaW5pdGlhbCBwdXJjaGFzZSB0byBzZXQgdXAgZXhpc3RpbmcgaW52ZW50b3J5IGFuZCBXQUNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDg2NDAwMDAwKS50b0lTT1N0cmluZygpLCAvLyBZZXN0ZXJkYXlcbiAgICAgICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBleGlzdGluZ1Byb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiBpbml0aWFsUHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH1dLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAqIGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSZXEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbml0aWFsUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKGluaXRpYWxSZXEpO1xuXG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0QmVmb3JlTmV3UHVyY2hhc2UgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBjb25zdCBpbnZlbnRvcnlCZWZvcmVOZXdQdXJjaGFzZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogZXhpc3RpbmdQcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuXG4gICAgICAgICAgICBleHBlY3QocHJvZHVjdEJlZm9yZU5ld1B1cmNoYXNlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZlbnRvcnlCZWZvcmVOZXdQdXJjaGFzZT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGludmVudG9yeUJlZm9yZU5ld1B1cmNoYXNlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gMS4gRGVmaW5lIGRhdGEgZm9yIHRoZSBuZXcgcHVyY2hhc2Ugb2YgdGhlIGV4aXN0aW5nIHByb2R1Y3RcbiAgICAgICAgICAgIGNvbnN0IG5ld1B1cmNoYXNlUHJpY2UgPSAxMDA7XG4gICAgICAgICAgICBjb25zdCBuZXdQdXJjaGFzZVF1YW50aXR5ID0gODtcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogZXhpc3RpbmdQcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBuZXdQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld1B1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjcmVhdGVkU2hvcElkXTogbmV3UHVyY2hhc2VRdWFudGl0eVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogbmV3UHVyY2hhc2VRdWFudGl0eSAqIG5ld1B1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyAzLiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZEludm9pY2VJZCA9IHJlc3BvbnNlQm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbVxuICAgICAgICAgICAgY29uc3QgZGJJbnZlbnRvcnlJdGVtID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IGV4aXN0aW5nUHJvZHVjdElkLFxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbFF1YW50aXR5ID0gaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKyBuZXdQdXJjaGFzZVF1YW50aXR5O1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8ucXVhbnRpdHkpLnRvQmUoZXhwZWN0ZWRUb3RhbFF1YW50aXR5KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHNob3BTcGVjaWZpY0Nvc3QgcmVjYWxjdWxhdGlvblxuICAgICAgICAgICAgLy8gU1NDID0gKChvbGRRdHkgKiBvbGRTU0MpICsgKG5ld1F0eSAqIG5ld1ByaWNlKSkgLyAob2xkUXR5ICsgbmV3UXR5KVxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRTaG9wU3BlY2lmaWNDb3N0ID1cbiAgICAgICAgICAgICAgICAoKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UpICsgKG5ld1B1cmNoYXNlUXVhbnRpdHkgKiBuZXdQdXJjaGFzZVByaWNlKSkgL1xuICAgICAgICAgICAgICAgIChpbml0aWFsUHVyY2hhc2VRdWFudGl0eSArIG5ld1B1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oZXhwZWN0ZWRTaG9wU3BlY2lmaWNDb3N0KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDIHJlY2FsY3VsYXRpb25cbiAgICAgICAgICAgIC8vIFdBQyA9ICgob2xkVG90YWxRdHkgKiBvbGRXQUMpICsgKG5ld1B1cmNoYXNlUXR5ICogbmV3UHVyY2hhc2VQcmljZSkpIC8gKG5ld1RvdGFsUXR5ICsgbmV3UHVyY2hhc2VRdHkpXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHByb2R1Y3QgV0FDIHdhcyBpbml0aWFsUHVyY2hhc2VQcmljZSBmb3IgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkuXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFByb2R1Y3RXQUMgPVxuICAgICAgICAgICAgICAgICgoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKiBpbml0aWFsUHVyY2hhc2VQcmljZSkgKyAobmV3UHVyY2hhc2VRdWFudGl0eSAqIG5ld1B1cmNoYXNlUHJpY2UpKSAvXG4gICAgICAgICAgICAgICAgKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICsgbmV3UHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBjb25zdCBkYlByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhleHBlY3RlZFByb2R1Y3RXQUMpO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBwdXJjaGFzZSB3aXRoIG11bHRpcGxlIGl0ZW1zIGFuZCB1cGRhdGUgaW52ZW50b3J5L1dBQyBmb3IgZWFjaCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSB0d28gZGlzdGluY3QgcHJvZHVjdHMgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdDFEYXRhID0geyBuYW1lOiAnTXVsdGlJdGVtIFByb2R1Y3QgQScsIHNrdTogJ01VTFRJMDAxJywgcHJpY2U6IDUwLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QyRGF0YSA9IHsgbmFtZTogJ011bHRpSXRlbSBQcm9kdWN0IEInLCBza3U6ICdNVUxUSTAwMicsIHByaWNlOiA3NSwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH07XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0MSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7IGRhdGE6IHByb2R1Y3QxRGF0YSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QyID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHsgZGF0YTogcHJvZHVjdDJEYXRhIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlMSA9IDQwO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eTEgPSA1O1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZTIgPSA2MDtcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUXVhbnRpdHkyID0gMztcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdDEuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwdXJjaGFzZVByaWNlMSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Mi5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHkyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogWyAvLyBFeHBsaWNpdCBkaXN0cmlidXRpb24gZm9yIGVhY2ggaXRlbVxuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcHVyY2hhc2VRdWFudGl0eTEgfSwgLy8gRGlzdHJpYnV0aW9uIGZvciBpdGVtIDFcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHkyIH0gIC8vIERpc3RyaWJ1dGlvbiBmb3IgaXRlbSAyXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogKHB1cmNoYXNlUXVhbnRpdHkxICogcHVyY2hhc2VQcmljZTEpICsgKHB1cmNoYXNlUXVhbnRpdHkyICogcHVyY2hhc2VQcmljZTIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMy4gU2ltdWxhdGUgQVBJIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHB1cmNoYXNlSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIDQuIEFzc2VydGlvbnNcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBhbmQgaXRzIGl0ZW1zXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBjcmVhdGVkSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogeyBvcmRlckJ5OiB7IHByb2R1Y3RJZDogJ2FzYycgfSB9IH0gLy8gT3JkZXIgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYXNzZXJ0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcbiAgICAgICAgICAgIC8vIEFzc3VtaW5nIHByb2R1Y3QxLmlkIDwgcHJvZHVjdDIuaWQgZHVlIHRvIGNyZWF0aW9uIG9yZGVyIGZvciBjb25zaXN0ZW50IGNoZWNrc1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkUHJvZHVjdHMgPSBbcHJvZHVjdDEsIHByb2R1Y3QyXS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1swXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5MSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzFdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1sxXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5Mik7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMik7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAxXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0xID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QxLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTE/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0xPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UxKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDEgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QxLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0MT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAyXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0yID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QyLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTI/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkyKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0yPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UyKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QyLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Mj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMik7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIGRpc3RyaWJ1dGUgYSBzaW5nbGUgcHVyY2hhc2UgaXRlbSB0byBtdWx0aXBsZSBzaG9wcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSB0d28gbmV3IHNob3BzIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgIGNvbnN0IHNob3BBID0gYXdhaXQgcHJpc21hLnNob3AuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnVGVzdCBTaG9wIEEnLCBsb2NhdGlvbjogJ0xvYyBBJyB9IH0pO1xuICAgICAgICAgICAgY29uc3Qgc2hvcEIgPSBhd2FpdCBwcmlzbWEuc2hvcC5jcmVhdGUoeyBkYXRhOiB7IG5hbWU6ICdUZXN0IFNob3AgQicsIGxvY2F0aW9uOiAnTG9jIEInIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIDIuIENyZWF0ZSBhIG5ldyBwcm9kdWN0XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnU3BsaXQgUHJvZHVjdCcsIHNrdTogJ1NQTElUMDAxJywgcHJpY2U6IDIwMCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZSA9IDE4MDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsUXVhbnRpdHkgPSAxMDtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5Rm9yU2hvcEEgPSA2O1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlGb3JTaG9wQiA9IDQ7XG5cbiAgICAgICAgICAgIGV4cGVjdChxdWFudGl0eUZvclNob3BBICsgcXVhbnRpdHlGb3JTaG9wQikudG9CZSh0b3RhbFF1YW50aXR5KTsgLy8gU2FuaXR5IGNoZWNrXG5cbiAgICAgICAgICAgIC8vIDMuIFByZXBhcmUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHRvdGFsUXVhbnRpdHksIC8vIFRvdGFsIHF1YW50aXR5IGZvciB0aGUgaXRlbSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyAvLyBEaXN0cmlidXRpb24gZm9yIHRoZSBzaW5nbGUgaXRlbSwgc3BsaXQgaW50byB0d28gc2hvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzaG9wQS5pZF06IHF1YW50aXR5Rm9yU2hvcEEsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2hvcEIuaWRdOiBxdWFudGl0eUZvclNob3BCLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogdG90YWxRdWFudGl0eSAqIHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyA0LiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNS4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBmb3IgU2hvcCBBXG4gICAgICAgICAgICBjb25zdCBpbnZJdGVtQSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0LmlkLCBzaG9wSWQ6IHNob3BBLmlkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1BKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlGb3JTaG9wQSk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUE/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGZvciBTaG9wIEJcbiAgICAgICAgICAgIGNvbnN0IGludkl0ZW1CID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QuaWQsIHNob3BJZDogc2hvcEIuaWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUIpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1CPy5xdWFudGl0eSkudG9CZShxdWFudGl0eUZvclNob3BCKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQj8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDIChzaG91bGQgYmUgdGhlIHB1cmNoYXNlIHByaWNlIGFzIGl0J3MgYWxsIG5ldyBzdG9jaylcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgZmFpbCB0byBjcmVhdGUgYSBwdXJjaGFzZSBpZiBhIHByb2R1Y3RJZCBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vbkV4aXN0ZW50UHJvZHVjdElkID0gOTk5OTk5OyAvLyBBc3N1bWluZyB0aGlzIElEIHdvbid0IGV4aXN0XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gMTAwO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eSA9IDU7XG5cbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBub25FeGlzdGVudFByb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IHB1cmNoYXNlUXVhbnRpdHkgKiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcblxuICAgICAgICAgICAgLy8gRXhwZWN0IGEgY2xpZW50IGVycm9yIChlLmcuLCA0MDAgb3IgNDA0KSBvciBwb3RlbnRpYWxseSA1MDAgaWYgbm90IGhhbmRsZWQgZ3JhY2VmdWxseVxuICAgICAgICAgICAgLy8gRm9yIHJvYnVzdCBlcnJvciBoYW5kbGluZywgQVBJIHNob3VsZCByZXR1cm4gc3BlY2lmaWMgZXJyb3IgY29kZS5cbiAgICAgICAgICAgIC8vIFByaXNtYSB3aWxsIHRocm93IGFuIGVycm9yIGlmIGEgcmVsYXRlZCByZWNvcmQgKHByb2R1Y3QpIGlzIG5vdCBmb3VuZCBmb3IgZm9yZWlnbiBrZXkuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiBhIDUwMCBpZiBub3QgY2F1Z2h0IGFuZCBoYW5kbGVkIGJ5IHRoZSBBUEkgcm91dGUuXG4gICAgICAgICAgICAvLyBMZXQncyBhaW0gZm9yIHRoZSBBUEkgdG8gY2F0Y2ggdGhpcyBhbmQgcmV0dXJuIGEgbW9yZSBzcGVjaWZpYyBjbGllbnQgZXJyb3IuXG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBjaGVjayBpZiBpdCdzIE5PVCBhIHN1Y2Nlc3MgKDIwMSkuXG4gICAgICAgICAgICAvLyBBIG1vcmUgcHJlY2lzZSBjaGVjayB3b3VsZCBiZSBmb3IgNDAwLzQwNC80MjIgZGVwZW5kaW5nIG9uIHBsYW5uZWQgZXJyb3IgaGFuZGxpbmcuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7IC8vIE9yIDQwMC80MDQgaWYgeW91IGltcGxlbWVudCBzcGVjaWZpYyBlcnJvciBoYW5kbGluZ1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSwgY2hlY2sgZm9yIGEgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSBvciBjb2RlIGlmIHlvdXIgQVBJIHByb3ZpZGVzIG9uZS5cbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgZmFpbCB0byBjcmVhdGUgYSBwdXJjaGFzZSBpZiBhIHN1cHBsaWVySWQgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXN0UHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBGb3IgSW52YWxpZCBTdXBwbGllciBUZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnSU5WIFNVUDAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAxMDAsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gODA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gNTtcbiAgICAgICAgICAgIGNvbnN0IG5vbkV4aXN0ZW50U3VwcGxpZXJJZCA9IDk5OTk5OTsgLy8gQXNzdW1pbmcgdGhpcyBJRCB3b24ndCBleGlzdFxuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IG5vbkV4aXN0ZW50U3VwcGxpZXJJZC50b1N0cmluZygpLCAvLyBJbnZhbGlkIHN1cHBsaWVyXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3QuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBwdXJjaGFzZVF1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBwdXJjaGFzZVF1YW50aXR5ICogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHB1cmNoYXNlSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTsgLy8gRXhwZWN0aW5nIDUwMCBhcyBQcmlzbWEgdGhyb3dzIFAyMDAzXG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1BVVCAvYXBpL3B1cmNoYXNlcy86aWQgKFVwZGF0ZSBQdXJjaGFzZSBJbnZvaWNlKScsICgpID0+IHtcbiAgICAgICAgbGV0IGV4aXN0aW5nSW52b2ljZUlkOiBzdHJpbmc7XG4gICAgICAgIGxldCBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZDogbnVtYmVyO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VQcmljZSA9IDUwO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDEwO1xuXG4gICAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZHVjdCBzcGVjaWZpY2FsbHkgZm9yIHRoZXNlIHVwZGF0ZS9kZWxldGUgdGVzdHMgaWYgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gVGhlIGdsb2JhbCBjcmVhdGVkUHJvZHVjdElkIGNhbiBiZSB1c2VkIGlmIGl0IGZpdHMsIG9yIG1ha2UgYSBuZXcgb25lLlxuICAgICAgICAgICAgLy8gTGV0J3MgdXNlIHRoZSBnbG9iYWwgb25lIGZvciBzaW1wbGljaXR5LCBhc3N1bWluZyBiZWZvcmVFYWNoIGNsZWFucyBpdCB1cC5cbiAgICAgICAgICAgIHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkID0gY3JlYXRlZFByb2R1Y3RJZDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGluaXRpYWwgcHVyY2hhc2UgaW52b2ljZSB0byBiZSB1cGRhdGVkIG9yIGRlbGV0ZWQgaW4gdGVzdHNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSA4NjQwMDAwMCkudG9JU09TdHJpbmcoKSwgLy8gWWVzdGVyZGF5XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVxID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogaW5pdGlhbEludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZVB1cmNoYXNlSW52b2ljZShyZXEpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4aXN0aW5nSW52b2ljZUlkID0gYm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IHZlcmlmeSBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShpbml0aWFsUHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGluaXRpYWxJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSBpdGVtIHF1YW50aXR5IChpbmNyZWFzZSksIHJlY2FsY3VsYXRlIHN0b2NrIGFuZCBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlJbmNyZWFzZSA9IDU7XG4gICAgICAgICAgICBjb25zdCBuZXdRdWFudGl0eSA9IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICsgcXVhbnRpdHlJbmNyZWFzZTtcbiAgICAgICAgICAgIC8vIFByaWNlIHJlbWFpbnMgdGhlIHNhbWUgZm9yIHRoaXMgaXRlbSBpbiB0aGlzIHVwZGF0ZSBzY2VuYXJpb1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByaWNlRm9ySXRlbSA9IGluaXRpYWxQdXJjaGFzZVByaWNlO1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc2VuZCB0aGUgY29tcGxldGUgc3RydWN0dXJlIGV4cGVjdGVkIGJ5IHRoZSBQVVQgcm91dGVcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIGFsbCBpdGVtcywgZXZlbiBpZiBvbmx5IG9uZSBpcyBjaGFuZ2luZy5cbiAgICAgICAgICAgICAgICAvLyBUaGUgUFVUIHJvdXRlIGxvZ2ljIG1pZ2h0IGNvbXBhcmUgd2l0aCBleGlzdGluZyBpdGVtcyB0byBzZWUgd2hhdCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtIGhhZCBhbiBJRCAoUHVyY2hhc2VJbnZvaWNlSXRlbSBpZCksIGl0IG1pZ2h0IGJlIG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGFzc3VtZSBmb3Igbm93IHRoZSBQVVQgbWF0Y2hlcyBpdGVtcyBiYXNlZCBvbiBwcm9kdWN0SWQgaWYgbm90IGl0ZW0gSUQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlZCBvbiBjdXJyZW50IFBVVCByb3V0ZSwgaXQgZXhwZWN0cyBwcm9kdWN0SWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3UXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogdXBkYXRlZFByaWNlRm9ySXRlbSwgLy8gU2VuZCB0aGUgb3JpZ2luYWwgcHJpY2UgaWYgaXQgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGlzdHJpYnV0aW9ucyBpbiBQVVQgbWlnaHQgbmVlZCB0byByZWZsZWN0IHRoZSAqbmV3IHRvdGFsKiBmb3IgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IG5ld1F1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIE90aGVyIGZpZWxkcyBsaWtlIHN1cHBsaWVySWQsIGRhdGUsIHRvdGFsQW1vdW50IG1pZ2h0IGJlIHVwZGF0YWJsZSB0b28uXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoaXMgdGVzdCwgZm9jdXMgb24gaXRlbSBxdWFudGl0eSBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgLy8gVGhlIFBVVCByb3V0ZSByZWNhbGN1bGF0ZXMgdG90YWxBbW91bnQgYmFzZWQgb24gaXRlbXMgaWYgbm90IHByb3ZpZGVkIG9yIGlmIGl0ZW1zIGNoYW5nZS5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgdG90YWxBbW91bnQgd2lsbCBiZSByZWNhbGN1bGF0ZWQgYnkgdGhlIEFQSS5cbiAgICAgICAgICAgICAgICAvLyBzdXBwbGllcklkIGFuZCBkYXRlIGNvdWxkIGJlIHBhcnQgb2YgdGhlIHBheWxvYWQgaWYgdGhleSBhcmUgdXBkYXRhYmxlLlxuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIGtlZXBpbmcgaXQgbWluaW1hbCB0byB0ZXN0IGl0ZW0gdXBkYXRlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBQVVQgaGFuZGxlciByZS1jYWxjdWxhdGVzIHRvdGFsIGFtb3VudCwgc28gbm90IHNlbmRpbmcgaXQuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIC8vIElNUE9SVEFOVDogTmVlZCB0byBwYXNzIHJvdXRlIHBhcmFtcyBmb3IgW2lkXSB0byB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IHN0YW5kYXJkIE5leHRSZXF1ZXN0IGJ1dCBob3cgdGVzdCBzZXR1cCBtaWdodCBuZWVkIGl0IG9yIGhvdyBoYW5kbGVyIGV4cGVjdHMgaXQuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCBoYW5kbGVyIGB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVxdWVzdDogTmV4dFJlcXVlc3QsIHsgcGFyYW1zIH06IHsgcGFyYW1zOiB7IGlkOiBzdHJpbmcgfSB9KWBcbiAgICAgICAgICAgICAgICAvLyBuZWVkcyBgcGFyYW1zYC4gbm9kZS1tb2Nrcy1odHRwIGBjcmVhdGVNb2Nrc2AgaGFuZGxlcyB0aGlzIHdlbGwuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGRpcmVjdCBOZXh0UmVxdWVzdCwgd2UgcGFzcyBpdCBpbiBjb250ZXh0IHRvIHRoZSBoYW5kbGVyIGNhbGwuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2ltdWxhdGUgQVBJIGNhbGwgLSB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVxLCB7IHBhcmFtczogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSB9KVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBob3cgeW91IGNhbGwgaXQgaWYgeW91IGFyZSB0ZXN0aW5nIHRoZSBoYW5kbGVyIGRpcmVjdGx5IGluIEplc3Qgd2l0aCBjb250ZXh0XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgYW5kIHNob3BTcGVjaWZpY0Nvc3RcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZShuZXdRdWFudGl0eSk7XG5cbiAgICAgICAgICAgIC8vIFdBQyBjYWxjdWxhdGlvbjogKChvbGRRdHkgKiBvbGRTU0MpICsgKGFkZGVkUXR5ICogcHJpY2VPZkFkZGVkUXR5KSkgLyAobmV3VG90YWxRdHkpXG4gICAgICAgICAgICAvLyBJbiB0aGlzIHNwZWNpZmljIHVwZGF0ZSwgdGhlIFBVVCByb3V0ZSByZXZlcnNlcyB0aGUgb2xkIGl0ZW0gYW5kIGFkZHMgdGhlIG5ldyBvbmUgYXMgaWYgaXQncyBhIG5ldyBwdXJjaGFzZSBsaW5lIGZvciBXQUMgY2FsY3MuXG4gICAgICAgICAgICAvLyBTbywgdGhlIG9sZCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSBhdCBpbml0aWFsUHVyY2hhc2VQcmljZSBpcyByZXZlcnNlZC5cbiAgICAgICAgICAgIC8vIFRoZW4sIG5ld1F1YW50aXR5IGF0IHVwZGF0ZWRQcmljZUZvckl0ZW0gaXMgYWRkZWQuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGUgY3VycmVudCBQVVQgbG9naWMgZmlyc3QgcmV2ZXJzZXMgKmFsbCogb2xkIGl0ZW1zIGJhc2VkIG9uIHRoZWlyICpvcmlnaW5hbCogcmVjb3JkZWQgY29zdC5cbiAgICAgICAgICAgIC8vIFRoZW4gaXQgYWRkcyAqYWxsKiBuZXcgaXRlbXMgYmFzZWQgb24gdGhlaXIgKm5ldyogY29zdC5cbiAgICAgICAgICAgIC8vIFNvIGZvciB0aGUgcHJvZHVjdCBXQUM6IChUb3RhbFZhbHVlQmVmb3JlIC0gT2xkSXRlbVZhbHVlICsgTmV3SXRlbVZhbHVlKSAvIChUb3RhbFN0b2NrQmVmb3JlIC0gT2xkSXRlbVF0eSArIE5ld0l0ZW1RdHkpXG4gICAgICAgICAgICAvLyBBbmQgZm9yIHNob3Agc3BlY2lmaWMgV0FDOiAoU2hvcFZhbHVlQmVmb3JlIC0gT2xkSXRlbVZhbHVlSW5TaG9wICsgTmV3SXRlbVZhbHVlSW5TaG9wKSAvIChTaG9wU3RvY2tCZWZvcmUgLSBPbGRJdGVtUXR5SW5TaG9wICsgTmV3SXRlbVF0eUluU2hvcClcblxuICAgICAgICAgICAgLy8gTGV0J3MgY2hlY2sgdGhlIGxvZ2ljIGZyb20gc3JjL2FwcC9hcGkvcHVyY2hhc2VzL1tpZF0vcm91dGUudHNcbiAgICAgICAgICAgIC8vIDEuIEl0IGZldGNoZXMgdGhlIG9sZCBpbnZvaWNlLlxuICAgICAgICAgICAgLy8gMi4gSXQgcmV2ZXJzZXMgaW52ZW50b3J5IGFkanVzdG1lbnRzIGZvciBBTEwgb2xkIGl0ZW1zIChkZWNyZWFzZSBzdG9jaywgV0FDIHVwZGF0ZWQpLlxuICAgICAgICAgICAgLy8gMy4gSXQgcHJvY2Vzc2VzIEFMTCBuZXcvdXBkYXRlZCBpdGVtcyBhcyBpZiB0aGV5IGFyZSBuZXcgcHVyY2hhc2VzIChpbmNyZWFzZSBzdG9jaywgV0FDIHVwZGF0ZWQpLlxuXG4gICAgICAgICAgICAvLyBTbywgYWZ0ZXIgcmV2ZXJzYWwgb2YgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgYXQgaW5pdGlhbFB1cmNoYXNlUHJpY2U6XG4gICAgICAgICAgICAvLyBQcm9kdWN0IFdBQyBhbmQgU2hvcFNwZWNpZmljQ29zdCB3b3VsZCBiZSBlZmZlY3RpdmVseSAwIGlmIHRoaXMgd2VyZSB0aGUgb25seSBwcm9kdWN0L3N0b2NrLlxuICAgICAgICAgICAgLy8gVGhlbiwgYWRkaW5nIG5ld1F1YW50aXR5IGF0IHVwZGF0ZWRQcmljZUZvckl0ZW06XG4gICAgICAgICAgICAvLyBUaGUgbmV3IFdBQ3Mgc2hvdWxkIGJlY29tZSB1cGRhdGVkUHJpY2VGb3JJdGVtLlxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgUHJvZHVjdCBXQUNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREIgcmVmbGVjdHMgdGhlIGNoYW5nZVxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7IGl0ZW1zOiB0cnVlIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnF1YW50aXR5KS50b0JlKG5ld1F1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByaWNlKS50b0JlKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUobmV3UXVhbnRpdHkgKiB1cGRhdGVkUHJpY2VGb3JJdGVtKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIGl0ZW0gcXVhbnRpdHkgKGRlY3JlYXNlKSwgcmVjYWxjdWxhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWFudGl0eURlY3JlYXNlID0gMztcbiAgICAgICAgICAgIGNvbnN0IG5ld1F1YW50aXR5ID0gaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgLSBxdWFudGl0eURlY3JlYXNlO1xuICAgICAgICAgICAgZXhwZWN0KG5ld1F1YW50aXR5KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApOyAvLyBFbnN1cmUgd2UgZG9uJ3QgZ28gbmVnYXRpdmUgZm9yIHRoaXMgdGVzdCBsb2dpY1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJpY2VGb3JJdGVtID0gaW5pdGlhbFB1cmNoYXNlUHJpY2U7IC8vIFByaWNlIHJlbWFpbnMgdGhlIHNhbWVcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3UXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogdXBkYXRlZFByaWNlRm9ySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogbmV3UXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdXBkYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSwgeyBwYXJhbXM6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZGF0YSkudG9IYXZlUHJvcGVydHkoJ2lkJywgZXhpc3RpbmdJbnZvaWNlSWQpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBzdG9jayBhbmQgc2hvcFNwZWNpZmljQ29zdFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKG5ld1F1YW50aXR5KTtcblxuICAgICAgICAgICAgLy8gRHVlIHRvIHRoZSByZXZlcnNhbCBhbmQgcmUtYWRkaXRpb24gbG9naWMgb2YgdGhlIFBVVCByb3V0ZTpcbiAgICAgICAgICAgIC8vIFRoZSBvbGQgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgYXQgaW5pdGlhbFB1cmNoYXNlUHJpY2UgaXMgcmV2ZXJzZWQuXG4gICAgICAgICAgICAvLyBUaGVuLCBuZXdRdWFudGl0eSBhdCB1cGRhdGVkUHJpY2VGb3JJdGVtIGlzIGFkZGVkLlxuICAgICAgICAgICAgLy8gU28sIG5ldyBXQUNzIHNob3VsZCBiZWNvbWUgdXBkYXRlZFByaWNlRm9ySXRlbSAod2hpY2ggaXMgaW5pdGlhbFB1cmNoYXNlUHJpY2UpLlxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgUHJvZHVjdCBXQUNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREJcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShuZXdRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZSh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/LnRvdGFsKS50b0JlKG5ld1F1YW50aXR5ICogdXBkYXRlZFByaWNlRm9ySXRlbSk7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSBpdGVtIHByaWNlLCByZWNhbGN1bGF0ZSBzdG9jayBhbmQgV0FDcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ByaWNlRm9ySXRlbSA9IGluaXRpYWxQdXJjaGFzZVByaWNlICsgMjU7IC8vIE5ldyBwcmljZSwgZS5nLiwgNTAgKyAyNSA9IDc1XG4gICAgICAgICAgICBjb25zdCBxdWFudGl0eVVuY2hhbmdlZCA9IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5OyAvLyBRdWFudGl0eSByZW1haW5zIHRoZSBzYW1lXG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHF1YW50aXR5VW5jaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld1ByaWNlRm9ySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcXVhbnRpdHlVbmNoYW5nZWQgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgLy8gdG90YWxBbW91bnQgd2lsbCBiZSByZWNhbGN1bGF0ZWQgYnkgdGhlIEFQSVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtleGlzdGluZ0ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgKHNob3VsZCBiZSB1bmNoYW5nZWQpIGFuZCBzaG9wU3BlY2lmaWNDb3N0XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlVbmNoYW5nZWQpO1xuICAgICAgICAgICAgLy8gV0FDIGxvZ2ljIGluIFBVVDogcmV2ZXJzZXMgb2xkLCBhZGRzIG5ldy4gU28gc2hvcFNwZWNpZmljQ29zdCBzaG91bGQgcmVmbGVjdCBuZXdQcmljZUZvckl0ZW0uXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8obmV3UHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8obmV3UHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREJcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShxdWFudGl0eVVuY2hhbmdlZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShuZXdQcmljZUZvckl0ZW0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUocXVhbnRpdHlVbmNoYW5nZWQgKiBuZXdQcmljZUZvckl0ZW0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBhZGQgYSBuZXcgaXRlbSB0byBhbiBleGlzdGluZyBpbnZvaWNlLCB1cGRhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBEZWZpbmUgYSBuZXcgcHJvZHVjdCBmb3IgdGhlIG5ldyBpdGVtXG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTmV3bHkgQWRkZWQgUHJvZHVjdCBmb3IgUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnUFVUTkVXMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDIwMCwgLy8gUmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUHJvZHVjdElkID0gbmV3SXRlbVByb2R1Y3QuaWQ7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUXVhbnRpdHkgPSA3O1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbVByaWNlID0gMTIwO1xuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBpdGVtIGRldGFpbHMgKGZyb20gYmVmb3JlRWFjaCBzZXR1cClcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbVByb2R1Y3RJZCA9IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxJdGVtUXVhbnRpdHkgPSBpbml0aWFsUHVyY2hhc2VRdWFudGl0eTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbVByaWNlID0gaW5pdGlhbFB1cmNoYXNlUHJpY2U7XG5cbiAgICAgICAgICAgIC8vIDIuIFByZXBhcmUgdGhlIHVwZGF0ZSBwYXlsb2FkIHdpdGggYm90aCBvcmlnaW5hbCBhbmQgbmV3IGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBvcmlnaW5hbEl0ZW1RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBvcmlnaW5hbEl0ZW1QcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBuZXdJdGVtUHJvZHVjdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3SXRlbVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld0l0ZW1QcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogb3JpZ2luYWxJdGVtUXVhbnRpdHkgfSwgLy8gRGlzdHJpYnV0aW9uIGZvciBvcmlnaW5hbCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBuZXdJdGVtUXVhbnRpdHkgfSAgICAgIC8vIERpc3RyaWJ1dGlvbiBmb3IgbmV3IGl0ZW1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIHRvdGFsQW1vdW50IHdpbGwgYmUgcmVjYWxjdWxhdGVkIGJ5IHRoZSBBUElcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIFNpbXVsYXRlIEFQSSBjYWxsXG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAvLyA0LiBBc3NlcnRpb25zXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7IGl0ZW1zOiB7IG9yZGVyQnk6IHsgcHJvZHVjdElkOiAnYXNjJyB9IH0gfSwgLy8gT3JkZXIgZm9yIGNvbnNpc3RlbnQgY2hlY2tzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcblxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbCA9IChvcmlnaW5hbEl0ZW1RdWFudGl0eSAqIG9yaWdpbmFsSXRlbVByaWNlKSArIChuZXdJdGVtUXVhbnRpdHkgKiBuZXdJdGVtUHJpY2UpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUoZXhwZWN0ZWRUb3RhbCk7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGl0ZW1zIGluIHRoZSByZXNwb25zZSAob3JkZXIgbWlnaHQgdmFyeSwgc28gZmluZCBieSBwcm9kdWN0SWQpXG4gICAgICAgICAgICBjb25zdCBkYk9yaWdpbmFsSXRlbSA9IGRiSW52b2ljZT8uaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ucHJvZHVjdElkID09PSBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQpO1xuICAgICAgICAgICAgY29uc3QgZGJOZXdJdGVtID0gZGJJbnZvaWNlPy5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5wcm9kdWN0SWQgPT09IG5ld0l0ZW1Qcm9kdWN0SWQpO1xuXG4gICAgICAgICAgICBleHBlY3QoZGJPcmlnaW5hbEl0ZW0pLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZGJPcmlnaW5hbEl0ZW0/LnF1YW50aXR5KS50b0JlKG9yaWdpbmFsSXRlbVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYk9yaWdpbmFsSXRlbT8ucHJpY2UpLnRvQmUob3JpZ2luYWxJdGVtUHJpY2UpO1xuXG4gICAgICAgICAgICBleHBlY3QoZGJOZXdJdGVtKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGRiTmV3SXRlbT8ucXVhbnRpdHkpLnRvQmUobmV3SXRlbVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYk5ld0l0ZW0/LnByaWNlKS50b0JlKG5ld0l0ZW1QcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgdGhlIG9yaWdpbmFsIGl0ZW1cbiAgICAgICAgICAgIC8vIChEdWUgdG8gUFVUIGxvZ2ljIG9mIHJldmVyc2UgJiByZS1hZGQsIFdBQ3Mgc2hvdWxkIHJlZmxlY3QgaXRzIGN1cnJlbnQgcHJpY2UpXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChvcmlnaW5hbEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUob3JpZ2luYWxJdGVtUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhvcmlnaW5hbEl0ZW1QcmljZSk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IG9yaWdpbmFsSXRlbVByb2R1Y3RJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8ob3JpZ2luYWxJdGVtUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBhbmQgUHJvZHVjdCBXQUMgZm9yIHRoZSBORVcgaXRlbVxuICAgICAgICAgICAgY29uc3QgbmV3SW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IG5ld0l0ZW1Qcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChuZXdJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKG5ld0l0ZW1RdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QobmV3SW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhuZXdJdGVtUHJpY2UpO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvZHVjdERiID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBuZXdJdGVtUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QobmV3UHJvZHVjdERiPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhuZXdJdGVtUHJpY2UpO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGV4aXN0aW5nIGludm9pY2UsIHVwZGF0ZSBzdG9jayBhbmQgV0FDcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIFNldHVwOiBFbnN1cmUgYW4gaW52b2ljZSB3aXRoIGF0IGxlYXN0IHR3byBpdGVtcyBleGlzdHMuXG4gICAgICAgICAgICAvLyBXZSdsbCB1c2UgdGhlIGV4aXN0aW5nIGBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZGAgYW5kIGNyZWF0ZSBvbmUgbW9yZSBwcm9kdWN0IGFuZCBpdGVtLlxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdFRvUmVtb3ZlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdQcm9kdWN0IFRvIEJlIFJlbW92ZWQnLFxuICAgICAgICAgICAgICAgICAgICBza3U6ICdQVVRSTVYwMDEnLFxuICAgICAgICAgICAgICAgICAgICBwcmljZTogMzAwLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdFRvUmVtb3ZlSWQgPSBwcm9kdWN0VG9SZW1vdmUuaWQ7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSA9IDQ7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9SZW1vdmVQcmljZSA9IDQwO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGludm9pY2UgKGNyZWF0ZWQgaW4gZ2xvYmFsIGJlZm9yZUVhY2ggZm9yIFBVVCkgdG8gaW5jbHVkZSB0aGlzIHNlY29uZCBpdGVtIGZpcnN0LlxuICAgICAgICAgICAgY29uc3QgYWRkU2Vjb25kSXRlbVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RUb1JlbW92ZUlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcHJvZHVjdFRvUmVtb3ZlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHJvZHVjdFRvUmVtb3ZlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhZGRSZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGFkZFNlY29uZEl0ZW1QYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdXBkYXRlUHVyY2hhc2VJbnZvaWNlKGFkZFJlcSwgeyBwYXJhbXM6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjazogSW52b2ljZSBzaG91bGQgaGF2ZSAyIGl0ZW1zXG4gICAgICAgICAgICBsZXQgaW52b2ljZVdpdGhUd29JdGVtcyA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9LCBpbmNsdWRlOiB7IGl0ZW1zOiB0cnVlIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52b2ljZVdpdGhUd29JdGVtcz8uaXRlbXMubGVuZ3RoKS50b0JlKDIpO1xuXG4gICAgICAgICAgICAvLyAyLiBQcmVwYXJlIHRoZSB1cGRhdGUgcGF5bG9hZCB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGl0ZW0gd2Ugd2FudCB0byBrZWVwLlxuICAgICAgICAgICAgY29uc3QgdXBkYXRlUGF5bG9hZFRvUmVtb3ZlSXRlbSA9IHtcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksIC8vIEtlZXAgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBpbml0aWFsUHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgfSAvLyBEaXN0cmlidXRpb24gZm9yIHRoZSBrZXB0IGl0ZW1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMy4gU2ltdWxhdGUgQVBJIGNhbGwgdG8gcmVtb3ZlIHRoZSBpdGVtXG4gICAgICAgICAgICBjb25zdCByZW1vdmVSZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWRUb1JlbW92ZUl0ZW0pLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZW1vdmVSZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAvLyA0LiBBc3NlcnRpb25zXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQiAtIHNob3VsZCBub3cgaGF2ZSBvbmx5IDEgaXRlbVxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7IGl0ZW1zOiB0cnVlIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShpbml0aWFsUHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShpbml0aWFsUHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy50b3RhbCkudG9CZShpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAqIGluaXRpYWxQdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gYW5kIFByb2R1Y3QgV0FDIGZvciB0aGUgS0VQVCBpdGVtXG4gICAgICAgICAgICBjb25zdCBrZXB0SW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3Qoa2VwdEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGtlcHRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcbiAgICAgICAgICAgIGNvbnN0IGtlcHRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGtlcHRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhpbml0aWFsUHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgdGhlIFJFTU9WRUQgaXRlbVxuICAgICAgICAgICAgLy8gU3RvY2sgc2hvdWxkIGJlIHplcm8gb3IgdGhlIGl0ZW0gbWlnaHQgYmUgZ29uZSBmcm9tIGludmVudG9yeSBpZiBpdCB3YXMgdGhlIG9ubHkgcHVyY2hhc2VcbiAgICAgICAgICAgIC8vIFdBQyBvbiBwcm9kdWN0IHNob3VsZCBiZSAwIGlmIG5vIG90aGVyIHB1cmNoYXNlcyBleGlzdC5cbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdFRvUmVtb3ZlSWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRoZSBQVVQgbG9naWMgcmV2ZXJzZXMgc3RvY2suIElmIHRoaXMgd2FzIHRoZSBvbmx5IHN0b2NrLCBpdCBiZWNvbWVzIDAuXG4gICAgICAgICAgICBleHBlY3QocmVtb3ZlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICAvLyBTaG9wU3BlY2lmaWNDb3N0IG1pZ2h0IGJlY29tZSAwIG9yIE5hTiBpZiBxdWFudGl0eSBpcyAwLiBUaGUgQVBJIHNldHMgaXQgdG8gMCBmb3Igc2FmZXR5LlxuICAgICAgICAgICAgZXhwZWN0KHJlbW92ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUHJvZHVjdERiID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0VG9SZW1vdmVJZCB9IH0pO1xuICAgICAgICAgICAgLy8gSWYgbm8gb3RoZXIgcHVyY2hhc2UgaXRlbXMgZm9yIHRoaXMgcHJvZHVjdCwgV0FDIHNob3VsZCBiZWNvbWUgMC5cbiAgICAgICAgICAgIGNvbnN0IG90aGVyUHVyY2hhc2VzT2ZSZW1vdmVkSXRlbSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmNvdW50KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RUb1JlbW92ZUlkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG90aGVyUHVyY2hhc2VzT2ZSZW1vdmVkSXRlbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChyZW1vdmVkUHJvZHVjdERiPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbygwKTtcbiAgICAgICAgICAgIH0gLy8gRWxzZSwgaXQgd291bGQgYmUgYmFzZWQgb24gb3RoZXIgcHVyY2hhc2VzLCB3aGljaCB0aGlzIHRlc3QgZG9lc24ndCBzZXQgdXAuXG5cbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0RFTEVURSAvYXBpL3B1cmNoYXNlcy86aWQgKERlbGV0ZSBQdXJjaGFzZSBJbnZvaWNlKScsICgpID0+IHtcbiAgICAgICAgbGV0IGludm9pY2VUb0RlbGV0ZUlkOiBzdHJpbmc7XG4gICAgICAgIGxldCBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkOiBudW1iZXI7XG4gICAgICAgIGNvbnN0IGRlbGV0ZVRlc3RJbml0aWFsUHJpY2UgPSA2MDtcbiAgICAgICAgY29uc3QgZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSA9IDEyO1xuXG4gICAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHByb2R1Y3QgZXhpc3RzIGZvciB0aGUgdGVzdFxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBGb3IgRGVsZXRlIFRlc3QnLFxuICAgICAgICAgICAgICAgICAgICBza3U6ICdERUxQUk9EMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDEwMCwgLy8gcmV0YWlsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkID0gcHJvZHVjdC5pZDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGluaXRpYWwgcHVyY2hhc2UgaW52b2ljZSB0byBiZSBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBkZWxldGVUZXN0SW5pdGlhbFByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSB9IC8vIEV4cGxpY2l0IGRpc3RyaWJ1dGlvblxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHkgKiBkZWxldGVUZXN0SW5pdGlhbFByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGluaXRpYWxJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaW52b2ljZVRvRGVsZXRlSWQgPSBib2R5LmRhdGEuaWQ7XG5cbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjazogdmVyaWZ5IGluaXRpYWwgc3RhdGUgYWZ0ZXIgY3JlYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxQcm9kdWN0REIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RGb3JEZWxldGVUZXN0SWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsUHJvZHVjdERCPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKGRlbGV0ZVRlc3RJbml0aWFsUHJpY2UpO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShkZWxldGVUZXN0SW5pdGlhbFByaWNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBkZWxldGUgYSBwdXJjaGFzZSBpbnZvaWNlIGFuZCBjb3JyZWN0bHkgcmV2ZXJzZSBzdG9jayBhbmQgV0FDcyBmb3IgYSBzaW5nbGUtaXRlbSBpbnZvaWNlIHdpdGggZXhwbGljaXQgZGlzdHJpYnV0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gQ2FsbCB0aGUgREVMRVRFIGVuZHBvaW50XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2ludm9pY2VUb0RlbGV0ZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXNwb25zZSA9IGF3YWl0IGRlbGV0ZVB1cmNoYXNlSW52b2ljZShkZWxldGVSZXEsIHsgcGFyYW1zOiB7IGlkOiBpbnZvaWNlVG9EZWxldGVJZCB9IH0pO1xuXG4gICAgICAgICAgICAvLyAyLiBBc3NlcnRpb25zIGZvciBERUxFVEUgcmVzcG9uc2VcbiAgICAgICAgICAgIGV4cGVjdChkZWxldGVSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3BvbnNlQm9keSA9IGF3YWl0IGRlbGV0ZVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4cGVjdChkZWxldGVSZXNwb25zZUJvZHkubWVzc2FnZSkudG9CZSgnUHVyY2hhc2UgaW52b2ljZSBkZWxldGVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgICAgICAgICAvLyAzLiBWZXJpZnkgUHVyY2hhc2VJbnZvaWNlIGlzIGRlbGV0ZWQgZnJvbSBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogaW52b2ljZVRvRGVsZXRlSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkudG9CZU51bGwoKTtcblxuICAgICAgICAgICAgLy8gNC4gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW1zIGFyZSBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2VJdGVtcyA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmZpbmRNYW55KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwdXJjaGFzZUludm9pY2VJZDogaW52b2ljZVRvRGVsZXRlSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZUl0ZW1zLmxlbmd0aCkudG9CZSgwKTtcblxuICAgICAgICAgICAgLy8gNS4gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgaXMgcmV2ZXJzZWRcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXNzdW1pbmcgdGhpcyB3YXMgdGhlIG9ubHkgcHVyY2hhc2UsIHN0b2NrIHNob3VsZCBiZSAwXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICAvLyBTaG9wU3BlY2lmaWNDb3N0IHNob3VsZCBhbHNvIGJlIDAgaWYgc3RvY2sgaXMgMFxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG5cbiAgICAgICAgICAgIC8vIDYuIFZlcmlmeSBQcm9kdWN0IFdBQyBpcyByZWNhbGN1bGF0ZWQgKHNob3VsZCBiZSAwIGlmIHRoaXMgd2FzIHRoZSBvbmx5IHB1cmNoYXNlKVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiBubyBvdGhlciBwdXJjaGFzZSBpdGVtcyBmb3IgdGhpcyBwcm9kdWN0LCBXQUMgc2hvdWxkIGJlY29tZSAwLlxuICAgICAgICAgICAgY29uc3Qgb3RoZXJQdXJjaGFzZXNPZlByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5jb3VudCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkLFxuICAgICAgICAgICAgICAgICAgICAvLyBwdXJjaGFzZUludm9pY2VJZDogeyBub3Q6IGludm9pY2VUb0RlbGV0ZUlkIH0gLy8gTm90IG5lZWRlZCBhcyBvcmlnaW5hbCBpbnZvaWNlIGl0ZW1zIGFyZSBnb25lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3RoZXJQdXJjaGFzZXNPZlByb2R1Y3QgPT09IDApIHsgLy8gVGhpcyBzaG91bGQgYmUgdHJ1ZSBmb3IgdGhpcyB0ZXN0XG4gICAgICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbygwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBkZWxldGUgYSBwdXJjaGFzZSBhbmQgcmV2ZXJzZSBzdG9jay9XQUMgd2hlbiBwcm9kdWN0IGlzIGluIGEgc2luZ2xlIGluZmVycmVkIHNob3AnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBTZXR1cDogQ3JlYXRlIGRlZGljYXRlZCBlbnRpdGllcyBmb3IgdGhpcyB0ZXN0IHRvIGVuc3VyZSBpc29sYXRpb24uXG4gICAgICAgICAgICBjb25zdCB0ZXN0U2hvcCA9IGF3YWl0IHByaXNtYS5zaG9wLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBuYW1lOiAnSW5mZXJyZWQgRGVsZXRlIFRlc3QgU2hvcCcsIGxvY2F0aW9uOiAnTG9jIFgnIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGVzdFN1cHBsaWVyID0gYXdhaXQgcHJpc21hLnN1cHBsaWVyLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBuYW1lOiAnSW5mZXJyZWQgRGVsZXRlIFRlc3QgU3VwcGxpZXInIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGVzdFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1Byb2R1Y3QgZm9yIEluZmVycmVkIERlbGV0ZScsXG4gICAgICAgICAgICAgICAgICAgIHNrdTogJ0lORkRFTDAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAyMDAsIC8vIHJldGFpbCBwcmljZVxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRlZEF2ZXJhZ2VDb3N0OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBpbnZlbnRvcnkgaXRlbSBmb3IgdGhpcyBwcm9kdWN0IGluIHRoZSB0ZXN0IHNob3AuXG4gICAgICAgICAgICAvLyBUaGlzIG1ha2VzIGl0IHRoZSBcInNpbmdsZSBpbmZlcnJlZCBzaG9wXCIuXG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiB0ZXN0UHJvZHVjdC5pZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcElkOiB0ZXN0U2hvcC5pZCxcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IDAsIC8vIFdpbGwgYmUgdXBkYXRlZCBieSB0aGUgcHVyY2hhc2VcbiAgICAgICAgICAgICAgICAgICAgc2hvcFNwZWNpZmljQ29zdDogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gMTI7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gNjA7XG5cbiAgICAgICAgICAgIGNvbnN0IGluZmVycmVkU2hvcEludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IHRlc3RTdXBwbGllci5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHRlc3RQcm9kdWN0LmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcHVyY2hhc2VRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgLy8gTk8gZGlzdHJpYnV0aW9ucyBwcm9wZXJ0eSBoZXJlIGZvciBpbmZlcmVuY2UgdG8ga2ljayBpbiBvbiBQT1NUXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IHB1cmNoYXNlUXVhbnRpdHkgKiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBwdXJjaGFzZSBpbnZvaWNlICh0aGlzIGlzIHdoZXJlIHRoZSBmYWlsdXJlIHdhcyBoYXBwZW5pbmcpXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVSZXEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbmZlcnJlZFNob3BJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKGNyZWF0ZVJlcSk7XG4gICAgICAgICAgICBleHBlY3QoY3JlYXRlUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7IC8vIEFzc2VydCBzdWNjZXNzZnVsIGNyZWF0aW9uXG5cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJvZHkgPSBhd2FpdCBjcmVhdGVSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCBpbnZvaWNlSWRGb3JJbmZlcnJlZERlbGV0ZSA9IGNyZWF0ZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrOiBWZXJpZnkgc3RvY2sgYW5kIFdBQyBhZnRlciBjcmVhdGlvblxuICAgICAgICAgICAgY29uc3QgaW52ZW50b3J5QWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogdGVzdFByb2R1Y3QuaWQsIHNob3BJZDogdGVzdFNob3AuaWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52ZW50b3J5QWZ0ZXJDcmVhdGU/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGludmVudG9yeUFmdGVyQ3JlYXRlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RBZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogdGVzdFByb2R1Y3QuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChwcm9kdWN0QWZ0ZXJDcmVhdGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKHB1cmNoYXNlUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyAyLiBDYWxsIHRoZSBERUxFVEUgZW5kcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcSA9IG5ldyBOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7aW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGV9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3BvbnNlID0gYXdhaXQgZGVsZXRlUHVyY2hhc2VJbnZvaWNlKGRlbGV0ZVJlcSwgeyBwYXJhbXM6IHsgaWQ6IGludm9pY2VJZEZvckluZmVycmVkRGVsZXRlIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIDMuIEFzc2VydGlvbnMgZm9yIERFTEVURSByZXNwb25zZVxuICAgICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzcG9uc2VCb2R5ID0gYXdhaXQgZGVsZXRlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3BvbnNlQm9keS5tZXNzYWdlKS50b0JlKCdQdXJjaGFzZSBpbnZvaWNlIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICAgICAgICAgIC8vIDQuIFZlcmlmeSBQdXJjaGFzZUludm9pY2UgYW5kIEl0ZW1zIGFyZSBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogaW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGUgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2UpLnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2VJdGVtcyA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmZpbmRNYW55KHsgd2hlcmU6IHsgcHVyY2hhc2VJbnZvaWNlSWQ6IGludm9pY2VJZEZvckluZmVycmVkRGVsZXRlIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlSXRlbXMubGVuZ3RoKS50b0JlKDApO1xuXG4gICAgICAgICAgICAvLyA1LiBWZXJpZnkgSW52ZW50b3J5SXRlbSBzdG9jayBhbmQgc2hvcFNwZWNpZmljQ29zdCBhcmUgcmV2ZXJzZWQgaW4gdGhlIGluZmVycmVkIHNob3BcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogdGVzdFByb2R1Y3QuaWQsIHNob3BJZDogdGVzdFNob3AuaWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oMCk7XG5cbiAgICAgICAgICAgIC8vIDYuIFZlcmlmeSBQcm9kdWN0IFdBQyBpcyByZWNhbGN1bGF0ZWQgdG8gMFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2R1Y3REQiA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogdGVzdFByb2R1Y3QuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdERCPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbygwKTtcblxuICAgICAgICAgICAgLy8gQ2xlYW51cCBkZWRpY2F0ZWQgZW50aXRpZXMgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZGVsZXRlTWFueSh7IHdoZXJlOiB7IHByb2R1Y3RJZDogdGVzdFByb2R1Y3QuaWQgfSB9KTtcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5wcm9kdWN0LmRlbGV0ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0UHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnN1cHBsaWVyLmRlbGV0ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0U3VwcGxpZXIuaWQgfSB9KTtcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5zaG9wLmRlbGV0ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0U2hvcC5pZCB9IH0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEFkZGVkIGEgbG9uZ2VyIHRpbWVvdXQgYXMgYSBwcmVjYXV0aW9uXG5cbiAgICAgICAgaXQoJ3Nob3VsZCBkZWxldGUgYW4gaW52b2ljZSB3aXRoIG11bHRpcGxlIGl0ZW1zLCByZXZlcnNpbmcgc3RvY2svV0FDIGZvciBlYWNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gU2V0dXA6IENyZWF0ZSBtdWx0aXBsZSBwcm9kdWN0cyBhbmQgYW4gaW52b2ljZSB3aXRoIGl0ZW1zIGZyb20gdGhlc2UgcHJvZHVjdHMuXG4gICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgZGlzdHJpYnV0ZSBlYWNoIHRvIHRoZSBtYWluIGNyZWF0ZWRTaG9wSWQgZnJvbSBnbG9iYWwgYmVmb3JlRWFjaC5cblxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdEEgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHsgbmFtZTogJ011bHRpLURlbCBQcm9kIEEnLCBza3U6ICdNREVMMDBBJywgcHJpY2U6IDEwMCwgd2VpZ2h0ZWRBdmVyYWdlQ29zdDogMCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RCID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IG5hbWU6ICdNdWx0aS1EZWwgUHJvZCBCJywgc2t1OiAnTURFTDAwQicsIHByaWNlOiAyMDAsIHdlaWdodGVkQXZlcmFnZUNvc3Q6IDAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5QSA9IDU7XG4gICAgICAgICAgICBjb25zdCBwcmljZUEgPSA1MDtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5QiA9IDM7XG4gICAgICAgICAgICBjb25zdCBwcmljZUIgPSAxMjA7XG5cbiAgICAgICAgICAgIGNvbnN0IG11bHRpSXRlbUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvZHVjdElkOiBwcm9kdWN0QS5pZC50b1N0cmluZygpLCBxdWFudGl0eTogcXVhbnRpdHlBLCBwcmljZTogcHJpY2VBIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvZHVjdElkOiBwcm9kdWN0Qi5pZC50b1N0cmluZygpLCBxdWFudGl0eTogcXVhbnRpdHlCLCBwcmljZTogcHJpY2VCIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBxdWFudGl0eUEgfSwgLy8gSXRlbSBBIHRvIG1haW4gc2hvcFxuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcXVhbnRpdHlCIH0gIC8vIEl0ZW0gQiB0byBtYWluIHNob3BcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiAocXVhbnRpdHlBICogcHJpY2VBKSArIChxdWFudGl0eUIgKiBwcmljZUIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobXVsdGlJdGVtSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZVB1cmNoYXNlSW52b2ljZShjcmVhdGVSZXEpO1xuICAgICAgICAgICAgZXhwZWN0KGNyZWF0ZVJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlQm9keSA9IGF3YWl0IGNyZWF0ZVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpSXRlbUludm9pY2VJZCA9IGNyZWF0ZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrIGludmVudG9yeSBhbmQgV0FDIGFmdGVyIGNyZWF0aW9uXG4gICAgICAgICAgICBjb25zdCBpbnZBX2FmdGVyQ3JlYXRlID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHsgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0QS5pZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52QV9hZnRlckNyZWF0ZT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlBKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZBX2FmdGVyQ3JlYXRlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHByaWNlQSk7XG4gICAgICAgICAgICBjb25zdCBwcm9kQV9hZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEEuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChwcm9kQV9hZnRlckNyZWF0ZT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwcmljZUEpO1xuXG4gICAgICAgICAgICBjb25zdCBpbnZCX2FmdGVyQ3JlYXRlID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHsgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Qi5pZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52Ql9hZnRlckNyZWF0ZT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlCKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZCX2FmdGVyQ3JlYXRlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHByaWNlQik7XG4gICAgICAgICAgICBjb25zdCBwcm9kQl9hZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEIuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChwcm9kQl9hZnRlckNyZWF0ZT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwcmljZUIpO1xuXG4gICAgICAgICAgICAvLyAyLiBDYWxsIERFTEVURSBlbmRwb2ludFxuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHttdWx0aUl0ZW1JbnZvaWNlSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3BvbnNlID0gYXdhaXQgZGVsZXRlUHVyY2hhc2VJbnZvaWNlKGRlbGV0ZVJlcSwgeyBwYXJhbXM6IHsgaWQ6IG11bHRpSXRlbUludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuXG4gICAgICAgICAgICAvLyAzLiBWZXJpZnkgaW52b2ljZSBhbmQgaXRlbXMgYXJlIGRlbGV0ZWRcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBtdWx0aUl0ZW1JbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2UpLnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2VJdGVtcyA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmZpbmRNYW55KHsgd2hlcmU6IHsgcHVyY2hhc2VJbnZvaWNlSWQ6IG11bHRpSXRlbUludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZUl0ZW1zLmxlbmd0aCkudG9CZSgwKTtcblxuICAgICAgICAgICAgLy8gNC4gVmVyaWZ5IHN0b2NrIGFuZCBXQUMgZm9yIFByb2R1Y3QgQSBhcmUgcmV2ZXJzZWRcbiAgICAgICAgICAgIGNvbnN0IGludkFfYWZ0ZXJEZWxldGUgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3QoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RBLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZBX2FmdGVyRGVsZXRlPy5xdWFudGl0eSkudG9CZSgwKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZBX2FmdGVyRGVsZXRlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbygwKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2RBX2FmdGVyRGVsZXRlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0QS5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHByb2RBX2FmdGVyRGVsZXRlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbygwKTtcblxuICAgICAgICAgICAgLy8gNS4gVmVyaWZ5IHN0b2NrIGFuZCBXQUMgZm9yIFByb2R1Y3QgQiBhcmUgcmV2ZXJzZWRcbiAgICAgICAgICAgIGNvbnN0IGludkJfYWZ0ZXJEZWxldGUgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3QoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RCLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZCX2FmdGVyRGVsZXRlPy5xdWFudGl0eSkudG9CZSgwKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZCX2FmdGVyRGVsZXRlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbygwKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2RCX2FmdGVyRGVsZXRlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Qi5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHByb2RCX2FmdGVyRGVsZXRlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbygwKTtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgcHJvZHVjdHMgYW5kIHRoZWlyIGludmVudG9yeSBpdGVtcyBjcmVhdGVkIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmRlbGV0ZU1hbnkoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IHsgaW46IFtwcm9kdWN0QS5pZCwgcHJvZHVjdEIuaWRdIH0gfSB9KTtcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5wcm9kdWN0LmRlbGV0ZU1hbnkoeyB3aGVyZTogeyBpZDogeyBpbjogW3Byb2R1Y3RBLmlkLCBwcm9kdWN0Qi5pZF0gfSB9IH0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIFRpbWVvdXQgZm9yIHNhZmV0eVxuICAgIH0pO1xuXG59KTsiXSwibmFtZXMiOlsiY3JlYXRlTW9ja05leHRSZXF1ZXN0IiwidXJsIiwib3B0aW9ucyIsIm1ldGhvZCIsImJvZHkiLCJoZWFkZXJzIiwiSGVhZGVycyIsImpzb24iLCJKU09OIiwicGFyc2UiLCJ0ZXh0Iiwic3RyaW5naWZ5IiwicHJpc21hIiwiUHJpc21hQ2xpZW50IiwiZGVzY3JpYmUiLCJjcmVhdGVkU2hvcElkIiwiY3JlYXRlZFN1cHBsaWVySWQiLCJjcmVhdGVkUHJvZHVjdElkIiwiYmVmb3JlQWxsIiwiYmVmb3JlRWFjaCIsInB1cmNoYXNlSW52b2ljZUl0ZW0iLCJkZWxldGVNYW55IiwicHVyY2hhc2VJbnZvaWNlIiwiaW52ZW50b3J5SXRlbSIsInByb2R1Y3QiLCJzdXBwbGllciIsInNob3AiLCJjcmVhdGUiLCJkYXRhIiwibmFtZSIsImxvY2F0aW9uIiwiaWQiLCJwcmljZSIsInNrdSIsInNob3BJZCIsImFmdGVyQWxsIiwiJGRpc2Nvbm5lY3QiLCJpdCIsIm5ld1Byb2R1Y3ROYW1lIiwibmV3UHJvZHVjdFNrdSIsInB1cmNoYXNlUHJpY2UiLCJwdXJjaGFzZVF1YW50aXR5IiwibmV3VGVzdFByb2R1Y3QiLCJuZXdUZXN0UHJvZHVjdElkIiwicHVyY2hhc2VJbnZvaWNlUGF5bG9hZCIsInN1cHBsaWVySWQiLCJ0b1N0cmluZyIsImRhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJpdGVtcyIsInByb2R1Y3RJZCIsInF1YW50aXR5IiwiZGlzdHJpYnV0aW9ucyIsInRvdGFsQW1vdW50Iiwic3RhdHVzIiwicmVxIiwicmVzcG9uc2UiLCJjcmVhdGVQdXJjaGFzZUludm9pY2UiLCJyZXNwb25zZUJvZHkiLCJleHBlY3QiLCJ0b0JlIiwidG9IYXZlUHJvcGVydHkiLCJjcmVhdGVkSW52b2ljZUlkIiwiZGJJbnZvaWNlIiwiZmluZFVuaXF1ZSIsIndoZXJlIiwiaW5jbHVkZSIsIm5vdCIsInRvQmVOdWxsIiwibGVuZ3RoIiwiZGJJbnZlbnRvcnlJdGVtIiwiZmluZEZpcnN0Iiwic2hvcFNwZWNpZmljQ29zdCIsImRiUHJvZHVjdCIsIndlaWdodGVkQXZlcmFnZUNvc3QiLCJpbml0aWFsUHVyY2hhc2VQcmljZSIsImluaXRpYWxQdXJjaGFzZVF1YW50aXR5IiwiZXhpc3RpbmdQcm9kdWN0SWQiLCJpbml0aWFsUGF5bG9hZCIsIm5vdyIsImluaXRpYWxSZXEiLCJOZXh0UmVxdWVzdCIsInByb2R1Y3RCZWZvcmVOZXdQdXJjaGFzZSIsImludmVudG9yeUJlZm9yZU5ld1B1cmNoYXNlIiwibmV3UHVyY2hhc2VQcmljZSIsIm5ld1B1cmNoYXNlUXVhbnRpdHkiLCJleHBlY3RlZFRvdGFsUXVhbnRpdHkiLCJleHBlY3RlZFNob3BTcGVjaWZpY0Nvc3QiLCJ0b0JlQ2xvc2VUbyIsImV4cGVjdGVkUHJvZHVjdFdBQyIsInByb2R1Y3QxRGF0YSIsInByb2R1Y3QyRGF0YSIsInByb2R1Y3QxIiwicHJvZHVjdDIiLCJwdXJjaGFzZVByaWNlMSIsInB1cmNoYXNlUXVhbnRpdHkxIiwicHVyY2hhc2VQcmljZTIiLCJwdXJjaGFzZVF1YW50aXR5MiIsIm9yZGVyQnkiLCJzb3J0ZWRQcm9kdWN0cyIsInNvcnQiLCJhIiwiYiIsImRiSW52ZW50b3J5SXRlbTEiLCJkYlByb2R1Y3QxIiwiZGJJbnZlbnRvcnlJdGVtMiIsImRiUHJvZHVjdDIiLCJzaG9wQSIsInNob3BCIiwidG90YWxRdWFudGl0eSIsInF1YW50aXR5Rm9yU2hvcEEiLCJxdWFudGl0eUZvclNob3BCIiwiaW52SXRlbUEiLCJpbnZJdGVtQiIsIm5vbkV4aXN0ZW50UHJvZHVjdElkIiwiZXJyb3IiLCJ0b0JlRGVmaW5lZCIsIm5vbkV4aXN0ZW50U3VwcGxpZXJJZCIsImV4aXN0aW5nSW52b2ljZUlkIiwicHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQiLCJpbml0aWFsSW52b2ljZVBheWxvYWQiLCJpbml0aWFsUHJvZHVjdCIsImluaXRpYWxJbnZlbnRvcnkiLCJxdWFudGl0eUluY3JlYXNlIiwibmV3UXVhbnRpdHkiLCJ1cGRhdGVkUHJpY2VGb3JJdGVtIiwidXBkYXRlUGF5bG9hZCIsInVwZGF0ZVB1cmNoYXNlSW52b2ljZSIsInBhcmFtcyIsInVwZGF0ZWRJbnZlbnRvcnkiLCJ1cGRhdGVkUHJvZHVjdCIsInRvdGFsIiwicXVhbnRpdHlEZWNyZWFzZSIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiLCJuZXdQcmljZUZvckl0ZW0iLCJxdWFudGl0eVVuY2hhbmdlZCIsIm5ld0l0ZW1Qcm9kdWN0IiwibmV3SXRlbVByb2R1Y3RJZCIsIm5ld0l0ZW1RdWFudGl0eSIsIm5ld0l0ZW1QcmljZSIsIm9yaWdpbmFsSXRlbVByb2R1Y3RJZCIsIm9yaWdpbmFsSXRlbVF1YW50aXR5Iiwib3JpZ2luYWxJdGVtUHJpY2UiLCJleHBlY3RlZFRvdGFsIiwiZGJPcmlnaW5hbEl0ZW0iLCJmaW5kIiwiaXRlbSIsImRiTmV3SXRlbSIsIm9yaWdpbmFsSW52ZW50b3J5Iiwib3JpZ2luYWxQcm9kdWN0IiwibmV3SW52ZW50b3J5IiwibmV3UHJvZHVjdERiIiwicHJvZHVjdFRvUmVtb3ZlIiwicHJvZHVjdFRvUmVtb3ZlSWQiLCJwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSIsInByb2R1Y3RUb1JlbW92ZVByaWNlIiwiYWRkU2Vjb25kSXRlbVBheWxvYWQiLCJhZGRSZXEiLCJpbnZvaWNlV2l0aFR3b0l0ZW1zIiwidXBkYXRlUGF5bG9hZFRvUmVtb3ZlSXRlbSIsInJlbW92ZVJlcSIsImtlcHRJbnZlbnRvcnkiLCJrZXB0UHJvZHVjdCIsInJlbW92ZWRJbnZlbnRvcnkiLCJyZW1vdmVkUHJvZHVjdERiIiwib3RoZXJQdXJjaGFzZXNPZlJlbW92ZWRJdGVtIiwiY291bnQiLCJpbnZvaWNlVG9EZWxldGVJZCIsInByb2R1Y3RGb3JEZWxldGVUZXN0SWQiLCJkZWxldGVUZXN0SW5pdGlhbFByaWNlIiwiZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSIsImluaXRpYWxQcm9kdWN0REIiLCJkZWxldGVSZXEiLCJkZWxldGVSZXNwb25zZSIsImRlbGV0ZVB1cmNoYXNlSW52b2ljZSIsImRlbGV0ZVJlc3BvbnNlQm9keSIsIm1lc3NhZ2UiLCJkYkludm9pY2VJdGVtcyIsImZpbmRNYW55IiwicHVyY2hhc2VJbnZvaWNlSWQiLCJvdGhlclB1cmNoYXNlc09mUHJvZHVjdCIsInRlc3RTaG9wIiwidGVzdFN1cHBsaWVyIiwidGVzdFByb2R1Y3QiLCJpbmZlcnJlZFNob3BJbnZvaWNlUGF5bG9hZCIsImNyZWF0ZVJlcSIsImNyZWF0ZVJlc3BvbnNlIiwiY3JlYXRlQm9keSIsImludm9pY2VJZEZvckluZmVycmVkRGVsZXRlIiwiaW52ZW50b3J5QWZ0ZXJDcmVhdGUiLCJwcm9kdWN0QWZ0ZXJDcmVhdGUiLCJ1cGRhdGVkUHJvZHVjdERCIiwiZGVsZXRlIiwicHJvZHVjdEEiLCJwcm9kdWN0QiIsInF1YW50aXR5QSIsInByaWNlQSIsInF1YW50aXR5QiIsInByaWNlQiIsIm11bHRpSXRlbUludm9pY2VQYXlsb2FkIiwibXVsdGlJdGVtSW52b2ljZUlkIiwiaW52QV9hZnRlckNyZWF0ZSIsInByb2RBX2FmdGVyQ3JlYXRlIiwiaW52Ql9hZnRlckNyZWF0ZSIsInByb2RCX2FmdGVyQ3JlYXRlIiwiaW52QV9hZnRlckRlbGV0ZSIsInByb2RBX2FmdGVyRGVsZXRlIiwiaW52Ql9hZnRlckRlbGV0ZSIsInByb2RCX2FmdGVyRGVsZXRlIiwiaW4iXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDOzs7O3dCQUM0Qjt1QkFDaUI7d0JBQ0Q7QUFXN0MsNkNBQTZDO0FBQzdDLE1BQU1BLHdCQUF3QixDQUFDQyxLQUFhQyxVQUl4QyxDQUFDLENBQUM7SUFDSixNQUFNLEVBQUVDLFNBQVMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsR0FBR0g7SUFDL0MsT0FBTztRQUNMQztRQUNBRjtRQUNBSSxTQUFTLElBQUlDLFFBQVFEO1FB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