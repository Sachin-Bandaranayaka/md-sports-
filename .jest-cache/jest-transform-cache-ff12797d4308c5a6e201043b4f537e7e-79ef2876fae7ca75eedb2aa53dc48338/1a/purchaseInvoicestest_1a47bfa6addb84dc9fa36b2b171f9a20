1861ac59949d584d75b203e57af11f98
/**
 * @jest-environment node
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _client = require("@prisma/client");
const _route = require("../../src/app/api/purchases/route");
const _route1 = require("../../src/app/api/purchases/[id]/route");
// Helper function to create mock NextRequest
const createMockNextRequest = (url, options = {})=>{
    const { method = "GET", body, headers = {} } = options;
    return {
        method,
        url,
        headers: new Headers(headers),
        json: async ()=>body ? typeof body === "string" ? JSON.parse(body) : body : {},
        text: async ()=>body ? typeof body === "string" ? body : JSON.stringify(body) : ""
    };
};
const prisma = new _client.PrismaClient();
describe("Purchase Invoice API Integration Tests", ()=>{
    let createdShopId;
    let createdSupplierId;
    let createdProductId;
    beforeAll(async ()=>{
    // Seed initial data if necessary, e.g., a default supplier or shop
    // For now, we'll create them in beforeEach or specific tests
    });
    beforeEach(async ()=>{
        // Clean up database tables to ensure test isolation
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        // Create a shop for testing
        const shop = await prisma.shop.create({
            data: {
                name: "Test Shop Local",
                location: "Test Location"
            }
        });
        createdShopId = shop.id;
        // Create a supplier for testing
        const supplier = await prisma.supplier.create({
            data: {
                name: "Test Supplier Local"
            }
        });
        createdSupplierId = supplier.id;
        // Create a product for testing updates/deletes (not for create new product test)
        const product = await prisma.product.create({
            data: {
                name: "Existing Product",
                price: 100,
                sku: "EXISTING001",
                shopId: createdShopId
            }
        });
        createdProductId = product.id;
    });
    afterAll(async ()=>{
        // Clean up database after all tests
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        await prisma.$disconnect();
    });
    describe("POST /api/purchases (Create Purchase Invoice)", ()=>{
        it("should create a purchase invoice for a new product, update inventory, and set WAC", async ()=>{
            // 1. Define data for a new product
            const newProductName = "Brand New Racket";
            const newProductSku = "NEWB001";
            const purchasePrice = 150;
            const purchaseQuantity = 10;
            // Create product first (as API expects productId)
            // In a real scenario, the UI might create product then purchase, or purchase API handles product creation
            // For this test, assume product is created just before, or API implies its creation from purchase (not current API)
            // Let's assume for now product must exist, if API doesn't create it from purchase items.
            // The current API's POST /api/purchases expects item.productId, implying product exists.
            const newTestProduct = await prisma.product.create({
                data: {
                    name: newProductName,
                    sku: newProductSku,
                    price: 250,
                    shopId: createdShopId // Optional default shop association
                }
            });
            const newTestProductId = newTestProduct.id;
            // 2. Prepare the request body for POST /api/purchases
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // 3. Construct a NextRequest instance
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: purchaseInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate the API call
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201); // Or 200 depending on your API's success response for POST
            expect(responseBody.data).toHaveProperty("id");
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice).not.toBeNull();
            expect(dbInvoice?.supplierId).toBe(createdSupplierId);
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(newTestProductId);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice);
            // Verify InventoryItem in DB
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newTestProductId,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem).not.toBeNull();
            expect(dbInventoryItem?.quantity).toBe(purchaseQuantity);
            // The POST route seems to calculate shopSpecificCost too.
            // WAC = (Current Total Value + New Purchase Value) / (Current Quantity + New Quantity)
            // For new item, existing shopSpecificCost is 0, currentQuantity is 0.
            // So newShopSpecificCost should be newCost (purchasePrice)
            expect(dbInventoryItem?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC in DB
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: newTestProductId
                }
            });
            expect(dbProduct).not.toBeNull();
            // For a new product, WAC should be equal to the purchase price of this first batch
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should create a purchase for an existing product, update inventory, and recalculate WACs", async ()=>{
            // 0. Initial state: Product exists, potentially with some inventory and WAC
            const initialPurchasePrice = 120;
            const initialPurchaseQuantity = 5;
            const existingProductId = createdProductId; // From beforeEach
            // Create an initial purchase to set up existing inventory and WAC
            const initialPayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const initialReq = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(initialPayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route.POST)(initialReq);
            const productBeforeNewPurchase = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            const inventoryBeforeNewPurchase = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            expect(productBeforeNewPurchase?.weightedAverageCost).toBe(initialPurchasePrice);
            expect(inventoryBeforeNewPurchase?.quantity).toBe(initialPurchaseQuantity);
            expect(inventoryBeforeNewPurchase?.shopSpecificCost).toBe(initialPurchasePrice);
            // 1. Define data for the new purchase of the existing product
            const newPurchasePrice = 100;
            const newPurchaseQuantity = 8;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: newPurchaseQuantity,
                        price: newPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newPurchaseQuantity
                    }
                ],
                totalAmount: newPurchaseQuantity * newPurchasePrice,
                status: "paid"
            };
            // 3. Simulate API call
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify InventoryItem
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            const expectedTotalQuantity = initialPurchaseQuantity + newPurchaseQuantity;
            expect(dbInventoryItem?.quantity).toBe(expectedTotalQuantity);
            // Verify shopSpecificCost recalculation
            // SSC = ((oldQty * oldSSC) + (newQty * newPrice)) / (oldQty + newQty)
            const expectedShopSpecificCost = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            expect(dbInventoryItem?.shopSpecificCost).toBeCloseTo(expectedShopSpecificCost);
            // Verify Product WAC recalculation
            // WAC = ((oldTotalQty * oldWAC) + (newPurchaseQty * newPurchasePrice)) / (newTotalQty + newPurchaseQty)
            // In this case, product WAC was initialPurchasePrice for initialPurchaseQuantity.
            const expectedProductWAC = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            expect(dbProduct?.weightedAverageCost).toBeCloseTo(expectedProductWAC);
        }, 15000); // Increased timeout
        it("should create a purchase with multiple items and update inventory/WAC for each", async ()=>{
            // 1. Create two distinct products for this test
            const product1Data = {
                name: "MultiItem Product A",
                sku: "MULTI001",
                price: 50,
                shopId: createdShopId
            };
            const product2Data = {
                name: "MultiItem Product B",
                sku: "MULTI002",
                price: 75,
                shopId: createdShopId
            };
            const product1 = await prisma.product.create({
                data: product1Data
            });
            const product2 = await prisma.product.create({
                data: product2Data
            });
            const purchasePrice1 = 40;
            const purchaseQuantity1 = 5;
            const purchasePrice2 = 60;
            const purchaseQuantity2 = 3;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product1.id.toString(),
                        quantity: purchaseQuantity1,
                        price: purchasePrice1
                    },
                    {
                        productId: product2.id.toString(),
                        quantity: purchaseQuantity2,
                        price: purchasePrice2
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity1
                    },
                    {
                        [createdShopId]: purchaseQuantity2
                    } // Distribution for item 2
                ],
                totalAmount: purchaseQuantity1 * purchasePrice1 + purchaseQuantity2 * purchasePrice2,
                status: "pending"
            };
            // 3. Simulate API call
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice and its items
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                } // Order to ensure consistent assertion
            });
            expect(dbInvoice?.items.length).toBe(2);
            // Assuming product1.id < product2.id due to creation order for consistent checks
            const sortedProducts = [
                product1,
                product2
            ].sort((a, b)=>a.id - b.id);
            expect(dbInvoice?.items[0].productId).toBe(sortedProducts[0].id);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity1);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice1);
            expect(dbInvoice?.items[1].productId).toBe(sortedProducts[1].id);
            expect(dbInvoice?.items[1].quantity).toBe(purchaseQuantity2);
            expect(dbInvoice?.items[1].price).toBe(purchasePrice2);
            // Verify InventoryItem and Product WAC for Product 1
            const dbInventoryItem1 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product1.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem1?.quantity).toBe(purchaseQuantity1);
            expect(dbInventoryItem1?.shopSpecificCost).toBe(purchasePrice1);
            const dbProduct1 = await prisma.product.findUnique({
                where: {
                    id: product1.id
                }
            });
            expect(dbProduct1?.weightedAverageCost).toBe(purchasePrice1);
            // Verify InventoryItem and Product WAC for Product 2
            const dbInventoryItem2 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product2.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem2?.quantity).toBe(purchaseQuantity2);
            expect(dbInventoryItem2?.shopSpecificCost).toBe(purchasePrice2);
            const dbProduct2 = await prisma.product.findUnique({
                where: {
                    id: product2.id
                }
            });
            expect(dbProduct2?.weightedAverageCost).toBe(purchasePrice2);
        }, 15000); // Increased timeout
        it("should distribute a single purchase item to multiple shops", async ()=>{
            // 1. Create two new shops for this test
            const shopA = await prisma.shop.create({
                data: {
                    name: "Test Shop A",
                    location: "Loc A"
                }
            });
            const shopB = await prisma.shop.create({
                data: {
                    name: "Test Shop B",
                    location: "Loc B"
                }
            });
            // 2. Create a new product
            const product = await prisma.product.create({
                data: {
                    name: "Split Product",
                    sku: "SPLIT001",
                    price: 200
                }
            });
            const purchasePrice = 180;
            const totalQuantity = 10;
            const quantityForShopA = 6;
            const quantityForShopB = 4;
            expect(quantityForShopA + quantityForShopB).toBe(totalQuantity); // Sanity check
            // 3. Prepare request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product.id.toString(),
                        quantity: totalQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [shopA.id]: quantityForShopA,
                        [shopB.id]: quantityForShopB
                    }
                ],
                totalAmount: totalQuantity * purchasePrice,
                status: "paid"
            };
            // 4. Simulate API call
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 5. Assertions
            expect(response.status).toBe(201);
            // Verify InventoryItem for Shop A
            const invItemA = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopA.id
                }
            });
            expect(invItemA).not.toBeNull();
            expect(invItemA?.quantity).toBe(quantityForShopA);
            expect(invItemA?.shopSpecificCost).toBe(purchasePrice);
            // Verify InventoryItem for Shop B
            const invItemB = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopB.id
                }
            });
            expect(invItemB).not.toBeNull();
            expect(invItemB?.quantity).toBe(quantityForShopB);
            expect(invItemB?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC (should be the purchase price as it's all new stock)
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: product.id
                }
            });
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a productId does not exist", async ()=>{
            const nonExistentProductId = 999999; // Assuming this ID won't exist
            const purchasePrice = 100;
            const purchaseQuantity = 5;
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: nonExistentProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            // Expect a client error (e.g., 400 or 404) or potentially 500 if not handled gracefully
            // For robust error handling, API should return specific error code.
            // Prisma will throw an error if a related record (product) is not found for foreign key.
            // This will likely result in a 500 if not caught and handled by the API route.
            // Let's aim for the API to catch this and return a more specific client error.
            // For now, we'll check if it's NOT a success (201).
            // A more precise check would be for 400/404/422 depending on planned error handling.
            expect(response.status).toBe(500); // Or 400/404 if you implement specific error handling
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        // Optionally, check for a specific error message or code if your API provides one.
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a supplierId does not exist", async ()=>{
            const newTestProduct = await prisma.product.create({
                data: {
                    name: "Product For Invalid Supplier Test",
                    sku: "INV SUP001",
                    price: 100
                }
            });
            const purchasePrice = 80;
            const purchaseQuantity = 5;
            const nonExistentSupplierId = 999999; // Assuming this ID won't exist
            const purchaseInvoicePayload = {
                supplierId: nonExistentSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            expect(response.status).toBe(500); // Expecting 500 as Prisma throws P2003
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        });
    });
    describe("PUT /api/purchases/:id (Update Purchase Invoice)", ()=>{
        let existingInvoiceId;
        let productForUpdateTestsId;
        const initialPurchasePrice = 50;
        const initialPurchaseQuantity = 10;
        beforeEach(async ()=>{
            // Create a product specifically for these update/delete tests if not already created
            // The global createdProductId can be used if it fits, or make a new one.
            // Let's use the global one for simplicity, assuming beforeEach cleans it up.
            productForUpdateTestsId = createdProductId;
            // Create an initial purchase invoice to be updated or deleted in tests
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: initialInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            existingInvoiceId = body.data.id;
            // Sanity check: verify initial state
            const initialProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(initialProduct?.weightedAverageCost).toBe(initialPurchasePrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(initialPurchasePrice);
        });
        it("should update item quantity (increase), recalculate stock and WACs", async ()=>{
            const quantityIncrease = 5;
            const newQuantity = initialPurchaseQuantity + quantityIncrease;
            // Price remains the same for this item in this update scenario
            const updatedPriceForItem = initialPurchasePrice;
            const updatePayload = {
                // We need to send the complete structure expected by the PUT route
                // This includes all items, even if only one is changing.
                // The PUT route logic might compare with existing items to see what changed.
                items: [
                    {
                        // If the item had an ID (PurchaseInvoiceItem id), it might be needed.
                        // Let's assume for now the PUT matches items based on productId if not item ID.
                        // Based on current PUT route, it expects productId.
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    // The distributions in PUT might need to reflect the *new total* for the item
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate API call - updatePurchaseInvoice(req, { params: { id: existingInvoiceId } })
            // This is how you call it if you are testing the handler directly in Jest with context
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // WAC calculation: ((oldQty * oldSSC) + (addedQty * priceOfAddedQty)) / (newTotalQty)
            // In this specific update, the PUT route reverses the old item and adds the new one as if it's a new purchase line for WAC calcs.
            // So, the old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // However, the current PUT logic first reverses *all* old items based on their *original* recorded cost.
            // Then it adds *all* new items based on their *new* cost.
            // So for the product WAC: (TotalValueBefore - OldItemValue + NewItemValue) / (TotalStockBefore - OldItemQty + NewItemQty)
            // And for shop specific WAC: (ShopValueBefore - OldItemValueInShop + NewItemValueInShop) / (ShopStockBefore - OldItemQtyInShop + NewItemQtyInShop)
            // Let's check the logic from src/app/api/purchases/[id]/route.ts
            // 1. It fetches the old invoice.
            // 2. It reverses inventory adjustments for ALL old items (decrease stock, WAC updated).
            // 3. It processes ALL new/updated items as if they are new purchases (increase stock, WAC updated).
            // So, after reversal of initialPurchaseQuantity at initialPurchasePrice:
            // Product WAC and ShopSpecificCost would be effectively 0 if this were the only product/stock.
            // Then, adding newQuantity at updatedPriceForItem:
            // The new WACs should become updatedPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB reflects the change
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item quantity (decrease), recalculate stock and WACs", async ()=>{
            const quantityDecrease = 3;
            const newQuantity = initialPurchaseQuantity - quantityDecrease;
            expect(newQuantity).toBeGreaterThanOrEqual(0); // Ensure we don't go negative for this test logic
            const updatedPriceForItem = initialPurchasePrice; // Price remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // Due to the reversal and re-addition logic of the PUT route:
            // The old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // So, new WACs should become updatedPriceForItem (which is initialPurchasePrice).
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item price, recalculate stock and WACs", async ()=>{
            const newPriceForItem = initialPurchasePrice + 25; // New price, e.g., 50 + 25 = 75
            const quantityUnchanged = initialPurchaseQuantity; // Quantity remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: quantityUnchanged,
                        price: newPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityUnchanged
                    }
                ]
            };
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock (should be unchanged) and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(quantityUnchanged);
            // WAC logic in PUT: reverses old, adds new. So shopSpecificCost should reflect newPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(newPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(newPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(quantityUnchanged);
            expect(dbInvoice?.items[0].price).toBe(newPriceForItem);
            expect(dbInvoice?.total).toBe(quantityUnchanged * newPriceForItem);
        }, 15000); // Increased timeout
        it("should add a new item to an existing invoice, update stock and WACs", async ()=>{
            // 1. Define a new product for the new item
            const newItemProduct = await prisma.product.create({
                data: {
                    name: "Newly Added Product for PUT",
                    sku: "PUTNEW001",
                    price: 200
                }
            });
            const newItemProductId = newItemProduct.id;
            const newItemQuantity = 7;
            const newItemPrice = 120;
            // Original item details (from beforeEach setup)
            const originalItemProductId = productForUpdateTestsId;
            const originalItemQuantity = initialPurchaseQuantity;
            const originalItemPrice = initialPurchasePrice;
            // 2. Prepare the update payload with both original and new item
            const updatePayload = {
                items: [
                    {
                        productId: originalItemProductId.toString(),
                        quantity: originalItemQuantity,
                        price: originalItemPrice
                    },
                    {
                        productId: newItemProductId.toString(),
                        quantity: newItemQuantity,
                        price: newItemPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: originalItemQuantity
                    },
                    {
                        [createdShopId]: newItemQuantity
                    } // Distribution for new item
                ]
            };
            // 3. Simulate API call
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                }
            });
            expect(dbInvoice?.items.length).toBe(2);
            const expectedTotal = originalItemQuantity * originalItemPrice + newItemQuantity * newItemPrice;
            expect(dbInvoice?.total).toBe(expectedTotal);
            // Find the items in the response (order might vary, so find by productId)
            const dbOriginalItem = dbInvoice?.items.find((item)=>item.productId === originalItemProductId);
            const dbNewItem = dbInvoice?.items.find((item)=>item.productId === newItemProductId);
            expect(dbOriginalItem).toBeDefined();
            expect(dbOriginalItem?.quantity).toBe(originalItemQuantity);
            expect(dbOriginalItem?.price).toBe(originalItemPrice);
            expect(dbNewItem).toBeDefined();
            expect(dbNewItem?.quantity).toBe(newItemQuantity);
            expect(dbNewItem?.price).toBe(newItemPrice);
            // Verify InventoryItem and Product WAC for the original item
            // (Due to PUT logic of reverse & re-add, WACs should reflect its current price)
            const originalInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: originalItemProductId,
                    shopId: createdShopId
                }
            });
            expect(originalInventory?.quantity).toBe(originalItemQuantity);
            expect(originalInventory?.shopSpecificCost).toBeCloseTo(originalItemPrice);
            const originalProduct = await prisma.product.findUnique({
                where: {
                    id: originalItemProductId
                }
            });
            expect(originalProduct?.weightedAverageCost).toBeCloseTo(originalItemPrice);
            // Verify InventoryItem and Product WAC for the NEW item
            const newInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newItemProductId,
                    shopId: createdShopId
                }
            });
            expect(newInventory?.quantity).toBe(newItemQuantity);
            expect(newInventory?.shopSpecificCost).toBeCloseTo(newItemPrice);
            const newProductDb = await prisma.product.findUnique({
                where: {
                    id: newItemProductId
                }
            });
            expect(newProductDb?.weightedAverageCost).toBeCloseTo(newItemPrice);
        }, 15000); // Increased timeout
        it("should remove an item from an existing invoice, update stock and WACs", async ()=>{
            // 1. Setup: Ensure an invoice with at least two items exists.
            // We'll use the existing `productForUpdateTestsId` and create one more product and item.
            const productToRemove = await prisma.product.create({
                data: {
                    name: "Product To Be Removed",
                    sku: "PUTRMV001",
                    price: 300
                }
            });
            const productToRemoveId = productToRemove.id;
            const productToRemoveQuantity = 4;
            const productToRemovePrice = 40;
            // Update the existing invoice (created in global beforeEach for PUT) to include this second item first.
            const addSecondItemPayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    },
                    {
                        productId: productToRemoveId.toString(),
                        quantity: productToRemoveQuantity,
                        price: productToRemovePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    },
                    {
                        [createdShopId]: productToRemoveQuantity
                    }
                ]
            };
            const addReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(addSecondItemPayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route1.PUT)(addReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            // Sanity check: Invoice should have 2 items
            let invoiceWithTwoItems = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(invoiceWithTwoItems?.items.length).toBe(2);
            // 2. Prepare the update payload that only contains the item we want to keep.
            const updatePayloadToRemoveItem = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    } // Distribution for the kept item
                ]
            };
            // 3. Simulate API call to remove the item
            const removeReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayloadToRemoveItem),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(removeReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB - should now have only 1 item
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(productForUpdateTestsId);
            expect(dbInvoice?.items[0].quantity).toBe(initialPurchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(initialPurchasePrice);
            expect(dbInvoice?.total).toBe(initialPurchaseQuantity * initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the KEPT item
            const keptInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(keptInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(keptInventory?.shopSpecificCost).toBeCloseTo(initialPurchasePrice);
            const keptProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(keptProduct?.weightedAverageCost).toBeCloseTo(initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the REMOVED item
            // Stock should be zero or the item might be gone from inventory if it was the only purchase
            // WAC on product should be 0 if no other purchases exist.
            const removedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productToRemoveId,
                    shopId: createdShopId
                }
            });
            // The PUT logic reverses stock. If this was the only stock, it becomes 0.
            expect(removedInventory?.quantity).toBe(0);
            // ShopSpecificCost might become 0 or NaN if quantity is 0. The API sets it to 0 for safety.
            expect(removedInventory?.shopSpecificCost).toBeCloseTo(0);
            const removedProductDb = await prisma.product.findUnique({
                where: {
                    id: productToRemoveId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfRemovedItem = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productToRemoveId
                }
            });
            if (otherPurchasesOfRemovedItem === 0) {
                expect(removedProductDb?.weightedAverageCost).toBeCloseTo(0);
            } // Else, it would be based on other purchases, which this test doesn't set up.
        }, 15000); // Increased timeout
    });
    describe("DELETE /api/purchases/:id (Delete Purchase Invoice)", ()=>{
        let invoiceToDeleteId;
        let productForDeleteTestId;
        const deleteTestInitialPrice = 60;
        const deleteTestInitialQuantity = 12;
        beforeEach(async ()=>{
            // Ensure product exists for the test
            const product = await prisma.product.create({
                data: {
                    name: "Product For Delete Test",
                    sku: "DELPROD001",
                    price: 100
                }
            });
            productForDeleteTestId = product.id;
            // Create an initial purchase invoice to be deleted
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productForDeleteTestId.toString(),
                        quantity: deleteTestInitialQuantity,
                        price: deleteTestInitialPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: deleteTestInitialQuantity
                    } // Explicit distribution
                ],
                totalAmount: deleteTestInitialQuantity * deleteTestInitialPrice,
                status: "paid"
            };
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: initialInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            invoiceToDeleteId = body.data.id;
            // Sanity check: verify initial state after creation
            const initialProductDB = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            expect(initialProductDB?.weightedAverageCost).toBe(deleteTestInitialPrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(deleteTestInitialQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(deleteTestInitialPrice);
        });
        it("should delete a purchase invoice and correctly reverse stock and WACs for a single-item invoice with explicit distribution", async ()=>{
            // 1. Call the DELETE endpoint
            const deleteReq = new NextRequest(`http://localhost/api/purchases/${invoiceToDeleteId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceToDeleteId
                }
            });
            // 2. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 3. Verify PurchaseInvoice is deleted from DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceToDeleteId
                }
            });
            expect(dbInvoice).toBeNull();
            // 4. Verify PurchaseInvoiceItems are deleted
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceToDeleteId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock is reversed
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            // Assuming this was the only purchase, stock should be 0
            expect(updatedInventory?.quantity).toBe(0);
            // ShopSpecificCost should also be 0 if stock is 0
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated (should be 0 if this was the only purchase)
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfProduct = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productForDeleteTestId
                }
            });
            if (otherPurchasesOfProduct === 0) {
                expect(updatedProduct?.weightedAverageCost).toBeCloseTo(0);
            }
        });
        it("should delete a purchase and reverse stock/WAC when product is in a single inferred shop", async ()=>{
            // 1. Setup: Create dedicated entities for this test to ensure isolation.
            const testShop = await prisma.shop.create({
                data: {
                    name: "Inferred Delete Test Shop",
                    location: "Loc X"
                }
            });
            const testSupplier = await prisma.supplier.create({
                data: {
                    name: "Inferred Delete Test Supplier"
                }
            });
            const testProduct = await prisma.product.create({
                data: {
                    name: "Product for Inferred Delete",
                    sku: "INFDEL001",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            // Create an inventory item for this product in the test shop.
            // This makes it the "single inferred shop".
            await prisma.inventoryItem.create({
                data: {
                    productId: testProduct.id,
                    shopId: testShop.id,
                    quantity: 0,
                    shopSpecificCost: 0
                }
            });
            const purchaseQuantity = 12;
            const purchasePrice = 60;
            const inferredShopInvoicePayload = {
                supplierId: testSupplier.id.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: testProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                // NO distributions property here for inference to kick in on POST
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // Create the purchase invoice (this is where the failure was happening)
            const createReq = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(inferredShopInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201); // Assert successful creation
            const createBody = await createResponse.json();
            const invoiceIdForInferredDelete = createBody.data.id;
            // Sanity check: Verify stock and WAC after creation
            const inventoryAfterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(inventoryAfterCreate?.quantity).toBe(purchaseQuantity);
            expect(inventoryAfterCreate?.shopSpecificCost).toBeCloseTo(purchasePrice);
            const productAfterCreate = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(productAfterCreate?.weightedAverageCost).toBeCloseTo(purchasePrice);
            // 2. Call the DELETE endpoint
            const deleteReq = new NextRequest(`http://localhost/api/purchases/${invoiceIdForInferredDelete}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceIdForInferredDelete
                }
            });
            // 3. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 4. Verify PurchaseInvoice and Items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock and shopSpecificCost are reversed in the inferred shop
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(updatedInventory?.quantity).toBe(0);
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated to 0
            const updatedProductDB = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(updatedProductDB?.weightedAverageCost).toBeCloseTo(0);
            // Cleanup dedicated entities for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: testProduct.id
                }
            });
            await prisma.product.delete({
                where: {
                    id: testProduct.id
                }
            });
            await prisma.supplier.delete({
                where: {
                    id: testSupplier.id
                }
            });
            await prisma.shop.delete({
                where: {
                    id: testShop.id
                }
            });
        }, 15000); // Added a longer timeout as a precaution
        it("should delete an invoice with multiple items, reversing stock/WAC for each", async ()=>{
            // 1. Setup: Create multiple products and an invoice with items from these products.
            // For simplicity, distribute each to the main createdShopId from global beforeEach.
            const productA = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod A",
                    sku: "MDEL00A",
                    price: 100,
                    weightedAverageCost: 0
                }
            });
            const productB = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod B",
                    sku: "MDEL00B",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            const quantityA = 5;
            const priceA = 50;
            const quantityB = 3;
            const priceB = 120;
            const multiItemInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productA.id.toString(),
                        quantity: quantityA,
                        price: priceA
                    },
                    {
                        productId: productB.id.toString(),
                        quantity: quantityB,
                        price: priceB
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityA
                    },
                    {
                        [createdShopId]: quantityB
                    } // Item B to main shop
                ],
                totalAmount: quantityA * priceA + quantityB * priceB,
                status: "paid"
            };
            const createReq = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: multiItemInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201);
            const createBody = await createResponse.json();
            const multiItemInvoiceId = createBody.data.id;
            // Sanity check inventory and WAC after creation
            const invA_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterCreate?.quantity).toBe(quantityA);
            expect(invA_afterCreate?.shopSpecificCost).toBe(priceA);
            const prodA_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterCreate?.weightedAverageCost).toBe(priceA);
            const invB_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterCreate?.quantity).toBe(quantityB);
            expect(invB_afterCreate?.shopSpecificCost).toBe(priceB);
            const prodB_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterCreate?.weightedAverageCost).toBe(priceB);
            // 2. Call DELETE endpoint
            const deleteReq = createMockNextRequest(`http://localhost/api/purchases/${multiItemInvoiceId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: multiItemInvoiceId
                }
            });
            expect(deleteResponse.status).toBe(200);
            // 3. Verify invoice and items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: multiItemInvoiceId
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: multiItemInvoiceId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 4. Verify stock and WAC for Product A are reversed
            const invA_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterDelete?.quantity).toBe(0);
            expect(invA_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodA_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // 5. Verify stock and WAC for Product B are reversed
            const invB_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterDelete?.quantity).toBe(0);
            expect(invB_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodB_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // Clean up products and their inventory items created for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
            await prisma.product.deleteMany({
                where: {
                    id: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
        }, 15000); // Timeout for safety
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvaW50ZWdyYXRpb24vcHVyY2hhc2VJbnZvaWNlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGplc3QtZW52aXJvbm1lbnQgbm9kZVxuICovXG5pbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tICdAcHJpc21hL2NsaWVudCc7XG5pbXBvcnQgeyBQT1NUIGFzIGNyZWF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvcm91dGUnOyAvLyBBZGp1c3QgaWYgZGlyZWN0IGltcG9ydCBpc24ndCBmZWFzaWJsZVxuaW1wb3J0IHsgUFVUIGFzIHVwZGF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuaW1wb3J0IHsgREVMRVRFIGFzIGRlbGV0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuLy8gTW9jayBOZXh0UmVxdWVzdCBpbnRlcmZhY2VcbmludGVyZmFjZSBOZXh0UmVxdWVzdCB7XG4gIG1ldGhvZDogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgaGVhZGVyczogSGVhZGVycztcbiAganNvbigpOiBQcm9taXNlPGFueT47XG4gIHRleHQoKTogUHJvbWlzZTxzdHJpbmc+O1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2sgTmV4dFJlcXVlc3RcbmNvbnN0IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCA9ICh1cmw6IHN0cmluZywgb3B0aW9uczoge1xuICBtZXRob2Q/OiBzdHJpbmc7XG4gIGJvZHk/OiBhbnk7XG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSA9IHt9KTogTmV4dFJlcXVlc3QgPT4ge1xuICBjb25zdCB7IG1ldGhvZCA9ICdHRVQnLCBib2R5LCBoZWFkZXJzID0ge30gfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIHVybCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICBqc29uOiBhc3luYyAoKSA9PiBib2R5ID8gKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoYm9keSkgOiBib2R5KSA6IHt9LFxuICAgIHRleHQ6IGFzeW5jICgpID0+IGJvZHkgPyAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnID8gYm9keSA6IEpTT04uc3RyaW5naWZ5KGJvZHkpKSA6ICcnLFxuICB9IGFzIE5leHRSZXF1ZXN0O1xufTtcblxuaW1wb3J0IHsgY3JlYXRlTW9ja3MgfSBmcm9tICdub2RlLW1vY2tzLWh0dHAnOyAvLyBPciBhbnkgb3RoZXIgd2F5IHRvIG1vY2sgTmV4dFJlcXVlc3QvUmVzcG9uc2VcblxuY29uc3QgcHJpc21hID0gbmV3IFByaXNtYUNsaWVudCgpO1xuXG5kZXNjcmliZSgnUHVyY2hhc2UgSW52b2ljZSBBUEkgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gICAgbGV0IGNyZWF0ZWRTaG9wSWQ6IHN0cmluZztcbiAgICBsZXQgY3JlYXRlZFN1cHBsaWVySWQ6IG51bWJlcjtcbiAgICBsZXQgY3JlYXRlZFByb2R1Y3RJZDogbnVtYmVyO1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gU2VlZCBpbml0aWFsIGRhdGEgaWYgbmVjZXNzYXJ5LCBlLmcuLCBhIGRlZmF1bHQgc3VwcGxpZXIgb3Igc2hvcFxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBjcmVhdGUgdGhlbSBpbiBiZWZvcmVFYWNoIG9yIHNwZWNpZmljIHRlc3RzXG4gICAgfSk7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgZGF0YWJhc2UgdGFibGVzIHRvIGVuc3VyZSB0ZXN0IGlzb2xhdGlvblxuICAgICAgICBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5wcm9kdWN0LmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5zaG9wLmRlbGV0ZU1hbnkoe30pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHNob3AgZm9yIHRlc3RpbmdcbiAgICAgICAgY29uc3Qgc2hvcCA9IGF3YWl0IHByaXNtYS5zaG9wLmNyZWF0ZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgU2hvcCBMb2NhbCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdUZXN0IExvY2F0aW9uJyxcbiAgICAgICAgICAgICAgICAvLyBBZGQgb3RoZXIgcmVxdWlyZWQgZmllbGRzIGlmIGFueVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNyZWF0ZWRTaG9wSWQgPSBzaG9wLmlkO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHN1cHBsaWVyIGZvciB0ZXN0aW5nXG4gICAgICAgIGNvbnN0IHN1cHBsaWVyID0gYXdhaXQgcHJpc21hLnN1cHBsaWVyLmNyZWF0ZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgU3VwcGxpZXIgTG9jYWwnLFxuICAgICAgICAgICAgICAgIC8vIEFkZCBvdGhlciByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjcmVhdGVkU3VwcGxpZXJJZCA9IHN1cHBsaWVyLmlkO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHByb2R1Y3QgZm9yIHRlc3RpbmcgdXBkYXRlcy9kZWxldGVzIChub3QgZm9yIGNyZWF0ZSBuZXcgcHJvZHVjdCB0ZXN0KVxuICAgICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXhpc3RpbmcgUHJvZHVjdCcsXG4gICAgICAgICAgICAgICAgcHJpY2U6IDEwMCwgLy8gcmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgc2t1OiAnRVhJU1RJTkcwMDEnLFxuICAgICAgICAgICAgICAgIHNob3BJZDogY3JlYXRlZFNob3BJZCwgLy8gT3B0aW9uYWw6IGFzc29jaWF0ZSB3aXRoIGEgc2hvcCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gd2VpZ2h0ZWRBdmVyYWdlQ29zdCB3aWxsIGJlIHNldCBieSBwdXJjaGFzZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNyZWF0ZWRQcm9kdWN0SWQgPSBwcm9kdWN0LmlkO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBDbGVhbiB1cCBkYXRhYmFzZSBhZnRlciBhbGwgdGVzdHNcbiAgICAgICAgYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEucHJvZHVjdC5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnN1cHBsaWVyLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuc2hvcC5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLiRkaXNjb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnUE9TVCAvYXBpL3B1cmNoYXNlcyAoQ3JlYXRlIFB1cmNoYXNlIEludm9pY2UpJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhIHB1cmNoYXNlIGludm9pY2UgZm9yIGEgbmV3IHByb2R1Y3QsIHVwZGF0ZSBpbnZlbnRvcnksIGFuZCBzZXQgV0FDJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gRGVmaW5lIGRhdGEgZm9yIGEgbmV3IHByb2R1Y3RcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb2R1Y3ROYW1lID0gJ0JyYW5kIE5ldyBSYWNrZXQnO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvZHVjdFNrdSA9ICdORVdCMDAxJztcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUHJpY2UgPSAxNTA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gMTA7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcm9kdWN0IGZpcnN0IChhcyBBUEkgZXhwZWN0cyBwcm9kdWN0SWQpXG4gICAgICAgICAgICAvLyBJbiBhIHJlYWwgc2NlbmFyaW8sIHRoZSBVSSBtaWdodCBjcmVhdGUgcHJvZHVjdCB0aGVuIHB1cmNoYXNlLCBvciBwdXJjaGFzZSBBUEkgaGFuZGxlcyBwcm9kdWN0IGNyZWF0aW9uXG4gICAgICAgICAgICAvLyBGb3IgdGhpcyB0ZXN0LCBhc3N1bWUgcHJvZHVjdCBpcyBjcmVhdGVkIGp1c3QgYmVmb3JlLCBvciBBUEkgaW1wbGllcyBpdHMgY3JlYXRpb24gZnJvbSBwdXJjaGFzZSAobm90IGN1cnJlbnQgQVBJKVxuICAgICAgICAgICAgLy8gTGV0J3MgYXNzdW1lIGZvciBub3cgcHJvZHVjdCBtdXN0IGV4aXN0LCBpZiBBUEkgZG9lc24ndCBjcmVhdGUgaXQgZnJvbSBwdXJjaGFzZSBpdGVtcy5cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IEFQSSdzIFBPU1QgL2FwaS9wdXJjaGFzZXMgZXhwZWN0cyBpdGVtLnByb2R1Y3RJZCwgaW1wbHlpbmcgcHJvZHVjdCBleGlzdHMuXG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1Rlc3RQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5ld1Byb2R1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBza3U6IG5ld1Byb2R1Y3RTa3UsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAyNTAsIC8vIFJldGFpbCBwcmljZVxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgLy8gT3B0aW9uYWwgZGVmYXVsdCBzaG9wIGFzc29jaWF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXN0UHJvZHVjdElkID0gbmV3VGVzdFByb2R1Y3QuaWQ7XG5cbiAgICAgICAgICAgIC8vIDIuIFByZXBhcmUgdGhlIHJlcXVlc3QgYm9keSBmb3IgUE9TVCAvYXBpL3B1cmNoYXNlc1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IG5ld1Rlc3RQcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbIC8vIEV4cGxpY2l0IGRpc3RyaWJ1dGlvbiBpcyBjcnVjaWFsIGJhc2VkIG9uIGN1cnJlbnQgUE9TVCBBUElcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2NyZWF0ZWRTaG9wSWRdOiBwdXJjaGFzZVF1YW50aXR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBwdXJjaGFzZVF1YW50aXR5ICogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIENvbnN0cnVjdCBhIE5leHRSZXF1ZXN0IGluc3RhbmNlXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBwdXJjaGFzZUludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHRoZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpOyAvLyBPciAyMDAgZGVwZW5kaW5nIG9uIHlvdXIgQVBJJ3Mgc3VjY2VzcyByZXNwb25zZSBmb3IgUE9TVFxuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogY3JlYXRlZEludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5zdXBwbGllcklkKS50b0JlKGNyZWF0ZWRTdXBwbGllcklkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShuZXdUZXN0UHJvZHVjdElkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGluIERCXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0gPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcElkOiBjcmVhdGVkU2hvcElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0pLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8ucXVhbnRpdHkpLnRvQmUocHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICAvLyBUaGUgUE9TVCByb3V0ZSBzZWVtcyB0byBjYWxjdWxhdGUgc2hvcFNwZWNpZmljQ29zdCB0b28uXG4gICAgICAgICAgICAvLyBXQUMgPSAoQ3VycmVudCBUb3RhbCBWYWx1ZSArIE5ldyBQdXJjaGFzZSBWYWx1ZSkgLyAoQ3VycmVudCBRdWFudGl0eSArIE5ldyBRdWFudGl0eSlcbiAgICAgICAgICAgIC8vIEZvciBuZXcgaXRlbSwgZXhpc3Rpbmcgc2hvcFNwZWNpZmljQ29zdCBpcyAwLCBjdXJyZW50UXVhbnRpdHkgaXMgMC5cbiAgICAgICAgICAgIC8vIFNvIG5ld1Nob3BTcGVjaWZpY0Nvc3Qgc2hvdWxkIGJlIG5ld0Nvc3QgKHB1cmNoYXNlUHJpY2UpXG4gICAgICAgICAgICBleHBlY3QoZGJJbnZlbnRvcnlJdGVtPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UpO1xuXG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQcm9kdWN0IFdBQyBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IG5ld1Rlc3RQcm9kdWN0SWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICAvLyBGb3IgYSBuZXcgcHJvZHVjdCwgV0FDIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgcHVyY2hhc2UgcHJpY2Ugb2YgdGhpcyBmaXJzdCBiYXRjaFxuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgcHVyY2hhc2UgZm9yIGFuIGV4aXN0aW5nIHByb2R1Y3QsIHVwZGF0ZSBpbnZlbnRvcnksIGFuZCByZWNhbGN1bGF0ZSBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMC4gSW5pdGlhbCBzdGF0ZTogUHJvZHVjdCBleGlzdHMsIHBvdGVudGlhbGx5IHdpdGggc29tZSBpbnZlbnRvcnkgYW5kIFdBQ1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFB1cmNoYXNlUHJpY2UgPSAxMjA7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDU7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3RJZCA9IGNyZWF0ZWRQcm9kdWN0SWQ7IC8vIEZyb20gYmVmb3JlRWFjaFxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gaW5pdGlhbCBwdXJjaGFzZSB0byBzZXQgdXAgZXhpc3RpbmcgaW52ZW50b3J5IGFuZCBXQUNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDg2NDAwMDAwKS50b0lTT1N0cmluZygpLCAvLyBZZXN0ZXJkYXlcbiAgICAgICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBleGlzdGluZ1Byb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiBpbml0aWFsUHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH1dLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAqIGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSZXEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbml0aWFsUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKGluaXRpYWxSZXEpO1xuXG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0QmVmb3JlTmV3UHVyY2hhc2UgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBjb25zdCBpbnZlbnRvcnlCZWZvcmVOZXdQdXJjaGFzZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogZXhpc3RpbmdQcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuXG4gICAgICAgICAgICBleHBlY3QocHJvZHVjdEJlZm9yZU5ld1B1cmNoYXNlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZlbnRvcnlCZWZvcmVOZXdQdXJjaGFzZT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGludmVudG9yeUJlZm9yZU5ld1B1cmNoYXNlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gMS4gRGVmaW5lIGRhdGEgZm9yIHRoZSBuZXcgcHVyY2hhc2Ugb2YgdGhlIGV4aXN0aW5nIHByb2R1Y3RcbiAgICAgICAgICAgIGNvbnN0IG5ld1B1cmNoYXNlUHJpY2UgPSAxMDA7XG4gICAgICAgICAgICBjb25zdCBuZXdQdXJjaGFzZVF1YW50aXR5ID0gODtcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogZXhpc3RpbmdQcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBuZXdQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld1B1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjcmVhdGVkU2hvcElkXTogbmV3UHVyY2hhc2VRdWFudGl0eVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogbmV3UHVyY2hhc2VRdWFudGl0eSAqIG5ld1B1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyAzLiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZEludm9pY2VJZCA9IHJlc3BvbnNlQm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbVxuICAgICAgICAgICAgY29uc3QgZGJJbnZlbnRvcnlJdGVtID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IGV4aXN0aW5nUHJvZHVjdElkLFxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbFF1YW50aXR5ID0gaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKyBuZXdQdXJjaGFzZVF1YW50aXR5O1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8ucXVhbnRpdHkpLnRvQmUoZXhwZWN0ZWRUb3RhbFF1YW50aXR5KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHNob3BTcGVjaWZpY0Nvc3QgcmVjYWxjdWxhdGlvblxuICAgICAgICAgICAgLy8gU1NDID0gKChvbGRRdHkgKiBvbGRTU0MpICsgKG5ld1F0eSAqIG5ld1ByaWNlKSkgLyAob2xkUXR5ICsgbmV3UXR5KVxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRTaG9wU3BlY2lmaWNDb3N0ID1cbiAgICAgICAgICAgICAgICAoKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UpICsgKG5ld1B1cmNoYXNlUXVhbnRpdHkgKiBuZXdQdXJjaGFzZVByaWNlKSkgL1xuICAgICAgICAgICAgICAgIChpbml0aWFsUHVyY2hhc2VRdWFudGl0eSArIG5ld1B1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oZXhwZWN0ZWRTaG9wU3BlY2lmaWNDb3N0KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDIHJlY2FsY3VsYXRpb25cbiAgICAgICAgICAgIC8vIFdBQyA9ICgob2xkVG90YWxRdHkgKiBvbGRXQUMpICsgKG5ld1B1cmNoYXNlUXR5ICogbmV3UHVyY2hhc2VQcmljZSkpIC8gKG5ld1RvdGFsUXR5ICsgbmV3UHVyY2hhc2VRdHkpXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHByb2R1Y3QgV0FDIHdhcyBpbml0aWFsUHVyY2hhc2VQcmljZSBmb3IgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkuXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFByb2R1Y3RXQUMgPVxuICAgICAgICAgICAgICAgICgoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKiBpbml0aWFsUHVyY2hhc2VQcmljZSkgKyAobmV3UHVyY2hhc2VRdWFudGl0eSAqIG5ld1B1cmNoYXNlUHJpY2UpKSAvXG4gICAgICAgICAgICAgICAgKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICsgbmV3UHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBjb25zdCBkYlByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhleHBlY3RlZFByb2R1Y3RXQUMpO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBwdXJjaGFzZSB3aXRoIG11bHRpcGxlIGl0ZW1zIGFuZCB1cGRhdGUgaW52ZW50b3J5L1dBQyBmb3IgZWFjaCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSB0d28gZGlzdGluY3QgcHJvZHVjdHMgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdDFEYXRhID0geyBuYW1lOiAnTXVsdGlJdGVtIFByb2R1Y3QgQScsIHNrdTogJ01VTFRJMDAxJywgcHJpY2U6IDUwLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QyRGF0YSA9IHsgbmFtZTogJ011bHRpSXRlbSBQcm9kdWN0IEInLCBza3U6ICdNVUxUSTAwMicsIHByaWNlOiA3NSwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH07XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0MSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7IGRhdGE6IHByb2R1Y3QxRGF0YSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QyID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHsgZGF0YTogcHJvZHVjdDJEYXRhIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlMSA9IDQwO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eTEgPSA1O1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZTIgPSA2MDtcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUXVhbnRpdHkyID0gMztcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdDEuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwdXJjaGFzZVByaWNlMSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Mi5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHkyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogWyAvLyBFeHBsaWNpdCBkaXN0cmlidXRpb24gZm9yIGVhY2ggaXRlbVxuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcHVyY2hhc2VRdWFudGl0eTEgfSwgLy8gRGlzdHJpYnV0aW9uIGZvciBpdGVtIDFcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHkyIH0gIC8vIERpc3RyaWJ1dGlvbiBmb3IgaXRlbSAyXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogKHB1cmNoYXNlUXVhbnRpdHkxICogcHVyY2hhc2VQcmljZTEpICsgKHB1cmNoYXNlUXVhbnRpdHkyICogcHVyY2hhc2VQcmljZTIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMy4gU2ltdWxhdGUgQVBJIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHB1cmNoYXNlSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIDQuIEFzc2VydGlvbnNcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBhbmQgaXRzIGl0ZW1zXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBjcmVhdGVkSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogeyBvcmRlckJ5OiB7IHByb2R1Y3RJZDogJ2FzYycgfSB9IH0gLy8gT3JkZXIgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYXNzZXJ0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcbiAgICAgICAgICAgIC8vIEFzc3VtaW5nIHByb2R1Y3QxLmlkIDwgcHJvZHVjdDIuaWQgZHVlIHRvIGNyZWF0aW9uIG9yZGVyIGZvciBjb25zaXN0ZW50IGNoZWNrc1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkUHJvZHVjdHMgPSBbcHJvZHVjdDEsIHByb2R1Y3QyXS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1swXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5MSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzFdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1sxXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5Mik7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMik7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAxXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0xID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QxLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTE/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0xPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UxKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDEgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QxLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0MT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAyXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0yID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QyLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTI/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkyKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0yPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UyKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QyLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Mj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMik7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIGRpc3RyaWJ1dGUgYSBzaW5nbGUgcHVyY2hhc2UgaXRlbSB0byBtdWx0aXBsZSBzaG9wcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSB0d28gbmV3IHNob3BzIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgIGNvbnN0IHNob3BBID0gYXdhaXQgcHJpc21hLnNob3AuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnVGVzdCBTaG9wIEEnLCBsb2NhdGlvbjogJ0xvYyBBJyB9IH0pO1xuICAgICAgICAgICAgY29uc3Qgc2hvcEIgPSBhd2FpdCBwcmlzbWEuc2hvcC5jcmVhdGUoeyBkYXRhOiB7IG5hbWU6ICdUZXN0IFNob3AgQicsIGxvY2F0aW9uOiAnTG9jIEInIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIDIuIENyZWF0ZSBhIG5ldyBwcm9kdWN0XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnU3BsaXQgUHJvZHVjdCcsIHNrdTogJ1NQTElUMDAxJywgcHJpY2U6IDIwMCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZSA9IDE4MDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsUXVhbnRpdHkgPSAxMDtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5Rm9yU2hvcEEgPSA2O1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlGb3JTaG9wQiA9IDQ7XG5cbiAgICAgICAgICAgIGV4cGVjdChxdWFudGl0eUZvclNob3BBICsgcXVhbnRpdHlGb3JTaG9wQikudG9CZSh0b3RhbFF1YW50aXR5KTsgLy8gU2FuaXR5IGNoZWNrXG5cbiAgICAgICAgICAgIC8vIDMuIFByZXBhcmUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHRvdGFsUXVhbnRpdHksIC8vIFRvdGFsIHF1YW50aXR5IGZvciB0aGUgaXRlbSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyAvLyBEaXN0cmlidXRpb24gZm9yIHRoZSBzaW5nbGUgaXRlbSwgc3BsaXQgaW50byB0d28gc2hvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzaG9wQS5pZF06IHF1YW50aXR5Rm9yU2hvcEEsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2hvcEIuaWRdOiBxdWFudGl0eUZvclNob3BCLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogdG90YWxRdWFudGl0eSAqIHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyA0LiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNS4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBmb3IgU2hvcCBBXG4gICAgICAgICAgICBjb25zdCBpbnZJdGVtQSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0LmlkLCBzaG9wSWQ6IHNob3BBLmlkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1BKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlGb3JTaG9wQSk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUE/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGZvciBTaG9wIEJcbiAgICAgICAgICAgIGNvbnN0IGludkl0ZW1CID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QuaWQsIHNob3BJZDogc2hvcEIuaWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUIpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1CPy5xdWFudGl0eSkudG9CZShxdWFudGl0eUZvclNob3BCKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQj8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDIChzaG91bGQgYmUgdGhlIHB1cmNoYXNlIHByaWNlIGFzIGl0J3MgYWxsIG5ldyBzdG9jaylcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgZmFpbCB0byBjcmVhdGUgYSBwdXJjaGFzZSBpZiBhIHByb2R1Y3RJZCBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vbkV4aXN0ZW50UHJvZHVjdElkID0gOTk5OTk5OyAvLyBBc3N1bWluZyB0aGlzIElEIHdvbid0IGV4aXN0XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gMTAwO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eSA9IDU7XG5cbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBub25FeGlzdGVudFByb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IHB1cmNoYXNlUXVhbnRpdHkgKiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcblxuICAgICAgICAgICAgLy8gRXhwZWN0IGEgY2xpZW50IGVycm9yIChlLmcuLCA0MDAgb3IgNDA0KSBvciBwb3RlbnRpYWxseSA1MDAgaWYgbm90IGhhbmRsZWQgZ3JhY2VmdWxseVxuICAgICAgICAgICAgLy8gRm9yIHJvYnVzdCBlcnJvciBoYW5kbGluZywgQVBJIHNob3VsZCByZXR1cm4gc3BlY2lmaWMgZXJyb3IgY29kZS5cbiAgICAgICAgICAgIC8vIFByaXNtYSB3aWxsIHRocm93IGFuIGVycm9yIGlmIGEgcmVsYXRlZCByZWNvcmQgKHByb2R1Y3QpIGlzIG5vdCBmb3VuZCBmb3IgZm9yZWlnbiBrZXkuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiBhIDUwMCBpZiBub3QgY2F1Z2h0IGFuZCBoYW5kbGVkIGJ5IHRoZSBBUEkgcm91dGUuXG4gICAgICAgICAgICAvLyBMZXQncyBhaW0gZm9yIHRoZSBBUEkgdG8gY2F0Y2ggdGhpcyBhbmQgcmV0dXJuIGEgbW9yZSBzcGVjaWZpYyBjbGllbnQgZXJyb3IuXG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBjaGVjayBpZiBpdCdzIE5PVCBhIHN1Y2Nlc3MgKDIwMSkuXG4gICAgICAgICAgICAvLyBBIG1vcmUgcHJlY2lzZSBjaGVjayB3b3VsZCBiZSBmb3IgNDAwLzQwNC80MjIgZGVwZW5kaW5nIG9uIHBsYW5uZWQgZXJyb3IgaGFuZGxpbmcuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7IC8vIE9yIDQwMC80MDQgaWYgeW91IGltcGxlbWVudCBzcGVjaWZpYyBlcnJvciBoYW5kbGluZ1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSwgY2hlY2sgZm9yIGEgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSBvciBjb2RlIGlmIHlvdXIgQVBJIHByb3ZpZGVzIG9uZS5cbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgZmFpbCB0byBjcmVhdGUgYSBwdXJjaGFzZSBpZiBhIHN1cHBsaWVySWQgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXN0UHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBGb3IgSW52YWxpZCBTdXBwbGllciBUZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnSU5WIFNVUDAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAxMDAsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gODA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gNTtcbiAgICAgICAgICAgIGNvbnN0IG5vbkV4aXN0ZW50U3VwcGxpZXJJZCA9IDk5OTk5OTsgLy8gQXNzdW1pbmcgdGhpcyBJRCB3b24ndCBleGlzdFxuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IG5vbkV4aXN0ZW50U3VwcGxpZXJJZC50b1N0cmluZygpLCAvLyBJbnZhbGlkIHN1cHBsaWVyXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3QuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBwdXJjaGFzZVF1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBwdXJjaGFzZVF1YW50aXR5ICogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHB1cmNoYXNlSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTsgLy8gRXhwZWN0aW5nIDUwMCBhcyBQcmlzbWEgdGhyb3dzIFAyMDAzXG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1BVVCAvYXBpL3B1cmNoYXNlcy86aWQgKFVwZGF0ZSBQdXJjaGFzZSBJbnZvaWNlKScsICgpID0+IHtcbiAgICAgICAgbGV0IGV4aXN0aW5nSW52b2ljZUlkOiBzdHJpbmc7XG4gICAgICAgIGxldCBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZDogbnVtYmVyO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VQcmljZSA9IDUwO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDEwO1xuXG4gICAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZHVjdCBzcGVjaWZpY2FsbHkgZm9yIHRoZXNlIHVwZGF0ZS9kZWxldGUgdGVzdHMgaWYgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gVGhlIGdsb2JhbCBjcmVhdGVkUHJvZHVjdElkIGNhbiBiZSB1c2VkIGlmIGl0IGZpdHMsIG9yIG1ha2UgYSBuZXcgb25lLlxuICAgICAgICAgICAgLy8gTGV0J3MgdXNlIHRoZSBnbG9iYWwgb25lIGZvciBzaW1wbGljaXR5LCBhc3N1bWluZyBiZWZvcmVFYWNoIGNsZWFucyBpdCB1cC5cbiAgICAgICAgICAgIHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkID0gY3JlYXRlZFByb2R1Y3RJZDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGluaXRpYWwgcHVyY2hhc2UgaW52b2ljZSB0byBiZSB1cGRhdGVkIG9yIGRlbGV0ZWQgaW4gdGVzdHNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSA4NjQwMDAwMCkudG9JU09TdHJpbmcoKSwgLy8gWWVzdGVyZGF5XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVxID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogaW5pdGlhbEludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZVB1cmNoYXNlSW52b2ljZShyZXEpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4aXN0aW5nSW52b2ljZUlkID0gYm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IHZlcmlmeSBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShpbml0aWFsUHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGluaXRpYWxJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSBpdGVtIHF1YW50aXR5IChpbmNyZWFzZSksIHJlY2FsY3VsYXRlIHN0b2NrIGFuZCBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlJbmNyZWFzZSA9IDU7XG4gICAgICAgICAgICBjb25zdCBuZXdRdWFudGl0eSA9IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICsgcXVhbnRpdHlJbmNyZWFzZTtcbiAgICAgICAgICAgIC8vIFByaWNlIHJlbWFpbnMgdGhlIHNhbWUgZm9yIHRoaXMgaXRlbSBpbiB0aGlzIHVwZGF0ZSBzY2VuYXJpb1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByaWNlRm9ySXRlbSA9IGluaXRpYWxQdXJjaGFzZVByaWNlO1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc2VuZCB0aGUgY29tcGxldGUgc3RydWN0dXJlIGV4cGVjdGVkIGJ5IHRoZSBQVVQgcm91dGVcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIGFsbCBpdGVtcywgZXZlbiBpZiBvbmx5IG9uZSBpcyBjaGFuZ2luZy5cbiAgICAgICAgICAgICAgICAvLyBUaGUgUFVUIHJvdXRlIGxvZ2ljIG1pZ2h0IGNvbXBhcmUgd2l0aCBleGlzdGluZyBpdGVtcyB0byBzZWUgd2hhdCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtIGhhZCBhbiBJRCAoUHVyY2hhc2VJbnZvaWNlSXRlbSBpZCksIGl0IG1pZ2h0IGJlIG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGFzc3VtZSBmb3Igbm93IHRoZSBQVVQgbWF0Y2hlcyBpdGVtcyBiYXNlZCBvbiBwcm9kdWN0SWQgaWYgbm90IGl0ZW0gSUQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlZCBvbiBjdXJyZW50IFBVVCByb3V0ZSwgaXQgZXhwZWN0cyBwcm9kdWN0SWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3UXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogdXBkYXRlZFByaWNlRm9ySXRlbSwgLy8gU2VuZCB0aGUgb3JpZ2luYWwgcHJpY2UgaWYgaXQgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGlzdHJpYnV0aW9ucyBpbiBQVVQgbWlnaHQgbmVlZCB0byByZWZsZWN0IHRoZSAqbmV3IHRvdGFsKiBmb3IgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IG5ld1F1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIE90aGVyIGZpZWxkcyBsaWtlIHN1cHBsaWVySWQsIGRhdGUsIHRvdGFsQW1vdW50IG1pZ2h0IGJlIHVwZGF0YWJsZSB0b28uXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoaXMgdGVzdCwgZm9jdXMgb24gaXRlbSBxdWFudGl0eSBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgLy8gVGhlIFBVVCByb3V0ZSByZWNhbGN1bGF0ZXMgdG90YWxBbW91bnQgYmFzZWQgb24gaXRlbXMgaWYgbm90IHByb3ZpZGVkIG9yIGlmIGl0ZW1zIGNoYW5nZS5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgdG90YWxBbW91bnQgd2lsbCBiZSByZWNhbGN1bGF0ZWQgYnkgdGhlIEFQSS5cbiAgICAgICAgICAgICAgICAvLyBzdXBwbGllcklkIGFuZCBkYXRlIGNvdWxkIGJlIHBhcnQgb2YgdGhlIHBheWxvYWQgaWYgdGhleSBhcmUgdXBkYXRhYmxlLlxuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIGtlZXBpbmcgaXQgbWluaW1hbCB0byB0ZXN0IGl0ZW0gdXBkYXRlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBQVVQgaGFuZGxlciByZS1jYWxjdWxhdGVzIHRvdGFsIGFtb3VudCwgc28gbm90IHNlbmRpbmcgaXQuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIC8vIElNUE9SVEFOVDogTmVlZCB0byBwYXNzIHJvdXRlIHBhcmFtcyBmb3IgW2lkXSB0byB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IHN0YW5kYXJkIE5leHRSZXF1ZXN0IGJ1dCBob3cgdGVzdCBzZXR1cCBtaWdodCBuZWVkIGl0IG9yIGhvdyBoYW5kbGVyIGV4cGVjdHMgaXQuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCBoYW5kbGVyIGB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVxdWVzdDogTmV4dFJlcXVlc3QsIHsgcGFyYW1zIH06IHsgcGFyYW1zOiB7IGlkOiBzdHJpbmcgfSB9KWBcbiAgICAgICAgICAgICAgICAvLyBuZWVkcyBgcGFyYW1zYC4gbm9kZS1tb2Nrcy1odHRwIGBjcmVhdGVNb2Nrc2AgaGFuZGxlcyB0aGlzIHdlbGwuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGRpcmVjdCBOZXh0UmVxdWVzdCwgd2UgcGFzcyBpdCBpbiBjb250ZXh0IHRvIHRoZSBoYW5kbGVyIGNhbGwuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2ltdWxhdGUgQVBJIGNhbGwgLSB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVxLCB7IHBhcmFtczogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSB9KVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBob3cgeW91IGNhbGwgaXQgaWYgeW91IGFyZSB0ZXN0aW5nIHRoZSBoYW5kbGVyIGRpcmVjdGx5IGluIEplc3Qgd2l0aCBjb250ZXh0XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgYW5kIHNob3BTcGVjaWZpY0Nvc3RcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZShuZXdRdWFudGl0eSk7XG5cbiAgICAgICAgICAgIC8vIFdBQyBjYWxjdWxhdGlvbjogKChvbGRRdHkgKiBvbGRTU0MpICsgKGFkZGVkUXR5ICogcHJpY2VPZkFkZGVkUXR5KSkgLyAobmV3VG90YWxRdHkpXG4gICAgICAgICAgICAvLyBJbiB0aGlzIHNwZWNpZmljIHVwZGF0ZSwgdGhlIFBVVCByb3V0ZSByZXZlcnNlcyB0aGUgb2xkIGl0ZW0gYW5kIGFkZHMgdGhlIG5ldyBvbmUgYXMgaWYgaXQncyBhIG5ldyBwdXJjaGFzZSBsaW5lIGZvciBXQUMgY2FsY3MuXG4gICAgICAgICAgICAvLyBTbywgdGhlIG9sZCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSBhdCBpbml0aWFsUHVyY2hhc2VQcmljZSBpcyByZXZlcnNlZC5cbiAgICAgICAgICAgIC8vIFRoZW4sIG5ld1F1YW50aXR5IGF0IHVwZGF0ZWRQcmljZUZvckl0ZW0gaXMgYWRkZWQuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGUgY3VycmVudCBQVVQgbG9naWMgZmlyc3QgcmV2ZXJzZXMgKmFsbCogb2xkIGl0ZW1zIGJhc2VkIG9uIHRoZWlyICpvcmlnaW5hbCogcmVjb3JkZWQgY29zdC5cbiAgICAgICAgICAgIC8vIFRoZW4gaXQgYWRkcyAqYWxsKiBuZXcgaXRlbXMgYmFzZWQgb24gdGhlaXIgKm5ldyogY29zdC5cbiAgICAgICAgICAgIC8vIFNvIGZvciB0aGUgcHJvZHVjdCBXQUM6IChUb3RhbFZhbHVlQmVmb3JlIC0gT2xkSXRlbVZhbHVlICsgTmV3SXRlbVZhbHVlKSAvIChUb3RhbFN0b2NrQmVmb3JlIC0gT2xkSXRlbVF0eSArIE5ld0l0ZW1RdHkpXG4gICAgICAgICAgICAvLyBBbmQgZm9yIHNob3Agc3BlY2lmaWMgV0FDOiAoU2hvcFZhbHVlQmVmb3JlIC0gT2xkSXRlbVZhbHVlSW5TaG9wICsgTmV3SXRlbVZhbHVlSW5TaG9wKSAvIChTaG9wU3RvY2tCZWZvcmUgLSBPbGRJdGVtUXR5SW5TaG9wICsgTmV3SXRlbVF0eUluU2hvcClcblxuICAgICAgICAgICAgLy8gTGV0J3MgY2hlY2sgdGhlIGxvZ2ljIGZyb20gc3JjL2FwcC9hcGkvcHVyY2hhc2VzL1tpZF0vcm91dGUudHNcbiAgICAgICAgICAgIC8vIDEuIEl0IGZldGNoZXMgdGhlIG9sZCBpbnZvaWNlLlxuICAgICAgICAgICAgLy8gMi4gSXQgcmV2ZXJzZXMgaW52ZW50b3J5IGFkanVzdG1lbnRzIGZvciBBTEwgb2xkIGl0ZW1zIChkZWNyZWFzZSBzdG9jaywgV0FDIHVwZGF0ZWQpLlxuICAgICAgICAgICAgLy8gMy4gSXQgcHJvY2Vzc2VzIEFMTCBuZXcvdXBkYXRlZCBpdGVtcyBhcyBpZiB0aGV5IGFyZSBuZXcgcHVyY2hhc2VzIChpbmNyZWFzZSBzdG9jaywgV0FDIHVwZGF0ZWQpLlxuXG4gICAgICAgICAgICAvLyBTbywgYWZ0ZXIgcmV2ZXJzYWwgb2YgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgYXQgaW5pdGlhbFB1cmNoYXNlUHJpY2U6XG4gICAgICAgICAgICAvLyBQcm9kdWN0IFdBQyBhbmQgU2hvcFNwZWNpZmljQ29zdCB3b3VsZCBiZSBlZmZlY3RpdmVseSAwIGlmIHRoaXMgd2VyZSB0aGUgb25seSBwcm9kdWN0L3N0b2NrLlxuICAgICAgICAgICAgLy8gVGhlbiwgYWRkaW5nIG5ld1F1YW50aXR5IGF0IHVwZGF0ZWRQcmljZUZvckl0ZW06XG4gICAgICAgICAgICAvLyBUaGUgbmV3IFdBQ3Mgc2hvdWxkIGJlY29tZSB1cGRhdGVkUHJpY2VGb3JJdGVtLlxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgUHJvZHVjdCBXQUNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREIgcmVmbGVjdHMgdGhlIGNoYW5nZVxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7IGl0ZW1zOiB0cnVlIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnF1YW50aXR5KS50b0JlKG5ld1F1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByaWNlKS50b0JlKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUobmV3UXVhbnRpdHkgKiB1cGRhdGVkUHJpY2VGb3JJdGVtKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIGl0ZW0gcXVhbnRpdHkgKGRlY3JlYXNlKSwgcmVjYWxjdWxhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWFudGl0eURlY3JlYXNlID0gMztcbiAgICAgICAgICAgIGNvbnN0IG5ld1F1YW50aXR5ID0gaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgLSBxdWFudGl0eURlY3JlYXNlO1xuICAgICAgICAgICAgZXhwZWN0KG5ld1F1YW50aXR5KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApOyAvLyBFbnN1cmUgd2UgZG9uJ3QgZ28gbmVnYXRpdmUgZm9yIHRoaXMgdGVzdCBsb2dpY1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJpY2VGb3JJdGVtID0gaW5pdGlhbFB1cmNoYXNlUHJpY2U7IC8vIFByaWNlIHJlbWFpbnMgdGhlIHNhbWVcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3UXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogdXBkYXRlZFByaWNlRm9ySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogbmV3UXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdXBkYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSwgeyBwYXJhbXM6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZGF0YSkudG9IYXZlUHJvcGVydHkoJ2lkJywgZXhpc3RpbmdJbnZvaWNlSWQpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBzdG9jayBhbmQgc2hvcFNwZWNpZmljQ29zdFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKG5ld1F1YW50aXR5KTtcblxuICAgICAgICAgICAgLy8gRHVlIHRvIHRoZSByZXZlcnNhbCBhbmQgcmUtYWRkaXRpb24gbG9naWMgb2YgdGhlIFBVVCByb3V0ZTpcbiAgICAgICAgICAgIC8vIFRoZSBvbGQgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgYXQgaW5pdGlhbFB1cmNoYXNlUHJpY2UgaXMgcmV2ZXJzZWQuXG4gICAgICAgICAgICAvLyBUaGVuLCBuZXdRdWFudGl0eSBhdCB1cGRhdGVkUHJpY2VGb3JJdGVtIGlzIGFkZGVkLlxuICAgICAgICAgICAgLy8gU28sIG5ldyBXQUNzIHNob3VsZCBiZWNvbWUgdXBkYXRlZFByaWNlRm9ySXRlbSAod2hpY2ggaXMgaW5pdGlhbFB1cmNoYXNlUHJpY2UpLlxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgUHJvZHVjdCBXQUNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREJcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShuZXdRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZSh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/LnRvdGFsKS50b0JlKG5ld1F1YW50aXR5ICogdXBkYXRlZFByaWNlRm9ySXRlbSk7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSBpdGVtIHByaWNlLCByZWNhbGN1bGF0ZSBzdG9jayBhbmQgV0FDcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ByaWNlRm9ySXRlbSA9IGluaXRpYWxQdXJjaGFzZVByaWNlICsgMjU7IC8vIE5ldyBwcmljZSwgZS5nLiwgNTAgKyAyNSA9IDc1XG4gICAgICAgICAgICBjb25zdCBxdWFudGl0eVVuY2hhbmdlZCA9IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5OyAvLyBRdWFudGl0eSByZW1haW5zIHRoZSBzYW1lXG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHF1YW50aXR5VW5jaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld1ByaWNlRm9ySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcXVhbnRpdHlVbmNoYW5nZWQgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgLy8gdG90YWxBbW91bnQgd2lsbCBiZSByZWNhbGN1bGF0ZWQgYnkgdGhlIEFQSVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtleGlzdGluZ0ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgKHNob3VsZCBiZSB1bmNoYW5nZWQpIGFuZCBzaG9wU3BlY2lmaWNDb3N0XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlVbmNoYW5nZWQpO1xuICAgICAgICAgICAgLy8gV0FDIGxvZ2ljIGluIFBVVDogcmV2ZXJzZXMgb2xkLCBhZGRzIG5ldy4gU28gc2hvcFNwZWNpZmljQ29zdCBzaG91bGQgcmVmbGVjdCBuZXdQcmljZUZvckl0ZW0uXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8obmV3UHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8obmV3UHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREJcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShxdWFudGl0eVVuY2hhbmdlZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShuZXdQcmljZUZvckl0ZW0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUocXVhbnRpdHlVbmNoYW5nZWQgKiBuZXdQcmljZUZvckl0ZW0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBhZGQgYSBuZXcgaXRlbSB0byBhbiBleGlzdGluZyBpbnZvaWNlLCB1cGRhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBEZWZpbmUgYSBuZXcgcHJvZHVjdCBmb3IgdGhlIG5ldyBpdGVtXG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTmV3bHkgQWRkZWQgUHJvZHVjdCBmb3IgUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnUFVUTkVXMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDIwMCwgLy8gUmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUHJvZHVjdElkID0gbmV3SXRlbVByb2R1Y3QuaWQ7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUXVhbnRpdHkgPSA3O1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbVByaWNlID0gMTIwO1xuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBpdGVtIGRldGFpbHMgKGZyb20gYmVmb3JlRWFjaCBzZXR1cClcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbVByb2R1Y3RJZCA9IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxJdGVtUXVhbnRpdHkgPSBpbml0aWFsUHVyY2hhc2VRdWFudGl0eTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbVByaWNlID0gaW5pdGlhbFB1cmNoYXNlUHJpY2U7XG5cbiAgICAgICAgICAgIC8vIDIuIFByZXBhcmUgdGhlIHVwZGF0ZSBwYXlsb2FkIHdpdGggYm90aCBvcmlnaW5hbCBhbmQgbmV3IGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBvcmlnaW5hbEl0ZW1RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBvcmlnaW5hbEl0ZW1QcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBuZXdJdGVtUHJvZHVjdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3SXRlbVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld0l0ZW1QcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogb3JpZ2luYWxJdGVtUXVhbnRpdHkgfSwgLy8gRGlzdHJpYnV0aW9uIGZvciBvcmlnaW5hbCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBuZXdJdGVtUXVhbnRpdHkgfSAgICAgIC8vIERpc3RyaWJ1dGlvbiBmb3IgbmV3IGl0ZW1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIHRvdGFsQW1vdW50IHdpbGwgYmUgcmVjYWxjdWxhdGVkIGJ5IHRoZSBBUElcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIFNpbXVsYXRlIEFQSSBjYWxsXG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAvLyA0LiBBc3NlcnRpb25zXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7IGl0ZW1zOiB7IG9yZGVyQnk6IHsgcHJvZHVjdElkOiAnYXNjJyB9IH0gfSwgLy8gT3JkZXIgZm9yIGNvbnNpc3RlbnQgY2hlY2tzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcblxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbCA9IChvcmlnaW5hbEl0ZW1RdWFudGl0eSAqIG9yaWdpbmFsSXRlbVByaWNlKSArIChuZXdJdGVtUXVhbnRpdHkgKiBuZXdJdGVtUHJpY2UpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUoZXhwZWN0ZWRUb3RhbCk7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGl0ZW1zIGluIHRoZSByZXNwb25zZSAob3JkZXIgbWlnaHQgdmFyeSwgc28gZmluZCBieSBwcm9kdWN0SWQpXG4gICAgICAgICAgICBjb25zdCBkYk9yaWdpbmFsSXRlbSA9IGRiSW52b2ljZT8uaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ucHJvZHVjdElkID09PSBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQpO1xuICAgICAgICAgICAgY29uc3QgZGJOZXdJdGVtID0gZGJJbnZvaWNlPy5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5wcm9kdWN0SWQgPT09IG5ld0l0ZW1Qcm9kdWN0SWQpO1xuXG4gICAgICAgICAgICBleHBlY3QoZGJPcmlnaW5hbEl0ZW0pLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZGJPcmlnaW5hbEl0ZW0/LnF1YW50aXR5KS50b0JlKG9yaWdpbmFsSXRlbVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYk9yaWdpbmFsSXRlbT8ucHJpY2UpLnRvQmUob3JpZ2luYWxJdGVtUHJpY2UpO1xuXG4gICAgICAgICAgICBleHBlY3QoZGJOZXdJdGVtKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGRiTmV3SXRlbT8ucXVhbnRpdHkpLnRvQmUobmV3SXRlbVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYk5ld0l0ZW0/LnByaWNlKS50b0JlKG5ld0l0ZW1QcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgdGhlIG9yaWdpbmFsIGl0ZW1cbiAgICAgICAgICAgIC8vIChEdWUgdG8gUFVUIGxvZ2ljIG9mIHJldmVyc2UgJiByZS1hZGQsIFdBQ3Mgc2hvdWxkIHJlZmxlY3QgaXRzIGN1cnJlbnQgcHJpY2UpXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChvcmlnaW5hbEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUob3JpZ2luYWxJdGVtUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhvcmlnaW5hbEl0ZW1QcmljZSk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IG9yaWdpbmFsSXRlbVByb2R1Y3RJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8ob3JpZ2luYWxJdGVtUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBhbmQgUHJvZHVjdCBXQUMgZm9yIHRoZSBORVcgaXRlbVxuICAgICAgICAgICAgY29uc3QgbmV3SW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IG5ld0l0ZW1Qcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChuZXdJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKG5ld0l0ZW1RdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QobmV3SW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhuZXdJdGVtUHJpY2UpO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvZHVjdERiID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBuZXdJdGVtUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QobmV3UHJvZHVjdERiPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhuZXdJdGVtUHJpY2UpO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGV4aXN0aW5nIGludm9pY2UsIHVwZGF0ZSBzdG9jayBhbmQgV0FDcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIFNldHVwOiBFbnN1cmUgYW4gaW52b2ljZSB3aXRoIGF0IGxlYXN0IHR3byBpdGVtcyBleGlzdHMuXG4gICAgICAgICAgICAvLyBXZSdsbCB1c2UgdGhlIGV4aXN0aW5nIGBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZGAgYW5kIGNyZWF0ZSBvbmUgbW9yZSBwcm9kdWN0IGFuZCBpdGVtLlxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdFRvUmVtb3ZlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdQcm9kdWN0IFRvIEJlIFJlbW92ZWQnLFxuICAgICAgICAgICAgICAgICAgICBza3U6ICdQVVRSTVYwMDEnLFxuICAgICAgICAgICAgICAgICAgICBwcmljZTogMzAwLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdFRvUmVtb3ZlSWQgPSBwcm9kdWN0VG9SZW1vdmUuaWQ7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSA9IDQ7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9SZW1vdmVQcmljZSA9IDQwO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGludm9pY2UgKGNyZWF0ZWQgaW4gZ2xvYmFsIGJlZm9yZUVhY2ggZm9yIFBVVCkgdG8gaW5jbHVkZSB0aGlzIHNlY29uZCBpdGVtIGZpcnN0LlxuICAgICAgICAgICAgY29uc3QgYWRkU2Vjb25kSXRlbVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RUb1JlbW92ZUlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcHJvZHVjdFRvUmVtb3ZlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHJvZHVjdFRvUmVtb3ZlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhZGRSZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGFkZFNlY29uZEl0ZW1QYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdXBkYXRlUHVyY2hhc2VJbnZvaWNlKGFkZFJlcSwgeyBwYXJhbXM6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjazogSW52b2ljZSBzaG91bGQgaGF2ZSAyIGl0ZW1zXG4gICAgICAgICAgICBsZXQgaW52b2ljZVdpdGhUd29JdGVtcyA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9LCBpbmNsdWRlOiB7IGl0ZW1zOiB0cnVlIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52b2ljZVdpdGhUd29JdGVtcz8uaXRlbXMubGVuZ3RoKS50b0JlKDIpO1xuXG4gICAgICAgICAgICAvLyAyLiBQcmVwYXJlIHRoZSB1cGRhdGUgcGF5bG9hZCB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGl0ZW0gd2Ugd2FudCB0byBrZWVwLlxuICAgICAgICAgICAgY29uc3QgdXBkYXRlUGF5bG9hZFRvUmVtb3ZlSXRlbSA9IHtcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksIC8vIEtlZXAgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBpbml0aWFsUHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgfSAvLyBEaXN0cmlidXRpb24gZm9yIHRoZSBrZXB0IGl0ZW1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMy4gU2ltdWxhdGUgQVBJIGNhbGwgdG8gcmVtb3ZlIHRoZSBpdGVtXG4gICAgICAgICAgICBjb25zdCByZW1vdmVSZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWRUb1JlbW92ZUl0ZW0pLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZW1vdmVSZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAvLyA0LiBBc3NlcnRpb25zXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQiAtIHNob3VsZCBub3cgaGF2ZSBvbmx5IDEgaXRlbVxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7IGl0ZW1zOiB0cnVlIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShpbml0aWFsUHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShpbml0aWFsUHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy50b3RhbCkudG9CZShpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAqIGluaXRpYWxQdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gYW5kIFByb2R1Y3QgV0FDIGZvciB0aGUgS0VQVCBpdGVtXG4gICAgICAgICAgICBjb25zdCBrZXB0SW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3Qoa2VwdEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGtlcHRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcbiAgICAgICAgICAgIGNvbnN0IGtlcHRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGtlcHRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhpbml0aWFsUHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgdGhlIFJFTU9WRUQgaXRlbVxuICAgICAgICAgICAgLy8gU3RvY2sgc2hvdWxkIGJlIHplcm8gb3IgdGhlIGl0ZW0gbWlnaHQgYmUgZ29uZSBmcm9tIGludmVudG9yeSBpZiBpdCB3YXMgdGhlIG9ubHkgcHVyY2hhc2VcbiAgICAgICAgICAgIC8vIFdBQyBvbiBwcm9kdWN0IHNob3VsZCBiZSAwIGlmIG5vIG90aGVyIHB1cmNoYXNlcyBleGlzdC5cbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdFRvUmVtb3ZlSWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRoZSBQVVQgbG9naWMgcmV2ZXJzZXMgc3RvY2suIElmIHRoaXMgd2FzIHRoZSBvbmx5IHN0b2NrLCBpdCBiZWNvbWVzIDAuXG4gICAgICAgICAgICBleHBlY3QocmVtb3ZlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICAvLyBTaG9wU3BlY2lmaWNDb3N0IG1pZ2h0IGJlY29tZSAwIG9yIE5hTiBpZiBxdWFudGl0eSBpcyAwLiBUaGUgQVBJIHNldHMgaXQgdG8gMCBmb3Igc2FmZXR5LlxuICAgICAgICAgICAgZXhwZWN0KHJlbW92ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUHJvZHVjdERiID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0VG9SZW1vdmVJZCB9IH0pO1xuICAgICAgICAgICAgLy8gSWYgbm8gb3RoZXIgcHVyY2hhc2UgaXRlbXMgZm9yIHRoaXMgcHJvZHVjdCwgV0FDIHNob3VsZCBiZWNvbWUgMC5cbiAgICAgICAgICAgIGNvbnN0IG90aGVyUHVyY2hhc2VzT2ZSZW1vdmVkSXRlbSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmNvdW50KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RUb1JlbW92ZUlkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG90aGVyUHVyY2hhc2VzT2ZSZW1vdmVkSXRlbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChyZW1vdmVkUHJvZHVjdERiPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbygwKTtcbiAgICAgICAgICAgIH0gLy8gRWxzZSwgaXQgd291bGQgYmUgYmFzZWQgb24gb3RoZXIgcHVyY2hhc2VzLCB3aGljaCB0aGlzIHRlc3QgZG9lc24ndCBzZXQgdXAuXG5cbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0RFTEVURSAvYXBpL3B1cmNoYXNlcy86aWQgKERlbGV0ZSBQdXJjaGFzZSBJbnZvaWNlKScsICgpID0+IHtcbiAgICAgICAgbGV0IGludm9pY2VUb0RlbGV0ZUlkOiBzdHJpbmc7XG4gICAgICAgIGxldCBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkOiBudW1iZXI7XG4gICAgICAgIGNvbnN0IGRlbGV0ZVRlc3RJbml0aWFsUHJpY2UgPSA2MDtcbiAgICAgICAgY29uc3QgZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSA9IDEyO1xuXG4gICAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHByb2R1Y3QgZXhpc3RzIGZvciB0aGUgdGVzdFxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBGb3IgRGVsZXRlIFRlc3QnLFxuICAgICAgICAgICAgICAgICAgICBza3U6ICdERUxQUk9EMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDEwMCwgLy8gcmV0YWlsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkID0gcHJvZHVjdC5pZDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGluaXRpYWwgcHVyY2hhc2UgaW52b2ljZSB0byBiZSBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBkZWxldGVUZXN0SW5pdGlhbFByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSB9IC8vIEV4cGxpY2l0IGRpc3RyaWJ1dGlvblxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHkgKiBkZWxldGVUZXN0SW5pdGlhbFByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IGluaXRpYWxJbnZvaWNlUGF5bG9hZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpbnZvaWNlVG9EZWxldGVJZCA9IGJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrOiB2ZXJpZnkgaW5pdGlhbCBzdGF0ZSBhZnRlciBjcmVhdGlvblxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFByb2R1Y3REQiA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGluaXRpYWxQcm9kdWN0REI/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmUoZGVsZXRlVGVzdEluaXRpYWxQcmljZSk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JEZWxldGVUZXN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZShkZWxldGVUZXN0SW5pdGlhbFF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKGRlbGV0ZVRlc3RJbml0aWFsUHJpY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhIHB1cmNoYXNlIGludm9pY2UgYW5kIGNvcnJlY3RseSByZXZlcnNlIHN0b2NrIGFuZCBXQUNzIGZvciBhIHNpbmdsZS1pdGVtIGludm9pY2Ugd2l0aCBleHBsaWNpdCBkaXN0cmlidXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBDYWxsIHRoZSBERUxFVEUgZW5kcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcSA9IG5ldyBOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7aW52b2ljZVRvRGVsZXRlSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3BvbnNlID0gYXdhaXQgZGVsZXRlUHVyY2hhc2VJbnZvaWNlKGRlbGV0ZVJlcSwgeyBwYXJhbXM6IHsgaWQ6IGludm9pY2VUb0RlbGV0ZUlkIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIDIuIEFzc2VydGlvbnMgZm9yIERFTEVURSByZXNwb25zZVxuICAgICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzcG9uc2VCb2R5ID0gYXdhaXQgZGVsZXRlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3BvbnNlQm9keS5tZXNzYWdlKS50b0JlKCdQdXJjaGFzZSBpbnZvaWNlIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICAgICAgICAgIC8vIDMuIFZlcmlmeSBQdXJjaGFzZUludm9pY2UgaXMgZGVsZXRlZCBmcm9tIERCXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBpbnZvaWNlVG9EZWxldGVJZCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlKS50b0JlTnVsbCgpO1xuXG4gICAgICAgICAgICAvLyA0LiBWZXJpZnkgUHVyY2hhc2VJbnZvaWNlSXRlbXMgYXJlIGRlbGV0ZWRcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZUl0ZW1zID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZmluZE1hbnkoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHB1cmNoYXNlSW52b2ljZUlkOiBpbnZvaWNlVG9EZWxldGVJZCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlSXRlbXMubGVuZ3RoKS50b0JlKDApO1xuXG4gICAgICAgICAgICAvLyA1LiBWZXJpZnkgSW52ZW50b3J5SXRlbSBzdG9jayBpcyByZXZlcnNlZFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBc3N1bWluZyB0aGlzIHdhcyB0aGUgb25seSBwdXJjaGFzZSwgc3RvY2sgc2hvdWxkIGJlIDBcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZSgwKTtcbiAgICAgICAgICAgIC8vIFNob3BTcGVjaWZpY0Nvc3Qgc2hvdWxkIGFsc28gYmUgMCBpZiBzdG9jayBpcyAwXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oMCk7XG5cblxuICAgICAgICAgICAgLy8gNi4gVmVyaWZ5IFByb2R1Y3QgV0FDIGlzIHJlY2FsY3VsYXRlZCAoc2hvdWxkIGJlIDAgaWYgdGhpcyB3YXMgdGhlIG9ubHkgcHVyY2hhc2UpXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElmIG5vIG90aGVyIHB1cmNoYXNlIGl0ZW1zIGZvciB0aGlzIHByb2R1Y3QsIFdBQyBzaG91bGQgYmVjb21lIDAuXG4gICAgICAgICAgICBjb25zdCBvdGhlclB1cmNoYXNlc09mUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmNvdW50KHtcbiAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JEZWxldGVUZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1cmNoYXNlSW52b2ljZUlkOiB7IG5vdDogaW52b2ljZVRvRGVsZXRlSWQgfSAvLyBOb3QgbmVlZGVkIGFzIG9yaWdpbmFsIGludm9pY2UgaXRlbXMgYXJlIGdvbmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvdGhlclB1cmNoYXNlc09mUHJvZHVjdCA9PT0gMCkgeyAvLyBUaGlzIHNob3VsZCBiZSB0cnVlIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgICAgICBleHBlY3QodXBkYXRlZFByb2R1Y3Q/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhIHB1cmNoYXNlIGFuZCByZXZlcnNlIHN0b2NrL1dBQyB3aGVuIHByb2R1Y3QgaXMgaW4gYSBzaW5nbGUgaW5mZXJyZWQgc2hvcCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIFNldHVwOiBDcmVhdGUgZGVkaWNhdGVkIGVudGl0aWVzIGZvciB0aGlzIHRlc3QgdG8gZW5zdXJlIGlzb2xhdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHRlc3RTaG9wID0gYXdhaXQgcHJpc21hLnNob3AuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IG5hbWU6ICdJbmZlcnJlZCBEZWxldGUgVGVzdCBTaG9wJywgbG9jYXRpb246ICdMb2MgWCcgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0ZXN0U3VwcGxpZXIgPSBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IG5hbWU6ICdJbmZlcnJlZCBEZWxldGUgVGVzdCBTdXBwbGllcicgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0ZXN0UHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBmb3IgSW5mZXJyZWQgRGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnSU5GREVMMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDIwMCwgLy8gcmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodGVkQXZlcmFnZUNvc3Q6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGludmVudG9yeSBpdGVtIGZvciB0aGlzIHByb2R1Y3QgaW4gdGhlIHRlc3Qgc2hvcC5cbiAgICAgICAgICAgIC8vIFRoaXMgbWFrZXMgaXQgdGhlIFwic2luZ2xlIGluZmVycmVkIHNob3BcIi5cbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHRlc3RQcm9kdWN0LmlkLFxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IHRlc3RTaG9wLmlkLFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogMCwgLy8gV2lsbCBiZSB1cGRhdGVkIGJ5IHRoZSBwdXJjaGFzZVxuICAgICAgICAgICAgICAgICAgICBzaG9wU3BlY2lmaWNDb3N0OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUXVhbnRpdHkgPSAxMjtcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUHJpY2UgPSA2MDtcblxuICAgICAgICAgICAgY29uc3QgaW5mZXJyZWRTaG9wSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogdGVzdFN1cHBsaWVyLmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogdGVzdFByb2R1Y3QuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyBOTyBkaXN0cmlidXRpb25zIHByb3BlcnR5IGhlcmUgZm9yIGluZmVyZW5jZSB0byBraWNrIGluIG9uIFBPU1RcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogcHVyY2hhc2VRdWFudGl0eSAqIHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHB1cmNoYXNlIGludm9pY2UgKHRoaXMgaXMgd2hlcmUgdGhlIGZhaWx1cmUgd2FzIGhhcHBlbmluZylcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlcSA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGluZmVycmVkU2hvcEludm9pY2VQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UoY3JlYXRlUmVxKTtcbiAgICAgICAgICAgIGV4cGVjdChjcmVhdGVSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTsgLy8gQXNzZXJ0IHN1Y2Nlc3NmdWwgY3JlYXRpb25cblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlQm9keSA9IGF3YWl0IGNyZWF0ZVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGludm9pY2VJZEZvckluZmVycmVkRGVsZXRlID0gY3JlYXRlQm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IFZlcmlmeSBzdG9jayBhbmQgV0FDIGFmdGVyIGNyZWF0aW9uXG4gICAgICAgICAgICBjb25zdCBpbnZlbnRvcnlBZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiB0ZXN0UHJvZHVjdC5pZCwgc2hvcElkOiB0ZXN0U2hvcC5pZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZlbnRvcnlBZnRlckNyZWF0ZT8ucXVhbnRpdHkpLnRvQmUocHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoaW52ZW50b3J5QWZ0ZXJDcmVhdGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKHB1cmNoYXNlUHJpY2UpO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdEFmdGVyQ3JlYXRlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0UHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHByb2R1Y3RBZnRlckNyZWF0ZT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8ocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIDIuIENhbGwgdGhlIERFTEVURSBlbmRwb2ludFxuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtpbnZvaWNlSWRGb3JJbmZlcnJlZERlbGV0ZX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzcG9uc2UgPSBhd2FpdCBkZWxldGVQdXJjaGFzZUludm9pY2UoZGVsZXRlUmVxLCB7IHBhcmFtczogeyBpZDogaW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGUgfSB9KTtcblxuICAgICAgICAgICAgLy8gMy4gQXNzZXJ0aW9ucyBmb3IgREVMRVRFIHJlc3BvbnNlXG4gICAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXNwb25zZUJvZHkgPSBhd2FpdCBkZWxldGVSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzcG9uc2VCb2R5Lm1lc3NhZ2UpLnRvQmUoJ1B1cmNoYXNlIGludm9pY2UgZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcblxuICAgICAgICAgICAgLy8gNC4gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBhbmQgSXRlbXMgYXJlIGRlbGV0ZWRcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBpbnZvaWNlSWRGb3JJbmZlcnJlZERlbGV0ZSB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZUl0ZW1zID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZmluZE1hbnkoeyB3aGVyZTogeyBwdXJjaGFzZUludm9pY2VJZDogaW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGUgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2VJdGVtcy5sZW5ndGgpLnRvQmUoMCk7XG5cbiAgICAgICAgICAgIC8vIDUuIFZlcmlmeSBJbnZlbnRvcnlJdGVtIHN0b2NrIGFuZCBzaG9wU3BlY2lmaWNDb3N0IGFyZSByZXZlcnNlZCBpbiB0aGUgaW5mZXJyZWQgc2hvcFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiB0ZXN0UHJvZHVjdC5pZCwgc2hvcElkOiB0ZXN0U2hvcC5pZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZSgwKTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbygwKTtcblxuICAgICAgICAgICAgLy8gNi4gVmVyaWZ5IFByb2R1Y3QgV0FDIGlzIHJlY2FsY3VsYXRlZCB0byAwXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdERCID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0UHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0REI/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICAvLyBDbGVhbnVwIGRlZGljYXRlZCBlbnRpdGllcyBmb3IgdGhpcyB0ZXN0XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5kZWxldGVNYW55KHsgd2hlcmU6IHsgcHJvZHVjdElkOiB0ZXN0UHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnByb2R1Y3QuZGVsZXRlKHsgd2hlcmU6IHsgaWQ6IHRlc3RQcm9kdWN0LmlkIH0gfSk7XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuZGVsZXRlKHsgd2hlcmU6IHsgaWQ6IHRlc3RTdXBwbGllci5pZCB9IH0pO1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnNob3AuZGVsZXRlKHsgd2hlcmU6IHsgaWQ6IHRlc3RTaG9wLmlkIH0gfSk7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gQWRkZWQgYSBsb25nZXIgdGltZW91dCBhcyBhIHByZWNhdXRpb25cblxuICAgICAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhbiBpbnZvaWNlIHdpdGggbXVsdGlwbGUgaXRlbXMsIHJldmVyc2luZyBzdG9jay9XQUMgZm9yIGVhY2gnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBTZXR1cDogQ3JlYXRlIG11bHRpcGxlIHByb2R1Y3RzIGFuZCBhbiBpbnZvaWNlIHdpdGggaXRlbXMgZnJvbSB0aGVzZSBwcm9kdWN0cy5cbiAgICAgICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCBkaXN0cmlidXRlIGVhY2ggdG8gdGhlIG1haW4gY3JlYXRlZFNob3BJZCBmcm9tIGdsb2JhbCBiZWZvcmVFYWNoLlxuXG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0QSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBuYW1lOiAnTXVsdGktRGVsIFByb2QgQScsIHNrdTogJ01ERUwwMEEnLCBwcmljZTogMTAwLCB3ZWlnaHRlZEF2ZXJhZ2VDb3N0OiAwIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdEIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHsgbmFtZTogJ011bHRpLURlbCBQcm9kIEInLCBza3U6ICdNREVMMDBCJywgcHJpY2U6IDIwMCwgd2VpZ2h0ZWRBdmVyYWdlQ29zdDogMCB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlBID0gNTtcbiAgICAgICAgICAgIGNvbnN0IHByaWNlQSA9IDUwO1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlCID0gMztcbiAgICAgICAgICAgIGNvbnN0IHByaWNlQiA9IDEyMDtcblxuICAgICAgICAgICAgY29uc3QgbXVsdGlJdGVtSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcm9kdWN0SWQ6IHByb2R1Y3RBLmlkLnRvU3RyaW5nKCksIHF1YW50aXR5OiBxdWFudGl0eUEsIHByaWNlOiBwcmljZUEgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcm9kdWN0SWQ6IHByb2R1Y3RCLmlkLnRvU3RyaW5nKCksIHF1YW50aXR5OiBxdWFudGl0eUIsIHByaWNlOiBwcmljZUIgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHF1YW50aXR5QSB9LCAvLyBJdGVtIEEgdG8gbWFpbiBzaG9wXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBxdWFudGl0eUIgfSAgLy8gSXRlbSBCIHRvIG1haW4gc2hvcFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IChxdWFudGl0eUEgKiBwcmljZUEpICsgKHF1YW50aXR5QiAqIHByaWNlQiksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVSZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBtdWx0aUl0ZW1JbnZvaWNlUGF5bG9hZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UoY3JlYXRlUmVxKTtcbiAgICAgICAgICAgIGV4cGVjdChjcmVhdGVSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJvZHkgPSBhd2FpdCBjcmVhdGVSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCBtdWx0aUl0ZW1JbnZvaWNlSWQgPSBjcmVhdGVCb2R5LmRhdGEuaWQ7XG5cbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjayBpbnZlbnRvcnkgYW5kIFdBQyBhZnRlciBjcmVhdGlvblxuICAgICAgICAgICAgY29uc3QgaW52QV9hZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEEuaWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkFfYWZ0ZXJDcmVhdGU/LnF1YW50aXR5KS50b0JlKHF1YW50aXR5QSk7XG4gICAgICAgICAgICBleHBlY3QoaW52QV9hZnRlckNyZWF0ZT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShwcmljZUEpO1xuICAgICAgICAgICAgY29uc3QgcHJvZEFfYWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RBLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QocHJvZEFfYWZ0ZXJDcmVhdGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmUocHJpY2VBKTtcblxuICAgICAgICAgICAgY29uc3QgaW52Ql9hZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEIuaWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkJfYWZ0ZXJDcmVhdGU/LnF1YW50aXR5KS50b0JlKHF1YW50aXR5Qik7XG4gICAgICAgICAgICBleHBlY3QoaW52Ql9hZnRlckNyZWF0ZT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShwcmljZUIpO1xuICAgICAgICAgICAgY29uc3QgcHJvZEJfYWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RCLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QocHJvZEJfYWZ0ZXJDcmVhdGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmUocHJpY2VCKTtcblxuICAgICAgICAgICAgLy8gMi4gQ2FsbCBERUxFVEUgZW5kcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcSA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7bXVsdGlJdGVtSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXNwb25zZSA9IGF3YWl0IGRlbGV0ZVB1cmNoYXNlSW52b2ljZShkZWxldGVSZXEsIHsgcGFyYW1zOiB7IGlkOiBtdWx0aUl0ZW1JbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkZWxldGVSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcblxuICAgICAgICAgICAgLy8gMy4gVmVyaWZ5IGludm9pY2UgYW5kIGl0ZW1zIGFyZSBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogbXVsdGlJdGVtSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlKS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlSXRlbXMgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5maW5kTWFueSh7IHdoZXJlOiB7IHB1cmNoYXNlSW52b2ljZUlkOiBtdWx0aUl0ZW1JbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2VJdGVtcy5sZW5ndGgpLnRvQmUoMCk7XG5cbiAgICAgICAgICAgIC8vIDQuIFZlcmlmeSBzdG9jayBhbmQgV0FDIGZvciBQcm9kdWN0IEEgYXJlIHJldmVyc2VkXG4gICAgICAgICAgICBjb25zdCBpbnZBX2FmdGVyRGVsZXRlID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHsgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0QS5pZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52QV9hZnRlckRlbGV0ZT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICBleHBlY3QoaW52QV9hZnRlckRlbGV0ZT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oMCk7XG4gICAgICAgICAgICBjb25zdCBwcm9kQV9hZnRlckRlbGV0ZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEEuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChwcm9kQV9hZnRlckRlbGV0ZT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oMCk7XG5cbiAgICAgICAgICAgIC8vIDUuIFZlcmlmeSBzdG9jayBhbmQgV0FDIGZvciBQcm9kdWN0IEIgYXJlIHJldmVyc2VkXG4gICAgICAgICAgICBjb25zdCBpbnZCX2FmdGVyRGVsZXRlID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHsgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Qi5pZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52Ql9hZnRlckRlbGV0ZT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICBleHBlY3QoaW52Ql9hZnRlckRlbGV0ZT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oMCk7XG4gICAgICAgICAgICBjb25zdCBwcm9kQl9hZnRlckRlbGV0ZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEIuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChwcm9kQl9hZnRlckRlbGV0ZT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oMCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHByb2R1Y3RzIGFuZCB0aGVpciBpbnZlbnRvcnkgaXRlbXMgY3JlYXRlZCBmb3IgdGhpcyB0ZXN0XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5kZWxldGVNYW55KHsgd2hlcmU6IHsgcHJvZHVjdElkOiB7IGluOiBbcHJvZHVjdEEuaWQsIHByb2R1Y3RCLmlkXSB9IH0gfSk7XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEucHJvZHVjdC5kZWxldGVNYW55KHsgd2hlcmU6IHsgaWQ6IHsgaW46IFtwcm9kdWN0QS5pZCwgcHJvZHVjdEIuaWRdIH0gfSB9KTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBUaW1lb3V0IGZvciBzYWZldHlcbiAgICB9KTtcblxufSk7Il0sIm5hbWVzIjpbImNyZWF0ZU1vY2tOZXh0UmVxdWVzdCIsInVybCIsIm9wdGlvbnMiLCJtZXRob2QiLCJib2R5IiwiaGVhZGVycyIsIkhlYWRlcnMiLCJqc29uIiwiSlNPTiIsInBhcnNlIiwidGV4dCIsInN0cmluZ2lmeSIsInByaXNtYSIsIlByaXNtYUNsaWVudCIsImRlc2NyaWJlIiwiY3JlYXRlZFNob3BJZCIsImNyZWF0ZWRTdXBwbGllcklkIiwiY3JlYXRlZFByb2R1Y3RJZCIsImJlZm9yZUFsbCIsImJlZm9yZUVhY2giLCJwdXJjaGFzZUludm9pY2VJdGVtIiwiZGVsZXRlTWFueSIsInB1cmNoYXNlSW52b2ljZSIsImludmVudG9yeUl0ZW0iLCJwcm9kdWN0Iiwic3VwcGxpZXIiLCJzaG9wIiwiY3JlYXRlIiwiZGF0YSIsIm5hbWUiLCJsb2NhdGlvbiIsImlkIiwicHJpY2UiLCJza3UiLCJzaG9wSWQiLCJhZnRlckFsbCIsIiRkaXNjb25uZWN0IiwiaXQiLCJuZXdQcm9kdWN0TmFtZSIsIm5ld1Byb2R1Y3RTa3UiLCJwdXJjaGFzZVByaWNlIiwicHVyY2hhc2VRdWFudGl0eSIsIm5ld1Rlc3RQcm9kdWN0IiwibmV3VGVzdFByb2R1Y3RJZCIsInB1cmNoYXNlSW52b2ljZVBheWxvYWQiLCJzdXBwbGllcklkIiwidG9TdHJpbmciLCJkYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiaXRlbXMiLCJwcm9kdWN0SWQiLCJxdWFudGl0eSIsImRpc3RyaWJ1dGlvbnMiLCJ0b3RhbEFtb3VudCIsInN0YXR1cyIsInJlcSIsInJlc3BvbnNlIiwiY3JlYXRlUHVyY2hhc2VJbnZvaWNlIiwicmVzcG9uc2VCb2R5IiwiZXhwZWN0IiwidG9CZSIsInRvSGF2ZVByb3BlcnR5IiwiY3JlYXRlZEludm9pY2VJZCIsImRiSW52b2ljZSIsImZpbmRVbmlxdWUiLCJ3aGVyZSIsImluY2x1ZGUiLCJub3QiLCJ0b0JlTnVsbCIsImxlbmd0aCIsImRiSW52ZW50b3J5SXRlbSIsImZpbmRGaXJzdCIsInNob3BTcGVjaWZpY0Nvc3QiLCJkYlByb2R1Y3QiLCJ3ZWlnaHRlZEF2ZXJhZ2VDb3N0IiwiaW5pdGlhbFB1cmNoYXNlUHJpY2UiLCJpbml0aWFsUHVyY2hhc2VRdWFudGl0eSIsImV4aXN0aW5nUHJvZHVjdElkIiwiaW5pdGlhbFBheWxvYWQiLCJub3ciLCJpbml0aWFsUmVxIiwiTmV4dFJlcXVlc3QiLCJwcm9kdWN0QmVmb3JlTmV3UHVyY2hhc2UiLCJpbnZlbnRvcnlCZWZvcmVOZXdQdXJjaGFzZSIsIm5ld1B1cmNoYXNlUHJpY2UiLCJuZXdQdXJjaGFzZVF1YW50aXR5IiwiZXhwZWN0ZWRUb3RhbFF1YW50aXR5IiwiZXhwZWN0ZWRTaG9wU3BlY2lmaWNDb3N0IiwidG9CZUNsb3NlVG8iLCJleHBlY3RlZFByb2R1Y3RXQUMiLCJwcm9kdWN0MURhdGEiLCJwcm9kdWN0MkRhdGEiLCJwcm9kdWN0MSIsInByb2R1Y3QyIiwicHVyY2hhc2VQcmljZTEiLCJwdXJjaGFzZVF1YW50aXR5MSIsInB1cmNoYXNlUHJpY2UyIiwicHVyY2hhc2VRdWFudGl0eTIiLCJvcmRlckJ5Iiwic29ydGVkUHJvZHVjdHMiLCJzb3J0IiwiYSIsImIiLCJkYkludmVudG9yeUl0ZW0xIiwiZGJQcm9kdWN0MSIsImRiSW52ZW50b3J5SXRlbTIiLCJkYlByb2R1Y3QyIiwic2hvcEEiLCJzaG9wQiIsInRvdGFsUXVhbnRpdHkiLCJxdWFudGl0eUZvclNob3BBIiwicXVhbnRpdHlGb3JTaG9wQiIsImludkl0ZW1BIiwiaW52SXRlbUIiLCJub25FeGlzdGVudFByb2R1Y3RJZCIsImVycm9yIiwidG9CZURlZmluZWQiLCJub25FeGlzdGVudFN1cHBsaWVySWQiLCJleGlzdGluZ0ludm9pY2VJZCIsInByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkIiwiaW5pdGlhbEludm9pY2VQYXlsb2FkIiwiaW5pdGlhbFByb2R1Y3QiLCJpbml0aWFsSW52ZW50b3J5IiwicXVhbnRpdHlJbmNyZWFzZSIsIm5ld1F1YW50aXR5IiwidXBkYXRlZFByaWNlRm9ySXRlbSIsInVwZGF0ZVBheWxvYWQiLCJ1cGRhdGVQdXJjaGFzZUludm9pY2UiLCJwYXJhbXMiLCJ1cGRhdGVkSW52ZW50b3J5IiwidXBkYXRlZFByb2R1Y3QiLCJ0b3RhbCIsInF1YW50aXR5RGVjcmVhc2UiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwibmV3UHJpY2VGb3JJdGVtIiwicXVhbnRpdHlVbmNoYW5nZWQiLCJuZXdJdGVtUHJvZHVjdCIsIm5ld0l0ZW1Qcm9kdWN0SWQiLCJuZXdJdGVtUXVhbnRpdHkiLCJuZXdJdGVtUHJpY2UiLCJvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQiLCJvcmlnaW5hbEl0ZW1RdWFudGl0eSIsIm9yaWdpbmFsSXRlbVByaWNlIiwiZXhwZWN0ZWRUb3RhbCIsImRiT3JpZ2luYWxJdGVtIiwiZmluZCIsIml0ZW0iLCJkYk5ld0l0ZW0iLCJvcmlnaW5hbEludmVudG9yeSIsIm9yaWdpbmFsUHJvZHVjdCIsIm5ld0ludmVudG9yeSIsIm5ld1Byb2R1Y3REYiIsInByb2R1Y3RUb1JlbW92ZSIsInByb2R1Y3RUb1JlbW92ZUlkIiwicHJvZHVjdFRvUmVtb3ZlUXVhbnRpdHkiLCJwcm9kdWN0VG9SZW1vdmVQcmljZSIsImFkZFNlY29uZEl0ZW1QYXlsb2FkIiwiYWRkUmVxIiwiaW52b2ljZVdpdGhUd29JdGVtcyIsInVwZGF0ZVBheWxvYWRUb1JlbW92ZUl0ZW0iLCJyZW1vdmVSZXEiLCJrZXB0SW52ZW50b3J5Iiwia2VwdFByb2R1Y3QiLCJyZW1vdmVkSW52ZW50b3J5IiwicmVtb3ZlZFByb2R1Y3REYiIsIm90aGVyUHVyY2hhc2VzT2ZSZW1vdmVkSXRlbSIsImNvdW50IiwiaW52b2ljZVRvRGVsZXRlSWQiLCJwcm9kdWN0Rm9yRGVsZXRlVGVzdElkIiwiZGVsZXRlVGVzdEluaXRpYWxQcmljZSIsImRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHkiLCJpbml0aWFsUHJvZHVjdERCIiwiZGVsZXRlUmVxIiwiZGVsZXRlUmVzcG9uc2UiLCJkZWxldGVQdXJjaGFzZUludm9pY2UiLCJkZWxldGVSZXNwb25zZUJvZHkiLCJtZXNzYWdlIiwiZGJJbnZvaWNlSXRlbXMiLCJmaW5kTWFueSIsInB1cmNoYXNlSW52b2ljZUlkIiwib3RoZXJQdXJjaGFzZXNPZlByb2R1Y3QiLCJ0ZXN0U2hvcCIsInRlc3RTdXBwbGllciIsInRlc3RQcm9kdWN0IiwiaW5mZXJyZWRTaG9wSW52b2ljZVBheWxvYWQiLCJjcmVhdGVSZXEiLCJjcmVhdGVSZXNwb25zZSIsImNyZWF0ZUJvZHkiLCJpbnZvaWNlSWRGb3JJbmZlcnJlZERlbGV0ZSIsImludmVudG9yeUFmdGVyQ3JlYXRlIiwicHJvZHVjdEFmdGVyQ3JlYXRlIiwidXBkYXRlZFByb2R1Y3REQiIsImRlbGV0ZSIsInByb2R1Y3RBIiwicHJvZHVjdEIiLCJxdWFudGl0eUEiLCJwcmljZUEiLCJxdWFudGl0eUIiLCJwcmljZUIiLCJtdWx0aUl0ZW1JbnZvaWNlUGF5bG9hZCIsIm11bHRpSXRlbUludm9pY2VJZCIsImludkFfYWZ0ZXJDcmVhdGUiLCJwcm9kQV9hZnRlckNyZWF0ZSIsImludkJfYWZ0ZXJDcmVhdGUiLCJwcm9kQl9hZnRlckNyZWF0ZSIsImludkFfYWZ0ZXJEZWxldGUiLCJwcm9kQV9hZnRlckRlbGV0ZSIsImludkJfYWZ0ZXJEZWxldGUiLCJwcm9kQl9hZnRlckRlbGV0ZSIsImluIl0sIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7Ozt3QkFDNEI7dUJBQ2lCO3dCQUNEO0FBVzdDLDZDQUE2QztBQUM3QyxNQUFNQSx3QkFBd0IsQ0FBQ0MsS0FBYUMsVUFJeEMsQ0FBQyxDQUFDO0lBQ0osTUFBTSxFQUFFQyxTQUFTLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFLEdBQUdIO0lBQy9DLE9BQU87UUFDTEM7UUFDQUY7UUFDQUksU0FBUyxJQUFJQyxRQUFRRDtRQUNyQkUsTUFB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