7ce070993d32bf3dcd3888750e724f3a
// Fixed Unit tests for AuthService
// This file tests the authentication service functionality
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _authService = require("../../src/services/authService");
const _jsonwebtoken = /*#__PURE__*/ _interop_require_wildcard(require("jsonwebtoken"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock dependencies BEFORE importing the service
const mockCacheService = {
    get: _globals.jest.fn(),
    set: _globals.jest.fn(),
    delete: _globals.jest.fn(),
    increment: _globals.jest.fn(),
    generateKey: _globals.jest.fn(),
    clear: _globals.jest.fn()
};
const mockPrisma = {
    user: {
        findUnique: _globals.jest.fn(),
        findFirst: _globals.jest.fn(),
        create: _globals.jest.fn(),
        update: _globals.jest.fn(),
        findMany: _globals.jest.fn(),
        delete: _globals.jest.fn()
    },
    permission: {
        findMany: _globals.jest.fn()
    },
    session: {
        create: _globals.jest.fn(),
        findUnique: _globals.jest.fn(),
        update: _globals.jest.fn(),
        deleteMany: _globals.jest.fn()
    },
    auditLog: {
        create: _globals.jest.fn()
    }
};
const mockBcrypt = {
    compare: _globals.jest.fn(),
    hash: _globals.jest.fn(),
    genSalt: _globals.jest.fn()
};
// Mock modules
_globals.jest.mock("@/lib/prisma", ()=>({
        __esModule: true,
        default: mockPrisma
    }));
_globals.jest.mock("@/lib/cache", ()=>({
        __esModule: true,
        cacheService: mockCacheService,
        cache: mockCacheService,
        CACHE_CONFIG: {
            KEYS: {
                USER_SESSION: "user_session",
                TOKEN_VALIDATION: "token_validation"
            },
            TTL: {
                USER_SESSION: 3600,
                TOKEN_VALIDATION: 1800
            }
        }
    }));
_globals.jest.mock("bcryptjs", ()=>mockBcrypt);
// Mock jsonwebtoken with a simple approach
const mockJwt = {
    sign: _globals.jest.fn(),
    verify: _globals.jest.fn(),
    decode: _globals.jest.fn(),
    TokenExpiredError: class extends Error {
        constructor(message, expiredAt){
            super(message);
            this.name = "TokenExpiredError";
            this.expiredAt = expiredAt || new Date();
        }
    },
    JsonWebTokenError: class extends Error {
        constructor(message){
            super(message);
            this.name = "JsonWebTokenError";
        }
    }
};
_globals.jest.mock("jsonwebtoken", ()=>mockJwt);
// Spy on the imported jwt to ensure our mocks work
const jwtVerifySpy = _globals.jest.spyOn(_jsonwebtoken, "verify");
const jwtSignSpy = _globals.jest.spyOn(_jsonwebtoken, "sign");
// Create proper mock types for easier access
const mockUserFindFirst = mockPrisma.user.findFirst;
const mockPermissionFindMany = mockPrisma.permission.findMany;
// mockJwt is already defined above
describe("AuthService", ()=>{
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        process.env.JWT_SECRET = "test-secret-key";
        process.env.JWT_ACCESS_TOKEN_EXPIRES_IN = "12h";
        // Setup default cache mocks
        mockCacheService.generateKey.mockReturnValue("mock-cache-key");
        mockCacheService.get.mockResolvedValue(null);
        mockCacheService.set.mockResolvedValue(true);
        mockCacheService.delete.mockResolvedValue(true);
        // Reset Prisma mocks
        mockUserFindFirst.mockResolvedValue(null);
        mockPermissionFindMany.mockResolvedValue([]);
        // Reset JWT mocks
        mockJwt.sign.mockReturnValue("mocked-jwt-token");
        mockJwt.verify.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
        mockJwt.decode.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
        jwtVerifySpy.mockClear();
        jwtSignSpy.mockClear();
    });
    describe("parseTimeStringToSeconds", ()=>{
        test("should parse seconds correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("30s")).toBe(30);
        });
        test("should parse minutes correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("5m")).toBe(300);
        });
        test("should parse hours correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("2h")).toBe(7200);
        });
        test("should parse days correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("1d")).toBe(86400);
        });
        test("should return 0 for invalid input", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("invalid")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("abc")).toBe(0);
        });
        test("should handle edge cases", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("0s")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("100x")).toBe(100); // Falls back to parsing the number part
        });
    });
    describe("authenticateUser", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            password: "hashedpassword",
            isActive: true,
            roleId: 1,
            shopId: 1,
            roleName: "admin",
            permissions: null,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should authenticate valid user credentials", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(true);
            mockJwt.sign.mockReturnValue("mock-jwt-token");
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(true);
            expect(result.token).toBe("mock-jwt-token");
            expect(result.user).toEqual({
                id: 1,
                email: "test@example.com",
                username: "testuser",
                fullName: "testuser",
                roleId: 1,
                roleName: "admin",
                shopId: 1,
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockUserFindFirst).toHaveBeenCalledWith({
                where: {
                    email: "test@example.com",
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            });
        });
        test("should reject invalid email", async ()=>{
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.authenticateUser)("invalid@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject invalid password", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(false);
            const result = await (0, _authService.authenticateUser)("test@example.com", "wrongpassword");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject inactive user", async ()=>{
            mockUserFindFirst.mockResolvedValue(null); // findFirst with isActive: true returns null
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should handle database errors gracefully", async ()=>{
            mockUserFindFirst.mockRejectedValue(new Error("Database connection failed"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
        test("should handle bcrypt errors gracefully", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockRejectedValue(new Error("Bcrypt error"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
    });
    describe("generateToken", ()=>{
        const mockPayload = {
            sub: 1,
            username: "testuser",
            email: "test@example.com",
            roleId: 1,
            shopId: 1,
            permissions: [
                "read_products",
                "write_products"
            ]
        };
        test("should generate JWT token", ()=>{
            const mockToken = "mock-jwt-token";
            mockJwt.sign.mockReturnValue(mockToken);
            const result = (0, _authService.generateToken)(mockPayload);
            expect(result).toBe(mockToken);
            expect(mockJwt.sign).toHaveBeenCalledWith(mockPayload, "test-secret-key", {
                expiresIn: "12h"
            });
        });
    });
    describe("verifyToken", ()=>{
        test("should verify valid token from cache", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should verify valid token and cache result", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockJwt.verify.mockReturnValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockJwt.verify).toHaveBeenCalledWith("valid-token", "test-secret-key");
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            const invalidError = new Error("Invalid token");
            mockJwt.verify.mockImplementation(()=>{
                throw invalidError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw invalidError;
            });
            await expect((0, _authService.verifyToken)("invalid-token")).rejects.toThrow("Invalid token");
        });
        test("should throw error for expired token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            const expiredError = new mockJwt.TokenExpiredError("Token expired", new Date());
            mockJwt.verify.mockImplementation(()=>{
                throw expiredError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw expiredError;
            });
            await expect((0, _authService.verifyToken)("expired-token")).rejects.toThrow("Token expired");
        });
    });
    describe("getUserFromDecodedPayload", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            isActive: true,
            roleId: 1,
            shopId: 1,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should return user from cache", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const cachedUser = {
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            };
            mockCacheService.get.mockResolvedValue(cachedUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual(cachedUser);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should return user from database and cache it", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockUserFindFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should return null for null payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)(null);
            expect(result).toBeNull();
        });
        test("should return null for invalid payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)({});
            expect(result).toBeNull();
        });
        test("should return null when user not found", async ()=>{
            const payload = {
                sub: 999,
                username: "nonexistent",
                email: "nonexistent@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null);
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toBeNull();
        });
    });
    describe("getUserFromToken", ()=>{
        test("should return user from valid token", async ()=>{
            const mockPayload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const mockUser = {
                id: 1,
                email: "test@example.com",
                name: "testuser",
                isActive: true,
                roleId: 1,
                shopId: 1,
                role: {
                    id: 1,
                    name: "admin",
                    permissions: [
                        {
                            name: "read_products"
                        }
                    ]
                }
            };
            // Mock verifyToken to return payload
            mockCacheService.get.mockResolvedValue(null);
            mockCacheService.generateKey.mockReturnValue("test-cache-key");
            mockCacheService.set.mockResolvedValue(undefined);
            mockJwt.verify.mockReturnValue(mockPayload);
            jwtVerifySpy.mockReturnValue(mockPayload);
            // Mock getUserFromDecodedPayload
            mockUserFindFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromToken)("valid-token");
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products"
                ]
            });
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockCacheService.generateKey.mockReturnValue("test-cache-key");
            // Mock both the direct mock and the spy
            const jwtError = new mockJwt.JsonWebTokenError("jwt malformed");
            mockJwt.verify.mockImplementation(()=>{
                throw jwtError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw jwtError;
            });
            await expect((0, _authService.getUserFromToken)("invalid")).rejects.toThrow("jwt malformed");
        });
    });
    describe("Error Handling", ()=>{
        test("should handle missing JWT_SECRET", async ()=>{
            const originalSecret = process.env.JWT_SECRET;
            delete process.env.JWT_SECRET;
            mockCacheService.get.mockResolvedValue(null);
            const secretError = new Error("secretOrPrivateKey must have a value");
            mockJwt.verify.mockImplementation(()=>{
                throw secretError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw secretError;
            });
            await expect((0, _authService.verifyToken)("any-token")).rejects.toThrow();
            // Restore the secret
            process.env.JWT_SECRET = originalSecret;
        });
        test("should handle malformed tokens gracefully", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            // Mock both the direct mock and the spy
            const jwtError = new mockJwt.JsonWebTokenError("jwt malformed");
            mockJwt.verify.mockImplementation(()=>{
                throw jwtError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw jwtError;
            });
            await expect((0, _authService.verifyToken)("malformed-token")).rejects.toThrow("jwt malformed");
        });
        test("should handle empty token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            await expect((0, _authService.verifyToken)("")).rejects.toThrow("jwt must be provided");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9hdXRoU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpeGVkIFVuaXQgdGVzdHMgZm9yIEF1dGhTZXJ2aWNlXG4vLyBUaGlzIGZpbGUgdGVzdHMgdGhlIGF1dGhlbnRpY2F0aW9uIHNlcnZpY2UgZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzIEJFRk9SRSBpbXBvcnRpbmcgdGhlIHNlcnZpY2VcbmNvbnN0IG1vY2tDYWNoZVNlcnZpY2UgPSB7XG4gIGdldDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgc2V0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBkZWxldGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGluY3JlbWVudDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgZ2VuZXJhdGVLZXk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGNsZWFyOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxufTtcblxuY29uc3QgbW9ja1ByaXNtYSA9IHtcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZEZpcnN0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICAgIGNyZWF0ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICB9LFxuICBwZXJtaXNzaW9uOiB7XG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG4gIHNlc3Npb246IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlTWFueTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgfSxcbiAgYXVkaXRMb2c6IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG59O1xuXG5jb25zdCBtb2NrQmNyeXB0ID0ge1xuICBjb21wYXJlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBoYXNoOiBqZXN0LmZuKCksXG4gIGdlblNhbHQ6IGplc3QuZm4oKSxcbn07XG5cbi8vIE1vY2sgbW9kdWxlc1xuamVzdC5tb2NrKCdAL2xpYi9wcmlzbWEnLCAoKSA9PiAoe1xuICBfX2VzTW9kdWxlOiB0cnVlLFxuICBkZWZhdWx0OiBtb2NrUHJpc21hLFxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvbGliL2NhY2hlJywgKCkgPT4gKHtcbiAgX19lc01vZHVsZTogdHJ1ZSxcbiAgY2FjaGVTZXJ2aWNlOiBtb2NrQ2FjaGVTZXJ2aWNlLFxuICBjYWNoZTogbW9ja0NhY2hlU2VydmljZSxcbiAgQ0FDSEVfQ09ORklHOiB7XG4gICAgS0VZUzoge1xuICAgICAgVVNFUl9TRVNTSU9OOiAndXNlcl9zZXNzaW9uJyxcbiAgICAgIFRPS0VOX1ZBTElEQVRJT046ICd0b2tlbl92YWxpZGF0aW9uJyxcbiAgICB9LFxuICAgIFRUTDoge1xuICAgICAgVVNFUl9TRVNTSU9OOiAzNjAwLFxuICAgICAgVE9LRU5fVkFMSURBVElPTjogMTgwMCxcbiAgICB9LFxuICB9LFxufSkpO1xuXG5qZXN0Lm1vY2soJ2JjcnlwdGpzJywgKCkgPT4gbW9ja0JjcnlwdCk7XG4vLyBNb2NrIGpzb253ZWJ0b2tlbiB3aXRoIGEgc2ltcGxlIGFwcHJvYWNoXG5jb25zdCBtb2NrSnd0ID0ge1xuICBzaWduOiBqZXN0LmZuKCksXG4gIHZlcmlmeTogamVzdC5mbigpLFxuICBkZWNvZGU6IGplc3QuZm4oKSxcbiAgVG9rZW5FeHBpcmVkRXJyb3I6IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgIGV4cGlyZWRBdDogRGF0ZTtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGV4cGlyZWRBdD86IERhdGUpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuRXhwaXJlZEVycm9yJztcbiAgICAgIHRoaXMuZXhwaXJlZEF0ID0gZXhwaXJlZEF0IHx8IG5ldyBEYXRlKCk7XG4gICAgfVxuICB9LFxuICBKc29uV2ViVG9rZW5FcnJvcjogY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIHRoaXMubmFtZSA9ICdKc29uV2ViVG9rZW5FcnJvcic7XG4gICAgfVxuICB9LFxufTtcblxuamVzdC5tb2NrKCdqc29ud2VidG9rZW4nLCAoKSA9PiBtb2NrSnd0KTtcblxuLy8gSW1wb3J0IGFmdGVyIG1vY2tpbmdcbmltcG9ydCB7IGF1dGhlbnRpY2F0ZVVzZXIsIGdlbmVyYXRlVG9rZW4sIHZlcmlmeVRva2VuLCBwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMsIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQsIGdldFVzZXJGcm9tVG9rZW4gfSBmcm9tICdAL3NlcnZpY2VzL2F1dGhTZXJ2aWNlJztcbmltcG9ydCAqIGFzIGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuXG4vLyBTcHkgb24gdGhlIGltcG9ydGVkIGp3dCB0byBlbnN1cmUgb3VyIG1vY2tzIHdvcmtcbmNvbnN0IGp3dFZlcmlmeVNweSA9IGplc3Quc3B5T24oand0LCAndmVyaWZ5Jyk7XG5jb25zdCBqd3RTaWduU3B5ID0gamVzdC5zcHlPbihqd3QsICdzaWduJyk7XG5cbi8vIENyZWF0ZSBwcm9wZXIgbW9jayB0eXBlcyBmb3IgZWFzaWVyIGFjY2Vzc1xuY29uc3QgbW9ja1VzZXJGaW5kRmlyc3QgPSBtb2NrUHJpc21hLnVzZXIuZmluZEZpcnN0IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PjtcbmNvbnN0IG1vY2tQZXJtaXNzaW9uRmluZE1hbnkgPSBtb2NrUHJpc21hLnBlcm1pc3Npb24uZmluZE1hbnkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuLy8gbW9ja0p3dCBpcyBhbHJlYWR5IGRlZmluZWQgYWJvdmVcblxuZGVzY3JpYmUoJ0F1dGhTZXJ2aWNlJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtc2VjcmV0LWtleSc7XG4gICAgcHJvY2Vzcy5lbnYuSldUX0FDQ0VTU19UT0tFTl9FWFBJUkVTX0lOID0gJzEyaCc7XG4gICAgXG4gICAgLy8gU2V0dXAgZGVmYXVsdCBjYWNoZSBtb2Nrc1xuICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkubW9ja1JldHVyblZhbHVlKCdtb2NrLWNhY2hlLWtleScpO1xuICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgIG1vY2tDYWNoZVNlcnZpY2Uuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuICAgIG1vY2tDYWNoZVNlcnZpY2UuZGVsZXRlLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuICAgIFxuICAgIC8vIFJlc2V0IFByaXNtYSBtb2Nrc1xuICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgIG1vY2tQZXJtaXNzaW9uRmluZE1hbnkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgIFxuICAgIC8vIFJlc2V0IEpXVCBtb2Nrc1xuICAgIG1vY2tKd3Quc2lnbi5tb2NrUmV0dXJuVmFsdWUoJ21vY2tlZC1qd3QtdG9rZW4nKTtcbiAgICBtb2NrSnd0LnZlcmlmeS5tb2NrUmV0dXJuVmFsdWUoeyB1c2VySWQ6IDEsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSk7XG4gICAgbW9ja0p3dC5kZWNvZGUubW9ja1JldHVyblZhbHVlKHsgdXNlcklkOiAxLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0pO1xuICAgIGp3dFZlcmlmeVNweS5tb2NrQ2xlYXIoKTtcbiAgICBqd3RTaWduU3B5Lm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBkZXNjcmliZSgncGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBwYXJzZSBzZWNvbmRzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzMwcycpKS50b0JlKDMwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwYXJzZSBtaW51dGVzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzVtJykpLnRvQmUoMzAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwYXJzZSBob3VycyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcyaCcpKS50b0JlKDcyMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIGRheXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMWQnKSkudG9CZSg4NjQwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIDAgZm9yIGludmFsaWQgaW5wdXQnLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcnKSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJ2ludmFsaWQnKSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJ2FiYycpKS50b0JlKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBlZGdlIGNhc2VzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMHMnKSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzEwMHgnKSkudG9CZSgxMDApOyAvLyBGYWxscyBiYWNrIHRvIHBhcnNpbmcgdGhlIG51bWJlciBwYXJ0XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhdXRoZW50aWNhdGVVc2VyJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgbmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgIHBhc3N3b3JkOiAnaGFzaGVkcGFzc3dvcmQnLFxuICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICByb2xlSWQ6IDEsXG4gICAgICBzaG9wSWQ6IDEsXG4gICAgICByb2xlTmFtZTogJ2FkbWluJyxcbiAgICAgIHBlcm1pc3Npb25zOiBudWxsLFxuICAgICAgcm9sZToge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ2FkbWluJyxcbiAgICAgICAgcGVybWlzc2lvbnM6IFtcbiAgICAgICAgICB7IG5hbWU6ICdyZWFkX3Byb2R1Y3RzJyB9LFxuICAgICAgICAgIHsgbmFtZTogJ3dyaXRlX3Byb2R1Y3RzJyB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGVzdCgnc2hvdWxkIGF1dGhlbnRpY2F0ZSB2YWxpZCB1c2VyIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuICAgICAgbW9ja0JjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUgYXMgYW55KTtcbiAgICAgIG1vY2tKd3Quc2lnbi5tb2NrUmV0dXJuVmFsdWUoJ21vY2stand0LXRva2VuJyBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudG9rZW4pLnRvQmUoJ21vY2stand0LXRva2VuJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnVzZXIpLnRvRXF1YWwoe1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGZ1bGxOYW1lOiAndGVzdHVzZXInLFxuICAgICAgICByb2xlSWQ6IDEsXG4gICAgICAgIHJvbGVOYW1lOiAnYWRtaW4nLFxuICAgICAgICBzaG9wSWQ6IDEsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja1VzZXJGaW5kRmlyc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGlzQWN0aXZlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICByb2xlOiB7XG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgIHBlcm1pc3Npb25zOiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0OiB7IG5hbWU6IHRydWUgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBlbWFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCdpbnZhbGlkQGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBwYXNzd29yZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIG1vY2tCY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZShmYWxzZSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3dyb25ncGFzc3dvcmQnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlamVjdCBpbmFjdGl2ZSB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIGZpbmRGaXJzdCB3aXRoIGlzQWN0aXZlOiB0cnVlIHJldHVybnMgbnVsbFxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBiY3J5cHQgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgICBtb2NrQmNyeXB0LmNvbXBhcmUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdCY3J5cHQgZXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnQXV0aGVudGljYXRpb24gZmFpbGVkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZW5lcmF0ZVRva2VuJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgc3ViOiAxLFxuICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgcm9sZUlkOiAxLFxuICAgICAgc2hvcElkOiAxLFxuICAgICAgcGVybWlzc2lvbnM6IFsncmVhZF9wcm9kdWN0cycsICd3cml0ZV9wcm9kdWN0cyddXG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSBKV1QgdG9rZW4nLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVG9rZW4gPSAnbW9jay1qd3QtdG9rZW4nO1xuICAgICAgbW9ja0p3dC5zaWduLm1vY2tSZXR1cm5WYWx1ZShtb2NrVG9rZW4pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBnZW5lcmF0ZVRva2VuKG1vY2tQYXlsb2FkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShtb2NrVG9rZW4pO1xuICAgICAgZXhwZWN0KG1vY2tKd3Quc2lnbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgbW9ja1BheWxvYWQsXG4gICAgICAgICAgJ3Rlc3Qtc2VjcmV0LWtleScsXG4gICAgICAgICAgeyBleHBpcmVzSW46ICcxMmgnIH1cbiAgICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3ZlcmlmeVRva2VuJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB2ZXJpZnkgdmFsaWQgdG9rZW4gZnJvbSBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgICBzdWI6ICcxJyxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgaWF0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDM2MDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQYXlsb2FkKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJ3ZhbGlkLXRva2VuJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1BheWxvYWQpO1xuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2UuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdmVyaWZ5IHZhbGlkIHRva2VuIGFuZCBjYWNoZSByZXN1bHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUGF5bG9hZCA9IHtcbiAgICAgICAgc3ViOiAnMScsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDEsXG4gICAgICAgIGlhdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgIGV4cDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAzNjAwXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTsgLy8gTm90IGluIGNhY2hlXG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrUmV0dXJuVmFsdWUobW9ja1BheWxvYWQgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJ3ZhbGlkLXRva2VuJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1BheWxvYWQpO1xuICAgICAgZXhwZWN0KG1vY2tKd3QudmVyaWZ5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndmFsaWQtdG9rZW4nLCAndGVzdC1zZWNyZXQta2V5Jyk7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5zZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgaW52YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgY29uc3QgaW52YWxpZEVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuJyk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBpbnZhbGlkRXJyb3I7XG4gICAgICB9KTtcbiAgICAgIGp3dFZlcmlmeVNweS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgdGhyb3cgaW52YWxpZEVycm9yO1xuICAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJ2ludmFsaWQtdG9rZW4nKSkucmVqZWN0cy50b1Rocm93KCdJbnZhbGlkIHRva2VuJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGV4cGlyZWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGNvbnN0IGV4cGlyZWRFcnJvciA9IG5ldyBtb2NrSnd0LlRva2VuRXhwaXJlZEVycm9yKCdUb2tlbiBleHBpcmVkJywgbmV3IERhdGUoKSk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBleHBpcmVkRXJyb3I7XG4gICAgICB9KTtcbiAgICAgIGp3dFZlcmlmeVNweS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgdGhyb3cgZXhwaXJlZEVycm9yO1xuICAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJ2V4cGlyZWQtdG9rZW4nKSkucmVqZWN0cy50b1Rocm93KCdUb2tlbiBleHBpcmVkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgbmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgcm9sZUlkOiAxLFxuICAgICAgc2hvcElkOiAxLFxuICAgICAgcm9sZToge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ2FkbWluJyxcbiAgICAgICAgcGVybWlzc2lvbnM6IFtcbiAgICAgICAgICB7IG5hbWU6ICdyZWFkX3Byb2R1Y3RzJyB9LFxuICAgICAgICAgIHsgbmFtZTogJ3dyaXRlX3Byb2R1Y3RzJyB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiB1c2VyIGZyb20gY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBzdWI6IDEsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGNhY2hlZFVzZXIgPSB7XG4gICAgICAgIC4uLm1vY2tVc2VyLFxuICAgICAgICByb2xlTmFtZTogJ2FkbWluJyxcbiAgICAgICAgcGVybWlzc2lvbnM6IFsncmVhZF9wcm9kdWN0cycsICd3cml0ZV9wcm9kdWN0cyddXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShjYWNoZWRVc2VyKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChwYXlsb2FkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChjYWNoZWRVc2VyKTtcbiAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmdldCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiB1c2VyIGZyb20gZGF0YWJhc2UgYW5kIGNhY2hlIGl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgc3ViOiAxLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTsgLy8gTm90IGluIGNhY2hlXG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5zZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgbnVsbCBwYXlsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChudWxsKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGludmFsaWQgcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQoe30gYXMgYW55KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgd2hlbiB1c2VyIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogOTk5LFxuICAgICAgICB1c2VybmFtZTogJ25vbmV4aXN0ZW50JyxcbiAgICAgICAgZW1haWw6ICdub25leGlzdGVudEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRVc2VyRnJvbVRva2VuJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIHZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgcm9sZUlkOiAxLFxuICAgICAgICBzaG9wSWQ6IDEsXG4gICAgICAgIHJvbGU6IHtcbiAgICAgICAgICBpZDogMSxcbiAgICAgICAgICBuYW1lOiAnYWRtaW4nLFxuICAgICAgICAgIHBlcm1pc3Npb25zOiBbeyBuYW1lOiAncmVhZF9wcm9kdWN0cycgfV1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayB2ZXJpZnlUb2tlbiB0byByZXR1cm4gcGF5bG9hZFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5Lm1vY2tSZXR1cm5WYWx1ZSgndGVzdC1jYWNoZS1rZXknKTtcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2Uuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrUmV0dXJuVmFsdWUobW9ja1BheWxvYWQpO1xuICAgICAgand0VmVyaWZ5U3B5Lm1vY2tSZXR1cm5WYWx1ZShtb2NrUGF5bG9hZCk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZFxuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbVRva2VuKCd2YWxpZC10b2tlbicpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgLi4ubW9ja1VzZXIsXG4gICAgICAgIHJvbGVOYW1lOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJ11cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBpbnZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5Lm1vY2tSZXR1cm5WYWx1ZSgndGVzdC1jYWNoZS1rZXknKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBib3RoIHRoZSBkaXJlY3QgbW9jayBhbmQgdGhlIHNweVxuICAgICAgY29uc3Qgand0RXJyb3IgPSBuZXcgbW9ja0p3dC5Kc29uV2ViVG9rZW5FcnJvcignand0IG1hbGZvcm1lZCcpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgand0RXJyb3I7XG4gICAgICB9KTtcbiAgICAgIGp3dFZlcmlmeVNweS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgdGhyb3cgand0RXJyb3I7XG4gICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChnZXRVc2VyRnJvbVRva2VuKCdpbnZhbGlkJykpLnJlamVjdHMudG9UaHJvdygnand0IG1hbGZvcm1lZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIEpXVF9TRUNSRVQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbFNlY3JldCA9IHByb2Nlc3MuZW52LkpXVF9TRUNSRVQ7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVDtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBjb25zdCBzZWNyZXRFcnJvciA9IG5ldyBFcnJvcignc2VjcmV0T3JQcml2YXRlS2V5IG11c3QgaGF2ZSBhIHZhbHVlJyk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBzZWNyZXRFcnJvcjtcbiAgICAgIH0pO1xuICAgICAgand0VmVyaWZ5U3B5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgICB0aHJvdyBzZWNyZXRFcnJvcjtcbiAgICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdhbnktdG9rZW4nKSkucmVqZWN0cy50b1Rocm93KCk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgdGhlIHNlY3JldFxuICAgICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCA9IG9yaWdpbmFsU2VjcmV0O1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtYWxmb3JtZWQgdG9rZW5zIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBib3RoIHRoZSBkaXJlY3QgbW9jayBhbmQgdGhlIHNweVxuICAgICAgY29uc3Qgand0RXJyb3IgPSBuZXcgbW9ja0p3dC5Kc29uV2ViVG9rZW5FcnJvcignand0IG1hbGZvcm1lZCcpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgand0RXJyb3I7XG4gICAgICB9KTtcbiAgICAgIGp3dFZlcmlmeVNweS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBqd3RFcnJvcjtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJ21hbGZvcm1lZC10b2tlbicpKS5yZWplY3RzLnRvVGhyb3coJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCcnKSkucmVqZWN0cy50b1Rocm93KCdqd3QgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJtb2NrQ2FjaGVTZXJ2aWNlIiwiZ2V0IiwiamVzdCIsImZuIiwic2V0IiwiZGVsZXRlIiwiaW5jcmVtZW50IiwiZ2VuZXJhdGVLZXkiLCJjbGVhciIsIm1vY2tQcmlzbWEiLCJ1c2VyIiwiZmluZFVuaXF1ZSIsImZpbmRGaXJzdCIsImNyZWF0ZSIsInVwZGF0ZSIsImZpbmRNYW55IiwicGVybWlzc2lvbiIsInNlc3Npb24iLCJkZWxldGVNYW55IiwiYXVkaXRMb2ciLCJtb2NrQmNyeXB0IiwiY29tcGFyZSIsImhhc2giLCJnZW5TYWx0IiwibW9jayIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiY2FjaGVTZXJ2aWNlIiwiY2FjaGUiLCJDQUNIRV9DT05GSUciLCJLRVlTIiwiVVNFUl9TRVNTSU9OIiwiVE9LRU5fVkFMSURBVElPTiIsIlRUTCIsIm1vY2tKd3QiLCJzaWduIiwidmVyaWZ5IiwiZGVjb2RlIiwiVG9rZW5FeHBpcmVkRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImV4cGlyZWRBdCIsIm5hbWUiLCJEYXRlIiwiSnNvbldlYlRva2VuRXJyb3IiLCJqd3RWZXJpZnlTcHkiLCJzcHlPbiIsImp3dCIsImp3dFNpZ25TcHkiLCJtb2NrVXNlckZpbmRGaXJzdCIsIm1vY2tQZXJtaXNzaW9uRmluZE1hbnkiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJKV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4iLCJtb2NrUmV0dXJuVmFsdWUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInVzZXJJZCIsImVtYWlsIiwibW9ja0NsZWFyIiwidGVzdCIsImV4cGVjdCIsInBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcyIsInRvQmUiLCJtb2NrVXNlciIsImlkIiwicGFzc3dvcmQiLCJpc0FjdGl2ZSIsInJvbGVJZCIsInNob3BJZCIsInJvbGVOYW1lIiwicGVybWlzc2lvbnMiLCJyb2xlIiwicmVzdWx0IiwiYXV0aGVudGljYXRlVXNlciIsInN1Y2Nlc3MiLCJ0b2tlbiIsInRvRXF1YWwiLCJ1c2VybmFtZSIsImZ1bGxOYW1lIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ3aGVyZSIsImluY2x1ZGUiLCJzZWxlY3QiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIm1vY2tQYXlsb2FkIiwic3ViIiwibW9ja1Rva2VuIiwiZ2VuZXJhdGVUb2tlbiIsImV4cGlyZXNJbiIsImlhdCIsIk1hdGgiLCJmbG9vciIsIm5vdyIsImV4cCIsInZlcmlmeVRva2VuIiwidG9IYXZlQmVlbkNhbGxlZCIsImludmFsaWRFcnJvciIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsInJlamVjdHMiLCJ0b1Rocm93IiwiZXhwaXJlZEVycm9yIiwicGF5bG9hZCIsImNhY2hlZFVzZXIiLCJnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkIiwidG9CZU51bGwiLCJ1bmRlZmluZWQiLCJnZXRVc2VyRnJvbVRva2VuIiwiand0RXJyb3IiLCJvcmlnaW5hbFNlY3JldCIsInNlY3JldEVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQSxtQ0FBbUM7QUFDbkMsMkRBQTJEOzs7Ozt5QkFFdEM7NkJBd0YrRztzRUFDL0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXZGckIsaURBQWlEO0FBQ2pELE1BQU1BLG1CQUFtQjtJQUN2QkMsS0FBS0MsYUFBSSxDQUFDQyxFQUFFO0lBQ1pDLEtBQUtGLGFBQUksQ0FBQ0MsRUFBRTtJQUNaRSxRQUFRSCxhQUFJLENBQUNDLEVBQUU7SUFDZkcsV0FBV0osYUFBSSxDQUFDQyxFQUFFO0lBQ2xCSSxhQUFhTCxhQUFJLENBQUNDLEVBQUU7SUFDcEJLLE9BQU9OLGFBQUksQ0FBQ0MsRUFBRTtBQUNoQjtBQUVBLE1BQU1NLGFBQWE7SUFDakJDLE1BQU07UUFDSkMsWUFBWVQsYUFBSSxDQUFDQyxFQUFFO1FBQ25CUyxXQUFXVixhQUFJLENBQUNDLEVBQUU7UUFDbEJVLFFBQVFYLGFBQUksQ0FBQ0MsRUFBRTtRQUNmVyxRQUFRWixhQUFJLENBQUNDLEVBQUU7UUFDZlksVUFBVWIsYUFBSSxDQUFDQyxFQUFFO1FBQ2pCRSxRQUFRSCxhQUFJLENBQUNDLEVBQUU7SUFDakI7SUFDQWEsWUFBWTtRQUNWRCxVQUFVYixhQUFJLENBQUNDLEVBQUU7SUFDbkI7SUFDQWMsU0FBUztRQUNQSixRQUFRWCxhQUFJLENBQUNDLEVBQUU7UUFDZlEsWUFBWVQsYUFBSSxDQUFDQyxFQUFFO1FBQ25CVyxR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