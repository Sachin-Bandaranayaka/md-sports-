{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/app/api/inventory/transfers/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { requirePermission } from '@/lib/utils/middleware';\nimport { prisma, safeQuery } from '@/lib/prisma';\nimport { verifyToken } from '@/lib/auth';\nimport { permissionService } from '@/lib/services/PermissionService';\nimport { transferCacheService } from '@/lib/transferCache';\nimport { trackTransferOperation } from '@/lib/transferPerformanceMonitor';\nimport { deduplicateRequest } from '@/lib/request-deduplication';\n\n// Type definition for transfer items\ninterface TransferItem {\n    productId: string;\n    quantity: string;\n}\n\n// Default fallback data for transfers\nconst defaultTransfersData = [\n    { id: 1, status: 'pending', created_at: '2025-05-20T10:00:00Z', completed_at: null, source_shop_name: 'Colombo Shop', destination_shop_name: 'Kandy Shop', initiated_by: 'System User', item_count: 5, total_items: 25 },\n    { id: 2, status: 'completed', created_at: '2025-05-19T09:30:00Z', completed_at: '2025-05-19T16:00:00Z', source_shop_name: 'Galle Shop', destination_shop_name: 'Colombo Shop', initiated_by: 'System User', item_count: 3, total_items: 15 },\n    { id: 3, status: 'cancelled', created_at: '2025-05-18T14:00:00Z', completed_at: null, source_shop_name: 'Kandy Shop', destination_shop_name: 'Jaffna Shop', initiated_by: 'System User', item_count: 2, total_items: 10 }\n];\n\n// GET: Fetch all inventory transfers\nexport async function GET(req: NextRequest) {\n    const operation = trackTransferOperation('list');\n\n    console.log('GET /api/inventory/transfers - Checking permission: inventory:transfer');\n    // Check for inventory:transfer permission (shop staff should have this)\n    const permissionError = await requirePermission('inventory:transfer')(req);\n    if (permissionError) {\n        console.error('Permission denied for inventory:transfer:', permissionError.status);\n        operation.end(false, 'unauthorized');\n        return permissionError;\n    }\n\n    // Get user context for shop filtering\n    const authHeader = req.headers.get('authorization');\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        operation.end(false, 'unauthorized');\n        return NextResponse.json({\n            success: false,\n            message: 'Authentication required'\n        }, { status: 401 });\n    }\n\n    const token = authHeader.split(' ')[1];\n    const decodedToken = await verifyToken(token);\n\n    if (!decodedToken) {\n        operation.end(false, 'unauthorized');\n        return NextResponse.json({\n            success: false,\n            message: 'Invalid token'\n        }, { status: 401 });\n    }\n\n    const userShopId = decodedToken.shopId;\n    const userPermissions = Array.isArray(decodedToken.permissions) ? decodedToken.permissions : [];\n    const isAdmin = permissionService.hasPermission({ permissions: userPermissions }, 'admin:all') || \n                    permissionService.hasPermission({ permissions: userPermissions }, 'shop:manage') || \n                    token === 'dev-token';\n    \n    console.log('User shop filtering - shopId:', userShopId, 'isAdmin:', isAdmin);\n\n    try {\n        console.log('Executing query to fetch transfers...');\n\n        // Generate cache key based on request parameters\n        const { searchParams } = new URL(req.url);\n        const cacheKey = transferCacheService.generateTransferCacheKey('transfers:list', {\n            page: parseInt(searchParams.get('page') || '1'),\n            limit: parseInt(searchParams.get('limit') || '10'),\n            status: searchParams.get('status') || undefined,\n            sourceShopId: searchParams.get('sourceShopId') ? parseInt(searchParams.get('sourceShopId')!) : undefined,\n            destinationShopId: searchParams.get('destinationShopId') ? parseInt(searchParams.get('destinationShopId')!) : undefined,\n            search: searchParams.get('search') || undefined,\n            startDate: searchParams.get('startDate') || undefined,\n            endDate: searchParams.get('endDate') || undefined\n        });\n\n        // Try to get from cache first\n        const cached = await transferCacheService.get(cacheKey);\n        if (cached) {\n            operation.end(true, undefined, true);\n            return NextResponse.json(cached);\n        }\n\n        // Use request deduplication for identical requests\n        const result = await deduplicateRequest(\n            async () => {\n                const transfers = await safeQuery(\n                    async () => {\n                        // Build where clause for shop filtering\n                        let whereClause: any = {};\n                        \n                        // If user is not admin and has a specific shop, filter transfers\n                        if (!isAdmin && userShopId) {\n                            whereClause = {\n                                OR: [\n                                    { fromShopId: userShopId },\n                                    { toShopId: userShopId }\n                                ]\n                            };\n                            console.log('Applying shop filter for shopId:', userShopId);\n                        } else {\n                            console.log('No shop filtering applied - admin user or no shop assigned');\n                        }\n                        \n                        const result = await prisma.inventoryTransfer.findMany({\n                            where: whereClause,\n                            select: {\n                                id: true,\n                                status: true,\n                                createdAt: true,\n                                updatedAt: true,\n                                notes: true,\n                                fromShop: {\n                                    select: {\n                                        id: true,\n                                        name: true\n                                    }\n                                },\n                                toShop: {\n                                    select: {\n                                        id: true,\n                                        name: true\n                                    }\n                                },\n                                fromUser: {\n                                    select: {\n                                        id: true,\n                                        name: true\n                                    }\n                                },\n                                transferItems: {\n                                    select: {\n                                        id: true,\n                                        quantity: true\n                                    }\n                                }\n                            },\n                            orderBy: {\n                                createdAt: 'desc'\n                            }\n                        });\n\n                        // Format the data to match the expected format from the SQL query\n                        return result.map(transfer => ({\n                            id: transfer.id,\n                            status: transfer.status,\n                            created_at: transfer.createdAt.toISOString(),\n                            completed_at: null, // This field doesn't exist in Prisma schema, could be added later\n                            source_shop_name: transfer.fromShop.name,\n                            destination_shop_name: transfer.toShop.name,\n                            initiated_by: transfer.fromUser.name,\n                            item_count: transfer.transferItems.length,\n                            total_items: transfer.transferItems.reduce((sum, item) => sum + item.quantity, 0)\n                        }));\n                    },\n                    defaultTransfersData,\n                    'Failed to fetch inventory transfers'\n                );\n\n                return {\n                    success: true,\n                    data: transfers\n                };\n            },\n            cacheKey,\n            'GET'\n        );\n\n        // Cache the result\n        await transferCacheService.set(cacheKey, result);\n\n        console.log('Query executed successfully. Results:', result.data);\n        console.log(`Retrieved ${result.data.length} transfers successfully`);\n        operation.end(true, undefined, false);\n        return NextResponse.json(result);\n    } catch (error) {\n        console.error('Error fetching transfers:', error);\n        operation.end(false, 'fetch_error');\n        return NextResponse.json({\n            success: false,\n            message: 'Error fetching transfers',\n            error: error instanceof Error ? error.message : String(error)\n        }, { status: 500 });\n    }\n}\n\n// POST: Create a new inventory transfer\nexport async function POST(req: NextRequest) {\n    console.log('POST /api/inventory/transfers - Checking permission: inventory:transfer');\n    // Check for inventory:transfer permission\n    const permissionError = await requirePermission('inventory:transfer')(req);\n    if (permissionError) {\n        console.error('Permission denied for inventory:transfer:', permissionError.status);\n        return permissionError;\n    }\n\n    // Create operation with metadata first\n    let operation: any;\n    \n    try {\n        const body = await req.json();\n        const { sourceShopId, destinationShopId, items } = body;\n\n        const operationMetadata = {\n            itemCount: items?.length || 0,\n            shopCount: 2 // source + destination\n        };\n        operation = trackTransferOperation('create', operationMetadata);\n\n        // Get user ID from authorization token\n        const authHeader = req.headers.get('authorization');\n        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n            operation.end(false, 'unauthorized');\n            return NextResponse.json({\n                success: false,\n                message: 'Authentication required'\n            }, { status: 401 });\n        }\n\n        const token = authHeader.split(' ')[1];\n        const decodedToken = await verifyToken(token);\n\n        if (!decodedToken || !decodedToken.sub) {\n            operation.end(false, 'unauthorized');\n            return NextResponse.json({\n                success: false,\n                message: 'Invalid token: signature verification failed'\n            }, { status: 401 });\n        }\n\n        const userId = decodedToken.sub;\n        console.log('Creating transfer for user ID:', userId);\n\n        // Validate request data\n        if (!sourceShopId || !destinationShopId || !items || !items.length) {\n            operation.end(false, 'validation_error');\n            return NextResponse.json({\n                success: false,\n                message: 'Missing required fields'\n            }, { status: 400 });\n        }\n\n        const result = await safeQuery(\n            async () => {\n                const newTransfer = await prisma.$transaction(\n                    async (tx) => {\n                        // 1. Reserve inventory in source shop\n                        for (const item of items) {\n                            const productIdNum = parseInt(item.productId);\n                            const qtyNum = parseInt(item.quantity);\n\n                            const inventory = await tx.inventoryItem.findFirst({\n                                where: { productId: productIdNum, shopId: sourceShopId }\n                            });\n\n                            if (!inventory || inventory.quantity < qtyNum) {\n                                throw new Error(`Insufficient stock for product ${productIdNum} in source shop`);\n                            }\n\n                            await tx.inventoryItem.update({\n                                where: { id: inventory.id },\n                                data: { quantity: { decrement: qtyNum } }\n                            });\n                        }\n\n                        // 2. Insert transfer & items\n                        return await tx.inventoryTransfer.create({\n                            data: {\n                                fromShopId: sourceShopId,\n                                toShopId: destinationShopId,\n                                fromUserId: userId,\n                                toUserId: userId,\n                                status: 'pending',\n                                transferItems: {\n                                    create: items.map((item: TransferItem) => ({\n                                        productId: parseInt(item.productId),\n                                        quantity: parseInt(item.quantity)\n                                    }))\n                                }\n                            }\n                        });\n                    },\n                    { timeout: 30000 }\n                );\n\n                return newTransfer;\n            },\n            null,\n            'Failed to create inventory transfer'\n        );\n\n        if (!result) {\n            throw new Error('Failed to create transfer');\n        }\n\n        // Invalidate relevant caches\n        await transferCacheService.invalidateTransferCache(result.id, [sourceShopId, destinationShopId]);\n\n        console.log('Transfer created successfully with ID:', result.id);\n        operation.end(true);\n        return NextResponse.json({\n            success: true,\n            message: 'Inventory transfer created successfully',\n            data: {\n                id: result.id\n            }\n        }, { status: 201 });\n    } catch (error) {\n        console.error('Error creating transfer:', error);\n        if (operation) {\n            operation.end(false, 'creation_error');\n        }\n        return NextResponse.json({\n            success: false,\n            message: 'Error creating transfer',\n            error: error instanceof Error ? error.message : String(error)\n        }, { status: 500 });\n    }\n}"],"names":["GET","POST","defaultTransfersData","id","status","created_at","completed_at","source_shop_name","destination_shop_name","initiated_by","item_count","total_items","req","operation","trackTransferOperation","console","log","permissionError","requirePermission","error","end","authHeader","headers","get","startsWith","NextResponse","json","success","message","token","split","decodedToken","verifyToken","userShopId","shopId","userPermissions","Array","isArray","permissions","isAdmin","permissionService","hasPermission","searchParams","URL","url","cacheKey","transferCacheService","generateTransferCacheKey","page","parseInt","limit","undefined","sourceShopId","destinationShopId","search","startDate","endDate","cached","result","deduplicateRequest","transfers","safeQuery","whereClause","OR","fromShopId","toShopId","prisma","inventoryTransfer","findMany","where","select","createdAt","updatedAt","notes","fromShop","name","toShop","fromUser","transferItems","quantity","orderBy","map","transfer","toISOString","length","reduce","sum","item","data","set","Error","String","body","items","operationMetadata","itemCount","shopCount","sub","userId","newTransfer","$transaction","tx","productIdNum","productId","qtyNum","inventory","inventoryItem","findFirst","update","decrement","create","fromUserId","toUserId","timeout","invalidateTransferCache"],"mappings":"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"}