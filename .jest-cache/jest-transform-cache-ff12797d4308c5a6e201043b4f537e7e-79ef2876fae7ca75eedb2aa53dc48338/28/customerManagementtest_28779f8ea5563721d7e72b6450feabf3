8812fc371b467307271dc66511532546
"use strict";
jest.mock("@/hooks/useAuth", ()=>({
        useAuth: ()=>mockUseAuth()
    }));
// Mock next/navigation
jest.mock("next/navigation", ()=>({
        useRouter: ()=>({
                push: jest.fn(),
                replace: jest.fn(),
                back: jest.fn(),
                forward: jest.fn(),
                refresh: jest.fn(),
                prefetch: jest.fn()
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
require("@testing-library/jest-dom");
// Mock the useAuth hook
const mockUseAuth = jest.fn();
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
describe("Customer Management System", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock localStorage
        Object.defineProperty(window, "localStorage", {
            value: {
                getItem: jest.fn(()=>"mock-token"),
                setItem: jest.fn(),
                removeItem: jest.fn()
            },
            writable: true
        });
        // Mock user with customer management permissions
        mockUseAuth.mockReturnValue({
            user: {
                id: "1",
                name: "Sales Manager",
                email: "sales@test.com",
                permissions: [
                    "sales:view",
                    "sales:create",
                    "sales:edit",
                    "customers:view",
                    "customers:create",
                    "customers:edit"
                ]
            },
            isLoading: false,
            isAuthenticated: true,
            login: jest.fn(),
            logout: jest.fn(),
            hasPermission: jest.fn((permission)=>{
                const userPermissions = [
                    "sales:view",
                    "sales:create",
                    "sales:edit",
                    "customers:view",
                    "customers:create",
                    "customers:edit"
                ];
                return userPermissions.includes(permission);
            })
        });
    });
    describe("Customer Creation and Validation", ()=>{
        test("should validate customer data correctly", ()=>{
            const validateCustomer = (customer)=>{
                const errors = [];
                if (!customer.name || customer.name.trim().length === 0) {
                    errors.push("Customer name is required");
                }
                if (customer.name && customer.name.length > 100) {
                    errors.push("Customer name must be 100 characters or less");
                }
                if (customer.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(customer.email)) {
                    errors.push("Invalid email format");
                }
                if (customer.phone && !/^[\d\s\-\+\(\)]+$/.test(customer.phone)) {
                    errors.push("Invalid phone number format");
                }
                if (customer.creditLimit && customer.creditLimit < 0) {
                    errors.push("Credit limit cannot be negative");
                }
                if (customer.paymentTerms && customer.paymentTerms < 0) {
                    errors.push("Payment terms cannot be negative");
                }
                return errors;
            };
            const validCustomer = {
                name: "John Doe",
                email: "john@example.com",
                phone: "+1234567890",
                address: "123 Main St",
                creditLimit: 5000,
                paymentTerms: 30
            };
            expect(validateCustomer(validCustomer)).toEqual([]);
            expect(validateCustomer({
                ...validCustomer,
                name: ""
            })).toContain("Customer name is required");
            expect(validateCustomer({
                ...validCustomer,
                email: "invalid-email"
            })).toContain("Invalid email format");
            expect(validateCustomer({
                ...validCustomer,
                phone: "abc123"
            })).toContain("Invalid phone number format");
            expect(validateCustomer({
                ...validCustomer,
                creditLimit: -100
            })).toContain("Credit limit cannot be negative");
        });
        test("should handle customer creation API call", async ()=>{
            const createCustomer = async (customerData)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            customer: {
                                id: "cust123",
                                ...customerData
                            },
                            message: "Customer created successfully"
                        })
                });
                const response = await fetch("/api/customers", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify(customerData)
                });
                return response.json();
            };
            const customerData = {
                name: "Jane Smith",
                email: "jane@example.com",
                phone: "+1987654321",
                creditLimit: 3000
            };
            const result = await createCustomer(customerData);
            expect(result.success).toBe(true);
            expect(result.customer.id).toBe("cust123");
            expect(mockFetch).toHaveBeenCalledWith("/api/customers", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer mock-token"
                },
                body: JSON.stringify(customerData)
            });
        });
    });
    describe("Credit Limit Management", ()=>{
        test("should calculate available credit correctly", ()=>{
            const calculateAvailableCredit = (creditLimit, currentBalance)=>{
                return Math.max(0, creditLimit - currentBalance);
            };
            expect(calculateAvailableCredit(5000, 2000)).toBe(3000);
            expect(calculateAvailableCredit(5000, 5000)).toBe(0);
            expect(calculateAvailableCredit(5000, 6000)).toBe(0); // Cannot go negative
        });
        test("should validate credit limit changes", ()=>{
            const validateCreditLimitChange = (currentBalance, newCreditLimit)=>{
                const errors = [];
                if (newCreditLimit < 0) {
                    errors.push("Credit limit cannot be negative");
                }
                if (newCreditLimit < currentBalance) {
                    errors.push("Credit limit cannot be less than current balance");
                }
                return errors;
            };
            expect(validateCreditLimitChange(2000, 5000)).toEqual([]);
            expect(validateCreditLimitChange(2000, -100)).toContain("Credit limit cannot be negative");
            expect(validateCreditLimitChange(2000, 1500)).toContain("Credit limit cannot be less than current balance");
        });
        test("should check credit availability for new sales", ()=>{
            const checkCreditAvailability = (customer, saleAmount)=>{
                const availableCredit = customer.creditLimit - customer.currentBalance;
                return {
                    approved: availableCredit >= saleAmount,
                    availableCredit,
                    requiredCredit: saleAmount,
                    shortfall: Math.max(0, saleAmount - availableCredit)
                };
            };
            const customer = {
                creditLimit: 5000,
                currentBalance: 2000
            };
            const result1 = checkCreditAvailability(customer, 2000);
            expect(result1.approved).toBe(true);
            expect(result1.availableCredit).toBe(3000);
            expect(result1.shortfall).toBe(0);
            const result2 = checkCreditAvailability(customer, 4000);
            expect(result2.approved).toBe(false);
            expect(result2.shortfall).toBe(1000);
        });
    });
    describe("Payment Terms and Due Dates", ()=>{
        test("should calculate due dates correctly", ()=>{
            const calculateDueDate = (invoiceDate, paymentTerms)=>{
                const dueDate = new Date(invoiceDate);
                dueDate.setDate(dueDate.getDate() + paymentTerms);
                return dueDate;
            };
            const invoiceDate = new Date("2024-01-01");
            const dueDate = calculateDueDate(invoiceDate, 30);
            expect(dueDate.toISOString().split("T")[0]).toBe("2024-01-31");
        });
        test("should identify overdue invoices", ()=>{
            const isOverdue = (dueDate, currentDate = new Date())=>{
                return currentDate > dueDate;
            };
            const pastDate = new Date("2023-12-01");
            const futureDate = new Date("2025-12-01");
            const today = new Date();
            expect(isOverdue(pastDate, today)).toBe(true);
            expect(isOverdue(futureDate, today)).toBe(false);
        });
        test("should calculate aging buckets", ()=>{
            const calculateAging = (dueDate, currentDate = new Date())=>{
                const daysPastDue = Math.floor((currentDate.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));
                if (daysPastDue <= 0) return "current";
                if (daysPastDue <= 30) return "1-30 days";
                if (daysPastDue <= 60) return "31-60 days";
                if (daysPastDue <= 90) return "61-90 days";
                return "over 90 days";
            };
            const today = new Date();
            const date30DaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
            const date60DaysAgo = new Date(today.getTime() - 60 * 24 * 60 * 60 * 1000);
            const date100DaysAgo = new Date(today.getTime() - 100 * 24 * 60 * 60 * 1000);
            expect(calculateAging(today)).toBe("current");
            expect(calculateAging(date30DaysAgo)).toBe("1-30 days");
            expect(calculateAging(date60DaysAgo)).toBe("31-60 days");
            expect(calculateAging(date100DaysAgo)).toBe("over 90 days");
        });
    });
    describe("Customer Transaction History", ()=>{
        test("should calculate customer balance correctly", ()=>{
            const calculateCustomerBalance = (transactions)=>{
                return transactions.reduce((balance, transaction)=>{
                    if (transaction.type === "invoice") {
                        return balance + transaction.amount;
                    } else if (transaction.type === "payment") {
                        return balance - transaction.amount;
                    } else if (transaction.type === "credit") {
                        return balance - transaction.amount;
                    }
                    return balance;
                }, 0);
            };
            const transactions = [
                {
                    type: "invoice",
                    amount: 1000
                },
                {
                    type: "payment",
                    amount: 500
                },
                {
                    type: "invoice",
                    amount: 800
                },
                {
                    type: "credit",
                    amount: 100
                }
            ];
            expect(calculateCustomerBalance(transactions)).toBe(1200); // 1000 - 500 + 800 - 100
        });
        test("should filter transactions by date range", ()=>{
            const filterTransactionsByDateRange = (transactions, startDate, endDate)=>{
                return transactions.filter((transaction)=>{
                    const transactionDate = new Date(transaction.date);
                    return transactionDate >= startDate && transactionDate <= endDate;
                });
            };
            const transactions = [
                {
                    id: 1,
                    date: "2024-01-15",
                    amount: 100
                },
                {
                    id: 2,
                    date: "2024-02-15",
                    amount: 200
                },
                {
                    id: 3,
                    date: "2024-03-15",
                    amount: 300
                }
            ];
            const startDate = new Date("2024-02-01");
            const endDate = new Date("2024-02-28");
            const filtered = filterTransactionsByDateRange(transactions, startDate, endDate);
            expect(filtered).toHaveLength(1);
            expect(filtered[0].id).toBe(2);
        });
        test("should generate customer statement", ()=>{
            const generateCustomerStatement = (customer, transactions)=>{
                const invoices = transactions.filter((t)=>t.type === "invoice");
                const payments = transactions.filter((t)=>t.type === "payment");
                const credits = transactions.filter((t)=>t.type === "credit");
                const totalInvoiced = invoices.reduce((sum, inv)=>sum + inv.amount, 0);
                const totalPaid = payments.reduce((sum, pay)=>sum + pay.amount, 0);
                const totalCredits = credits.reduce((sum, cr)=>sum + cr.amount, 0);
                const currentBalance = totalInvoiced - totalPaid - totalCredits;
                return {
                    customer,
                    summary: {
                        totalInvoiced,
                        totalPaid,
                        totalCredits,
                        currentBalance
                    },
                    transactions: transactions.sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime())
                };
            };
            const customer = {
                id: "cust1",
                name: "John Doe"
            };
            const transactions = [
                {
                    type: "invoice",
                    amount: 1000,
                    date: "2024-01-01"
                },
                {
                    type: "payment",
                    amount: 600,
                    date: "2024-01-15"
                },
                {
                    type: "credit",
                    amount: 50,
                    date: "2024-01-20"
                }
            ];
            const statement = generateCustomerStatement(customer, transactions);
            expect(statement.summary.totalInvoiced).toBe(1000);
            expect(statement.summary.totalPaid).toBe(600);
            expect(statement.summary.totalCredits).toBe(50);
            expect(statement.summary.currentBalance).toBe(350);
        });
    });
    describe("Customer Search and Filtering", ()=>{
        test("should search customers by name", ()=>{
            const searchCustomers = (customers, searchTerm)=>{
                if (!searchTerm) return customers;
                const term = searchTerm.toLowerCase();
                return customers.filter((customer)=>customer.name.toLowerCase().includes(term) || customer.email?.toLowerCase().includes(term) || customer.phone?.includes(term));
            };
            const customers = [
                {
                    name: "John Doe",
                    email: "john@example.com",
                    phone: "123456789"
                },
                {
                    name: "Jane Smith",
                    email: "jane@example.com",
                    phone: "987654321"
                },
                {
                    name: "Bob Johnson",
                    email: "bob@example.com",
                    phone: "555666777"
                }
            ];
            expect(searchCustomers(customers, "john")).toHaveLength(2); // John Doe and Bob Johnson
            expect(searchCustomers(customers, "jane@")).toHaveLength(1);
            expect(searchCustomers(customers, "555")).toHaveLength(1);
        });
        test("should filter customers by credit status", ()=>{
            const filterByCredit = (customers, filterType)=>{
                switch(filterType){
                    case "overLimit":
                        return customers.filter((c)=>c.currentBalance > c.creditLimit);
                    case "nearLimit":
                        return customers.filter((c)=>{
                            const utilization = c.currentBalance / c.creditLimit;
                            return utilization >= 0.8 && utilization <= 1;
                        });
                    case "goodStanding":
                        return customers.filter((c)=>c.currentBalance <= c.creditLimit * 0.8);
                    default:
                        return customers;
                }
            };
            const customers = [
                {
                    name: "Customer A",
                    creditLimit: 1000,
                    currentBalance: 1200
                },
                {
                    name: "Customer B",
                    creditLimit: 1000,
                    currentBalance: 900
                },
                {
                    name: "Customer C",
                    creditLimit: 1000,
                    currentBalance: 500
                } // Good standing
            ];
            expect(filterByCredit(customers, "overLimit")).toHaveLength(1);
            expect(filterByCredit(customers, "nearLimit")).toHaveLength(1);
            expect(filterByCredit(customers, "goodStanding")).toHaveLength(1);
        });
    });
    describe("Customer API Integration", ()=>{
        test("should fetch customer list with pagination", async ()=>{
            const fetchCustomers = async (page = 1, limit = 10, search)=>{
                const params = new URLSearchParams({
                    page: page.toString(),
                    limit: limit.toString(),
                    ...search && {
                        search
                    }
                });
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            customers: [
                                {
                                    id: "cust1",
                                    name: "Customer 1"
                                },
                                {
                                    id: "cust2",
                                    name: "Customer 2"
                                }
                            ],
                            pagination: {
                                page: 1,
                                limit: 10,
                                total: 25,
                                pages: 3
                            }
                        })
                });
                const response = await fetch(`/api/customers?${params}`, {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return response.json();
            };
            const result = await fetchCustomers(1, 10, "test");
            expect(result.customers).toHaveLength(2);
            expect(result.pagination.total).toBe(25);
        });
        test("should update customer information", async ()=>{
            const updateCustomer = async (customerId, updateData)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            customer: {
                                id: customerId,
                                ...updateData
                            },
                            message: "Customer updated successfully"
                        })
                });
                const response = await fetch(`/api/customers/${customerId}`, {
                    method: "PUT",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify(updateData)
                });
                return response.json();
            };
            const updateData = {
                creditLimit: 7500,
                paymentTerms: 45
            };
            const result = await updateCustomer("cust123", updateData);
            expect(result.success).toBe(true);
            expect(result.customer.creditLimit).toBe(7500);
        });
    });
    describe("Permission-based Access Control", ()=>{
        test("should restrict customer operations based on permissions", ()=>{
            const checkCustomerAccess = (userPermissions, action)=>{
                const permissionMap = {
                    "view": "customers:view",
                    "create": "customers:create",
                    "edit": "customers:edit",
                    "delete": "customers:delete"
                };
                const requiredPermission = permissionMap[action];
                return userPermissions.includes(requiredPermission) || userPermissions.includes("sales:manage");
            };
            const userPermissions = [
                "customers:view",
                "customers:create"
            ];
            expect(checkCustomerAccess(userPermissions, "view")).toBe(true);
            expect(checkCustomerAccess(userPermissions, "create")).toBe(true);
            expect(checkCustomerAccess(userPermissions, "edit")).toBe(false);
            expect(checkCustomerAccess(userPermissions, "delete")).toBe(false);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvaW50ZWdyYXRpb24vY3VzdG9tZXJNYW5hZ2VtZW50LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIGZpcmVFdmVudCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2plc3QtZG9tJztcblxuLy8gTW9jayB0aGUgdXNlQXV0aCBob29rXG5jb25zdCBtb2NrVXNlQXV0aCA9IGplc3QuZm4oKTtcbmplc3QubW9jaygnQC9ob29rcy91c2VBdXRoJywgKCkgPT4gKHtcbiAgdXNlQXV0aDogKCkgPT4gbW9ja1VzZUF1dGgoKSxcbn0pKTtcblxuLy8gTW9jayBuZXh0L25hdmlnYXRpb25cbmplc3QubW9jaygnbmV4dC9uYXZpZ2F0aW9uJywgKCkgPT4gKHtcbiAgdXNlUm91dGVyOiAoKSA9PiAoe1xuICAgIHB1c2g6IGplc3QuZm4oKSxcbiAgICByZXBsYWNlOiBqZXN0LmZuKCksXG4gICAgYmFjazogamVzdC5mbigpLFxuICAgIGZvcndhcmQ6IGplc3QuZm4oKSxcbiAgICByZWZyZXNoOiBqZXN0LmZuKCksXG4gICAgcHJlZmV0Y2g6IGplc3QuZm4oKSxcbiAgfSksXG59KSk7XG5cbi8vIE1vY2sgZmV0Y2ggZ2xvYmFsbHlcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKTtcbmdsb2JhbC5mZXRjaCA9IG1vY2tGZXRjaDtcblxuZGVzY3JpYmUoJ0N1c3RvbWVyIE1hbmFnZW1lbnQgU3lzdGVtJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBNb2NrIGxvY2FsU3RvcmFnZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdsb2NhbFN0b3JhZ2UnLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBnZXRJdGVtOiBqZXN0LmZuKCgpID0+ICdtb2NrLXRva2VuJyksXG4gICAgICAgIHNldEl0ZW06IGplc3QuZm4oKSxcbiAgICAgICAgcmVtb3ZlSXRlbTogamVzdC5mbigpLFxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLy8gTW9jayB1c2VyIHdpdGggY3VzdG9tZXIgbWFuYWdlbWVudCBwZXJtaXNzaW9uc1xuICAgIG1vY2tVc2VBdXRoLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICB1c2VyOiB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIG5hbWU6ICdTYWxlcyBNYW5hZ2VyJyxcbiAgICAgICAgZW1haWw6ICdzYWxlc0B0ZXN0LmNvbScsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3NhbGVzOnZpZXcnLCAnc2FsZXM6Y3JlYXRlJywgJ3NhbGVzOmVkaXQnLCAnY3VzdG9tZXJzOnZpZXcnLCAnY3VzdG9tZXJzOmNyZWF0ZScsICdjdXN0b21lcnM6ZWRpdCddXG4gICAgICB9LFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgIGxvZ2luOiBqZXN0LmZuKCksXG4gICAgICBsb2dvdXQ6IGplc3QuZm4oKSxcbiAgICAgIGhhc1Blcm1pc3Npb246IGplc3QuZm4oKHBlcm1pc3Npb24pID0+IHtcbiAgICAgICAgY29uc3QgdXNlclBlcm1pc3Npb25zID0gWydzYWxlczp2aWV3JywgJ3NhbGVzOmNyZWF0ZScsICdzYWxlczplZGl0JywgJ2N1c3RvbWVyczp2aWV3JywgJ2N1c3RvbWVyczpjcmVhdGUnLCAnY3VzdG9tZXJzOmVkaXQnXTtcbiAgICAgICAgcmV0dXJuIHVzZXJQZXJtaXNzaW9ucy5pbmNsdWRlcyhwZXJtaXNzaW9uKTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDdXN0b21lciBDcmVhdGlvbiBhbmQgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdmFsaWRhdGUgY3VzdG9tZXIgZGF0YSBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0ZUN1c3RvbWVyID0gKGN1c3RvbWVyOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFjdXN0b21lci5uYW1lIHx8IGN1c3RvbWVyLm5hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKCdDdXN0b21lciBuYW1lIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjdXN0b21lci5uYW1lICYmIGN1c3RvbWVyLm5hbWUubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ0N1c3RvbWVyIG5hbWUgbXVzdCBiZSAxMDAgY2hhcmFjdGVycyBvciBsZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjdXN0b21lci5lbWFpbCAmJiAhL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC8udGVzdChjdXN0b21lci5lbWFpbCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaCgnSW52YWxpZCBlbWFpbCBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGN1c3RvbWVyLnBob25lICYmICEvXltcXGRcXHNcXC1cXCtcXChcXCldKyQvLnRlc3QoY3VzdG9tZXIucGhvbmUpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ0ludmFsaWQgcGhvbmUgbnVtYmVyIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoY3VzdG9tZXIuY3JlZGl0TGltaXQgJiYgY3VzdG9tZXIuY3JlZGl0TGltaXQgPCAwKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ0NyZWRpdCBsaW1pdCBjYW5ub3QgYmUgbmVnYXRpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGN1c3RvbWVyLnBheW1lbnRUZXJtcyAmJiBjdXN0b21lci5wYXltZW50VGVybXMgPCAwKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ1BheW1lbnQgdGVybXMgY2Fubm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB2YWxpZEN1c3RvbWVyID0ge1xuICAgICAgICBuYW1lOiAnSm9obiBEb2UnLFxuICAgICAgICBlbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgICBwaG9uZTogJysxMjM0NTY3ODkwJyxcbiAgICAgICAgYWRkcmVzczogJzEyMyBNYWluIFN0JyxcbiAgICAgICAgY3JlZGl0TGltaXQ6IDUwMDAsXG4gICAgICAgIHBheW1lbnRUZXJtczogMzBcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdCh2YWxpZGF0ZUN1c3RvbWVyKHZhbGlkQ3VzdG9tZXIpKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZUN1c3RvbWVyKHsgLi4udmFsaWRDdXN0b21lciwgbmFtZTogJycgfSkpLnRvQ29udGFpbignQ3VzdG9tZXIgbmFtZSBpcyByZXF1aXJlZCcpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRlQ3VzdG9tZXIoeyAuLi52YWxpZEN1c3RvbWVyLCBlbWFpbDogJ2ludmFsaWQtZW1haWwnIH0pKS50b0NvbnRhaW4oJ0ludmFsaWQgZW1haWwgZm9ybWF0Jyk7XG4gICAgICBleHBlY3QodmFsaWRhdGVDdXN0b21lcih7IC4uLnZhbGlkQ3VzdG9tZXIsIHBob25lOiAnYWJjMTIzJyB9KSkudG9Db250YWluKCdJbnZhbGlkIHBob25lIG51bWJlciBmb3JtYXQnKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZUN1c3RvbWVyKHsgLi4udmFsaWRDdXN0b21lciwgY3JlZGl0TGltaXQ6IC0xMDAgfSkpLnRvQ29udGFpbignQ3JlZGl0IGxpbWl0IGNhbm5vdCBiZSBuZWdhdGl2ZScpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBjdXN0b21lciBjcmVhdGlvbiBBUEkgY2FsbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNyZWF0ZUN1c3RvbWVyID0gYXN5bmMgKGN1c3RvbWVyRGF0YTogYW55KSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgY3VzdG9tZXI6IHsgaWQ6ICdjdXN0MTIzJywgLi4uY3VzdG9tZXJEYXRhIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ3VzdG9tZXIgY3JlYXRlZCBzdWNjZXNzZnVsbHknXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jdXN0b21lcnMnLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY3VzdG9tZXJEYXRhKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY3VzdG9tZXJEYXRhID0ge1xuICAgICAgICBuYW1lOiAnSmFuZSBTbWl0aCcsXG4gICAgICAgIGVtYWlsOiAnamFuZUBleGFtcGxlLmNvbScsXG4gICAgICAgIHBob25lOiAnKzE5ODc2NTQzMjEnLFxuICAgICAgICBjcmVkaXRMaW1pdDogMzAwMFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlQ3VzdG9tZXIoY3VzdG9tZXJEYXRhKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VzdG9tZXIuaWQpLnRvQmUoJ2N1c3QxMjMnKTtcbiAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXBpL2N1c3RvbWVycycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjdXN0b21lckRhdGEpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NyZWRpdCBMaW1pdCBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBjYWxjdWxhdGUgYXZhaWxhYmxlIGNyZWRpdCBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxjdWxhdGVBdmFpbGFibGVDcmVkaXQgPSAoY3JlZGl0TGltaXQ6IG51bWJlciwgY3VycmVudEJhbGFuY2U6IG51bWJlcikgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgY3JlZGl0TGltaXQgLSBjdXJyZW50QmFsYW5jZSk7XG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoY2FsY3VsYXRlQXZhaWxhYmxlQ3JlZGl0KDUwMDAsIDIwMDApKS50b0JlKDMwMDApO1xuICAgICAgZXhwZWN0KGNhbGN1bGF0ZUF2YWlsYWJsZUNyZWRpdCg1MDAwLCA1MDAwKSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChjYWxjdWxhdGVBdmFpbGFibGVDcmVkaXQoNTAwMCwgNjAwMCkpLnRvQmUoMCk7IC8vIENhbm5vdCBnbyBuZWdhdGl2ZVxuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHZhbGlkYXRlIGNyZWRpdCBsaW1pdCBjaGFuZ2VzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGVDcmVkaXRMaW1pdENoYW5nZSA9IChjdXJyZW50QmFsYW5jZTogbnVtYmVyLCBuZXdDcmVkaXRMaW1pdDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChuZXdDcmVkaXRMaW1pdCA8IDApIHtcbiAgICAgICAgICBlcnJvcnMucHVzaCgnQ3JlZGl0IGxpbWl0IGNhbm5vdCBiZSBuZWdhdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAobmV3Q3JlZGl0TGltaXQgPCBjdXJyZW50QmFsYW5jZSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKCdDcmVkaXQgbGltaXQgY2Fubm90IGJlIGxlc3MgdGhhbiBjdXJyZW50IGJhbGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdCh2YWxpZGF0ZUNyZWRpdExpbWl0Q2hhbmdlKDIwMDAsIDUwMDApKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZUNyZWRpdExpbWl0Q2hhbmdlKDIwMDAsIC0xMDApKS50b0NvbnRhaW4oJ0NyZWRpdCBsaW1pdCBjYW5ub3QgYmUgbmVnYXRpdmUnKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZUNyZWRpdExpbWl0Q2hhbmdlKDIwMDAsIDE1MDApKS50b0NvbnRhaW4oJ0NyZWRpdCBsaW1pdCBjYW5ub3QgYmUgbGVzcyB0aGFuIGN1cnJlbnQgYmFsYW5jZScpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGNoZWNrIGNyZWRpdCBhdmFpbGFiaWxpdHkgZm9yIG5ldyBzYWxlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNoZWNrQ3JlZGl0QXZhaWxhYmlsaXR5ID0gKGN1c3RvbWVyOiBhbnksIHNhbGVBbW91bnQ6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBhdmFpbGFibGVDcmVkaXQgPSBjdXN0b21lci5jcmVkaXRMaW1pdCAtIGN1c3RvbWVyLmN1cnJlbnRCYWxhbmNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFwcHJvdmVkOiBhdmFpbGFibGVDcmVkaXQgPj0gc2FsZUFtb3VudCxcbiAgICAgICAgICBhdmFpbGFibGVDcmVkaXQsXG4gICAgICAgICAgcmVxdWlyZWRDcmVkaXQ6IHNhbGVBbW91bnQsXG4gICAgICAgICAgc2hvcnRmYWxsOiBNYXRoLm1heCgwLCBzYWxlQW1vdW50IC0gYXZhaWxhYmxlQ3JlZGl0KVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY3VzdG9tZXIgPSB7IGNyZWRpdExpbWl0OiA1MDAwLCBjdXJyZW50QmFsYW5jZTogMjAwMCB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQxID0gY2hlY2tDcmVkaXRBdmFpbGFiaWxpdHkoY3VzdG9tZXIsIDIwMDApO1xuICAgICAgZXhwZWN0KHJlc3VsdDEuYXBwcm92ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0MS5hdmFpbGFibGVDcmVkaXQpLnRvQmUoMzAwMCk7XG4gICAgICBleHBlY3QocmVzdWx0MS5zaG9ydGZhbGwpLnRvQmUoMCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdDIgPSBjaGVja0NyZWRpdEF2YWlsYWJpbGl0eShjdXN0b21lciwgNDAwMCk7XG4gICAgICBleHBlY3QocmVzdWx0Mi5hcHByb3ZlZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Mi5zaG9ydGZhbGwpLnRvQmUoMTAwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQYXltZW50IFRlcm1zIGFuZCBEdWUgRGF0ZXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNhbGN1bGF0ZSBkdWUgZGF0ZXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgY2FsY3VsYXRlRHVlRGF0ZSA9IChpbnZvaWNlRGF0ZTogRGF0ZSwgcGF5bWVudFRlcm1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgZHVlRGF0ZSA9IG5ldyBEYXRlKGludm9pY2VEYXRlKTtcbiAgICAgICAgZHVlRGF0ZS5zZXREYXRlKGR1ZURhdGUuZ2V0RGF0ZSgpICsgcGF5bWVudFRlcm1zKTtcbiAgICAgICAgcmV0dXJuIGR1ZURhdGU7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbnZvaWNlRGF0ZSA9IG5ldyBEYXRlKCcyMDI0LTAxLTAxJyk7XG4gICAgICBjb25zdCBkdWVEYXRlID0gY2FsY3VsYXRlRHVlRGF0ZShpbnZvaWNlRGF0ZSwgMzApO1xuICAgICAgZXhwZWN0KGR1ZURhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKS50b0JlKCcyMDI0LTAxLTMxJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaWRlbnRpZnkgb3ZlcmR1ZSBpbnZvaWNlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGlzT3ZlcmR1ZSA9IChkdWVEYXRlOiBEYXRlLCBjdXJyZW50RGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCkpID0+IHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlID4gZHVlRGF0ZTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBhc3REYXRlID0gbmV3IERhdGUoJzIwMjMtMTItMDEnKTtcbiAgICAgIGNvbnN0IGZ1dHVyZURhdGUgPSBuZXcgRGF0ZSgnMjAyNS0xMi0wMScpO1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICBleHBlY3QoaXNPdmVyZHVlKHBhc3REYXRlLCB0b2RheSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoaXNPdmVyZHVlKGZ1dHVyZURhdGUsIHRvZGF5KSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgY2FsY3VsYXRlIGFnaW5nIGJ1Y2tldHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxjdWxhdGVBZ2luZyA9IChkdWVEYXRlOiBEYXRlLCBjdXJyZW50RGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCkpID0+IHtcbiAgICAgICAgY29uc3QgZGF5c1Bhc3REdWUgPSBNYXRoLmZsb29yKChjdXJyZW50RGF0ZS5nZXRUaW1lKCkgLSBkdWVEYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRheXNQYXN0RHVlIDw9IDApIHJldHVybiAnY3VycmVudCc7XG4gICAgICAgIGlmIChkYXlzUGFzdER1ZSA8PSAzMCkgcmV0dXJuICcxLTMwIGRheXMnO1xuICAgICAgICBpZiAoZGF5c1Bhc3REdWUgPD0gNjApIHJldHVybiAnMzEtNjAgZGF5cyc7XG4gICAgICAgIGlmIChkYXlzUGFzdER1ZSA8PSA5MCkgcmV0dXJuICc2MS05MCBkYXlzJztcbiAgICAgICAgcmV0dXJuICdvdmVyIDkwIGRheXMnO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgZGF0ZTMwRGF5c0FnbyA9IG5ldyBEYXRlKHRvZGF5LmdldFRpbWUoKSAtIDMwICogMjQgKiA2MCAqIDYwICogMTAwMCk7XG4gICAgICBjb25zdCBkYXRlNjBEYXlzQWdvID0gbmV3IERhdGUodG9kYXkuZ2V0VGltZSgpIC0gNjAgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgIGNvbnN0IGRhdGUxMDBEYXlzQWdvID0gbmV3IERhdGUodG9kYXkuZ2V0VGltZSgpIC0gMTAwICogMjQgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgICAgIGV4cGVjdChjYWxjdWxhdGVBZ2luZyh0b2RheSkpLnRvQmUoJ2N1cnJlbnQnKTtcbiAgICAgIGV4cGVjdChjYWxjdWxhdGVBZ2luZyhkYXRlMzBEYXlzQWdvKSkudG9CZSgnMS0zMCBkYXlzJyk7XG4gICAgICBleHBlY3QoY2FsY3VsYXRlQWdpbmcoZGF0ZTYwRGF5c0FnbykpLnRvQmUoJzMxLTYwIGRheXMnKTtcbiAgICAgIGV4cGVjdChjYWxjdWxhdGVBZ2luZyhkYXRlMTAwRGF5c0FnbykpLnRvQmUoJ292ZXIgOTAgZGF5cycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ3VzdG9tZXIgVHJhbnNhY3Rpb24gSGlzdG9yeScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgY2FsY3VsYXRlIGN1c3RvbWVyIGJhbGFuY2UgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgY2FsY3VsYXRlQ3VzdG9tZXJCYWxhbmNlID0gKHRyYW5zYWN0aW9uczogYW55W10pID0+IHtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5yZWR1Y2UoKGJhbGFuY2UsIHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09ICdpbnZvaWNlJykge1xuICAgICAgICAgICAgcmV0dXJuIGJhbGFuY2UgKyB0cmFuc2FjdGlvbi5hbW91bnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSAncGF5bWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBiYWxhbmNlIC0gdHJhbnNhY3Rpb24uYW1vdW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gJ2NyZWRpdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBiYWxhbmNlIC0gdHJhbnNhY3Rpb24uYW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFsYW5jZTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBbXG4gICAgICAgIHsgdHlwZTogJ2ludm9pY2UnLCBhbW91bnQ6IDEwMDAgfSxcbiAgICAgICAgeyB0eXBlOiAncGF5bWVudCcsIGFtb3VudDogNTAwIH0sXG4gICAgICAgIHsgdHlwZTogJ2ludm9pY2UnLCBhbW91bnQ6IDgwMCB9LFxuICAgICAgICB7IHR5cGU6ICdjcmVkaXQnLCBhbW91bnQ6IDEwMCB9XG4gICAgICBdO1xuXG4gICAgICBleHBlY3QoY2FsY3VsYXRlQ3VzdG9tZXJCYWxhbmNlKHRyYW5zYWN0aW9ucykpLnRvQmUoMTIwMCk7IC8vIDEwMDAgLSA1MDAgKyA4MDAgLSAxMDBcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBmaWx0ZXIgdHJhbnNhY3Rpb25zIGJ5IGRhdGUgcmFuZ2UnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmaWx0ZXJUcmFuc2FjdGlvbnNCeURhdGVSYW5nZSA9ICh0cmFuc2FjdGlvbnM6IGFueVtdLCBzdGFydERhdGU6IERhdGUsIGVuZERhdGU6IERhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5maWx0ZXIodHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0ZSA9IG5ldyBEYXRlKHRyYW5zYWN0aW9uLmRhdGUpO1xuICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkRhdGUgPj0gc3RhcnREYXRlICYmIHRyYW5zYWN0aW9uRGF0ZSA8PSBlbmREYXRlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IFtcbiAgICAgICAgeyBpZDogMSwgZGF0ZTogJzIwMjQtMDEtMTUnLCBhbW91bnQ6IDEwMCB9LFxuICAgICAgICB7IGlkOiAyLCBkYXRlOiAnMjAyNC0wMi0xNScsIGFtb3VudDogMjAwIH0sXG4gICAgICAgIHsgaWQ6IDMsIGRhdGU6ICcyMDI0LTAzLTE1JywgYW1vdW50OiAzMDAgfVxuICAgICAgXTtcblxuICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoJzIwMjQtMDItMDEnKTtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZSgnMjAyNC0wMi0yOCcpO1xuICAgICAgY29uc3QgZmlsdGVyZWQgPSBmaWx0ZXJUcmFuc2FjdGlvbnNCeURhdGVSYW5nZSh0cmFuc2FjdGlvbnMsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG5cbiAgICAgIGV4cGVjdChmaWx0ZXJlZCkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KGZpbHRlcmVkWzBdLmlkKS50b0JlKDIpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGdlbmVyYXRlIGN1c3RvbWVyIHN0YXRlbWVudCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGdlbmVyYXRlQ3VzdG9tZXJTdGF0ZW1lbnQgPSAoY3VzdG9tZXI6IGFueSwgdHJhbnNhY3Rpb25zOiBhbnlbXSkgPT4ge1xuICAgICAgICBjb25zdCBpbnZvaWNlcyA9IHRyYW5zYWN0aW9ucy5maWx0ZXIodCA9PiB0LnR5cGUgPT09ICdpbnZvaWNlJyk7XG4gICAgICAgIGNvbnN0IHBheW1lbnRzID0gdHJhbnNhY3Rpb25zLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gJ3BheW1lbnQnKTtcbiAgICAgICAgY29uc3QgY3JlZGl0cyA9IHRyYW5zYWN0aW9ucy5maWx0ZXIodCA9PiB0LnR5cGUgPT09ICdjcmVkaXQnKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRvdGFsSW52b2ljZWQgPSBpbnZvaWNlcy5yZWR1Y2UoKHN1bSwgaW52KSA9PiBzdW0gKyBpbnYuYW1vdW50LCAwKTtcbiAgICAgICAgY29uc3QgdG90YWxQYWlkID0gcGF5bWVudHMucmVkdWNlKChzdW0sIHBheSkgPT4gc3VtICsgcGF5LmFtb3VudCwgMCk7XG4gICAgICAgIGNvbnN0IHRvdGFsQ3JlZGl0cyA9IGNyZWRpdHMucmVkdWNlKChzdW0sIGNyKSA9PiBzdW0gKyBjci5hbW91bnQsIDApO1xuICAgICAgICBjb25zdCBjdXJyZW50QmFsYW5jZSA9IHRvdGFsSW52b2ljZWQgLSB0b3RhbFBhaWQgLSB0b3RhbENyZWRpdHM7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGN1c3RvbWVyLFxuICAgICAgICAgIHN1bW1hcnk6IHtcbiAgICAgICAgICAgIHRvdGFsSW52b2ljZWQsXG4gICAgICAgICAgICB0b3RhbFBhaWQsXG4gICAgICAgICAgICB0b3RhbENyZWRpdHMsXG4gICAgICAgICAgICBjdXJyZW50QmFsYW5jZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmRhdGUpLmdldFRpbWUoKSlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGN1c3RvbWVyID0geyBpZDogJ2N1c3QxJywgbmFtZTogJ0pvaG4gRG9lJyB9O1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gW1xuICAgICAgICB7IHR5cGU6ICdpbnZvaWNlJywgYW1vdW50OiAxMDAwLCBkYXRlOiAnMjAyNC0wMS0wMScgfSxcbiAgICAgICAgeyB0eXBlOiAncGF5bWVudCcsIGFtb3VudDogNjAwLCBkYXRlOiAnMjAyNC0wMS0xNScgfSxcbiAgICAgICAgeyB0eXBlOiAnY3JlZGl0JywgYW1vdW50OiA1MCwgZGF0ZTogJzIwMjQtMDEtMjAnIH1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHN0YXRlbWVudCA9IGdlbmVyYXRlQ3VzdG9tZXJTdGF0ZW1lbnQoY3VzdG9tZXIsIHRyYW5zYWN0aW9ucyk7XG4gICAgICBleHBlY3Qoc3RhdGVtZW50LnN1bW1hcnkudG90YWxJbnZvaWNlZCkudG9CZSgxMDAwKTtcbiAgICAgIGV4cGVjdChzdGF0ZW1lbnQuc3VtbWFyeS50b3RhbFBhaWQpLnRvQmUoNjAwKTtcbiAgICAgIGV4cGVjdChzdGF0ZW1lbnQuc3VtbWFyeS50b3RhbENyZWRpdHMpLnRvQmUoNTApO1xuICAgICAgZXhwZWN0KHN0YXRlbWVudC5zdW1tYXJ5LmN1cnJlbnRCYWxhbmNlKS50b0JlKDM1MCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDdXN0b21lciBTZWFyY2ggYW5kIEZpbHRlcmluZycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgc2VhcmNoIGN1c3RvbWVycyBieSBuYW1lJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoQ3VzdG9tZXJzID0gKGN1c3RvbWVyczogYW55W10sIHNlYXJjaFRlcm06IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIXNlYXJjaFRlcm0pIHJldHVybiBjdXN0b21lcnM7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXJtID0gc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gY3VzdG9tZXJzLmZpbHRlcihjdXN0b21lciA9PiBcbiAgICAgICAgICBjdXN0b21lci5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModGVybSkgfHxcbiAgICAgICAgICBjdXN0b21lci5lbWFpbD8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZXJtKSB8fFxuICAgICAgICAgIGN1c3RvbWVyLnBob25lPy5pbmNsdWRlcyh0ZXJtKVxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY3VzdG9tZXJzID0gW1xuICAgICAgICB7IG5hbWU6ICdKb2huIERvZScsIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsIHBob25lOiAnMTIzNDU2Nzg5JyB9LFxuICAgICAgICB7IG5hbWU6ICdKYW5lIFNtaXRoJywgZW1haWw6ICdqYW5lQGV4YW1wbGUuY29tJywgcGhvbmU6ICc5ODc2NTQzMjEnIH0sXG4gICAgICAgIHsgbmFtZTogJ0JvYiBKb2huc29uJywgZW1haWw6ICdib2JAZXhhbXBsZS5jb20nLCBwaG9uZTogJzU1NTY2Njc3NycgfVxuICAgICAgXTtcblxuICAgICAgZXhwZWN0KHNlYXJjaEN1c3RvbWVycyhjdXN0b21lcnMsICdqb2huJykpLnRvSGF2ZUxlbmd0aCgyKTsgLy8gSm9obiBEb2UgYW5kIEJvYiBKb2huc29uXG4gICAgICBleHBlY3Qoc2VhcmNoQ3VzdG9tZXJzKGN1c3RvbWVycywgJ2phbmVAJykpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChzZWFyY2hDdXN0b21lcnMoY3VzdG9tZXJzLCAnNTU1JykpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBmaWx0ZXIgY3VzdG9tZXJzIGJ5IGNyZWRpdCBzdGF0dXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmaWx0ZXJCeUNyZWRpdCA9IChjdXN0b21lcnM6IGFueVtdLCBmaWx0ZXJUeXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXJUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnb3ZlckxpbWl0JzpcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21lcnMuZmlsdGVyKGMgPT4gYy5jdXJyZW50QmFsYW5jZSA+IGMuY3JlZGl0TGltaXQpO1xuICAgICAgICAgIGNhc2UgJ25lYXJMaW1pdCc6XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tZXJzLmZpbHRlcihjID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdXRpbGl6YXRpb24gPSBjLmN1cnJlbnRCYWxhbmNlIC8gYy5jcmVkaXRMaW1pdDtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWxpemF0aW9uID49IDAuOCAmJiB1dGlsaXphdGlvbiA8PSAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSAnZ29vZFN0YW5kaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21lcnMuZmlsdGVyKGMgPT4gYy5jdXJyZW50QmFsYW5jZSA8PSBjLmNyZWRpdExpbWl0ICogMC44KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbWVycztcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY3VzdG9tZXJzID0gW1xuICAgICAgICB7IG5hbWU6ICdDdXN0b21lciBBJywgY3JlZGl0TGltaXQ6IDEwMDAsIGN1cnJlbnRCYWxhbmNlOiAxMjAwIH0sIC8vIE92ZXIgbGltaXRcbiAgICAgICAgeyBuYW1lOiAnQ3VzdG9tZXIgQicsIGNyZWRpdExpbWl0OiAxMDAwLCBjdXJyZW50QmFsYW5jZTogOTAwIH0sICAvLyBOZWFyIGxpbWl0XG4gICAgICAgIHsgbmFtZTogJ0N1c3RvbWVyIEMnLCBjcmVkaXRMaW1pdDogMTAwMCwgY3VycmVudEJhbGFuY2U6IDUwMCB9ICAgLy8gR29vZCBzdGFuZGluZ1xuICAgICAgXTtcblxuICAgICAgZXhwZWN0KGZpbHRlckJ5Q3JlZGl0KGN1c3RvbWVycywgJ292ZXJMaW1pdCcpKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoZmlsdGVyQnlDcmVkaXQoY3VzdG9tZXJzLCAnbmVhckxpbWl0JykpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChmaWx0ZXJCeUNyZWRpdChjdXN0b21lcnMsICdnb29kU3RhbmRpbmcnKSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ3VzdG9tZXIgQVBJIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBmZXRjaCBjdXN0b21lciBsaXN0IHdpdGggcGFnaW5hdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZldGNoQ3VzdG9tZXJzID0gYXN5bmMgKHBhZ2U6IG51bWJlciA9IDEsIGxpbWl0OiBudW1iZXIgPSAxMCwgc2VhcmNoPzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgIHBhZ2U6IHBhZ2UudG9TdHJpbmcoKSxcbiAgICAgICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAuLi4oc2VhcmNoICYmIHsgc2VhcmNoIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBjdXN0b21lcnM6IFtcbiAgICAgICAgICAgICAgeyBpZDogJ2N1c3QxJywgbmFtZTogJ0N1c3RvbWVyIDEnIH0sXG4gICAgICAgICAgICAgIHsgaWQ6ICdjdXN0MicsIG5hbWU6ICdDdXN0b21lciAyJyB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICBwYWdlOiAxLFxuICAgICAgICAgICAgICBsaW1pdDogMTAsXG4gICAgICAgICAgICAgIHRvdGFsOiAyNSxcbiAgICAgICAgICAgICAgcGFnZXM6IDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2N1c3RvbWVycz8ke3BhcmFtc31gLCB7XG4gICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9jay10b2tlbicgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hDdXN0b21lcnMoMSwgMTAsICd0ZXN0Jyk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1c3RvbWVycykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wYWdpbmF0aW9uLnRvdGFsKS50b0JlKDI1KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB1cGRhdGUgY3VzdG9tZXIgaW5mb3JtYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVDdXN0b21lciA9IGFzeW5jIChjdXN0b21lcklkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IGFueSkgPT4ge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGN1c3RvbWVyOiB7IGlkOiBjdXN0b21lcklkLCAuLi51cGRhdGVEYXRhIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ3VzdG9tZXIgdXBkYXRlZCBzdWNjZXNzZnVsbHknXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9jdXN0b21lcnMvJHtjdXN0b21lcklkfWAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9jay10b2tlbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZURhdGEpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVEYXRhID0geyBjcmVkaXRMaW1pdDogNzUwMCwgcGF5bWVudFRlcm1zOiA0NSB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBkYXRlQ3VzdG9tZXIoJ2N1c3QxMjMnLCB1cGRhdGVEYXRhKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXN0b21lci5jcmVkaXRMaW1pdCkudG9CZSg3NTAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Blcm1pc3Npb24tYmFzZWQgQWNjZXNzIENvbnRyb2wnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHJlc3RyaWN0IGN1c3RvbWVyIG9wZXJhdGlvbnMgYmFzZWQgb24gcGVybWlzc2lvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjaGVja0N1c3RvbWVyQWNjZXNzID0gKHVzZXJQZXJtaXNzaW9uczogc3RyaW5nW10sIGFjdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25NYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgICAgJ3ZpZXcnOiAnY3VzdG9tZXJzOnZpZXcnLFxuICAgICAgICAgICdjcmVhdGUnOiAnY3VzdG9tZXJzOmNyZWF0ZScsXG4gICAgICAgICAgJ2VkaXQnOiAnY3VzdG9tZXJzOmVkaXQnLFxuICAgICAgICAgICdkZWxldGUnOiAnY3VzdG9tZXJzOmRlbGV0ZSdcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUGVybWlzc2lvbiA9IHBlcm1pc3Npb25NYXBbYWN0aW9uXTtcbiAgICAgICAgcmV0dXJuIHVzZXJQZXJtaXNzaW9ucy5pbmNsdWRlcyhyZXF1aXJlZFBlcm1pc3Npb24pIHx8IHVzZXJQZXJtaXNzaW9ucy5pbmNsdWRlcygnc2FsZXM6bWFuYWdlJyk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1c2VyUGVybWlzc2lvbnMgPSBbJ2N1c3RvbWVyczp2aWV3JywgJ2N1c3RvbWVyczpjcmVhdGUnXTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGNoZWNrQ3VzdG9tZXJBY2Nlc3ModXNlclBlcm1pc3Npb25zLCAndmlldycpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGNoZWNrQ3VzdG9tZXJBY2Nlc3ModXNlclBlcm1pc3Npb25zLCAnY3JlYXRlJykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoY2hlY2tDdXN0b21lckFjY2Vzcyh1c2VyUGVybWlzc2lvbnMsICdlZGl0JykpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGNoZWNrQ3VzdG9tZXJBY2Nlc3ModXNlclBlcm1pc3Npb25zLCAnZGVsZXRlJykpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZUF1dGgiLCJtb2NrVXNlQXV0aCIsInVzZVJvdXRlciIsInB1c2giLCJmbiIsInJlcGxhY2UiLCJiYWNrIiwiZm9yd2FyZCIsInJlZnJlc2giLCJwcmVmZXRjaCIsIm1vY2tGZXRjaCIsImdsb2JhbCIsImZldGNoIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid2luZG93IiwidmFsdWUiLCJnZXRJdGVtIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJ3cml0YWJsZSIsIm1vY2tSZXR1cm5WYWx1ZSIsInVzZXIiLCJpZCIsIm5hbWUiLCJlbWFpbCIsInBlcm1pc3Npb25zIiwiaXNMb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwibG9naW4iLCJsb2dvdXQiLCJoYXNQZXJtaXNzaW9uIiwicGVybWlzc2lvbiIsInVzZXJQZXJtaXNzaW9ucyIsImluY2x1ZGVzIiwidGVzdCIsInZhbGlkYXRlQ3VzdG9tZXIiLCJjdXN0b21lciIsImVycm9ycyIsInRyaW0iLCJsZW5ndGgiLCJwaG9uZSIsImNyZWRpdExpbWl0IiwicGF5bWVudFRlcm1zIiwidmFsaWRDdXN0b21lciIsImFkZHJlc3MiLCJleHBlY3QiLCJ0b0VxdWFsIiwidG9Db250YWluIiwiY3JlYXRlQ3VzdG9tZXIiLCJjdXN0b21lckRhdGEiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJvayIsImpzb24iLCJzdWNjZXNzIiwibWVzc2FnZSIsInJlc3BvbnNlIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzdWx0IiwidG9CZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiY2FsY3VsYXRlQXZhaWxhYmxlQ3JlZGl0IiwiY3VycmVudEJhbGFuY2UiLCJNYXRoIiwibWF4IiwidmFsaWRhdGVDcmVkaXRMaW1pdENoYW5nZSIsIm5ld0NyZWRpdExpbWl0IiwiY2hlY2tDcmVkaXRBdmFpbGFiaWxpdHkiLCJzYWxlQW1vdW50IiwiYXZhaWxhYmxlQ3JlZGl0IiwiYXBwcm92ZWQiLCJyZXF1aXJlZENyZWRpdCIsInNob3J0ZmFsbCIsInJlc3VsdDEiLCJyZXN1bHQyIiwiY2FsY3VsYXRlRHVlRGF0ZSIsImludm9pY2VEYXRlIiwiZHVlRGF0ZSIsIkRhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJpc092ZXJkdWUiLCJjdXJyZW50RGF0ZSIsInBhc3REYXRlIiwiZnV0dXJlRGF0ZSIsInRvZGF5IiwiY2FsY3VsYXRlQWdpbmciLCJkYXlzUGFzdER1ZSIsImZsb29yIiwiZ2V0VGltZSIsImRhdGUzMERheXNBZ28iLCJkYXRlNjBEYXlzQWdvIiwiZGF0ZTEwMERheXNBZ28iLCJjYWxjdWxhdGVDdXN0b21lckJhbGFuY2UiLCJ0cmFuc2FjdGlvbnMiLCJyZWR1Y2UiLCJiYWxhbmNlIiwidHJhbnNhY3Rpb24iLCJ0eXBlIiwiYW1vdW50IiwiZmlsdGVyVHJhbnNhY3Rpb25zQnlEYXRlUmFuZ2UiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiZmlsdGVyIiwidHJhbnNhY3Rpb25EYXRlIiwiZGF0ZSIsImZpbHRlcmVkIiwidG9IYXZlTGVuZ3RoIiwiZ2VuZXJhdGVDdXN0b21lclN0YXRlbWVudCIsImludm9pY2VzIiwidCIsInBheW1lbnRzIiwiY3JlZGl0cyIsInRvdGFsSW52b2ljZWQiLCJzdW0iLCJpbnYiLCJ0b3RhbFBhaWQiLCJwYXkiLCJ0b3RhbENyZWRpdHMiLCJjciIsInN1bW1hcnkiLCJzb3J0IiwiYSIsImIiLCJzdGF0ZW1lbnQiLCJzZWFyY2hDdXN0b21lcnMiLCJjdXN0b21lcnMiLCJzZWFyY2hUZXJtIiwidGVybSIsInRvTG93ZXJDYXNlIiwiZmlsdGVyQnlDcmVkaXQiLCJmaWx0ZXJUeXBlIiwiYyIsInV0aWxpemF0aW9uIiwiZmV0Y2hDdXN0b21lcnMiLCJwYWdlIiwibGltaXQiLCJzZWFyY2giLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsInBhZ2luYXRpb24iLCJ0b3RhbCIsInBhZ2VzIiwidXBkYXRlQ3VzdG9tZXIiLCJjdXN0b21lcklkIiwidXBkYXRlRGF0YSIsImNoZWNrQ3VzdG9tZXJBY2Nlc3MiLCJhY3Rpb24iLCJwZXJtaXNzaW9uTWFwIiwicmVxdWlyZWRQZXJtaXNzaW9uIl0sIm1hcHBpbmdzIjoiO0FBS0FBLEtBQUtDLElBQUksQ0FBQyxtQkFBbUIsSUFBTyxDQUFBO1FBQ2xDQyxTQUFTLElBQU1DO0lBQ2pCLENBQUE7QUFFQSx1QkFBdUI7QUFDdkJILEtBQUtDLElBQUksQ0FBQyxtQkFBbUIsSUFBTyxDQUFBO1FBQ2xDRyxXQUFXLElBQU8sQ0FBQTtnQkFDaEJDLE1BQU1MLEtBQUtNLEVBQUU7Z0JBQ2JDLFNBQVNQLEtBQUtNLEVBQUU7Z0JBQ2hCRSxNQUFNUixLQUFLTSxFQUFFO2dCQUNiRyxTQUFTVCxLQUFLTSxFQUFFO2dCQUNoQkksU0FBU1YsS0FBS00sRUFBRTtnQkFDaEJLLFVBQVVYLEtBQUtNLEVBQUU7WUFDbkIsQ0FBQTtJQUNGLENBQUE7Ozs7UUFsQk87QUFFUCx3QkFBd0I7QUFDeEIsTUFBTUgsY0FBY0gsS0FBS00sRUFBRTtBQWlCM0Isc0JBQXNCO0FBQ3RCLE1BQU1NLFlBQVlaLEtBQUtNLEVBQUU7QUFDekJPLE9BQU9DLEtBQUssR0FBR0Y7QUFFZkcsU0FBUyw4QkFBOEI7SUFDckNDLFdBQVc7UUFDVGhCLEtBQUtpQixhQUFhO1FBRWxCLG9CQUFvQjtRQUNwQkMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRLGdCQUFnQjtZQUM1Q0MsT0FBTztnQkFDTEMsU0FBU3RCLEtBQUtNLEVBQUUsQ0FBQyxJQUFNO2dCQUN2QmlCLFNBQVN2QixLQUFLTSxFQUFFO2dCQUNoQmtCLFlBQVl4QixLQUFLTSxFQUFFO1lBQ3JCO1lBQ0FtQixVQUFVO1FBQ1o7UUFFQSxpREFBaUQ7UUFDakR0QixZQUFZdUIsZUFBZSxDQUFD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