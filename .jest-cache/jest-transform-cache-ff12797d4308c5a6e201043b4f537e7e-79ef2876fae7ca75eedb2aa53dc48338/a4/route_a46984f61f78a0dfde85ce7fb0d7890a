e6c528cae12a6af906c2bb1cc6ee4fb2
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DELETE: function() {
        return DELETE;
    },
    GET: function() {
        return GET;
    },
    PUT: function() {
        return PUT;
    }
});
const _server = require("next/server");
const _cache = require("next/cache");
const _prisma = /*#__PURE__*/ _interop_require_default(require("../../../../lib/prisma"));
const _cache1 = require("../../../../lib/cache");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function GET(request, { params }) {
    const id = params.id; // Store params.id early to avoid async issues
    try {
        const purchaseId = parseInt(id);
        if (isNaN(purchaseId)) {
            return _server.NextResponse.json({
                error: {
                    message: "Invalid purchase ID format"
                }
            }, {
                status: 400
            });
        }
        const purchase = await _prisma.default.purchaseInvoice.findUnique({
            where: {
                id: purchaseId
            },
            include: {
                supplier: true,
                items: {
                    include: {
                        product: true
                    }
                }
            }
        });
        if (!purchase) {
            return _server.NextResponse.json({
                error: {
                    message: "Purchase invoice not found"
                }
            }, {
                status: 404
            });
        }
        return _server.NextResponse.json(purchase);
    } catch (error) {
        console.error(`Error fetching purchase invoice ${id}:`, error);
        const details = error instanceof Error ? error.message : "An unknown error occurred";
        return _server.NextResponse.json({
            error: {
                message: "Failed to fetch purchase invoice",
                details: details
            }
        }, {
            status: 500
        });
    }
}
async function PUT(request, { params }) {
    const id = params.id;
    try {
        const purchaseId = parseInt(id);
        if (isNaN(purchaseId)) {
            return _server.NextResponse.json({
                error: {
                    message: "Invalid purchase ID format"
                }
            }, {
                status: 400
            });
        }
        const body = await request.json();
        const originalPurchase = await _prisma.default.purchaseInvoice.findUnique({
            where: {
                id: purchaseId
            },
            include: {
                items: {
                    include: {
                        product: true
                    }
                }
            }
        });
        if (!originalPurchase) {
            return _server.NextResponse.json({
                error: {
                    message: "Purchase invoice not found to update"
                }
            }, {
                status: 404
            });
        }
        const { items: newItemsData, distributions: newDistributionsData, ...invoiceData } = body;
        const { id: _, createdAt, updatedAt, supplier, notes, ...dirtyData } = invoiceData;
        const cleanedInvoiceData = {};
        if (dirtyData.invoiceNumber) cleanedInvoiceData.invoiceNumber = dirtyData.invoiceNumber;
        if (dirtyData.status) cleanedInvoiceData.status = dirtyData.status;
        if (dirtyData.date) cleanedInvoiceData.date = new Date(dirtyData.date);
        if (dirtyData.dueDate !== undefined) cleanedInvoiceData.dueDate = dirtyData.dueDate ? new Date(dirtyData.dueDate) : null;
        if (dirtyData.totalAmount !== undefined) cleanedInvoiceData.total = Number(dirtyData.totalAmount);
        else if (dirtyData.total !== undefined) cleanedInvoiceData.total = Number(dirtyData.total);
        cleanedInvoiceData.distributions = newDistributionsData !== undefined ? newDistributionsData : originalPurchase.distributions;
        if (dirtyData.supplierId) cleanedInvoiceData.supplier = {
            connect: {
                id: Number(dirtyData.supplierId)
            }
        };
        else if (dirtyData.supplierId === null && originalPurchase.supplierId) cleanedInvoiceData.supplier = {
            disconnect: true
        };
        const result = await _prisma.default.$transaction(async (tx)=>{
            const inventoryUpdates = [];
            if (originalPurchase.items && originalPurchase.items.length > 0) {
                for (const oldItem of originalPurchase.items){
                    const productToUpdate = await tx.product.findUnique({
                        where: {
                            id: oldItem.productId
                        }
                    });
                    if (!productToUpdate) continue;
                    const oldItemDistribution = originalPurchase.distributions && Array.isArray(originalPurchase.distributions) && originalPurchase.items.indexOf(oldItem) < originalPurchase.distributions.length ? originalPurchase.distributions[originalPurchase.items.indexOf(oldItem)] : originalPurchase.distributions && typeof originalPurchase.distributions === "object" && !Array.isArray(originalPurchase.distributions) ? originalPurchase.distributions : null;
                    if (oldItemDistribution && Object.keys(oldItemDistribution).length > 0) {
                        for (const [shopIdStr, quantityInShop] of Object.entries(oldItemDistribution)){
                            const shopId = shopIdStr;
                            const qtyToRemove = Number(quantityInShop);
                            if (qtyToRemove <= 0 || isNaN(qtyToRemove)) continue;
                            const inventory = await tx.inventoryItem.findFirst({
                                where: {
                                    productId: oldItem.productId,
                                    shopId: shopId
                                }
                            });
                            if (inventory) {
                                const oldShopQuantity = inventory.quantity;
                                const newQuantity = Math.max(0, inventory.quantity - qtyToRemove);
                                await tx.inventoryItem.update({
                                    where: {
                                        id: inventory.id
                                    },
                                    data: {
                                        quantity: newQuantity,
                                        // If new quantity is 0, reset shopSpecificCost, else keep existing
                                        shopSpecificCost: newQuantity === 0 ? 0 : inventory.shopSpecificCost
                                    }
                                });
                                inventoryUpdates.push({
                                    productId: oldItem.productId,
                                    shopId: Number(shopId),
                                    newQuantity,
                                    oldQuantity: oldShopQuantity
                                });
                            }
                        }
                    } else {
                        // oldItemDistribution is missing. Attempt to infer shop for stock reversal.
                        console.warn(`Old item ${oldItem.productId} in purchase ${purchaseId} has no distribution. Attempting to infer shop for stock reversal.`);
                        const existingInventoriesForOldItem = await tx.inventoryItem.findMany({
                            where: {
                                productId: oldItem.productId
                            }
                        });
                        if (existingInventoriesForOldItem.length === 1) {
                            const shopIdToReverseFrom = existingInventoriesForOldItem[0].shopId;
                            const inventory = existingInventoriesForOldItem[0]; // Already fetched
                            const oldShopQuantity = inventory.quantity;
                            const newQuantity = Math.max(0, inventory.quantity - oldItem.quantity); // Use total oldItem.quantity
                            await tx.inventoryItem.update({
                                where: {
                                    id: inventory.id
                                },
                                data: {
                                    quantity: newQuantity,
                                    // If new quantity is 0, reset shopSpecificCost, else keep existing
                                    shopSpecificCost: newQuantity === 0 ? 0 : inventory.shopSpecificCost
                                }
                            });
                            inventoryUpdates.push({
                                productId: oldItem.productId,
                                shopId: Number(shopIdToReverseFrom),
                                newQuantity,
                                oldQuantity: oldShopQuantity
                            });
                            console.log(`Reversed ${oldItem.quantity} from product ${oldItem.productId} in inferred shop ${shopIdToReverseFrom}.`);
                        } else if (existingInventoriesForOldItem.length === 0) {
                            console.error(`Old item ${oldItem.productId} not found in any inventory. Cannot reverse stock for this item line from a specific shop.`);
                        } else {
                            console.error(`Old item ${oldItem.productId} exists in multiple shops and no specific distribution for reversal. Ambiguous. Stock not reversed from a specific shop for this item line.`);
                        }
                    }
                    let currentTotalProductQuantity = 0;
                    const allInventoryForProductAfterReversal = await tx.inventoryItem.findMany({
                        where: {
                            productId: oldItem.productId
                        }
                    });
                    currentTotalProductQuantity = allInventoryForProductAfterReversal.reduce((sum, inv)=>sum + inv.quantity, 0);
                    // Recalculate WAC based on remaining purchase history after removing this item
                    const remainingPurchaseItems = await tx.purchaseInvoiceItem.findMany({
                        where: {
                            productId: oldItem.productId,
                            purchaseInvoiceId: {
                                not: purchaseId
                            } // Exclude current invoice being updated
                        }
                    });
                    let totalRemainingQuantity = 0;
                    let totalRemainingValue = 0;
                    remainingPurchaseItems.forEach((purchaseItem)=>{
                        totalRemainingQuantity += purchaseItem.quantity;
                        totalRemainingValue += purchaseItem.quantity * purchaseItem.price;
                    });
                    let newWAC = 0;
                    if (totalRemainingQuantity > 0) {
                        newWAC = totalRemainingValue / totalRemainingQuantity;
                    }
                    await tx.product.update({
                        where: {
                            id: oldItem.productId
                        },
                        data: {
                            weightedAverageCost: newWAC >= 0 ? newWAC : 0
                        }
                    });
                }
            }
            await tx.purchaseInvoiceItem.deleteMany({
                where: {
                    purchaseInvoiceId: purchaseId
                }
            });
            // Recalculate totalAmount for the invoice based on new/updated items
            let newTotalInvoiceAmount = 0;
            if (newItemsData && Array.isArray(newItemsData)) {
                newItemsData.forEach((item)=>{
                    newTotalInvoiceAmount += Number(item.quantity) * Number(item.price || 0);
                });
            }
            cleanedInvoiceData.total = newTotalInvoiceAmount; // Ensure this is assigned to the correct field for DB update
            const updatedInvoice = await tx.purchaseInvoice.update({
                where: {
                    id: purchaseId
                },
                data: cleanedInvoiceData
            });
            if (newItemsData && Array.isArray(newItemsData)) {
                for(let i = 0; i < newItemsData.length; i++){
                    const newItem = newItemsData[i];
                    if (!newItem.productId || !newItem.quantity || newItem.quantity <= 0) continue;
                    await tx.purchaseInvoiceItem.create({
                        data: {
                            purchaseInvoiceId: purchaseId,
                            productId: Number(newItem.productId),
                            quantity: Number(newItem.quantity),
                            price: Number(newItem.price || 0),
                            total: Number(newItem.quantity) * Number(newItem.price || 0)
                        }
                    });
                    const productToUpdate = await tx.product.findUnique({
                        where: {
                            id: Number(newItem.productId)
                        }
                    });
                    if (!productToUpdate) continue;
                    const newItemDistribution = newDistributionsData && Array.isArray(newDistributionsData) && newDistributionsData[i] ? newDistributionsData[i] : newDistributionsData && typeof newDistributionsData === "object" && !Array.isArray(newDistributionsData) ? newDistributionsData : null;
                    const itemQuantityTotal = Number(newItem.quantity);
                    if (newItemDistribution && Object.keys(newItemDistribution).length > 0) {
                        for (const [shopIdStr, quantityInShop] of Object.entries(newItemDistribution)){
                            const shopId = shopIdStr;
                            const qtyToAdd = Number(quantityInShop);
                            if (qtyToAdd <= 0 || isNaN(qtyToAdd)) continue;
                            const inventory = await tx.inventoryItem.findFirst({
                                where: {
                                    productId: Number(newItem.productId),
                                    shopId: shopId
                                }
                            });
                            let finalQuantity = 0;
                            const oldInvQty = inventory?.quantity || 0;
                            let newShopSpecificCostValue = 0;
                            const itemPrice = Number(newItem.price || 0);
                            if (inventory) {
                                finalQuantity = inventory.quantity + qtyToAdd;
                                const oldShopTotalValue = (inventory.quantity || 0) * (inventory.shopSpecificCost || 0);
                                const valueOfThisBatch = qtyToAdd * itemPrice;
                                if (finalQuantity > 0) {
                                    newShopSpecificCostValue = (oldShopTotalValue + valueOfThisBatch) / finalQuantity;
                                } else {
                                    newShopSpecificCostValue = 0;
                                }
                                await tx.inventoryItem.update({
                                    where: {
                                        id: inventory.id
                                    },
                                    data: {
                                        quantity: finalQuantity,
                                        shopSpecificCost: newShopSpecificCostValue >= 0 ? newShopSpecificCostValue : 0
                                    }
                                });
                            } else {
                                finalQuantity = qtyToAdd;
                                newShopSpecificCostValue = itemPrice;
                                await tx.inventoryItem.create({
                                    data: {
                                        productId: Number(newItem.productId),
                                        shopId: shopId,
                                        quantity: finalQuantity,
                                        shopSpecificCost: newShopSpecificCostValue >= 0 ? newShopSpecificCostValue : 0
                                    }
                                });
                            }
                            inventoryUpdates.push({
                                productId: Number(newItem.productId),
                                shopId: Number(shopId),
                                newQuantity: finalQuantity,
                                oldQuantity: oldInvQty
                            });
                        }
                    } else {
                        // newItemDistribution is missing or empty. Try to infer shop or log error.
                        console.warn(`Purchase item with productId ${newItem.productId} in invoice ${purchaseId} does not have explicit shop distribution data. Attempting to infer target shop.`);
                        const existingInventoryItems = await tx.inventoryItem.findMany({
                            where: {
                                productId: Number(newItem.productId)
                            }
                        });
                        let targetShopId = null;
                        if (existingInventoryItems.length === 1) {
                            targetShopId = existingInventoryItems[0].shopId;
                            console.log(`Product ${newItem.productId} exists in one shop (${targetShopId}). Attributing new stock there.`);
                        } else if (existingInventoryItems.length === 0) {
                            console.error(`Product ${newItem.productId} is new to inventory and no shop distribution provided. Cannot automatically assign to a shop. Inventory not updated for this item.`);
                        } else {
                            console.error(`Product ${newItem.productId} exists in multiple shops and no specific distribution provided. Ambiguous. Inventory not updated for this item.`);
                        }
                        if (targetShopId) {
                            const qtyToAdd = itemQuantityTotal; // The total quantity for this newItem.
                            if (qtyToAdd > 0) {
                                const inventory = await tx.inventoryItem.findFirst({
                                    where: {
                                        productId: Number(newItem.productId),
                                        shopId: targetShopId
                                    }
                                });
                                let finalQuantity = 0;
                                const oldInvQty = inventory?.quantity || 0;
                                let newShopSpecificCostValue = 0;
                                const itemPrice = Number(newItem.price || 0);
                                if (inventory) {
                                    finalQuantity = inventory.quantity + qtyToAdd;
                                    const oldShopTotalValue = (inventory.quantity || 0) * (inventory.shopSpecificCost || 0);
                                    const valueOfThisBatch = qtyToAdd * itemPrice;
                                    if (finalQuantity > 0) {
                                        newShopSpecificCostValue = (oldShopTotalValue + valueOfThisBatch) / finalQuantity;
                                    } else {
                                        newShopSpecificCostValue = 0;
                                    }
                                    await tx.inventoryItem.update({
                                        where: {
                                            id: inventory.id
                                        },
                                        data: {
                                            quantity: finalQuantity,
                                            shopSpecificCost: newShopSpecificCostValue >= 0 ? newShopSpecificCostValue : 0
                                        }
                                    });
                                } else {
                                    finalQuantity = qtyToAdd;
                                    newShopSpecificCostValue = itemPrice;
                                    console.warn(`InventoryItem for product ${newItem.productId} in targetShopId ${targetShopId} not found during update, attempting create.`);
                                    await tx.inventoryItem.create({
                                        data: {
                                            productId: Number(newItem.productId),
                                            shopId: targetShopId,
                                            quantity: finalQuantity,
                                            shopSpecificCost: newShopSpecificCostValue >= 0 ? newShopSpecificCostValue : 0
                                        }
                                    });
                                }
                                inventoryUpdates.push({
                                    productId: Number(newItem.productId),
                                    shopId: Number(targetShopId),
                                    newQuantity: finalQuantity,
                                    oldQuantity: oldInvQty
                                });
                            } else {
                                console.warn(`Quantity for product ${newItem.productId} is zero or negative. No inventory update performed for this item.`);
                            }
                        }
                    }
                    // Recalculate WAC based on all purchase history for this product
                    // This ensures accuracy regardless of update order
                    const allPurchaseItems = await tx.purchaseInvoiceItem.findMany({
                        where: {
                            productId: Number(newItem.productId)
                        }
                    });
                    let totalPurchaseQuantity = 0;
                    let totalPurchaseValue = 0;
                    allPurchaseItems.forEach((purchaseItem)=>{
                        totalPurchaseQuantity += purchaseItem.quantity;
                        totalPurchaseValue += purchaseItem.quantity * purchaseItem.price;
                    });
                    let newWeightedAverageCost = 0;
                    if (totalPurchaseQuantity > 0) {
                        newWeightedAverageCost = totalPurchaseValue / totalPurchaseQuantity;
                    }
                    // Ensure WAC is valid
                    if (newWeightedAverageCost <= 0 || isNaN(newWeightedAverageCost)) {
                        newWeightedAverageCost = Number(newItem.price);
                    }
                    await tx.product.update({
                        where: {
                            id: Number(newItem.productId)
                        },
                        data: {
                            weightedAverageCost: newWeightedAverageCost
                        }
                    });
                }
            }
            const fullUpdatedInvoice = await tx.purchaseInvoice.findUnique({
                where: {
                    id: purchaseId
                },
                include: {
                    supplier: true,
                    items: {
                        include: {
                            product: true
                        }
                    }
                }
            });
            return {
                fullUpdatedInvoice,
                inventoryUpdates
            };
        }, {
            timeout: 30000
        });
        // Real-time updates now handled by polling system
        if (result && result.fullUpdatedInvoice) {
            console.log("Purchase invoice updated successfully");
        }
        // After successful transaction, invalidate relevant caches
        try {
            await _cache1.cacheService.invalidateInventory(); // Handles 'inventory:summary:*' and 'products:*'
            await _cache1.cacheService.del("dashboard:inventory");
            await _cache1.cacheService.del("dashboard:inventory-value");
            await _cache1.cacheService.del("dashboard:shops");
            await _cache1.cacheService.del("dashboard:all");
            await _cache1.cacheService.del("dashboard:summary");
            // Invalidate purchases-specific caches
            await _cache1.cacheService.invalidatePattern("purchases-optimized*");
            await _cache1.cacheService.invalidatePattern("purchase-stats*");
            console.log("Relevant caches invalidated after purchase update.");
        } catch (cacheError) {
            console.error("Error invalidating caches after purchase update:", cacheError);
        // Do not let cache invalidation error fail the main operation
        }
        // Revalidate Next.js cached pages
        try {
            (0, _cache.revalidateTag)("purchase-invoices");
            (0, _cache.revalidateTag)(`purchase-${purchaseId}`);
            (0, _cache.revalidatePath)(`/purchases/${purchaseId}`);
            (0, _cache.revalidatePath)(`/purchases/${purchaseId}/edit`);
            (0, _cache.revalidatePath)("/purchases");
            console.log("Next.js pages revalidated after purchase update.");
        } catch (revalidateError) {
            console.error("Error revalidating Next.js pages after purchase update:", revalidateError);
        }
        return _server.NextResponse.json({
            message: "Purchase invoice updated successfully",
            data: result.fullUpdatedInvoice
        });
    } catch (error) {
        console.error(`Error updating purchase invoice ${id}:`, error);
        const details = error instanceof Error ? error.message : String(error);
        return _server.NextResponse.json({
            error: {
                message: "Failed to update purchase invoice",
                details: details
            }
        }, {
            status: 500
        });
    }
}
async function DELETE(request, { params }) {
    const purchaseIdStr = params.id;
    try {
        const purchaseId = parseInt(purchaseIdStr);
        if (isNaN(purchaseId)) {
            return _server.NextResponse.json({
                error: {
                    message: "Invalid purchase ID format"
                }
            }, {
                status: 400
            });
        }
        const purchaseToDelete = await _prisma.default.purchaseInvoice.findUnique({
            where: {
                id: purchaseId
            },
            include: {
                items: {
                    include: {
                        product: true
                    }
                }
            }
        });
        if (!purchaseToDelete) {
            return _server.NextResponse.json({
                error: {
                    message: "Purchase invoice not found to delete"
                }
            }, {
                status: 404
            });
        }
        const result = await _prisma.default.$transaction(async (tx)=>{
            const inventoryUpdates = [];
            if (purchaseToDelete.items && purchaseToDelete.items.length > 0) {
                for (const item of purchaseToDelete.items){
                    if (!item.product) {
                        console.warn(`Item ${item.id} for purchase ${purchaseId} is missing product data. Skipping stock adjustment.`);
                        continue;
                    }
                    const productId = item.productId;
                    const quantityToRemoveForItemTotal = item.quantity; // Total quantity for this item line
                    let itemDistributionInfo = null;
                    const distributionsOnInvoice = purchaseToDelete.distributions;
                    // Attempt to get specific distribution for this item
                    if (distributionsOnInvoice && Array.isArray(distributionsOnInvoice) && purchaseToDelete.items.indexOf(item) < distributionsOnInvoice.length) {
                        const distData = distributionsOnInvoice[purchaseToDelete.items.indexOf(item)];
                        if (distData && typeof distData === "object" && Object.keys(distData).length > 0) {
                            itemDistributionInfo = distData;
                        }
                    }
                    if (itemDistributionInfo) {
                        // Case 1: Explicit distribution data found for the item
                        console.log(`Reversing item-specific distribution for product ${productId}, purchase ${purchaseId}`);
                        for (const [shopIdStr, distributedQuantityStr] of Object.entries(itemDistributionInfo)){
                            const shopId = shopIdStr;
                            const qtyInShopToRemove = Number(distributedQuantityStr);
                            if (isNaN(qtyInShopToRemove) || qtyInShopToRemove <= 0) continue;
                            const inventoryItem = await tx.inventoryItem.findFirst({
                                where: {
                                    productId,
                                    shopId: shopId
                                }
                            });
                            if (inventoryItem) {
                                const oldShopQuantity = inventoryItem.quantity;
                                const newShopQuantity = Math.max(0, inventoryItem.quantity - qtyInShopToRemove);
                                const updateData = {
                                    quantity: newShopQuantity,
                                    shopSpecificCost: newShopQuantity === 0 ? 0 : inventoryItem.shopSpecificCost
                                };
                                await tx.inventoryItem.update({
                                    where: {
                                        id: inventoryItem.id
                                    },
                                    data: updateData
                                });
                                inventoryUpdates.push({
                                    productId,
                                    shopId: Number(shopId),
                                    newQuantity: newShopQuantity,
                                    oldQuantity: oldShopQuantity
                                });
                                console.log(`  - Reduced inventory for product ${productId} in shop ${shopId} by ${qtyInShopToRemove}. Old: ${oldShopQuantity}, New: ${newShopQuantity}`);
                            } else {
                                console.warn(`  - Inventory item not found for product ${productId} in shop ${shopId} during purchase deletion with explicit distribution. Stock may be inaccurate.`);
                            }
                        }
                    } else {
                        // Case 2: No explicit distribution for this item. Attempt to infer.
                        console.warn(`No specific distribution found for item ${productId} in deleted purchase ${purchaseId}. Attempting to infer shop(s) for stock reversal of total quantity ${quantityToRemoveForItemTotal}.`);
                        const existingInventoriesForItem = await tx.inventoryItem.findMany({
                            where: {
                                productId: productId
                            }
                        });
                        if (existingInventoriesForItem.length === 1) {
                            const singleShopInventory = existingInventoriesForItem[0];
                            const shopIdToDeductFrom = singleShopInventory.shopId;
                            console.log(`Product ${productId} found in single shop ${shopIdToDeductFrom}. Deducting total item quantity ${quantityToRemoveForItemTotal}.`);
                            const oldShopQuantity = singleShopInventory.quantity;
                            const newShopQuantity = Math.max(0, singleShopInventory.quantity - quantityToRemoveForItemTotal);
                            const updateDataInferred = {
                                quantity: newShopQuantity,
                                shopSpecificCost: newShopQuantity === 0 ? 0 : singleShopInventory.shopSpecificCost
                            };
                            await tx.inventoryItem.update({
                                where: {
                                    id: singleShopInventory.id
                                },
                                data: updateDataInferred
                            });
                            inventoryUpdates.push({
                                productId,
                                shopId: Number(shopIdToDeductFrom),
                                newQuantity: newShopQuantity,
                                oldQuantity: oldShopQuantity
                            });
                            console.log(`  - Reduced inventory for product ${productId} in inferred shop ${shopIdToDeductFrom} by ${quantityToRemoveForItemTotal}. Old: ${oldShopQuantity}, New: ${newShopQuantity}`);
                        } else if (existingInventoriesForItem.length === 0) {
                            console.error(`Product ${productId} (from deleted purchase ${purchaseId}) not found in any inventory. Cannot reverse stock for this item.`);
                        } else {
                            console.error(`Product ${productId} (from deleted purchase ${purchaseId}) exists in multiple shops, but no specific distribution data was found on the invoice for reversal. Ambiguous. Stock not automatically reversed for this item. Manual adjustment may be needed.`);
                        }
                    }
                    // ---- BEGIN WAC Recalculation for the deleted item ----
                    const remainingPurchaseItems = await tx.purchaseInvoiceItem.findMany({
                        where: {
                            productId: productId,
                            purchaseInvoiceId: {
                                not: purchaseId
                            }
                        }
                    });
                    let totalRemainingQuantity = 0;
                    let totalRemainingValue = 0;
                    remainingPurchaseItems.forEach((pItem)=>{
                        totalRemainingQuantity += pItem.quantity;
                        totalRemainingValue += pItem.quantity * pItem.price;
                    });
                    let newCalculatedWAC = 0;
                    if (totalRemainingQuantity > 0) {
                        newCalculatedWAC = totalRemainingValue / totalRemainingQuantity;
                    }
                    await tx.product.update({
                        where: {
                            id: productId
                        },
                        data: {
                            weightedAverageCost: newCalculatedWAC >= 0 ? newCalculatedWAC : 0
                        }
                    });
                // ---- END WAC Recalculation ----
                }
            }
            await tx.purchaseInvoiceItem.deleteMany({
                where: {
                    purchaseInvoiceId: purchaseId
                }
            });
            await tx.purchaseInvoice.delete({
                where: {
                    id: purchaseId
                }
            });
            return {
                deletedInvoiceId: purchaseId,
                inventoryUpdates
            };
        });
        // Real-time updates now handled by polling system
        if (result && result.deletedInvoiceId) {
            console.log(`Purchase invoice ${result.deletedInvoiceId} deleted successfully`);
        }
        // After successful transaction, invalidate relevant caches
        try {
            await _cache1.cacheService.invalidateInventory(); // Handles 'inventory:summary:*' and 'products:*'
            await _cache1.cacheService.del("dashboard:inventory");
            await _cache1.cacheService.del("dashboard:inventory-value");
            await _cache1.cacheService.del("dashboard:shops");
            await _cache1.cacheService.del("dashboard:all");
            await _cache1.cacheService.del("dashboard:summary");
            // Invalidate purchases-specific caches
            await _cache1.cacheService.invalidatePattern("purchases-optimized*");
            await _cache1.cacheService.invalidatePattern("purchase-stats*");
            console.log("Relevant caches invalidated after purchase deletion.");
        } catch (cacheError) {
            console.error("Error invalidating caches after purchase deletion:", cacheError);
        // Do not let cache invalidation error fail the main operation
        }
        // Revalidate Next.js cached pages
        try {
            (0, _cache.revalidateTag)("purchase-invoices");
            (0, _cache.revalidateTag)(`purchase-${purchaseId}`);
            (0, _cache.revalidatePath)(`/purchases/${purchaseId}`);
            (0, _cache.revalidatePath)(`/purchases/${purchaseId}/edit`);
            (0, _cache.revalidatePath)("/purchases");
            console.log("Next.js pages revalidated after purchase deletion.");
        } catch (revalidateError) {
            console.error("Error revalidating Next.js pages after purchase deletion:", revalidateError);
        }
        return _server.NextResponse.json({
            message: "Purchase invoice deleted successfully"
        });
    } catch (error) {
        console.error(`Error deleting purchase invoice ${purchaseIdStr}:`, error);
        const details = error instanceof Error ? error.message : "An unknown error occurred";
        return _server.NextResponse.json({
            error: {
                message: "Failed to delete purchase invoice",
                details: details
            }
        }, {
            status: 500
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vc3JjL2FwcC9hcGkvcHVyY2hhc2VzL1tpZF0vcm91dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IHJldmFsaWRhdGVUYWcsIHJldmFsaWRhdGVQYXRoIH0gZnJvbSAnbmV4dC9jYWNoZSc7XG5pbXBvcnQgcHJpc21hIGZyb20gJ0AvbGliL3ByaXNtYSc7XG5pbXBvcnQgeyBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciB9IGZyb20gJ0BwcmlzbWEvY2xpZW50L3J1bnRpbWUvbGlicmFyeSc7XG5pbXBvcnQgeyBnZXRUb2tlbiB9IGZyb20gJ25leHQtYXV0aC9qd3QnO1xuaW1wb3J0IHsgY2FjaGVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvY2FjaGUnO1xuXG4vLyBHRVQgL2FwaS9wdXJjaGFzZXMvW2lkXSAtIEdldCBhIHNwZWNpZmljIHB1cmNoYXNlIGludm9pY2VcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQoXG4gICAgcmVxdWVzdDogTmV4dFJlcXVlc3QsXG4gICAgeyBwYXJhbXMgfTogeyBwYXJhbXM6IHsgaWQ6IHN0cmluZyB9IH1cbikge1xuICAgIGNvbnN0IGlkID0gcGFyYW1zLmlkOyAvLyBTdG9yZSBwYXJhbXMuaWQgZWFybHkgdG8gYXZvaWQgYXN5bmMgaXNzdWVzXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHVyY2hhc2VJZCA9IHBhcnNlSW50KGlkKTtcblxuICAgICAgICBpZiAoaXNOYU4ocHVyY2hhc2VJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgICAgICB7IGVycm9yOiB7IG1lc3NhZ2U6ICdJbnZhbGlkIHB1cmNoYXNlIElEIGZvcm1hdCcgfSB9LFxuICAgICAgICAgICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHB1cmNoYXNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHB1cmNoYXNlSWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXB1cmNoYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICAgICAgeyBlcnJvcjogeyBtZXNzYWdlOiAnUHVyY2hhc2UgaW52b2ljZSBub3QgZm91bmQnIH0gfSxcbiAgICAgICAgICAgICAgICB7IHN0YXR1czogNDA0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocHVyY2hhc2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHB1cmNoYXNlIGludm9pY2UgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCc7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgIHsgZXJyb3I6IHsgbWVzc2FnZTogJ0ZhaWxlZCB0byBmZXRjaCBwdXJjaGFzZSBpbnZvaWNlJywgZGV0YWlsczogZGV0YWlscyB9IH0sXG4gICAgICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8vIFBVVCAvYXBpL3B1cmNoYXNlcy9baWRdIC0gVXBkYXRlIGEgcHVyY2hhc2UgaW52b2ljZVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBVVChcbiAgICByZXF1ZXN0OiBOZXh0UmVxdWVzdCxcbiAgICB7IHBhcmFtcyB9OiB7IHBhcmFtczogeyBpZDogc3RyaW5nIH0gfVxuKSB7XG4gICAgY29uc3QgaWQgPSBwYXJhbXMuaWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHVyY2hhc2VJZCA9IHBhcnNlSW50KGlkKTtcbiAgICAgICAgaWYgKGlzTmFOKHB1cmNoYXNlSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICAgICAgeyBlcnJvcjogeyBtZXNzYWdlOiAnSW52YWxpZCBwdXJjaGFzZSBJRCBmb3JtYXQnIH0gfSxcbiAgICAgICAgICAgICAgICB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQdXJjaGFzZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICB3aGVyZTogeyBpZDogcHVyY2hhc2VJZCB9LFxuICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogeyBpbmNsdWRlOiB7IHByb2R1Y3Q6IHRydWUgfSB9IH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW9yaWdpbmFsUHVyY2hhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgICAgICB7IGVycm9yOiB7IG1lc3NhZ2U6ICdQdXJjaGFzZSBpbnZvaWNlIG5vdCBmb3VuZCB0byB1cGRhdGUnIH0gfSxcbiAgICAgICAgICAgICAgICB7IHN0YXR1czogNDA0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXRlbXM6IG5ld0l0ZW1zRGF0YSwgZGlzdHJpYnV0aW9uczogbmV3RGlzdHJpYnV0aW9uc0RhdGEsIC4uLmludm9pY2VEYXRhIH0gPSBib2R5O1xuICAgICAgICBjb25zdCB7IGlkOiBfLCBjcmVhdGVkQXQsIHVwZGF0ZWRBdCwgc3VwcGxpZXIsIG5vdGVzLCAuLi5kaXJ0eURhdGEgfSA9IGludm9pY2VEYXRhO1xuICAgICAgICBjb25zdCBjbGVhbmVkSW52b2ljZURhdGE6IGFueSA9IHt9O1xuICAgICAgICBpZiAoZGlydHlEYXRhLmludm9pY2VOdW1iZXIpIGNsZWFuZWRJbnZvaWNlRGF0YS5pbnZvaWNlTnVtYmVyID0gZGlydHlEYXRhLmludm9pY2VOdW1iZXI7XG4gICAgICAgIGlmIChkaXJ0eURhdGEuc3RhdHVzKSBjbGVhbmVkSW52b2ljZURhdGEuc3RhdHVzID0gZGlydHlEYXRhLnN0YXR1cztcbiAgICAgICAgaWYgKGRpcnR5RGF0YS5kYXRlKSBjbGVhbmVkSW52b2ljZURhdGEuZGF0ZSA9IG5ldyBEYXRlKGRpcnR5RGF0YS5kYXRlKTtcbiAgICAgICAgaWYgKGRpcnR5RGF0YS5kdWVEYXRlICE9PSB1bmRlZmluZWQpIGNsZWFuZWRJbnZvaWNlRGF0YS5kdWVEYXRlID0gZGlydHlEYXRhLmR1ZURhdGUgPyBuZXcgRGF0ZShkaXJ0eURhdGEuZHVlRGF0ZSkgOiBudWxsO1xuICAgICAgICBpZiAoZGlydHlEYXRhLnRvdGFsQW1vdW50ICE9PSB1bmRlZmluZWQpIGNsZWFuZWRJbnZvaWNlRGF0YS50b3RhbCA9IE51bWJlcihkaXJ0eURhdGEudG90YWxBbW91bnQpO1xuICAgICAgICBlbHNlIGlmIChkaXJ0eURhdGEudG90YWwgIT09IHVuZGVmaW5lZCkgY2xlYW5lZEludm9pY2VEYXRhLnRvdGFsID0gTnVtYmVyKGRpcnR5RGF0YS50b3RhbCk7XG4gICAgICAgIGNsZWFuZWRJbnZvaWNlRGF0YS5kaXN0cmlidXRpb25zID0gbmV3RGlzdHJpYnV0aW9uc0RhdGEgIT09IHVuZGVmaW5lZCA/IG5ld0Rpc3RyaWJ1dGlvbnNEYXRhIDogb3JpZ2luYWxQdXJjaGFzZS5kaXN0cmlidXRpb25zO1xuICAgICAgICBpZiAoZGlydHlEYXRhLnN1cHBsaWVySWQpIGNsZWFuZWRJbnZvaWNlRGF0YS5zdXBwbGllciA9IHsgY29ubmVjdDogeyBpZDogTnVtYmVyKGRpcnR5RGF0YS5zdXBwbGllcklkKSB9IH07XG4gICAgICAgIGVsc2UgaWYgKGRpcnR5RGF0YS5zdXBwbGllcklkID09PSBudWxsICYmIG9yaWdpbmFsUHVyY2hhc2Uuc3VwcGxpZXJJZCkgY2xlYW5lZEludm9pY2VEYXRhLnN1cHBsaWVyID0geyBkaXNjb25uZWN0OiB0cnVlIH07XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLiR0cmFuc2FjdGlvbihhc3luYyAodHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludmVudG9yeVVwZGF0ZXM6IEFycmF5PHsgcHJvZHVjdElkOiBudW1iZXIsIHNob3BJZDogbnVtYmVyLCBuZXdRdWFudGl0eTogbnVtYmVyLCBvbGRRdWFudGl0eT86IG51bWJlciB9PiA9IFtdO1xuXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxQdXJjaGFzZS5pdGVtcyAmJiBvcmlnaW5hbFB1cmNoYXNlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9sZEl0ZW0gb2Ygb3JpZ2luYWxQdXJjaGFzZS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9VcGRhdGUgPSBhd2FpdCB0eC5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogb2xkSXRlbS5wcm9kdWN0SWQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9kdWN0VG9VcGRhdGUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZEl0ZW1EaXN0cmlidXRpb24gPSBvcmlnaW5hbFB1cmNoYXNlLmRpc3RyaWJ1dGlvbnMgJiYgQXJyYXkuaXNBcnJheShvcmlnaW5hbFB1cmNoYXNlLmRpc3RyaWJ1dGlvbnMpICYmIG9yaWdpbmFsUHVyY2hhc2UuaXRlbXMuaW5kZXhPZihvbGRJdGVtKSA8IG9yaWdpbmFsUHVyY2hhc2UuZGlzdHJpYnV0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3JpZ2luYWxQdXJjaGFzZS5kaXN0cmlidXRpb25zW29yaWdpbmFsUHVyY2hhc2UuaXRlbXMuaW5kZXhPZihvbGRJdGVtKV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogKG9yaWdpbmFsUHVyY2hhc2UuZGlzdHJpYnV0aW9ucyAmJiB0eXBlb2Ygb3JpZ2luYWxQdXJjaGFzZS5kaXN0cmlidXRpb25zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvcmlnaW5hbFB1cmNoYXNlLmRpc3RyaWJ1dGlvbnMpID8gb3JpZ2luYWxQdXJjaGFzZS5kaXN0cmlidXRpb25zIDogbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEl0ZW1EaXN0cmlidXRpb24gJiYgT2JqZWN0LmtleXMob2xkSXRlbURpc3RyaWJ1dGlvbikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbc2hvcElkU3RyLCBxdWFudGl0eUluU2hvcF0gb2YgT2JqZWN0LmVudHJpZXMob2xkSXRlbURpc3RyaWJ1dGlvbiBhcyBhbnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvcElkID0gc2hvcElkU3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF0eVRvUmVtb3ZlID0gTnVtYmVyKHF1YW50aXR5SW5TaG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXR5VG9SZW1vdmUgPD0gMCB8fCBpc05hTihxdHlUb1JlbW92ZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGludmVudG9yeSA9IGF3YWl0IHR4LmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHsgd2hlcmU6IHsgcHJvZHVjdElkOiBvbGRJdGVtLnByb2R1Y3RJZCwgc2hvcElkOiBzaG9wSWQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52ZW50b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFNob3BRdWFudGl0eSA9IGludmVudG9yeS5xdWFudGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UXVhbnRpdHkgPSBNYXRoLm1heCgwLCBpbnZlbnRvcnkucXVhbnRpdHkgLSBxdHlUb1JlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0udXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBpbnZlbnRvcnkuaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3UXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmV3IHF1YW50aXR5IGlzIDAsIHJlc2V0IHNob3BTcGVjaWZpY0Nvc3QsIGVsc2Uga2VlcCBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BTcGVjaWZpY0Nvc3Q6IG5ld1F1YW50aXR5ID09PSAwID8gMCA6IGludmVudG9yeS5zaG9wU3BlY2lmaWNDb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZlbnRvcnlVcGRhdGVzLnB1c2goeyBwcm9kdWN0SWQ6IG9sZEl0ZW0ucHJvZHVjdElkLCBzaG9wSWQ6IE51bWJlcihzaG9wSWQpLCBuZXdRdWFudGl0eSwgb2xkUXVhbnRpdHk6IG9sZFNob3BRdWFudGl0eSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbGRJdGVtRGlzdHJpYnV0aW9uIGlzIG1pc3NpbmcuIEF0dGVtcHQgdG8gaW5mZXIgc2hvcCBmb3Igc3RvY2sgcmV2ZXJzYWwuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYE9sZCBpdGVtICR7b2xkSXRlbS5wcm9kdWN0SWR9IGluIHB1cmNoYXNlICR7cHVyY2hhc2VJZH0gaGFzIG5vIGRpc3RyaWJ1dGlvbi4gQXR0ZW1wdGluZyB0byBpbmZlciBzaG9wIGZvciBzdG9jayByZXZlcnNhbC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSW52ZW50b3JpZXNGb3JPbGRJdGVtID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBvbGRJdGVtLnByb2R1Y3RJZCB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0ludmVudG9yaWVzRm9yT2xkSXRlbS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG9wSWRUb1JldmVyc2VGcm9tID0gZXhpc3RpbmdJbnZlbnRvcmllc0Zvck9sZEl0ZW1bMF0uc2hvcElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGludmVudG9yeSA9IGV4aXN0aW5nSW52ZW50b3JpZXNGb3JPbGRJdGVtWzBdOyAvLyBBbHJlYWR5IGZldGNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRTaG9wUXVhbnRpdHkgPSBpbnZlbnRvcnkucXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UXVhbnRpdHkgPSBNYXRoLm1heCgwLCBpbnZlbnRvcnkucXVhbnRpdHkgLSBvbGRJdGVtLnF1YW50aXR5KTsgLy8gVXNlIHRvdGFsIG9sZEl0ZW0ucXVhbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBpbnZlbnRvcnkuaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IG5ld1F1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmV3IHF1YW50aXR5IGlzIDAsIHJlc2V0IHNob3BTcGVjaWZpY0Nvc3QsIGVsc2Uga2VlcCBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcFNwZWNpZmljQ29zdDogbmV3UXVhbnRpdHkgPT09IDAgPyAwIDogaW52ZW50b3J5LnNob3BTcGVjaWZpY0Nvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmVudG9yeVVwZGF0ZXMucHVzaCh7IHByb2R1Y3RJZDogb2xkSXRlbS5wcm9kdWN0SWQsIHNob3BJZDogTnVtYmVyKHNob3BJZFRvUmV2ZXJzZUZyb20pLCBuZXdRdWFudGl0eSwgb2xkUXVhbnRpdHk6IG9sZFNob3BRdWFudGl0eSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmV2ZXJzZWQgJHtvbGRJdGVtLnF1YW50aXR5fSBmcm9tIHByb2R1Y3QgJHtvbGRJdGVtLnByb2R1Y3RJZH0gaW4gaW5mZXJyZWQgc2hvcCAke3Nob3BJZFRvUmV2ZXJzZUZyb219LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0ludmVudG9yaWVzRm9yT2xkSXRlbS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBPbGQgaXRlbSAke29sZEl0ZW0ucHJvZHVjdElkfSBub3QgZm91bmQgaW4gYW55IGludmVudG9yeS4gQ2Fubm90IHJldmVyc2Ugc3RvY2sgZm9yIHRoaXMgaXRlbSBsaW5lIGZyb20gYSBzcGVjaWZpYyBzaG9wLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gTXVsdGlwbGUgc2hvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBPbGQgaXRlbSAke29sZEl0ZW0ucHJvZHVjdElkfSBleGlzdHMgaW4gbXVsdGlwbGUgc2hvcHMgYW5kIG5vIHNwZWNpZmljIGRpc3RyaWJ1dGlvbiBmb3IgcmV2ZXJzYWwuIEFtYmlndW91cy4gU3RvY2sgbm90IHJldmVyc2VkIGZyb20gYSBzcGVjaWZpYyBzaG9wIGZvciB0aGlzIGl0ZW0gbGluZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50VG90YWxQcm9kdWN0UXVhbnRpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxJbnZlbnRvcnlGb3JQcm9kdWN0QWZ0ZXJSZXZlcnNhbCA9IGF3YWl0IHR4LmludmVudG9yeUl0ZW0uZmluZE1hbnkoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IG9sZEl0ZW0ucHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb3RhbFByb2R1Y3RRdWFudGl0eSA9IGFsbEludmVudG9yeUZvclByb2R1Y3RBZnRlclJldmVyc2FsLnJlZHVjZSgoc3VtLCBpbnYpID0+IHN1bSArIGludi5xdWFudGl0eSwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgV0FDIGJhc2VkIG9uIHJlbWFpbmluZyBwdXJjaGFzZSBoaXN0b3J5IGFmdGVyIHJlbW92aW5nIHRoaXMgaXRlbVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdQdXJjaGFzZUl0ZW1zID0gYXdhaXQgdHgucHVyY2hhc2VJbnZvaWNlSXRlbS5maW5kTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogb2xkSXRlbS5wcm9kdWN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVyY2hhc2VJbnZvaWNlSWQ6IHsgbm90OiBwdXJjaGFzZUlkIH0gLy8gRXhjbHVkZSBjdXJyZW50IGludm9pY2UgYmVpbmcgdXBkYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxSZW1haW5pbmdRdWFudGl0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbFJlbWFpbmluZ1ZhbHVlID0gMDtcblxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdQdXJjaGFzZUl0ZW1zLmZvckVhY2gocHVyY2hhc2VJdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmVtYWluaW5nUXVhbnRpdHkgKz0gcHVyY2hhc2VJdGVtLnF1YW50aXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxSZW1haW5pbmdWYWx1ZSArPSBwdXJjaGFzZUl0ZW0ucXVhbnRpdHkgKiBwdXJjaGFzZUl0ZW0ucHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdXQUMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxSZW1haW5pbmdRdWFudGl0eSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1dBQyA9IHRvdGFsUmVtYWluaW5nVmFsdWUgLyB0b3RhbFJlbWFpbmluZ1F1YW50aXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdHgucHJvZHVjdC51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IG9sZEl0ZW0ucHJvZHVjdElkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHdlaWdodGVkQXZlcmFnZUNvc3Q6IG5ld1dBQyA+PSAwID8gbmV3V0FDIDogMCB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgdHgucHVyY2hhc2VJbnZvaWNlSXRlbS5kZWxldGVNYW55KHsgd2hlcmU6IHsgcHVyY2hhc2VJbnZvaWNlSWQ6IHB1cmNoYXNlSWQgfSB9KTtcblxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgdG90YWxBbW91bnQgZm9yIHRoZSBpbnZvaWNlIGJhc2VkIG9uIG5ldy91cGRhdGVkIGl0ZW1zXG4gICAgICAgICAgICBsZXQgbmV3VG90YWxJbnZvaWNlQW1vdW50ID0gMDtcbiAgICAgICAgICAgIGlmIChuZXdJdGVtc0RhdGEgJiYgQXJyYXkuaXNBcnJheShuZXdJdGVtc0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgbmV3SXRlbXNEYXRhLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvdGFsSW52b2ljZUFtb3VudCArPSBOdW1iZXIoaXRlbS5xdWFudGl0eSkgKiBOdW1iZXIoaXRlbS5wcmljZSB8fCAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFuZWRJbnZvaWNlRGF0YS50b3RhbCA9IG5ld1RvdGFsSW52b2ljZUFtb3VudDsgLy8gRW5zdXJlIHRoaXMgaXMgYXNzaWduZWQgdG8gdGhlIGNvcnJlY3QgZmllbGQgZm9yIERCIHVwZGF0ZVxuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW52b2ljZSA9IGF3YWl0IHR4LnB1cmNoYXNlSW52b2ljZS51cGRhdGUoeyB3aGVyZTogeyBpZDogcHVyY2hhc2VJZCB9LCBkYXRhOiBjbGVhbmVkSW52b2ljZURhdGEgfSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdJdGVtc0RhdGEgJiYgQXJyYXkuaXNBcnJheShuZXdJdGVtc0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdJdGVtc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IG5ld0l0ZW1zRGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdJdGVtLnByb2R1Y3RJZCB8fCAhbmV3SXRlbS5xdWFudGl0eSB8fCBuZXdJdGVtLnF1YW50aXR5IDw9IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5wdXJjaGFzZUludm9pY2VJdGVtLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVyY2hhc2VJbnZvaWNlSWQ6IHB1cmNoYXNlSWQsIHByb2R1Y3RJZDogTnVtYmVyKG5ld0l0ZW0ucHJvZHVjdElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogTnVtYmVyKG5ld0l0ZW0ucXVhbnRpdHkpLCBwcmljZTogTnVtYmVyKG5ld0l0ZW0ucHJpY2UgfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw6IE51bWJlcihuZXdJdGVtLnF1YW50aXR5KSAqIE51bWJlcihuZXdJdGVtLnByaWNlIHx8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9VcGRhdGUgPSBhd2FpdCB0eC5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogTnVtYmVyKG5ld0l0ZW0ucHJvZHVjdElkKSB9IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb2R1Y3RUb1VwZGF0ZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbURpc3RyaWJ1dGlvbiA9IG5ld0Rpc3RyaWJ1dGlvbnNEYXRhICYmIEFycmF5LmlzQXJyYXkobmV3RGlzdHJpYnV0aW9uc0RhdGEpICYmIG5ld0Rpc3RyaWJ1dGlvbnNEYXRhW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ld0Rpc3RyaWJ1dGlvbnNEYXRhW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChuZXdEaXN0cmlidXRpb25zRGF0YSAmJiB0eXBlb2YgbmV3RGlzdHJpYnV0aW9uc0RhdGEgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG5ld0Rpc3RyaWJ1dGlvbnNEYXRhKSA/IG5ld0Rpc3RyaWJ1dGlvbnNEYXRhIDogbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbVF1YW50aXR5VG90YWwgPSBOdW1iZXIobmV3SXRlbS5xdWFudGl0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0l0ZW1EaXN0cmlidXRpb24gJiYgT2JqZWN0LmtleXMobmV3SXRlbURpc3RyaWJ1dGlvbikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbc2hvcElkU3RyLCBxdWFudGl0eUluU2hvcF0gb2YgT2JqZWN0LmVudHJpZXMobmV3SXRlbURpc3RyaWJ1dGlvbiBhcyBhbnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvcElkID0gc2hvcElkU3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF0eVRvQWRkID0gTnVtYmVyKHF1YW50aXR5SW5TaG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXR5VG9BZGQgPD0gMCB8fCBpc05hTihxdHlUb0FkZCkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW52ZW50b3J5ID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kRmlyc3QoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IE51bWJlcihuZXdJdGVtLnByb2R1Y3RJZCksIHNob3BJZDogc2hvcElkIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsUXVhbnRpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZEludlF0eSA9IGludmVudG9yeT8ucXVhbnRpdHkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3U2hvcFNwZWNpZmljQ29zdFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtUHJpY2UgPSBOdW1iZXIobmV3SXRlbS5wcmljZSB8fCAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnZlbnRvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxRdWFudGl0eSA9IGludmVudG9yeS5xdWFudGl0eSArIHF0eVRvQWRkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRTaG9wVG90YWxWYWx1ZSA9IChpbnZlbnRvcnkucXVhbnRpdHkgfHwgMCkgKiAoaW52ZW50b3J5LnNob3BTcGVjaWZpY0Nvc3QgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlT2ZUaGlzQmF0Y2ggPSBxdHlUb0FkZCAqIGl0ZW1QcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsUXVhbnRpdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTaG9wU3BlY2lmaWNDb3N0VmFsdWUgPSAob2xkU2hvcFRvdGFsVmFsdWUgKyB2YWx1ZU9mVGhpc0JhdGNoKSAvIGZpbmFsUXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTaG9wU3BlY2lmaWNDb3N0VmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0udXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBpbnZlbnRvcnkuaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcXVhbnRpdHk6IGZpbmFsUXVhbnRpdHksIHNob3BTcGVjaWZpY0Nvc3Q6IG5ld1Nob3BTcGVjaWZpY0Nvc3RWYWx1ZSA+PSAwID8gbmV3U2hvcFNwZWNpZmljQ29zdFZhbHVlIDogMCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsUXVhbnRpdHkgPSBxdHlUb0FkZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2hvcFNwZWNpZmljQ29zdFZhbHVlID0gaXRlbVByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBOdW1iZXIobmV3SXRlbS5wcm9kdWN0SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BJZDogc2hvcElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBmaW5hbFF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BTcGVjaWZpY0Nvc3Q6IG5ld1Nob3BTcGVjaWZpY0Nvc3RWYWx1ZSA+PSAwID8gbmV3U2hvcFNwZWNpZmljQ29zdFZhbHVlIDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52ZW50b3J5VXBkYXRlcy5wdXNoKHsgcHJvZHVjdElkOiBOdW1iZXIobmV3SXRlbS5wcm9kdWN0SWQpLCBzaG9wSWQ6IE51bWJlcihzaG9wSWQpLCBuZXdRdWFudGl0eTogZmluYWxRdWFudGl0eSwgb2xkUXVhbnRpdHk6IG9sZEludlF0eSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ld0l0ZW1EaXN0cmlidXRpb24gaXMgbWlzc2luZyBvciBlbXB0eS4gVHJ5IHRvIGluZmVyIHNob3Agb3IgbG9nIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBQdXJjaGFzZSBpdGVtIHdpdGggcHJvZHVjdElkICR7bmV3SXRlbS5wcm9kdWN0SWR9IGluIGludm9pY2UgJHtwdXJjaGFzZUlkfSBkb2VzIG5vdCBoYXZlIGV4cGxpY2l0IHNob3AgZGlzdHJpYnV0aW9uIGRhdGEuIEF0dGVtcHRpbmcgdG8gaW5mZXIgdGFyZ2V0IHNob3AuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0ludmVudG9yeUl0ZW1zID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBOdW1iZXIobmV3SXRlbS5wcm9kdWN0SWQpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0U2hvcElkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nSW52ZW50b3J5SXRlbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2hvcElkID0gZXhpc3RpbmdJbnZlbnRvcnlJdGVtc1swXS5zaG9wSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFByb2R1Y3QgJHtuZXdJdGVtLnByb2R1Y3RJZH0gZXhpc3RzIGluIG9uZSBzaG9wICgke3RhcmdldFNob3BJZH0pLiBBdHRyaWJ1dGluZyBuZXcgc3RvY2sgdGhlcmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nSW52ZW50b3J5SXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUHJvZHVjdCAke25ld0l0ZW0ucHJvZHVjdElkfSBpcyBuZXcgdG8gaW52ZW50b3J5IGFuZCBubyBzaG9wIGRpc3RyaWJ1dGlvbiBwcm92aWRlZC4gQ2Fubm90IGF1dG9tYXRpY2FsbHkgYXNzaWduIHRvIGEgc2hvcC4gSW52ZW50b3J5IG5vdCB1cGRhdGVkIGZvciB0aGlzIGl0ZW0uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBleGlzdGluZ0ludmVudG9yeUl0ZW1zLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBQcm9kdWN0ICR7bmV3SXRlbS5wcm9kdWN0SWR9IGV4aXN0cyBpbiBtdWx0aXBsZSBzaG9wcyBhbmQgbm8gc3BlY2lmaWMgZGlzdHJpYnV0aW9uIHByb3ZpZGVkLiBBbWJpZ3VvdXMuIEludmVudG9yeSBub3QgdXBkYXRlZCBmb3IgdGhpcyBpdGVtLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U2hvcElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcXR5VG9BZGQgPSBpdGVtUXVhbnRpdHlUb3RhbDsgLy8gVGhlIHRvdGFsIHF1YW50aXR5IGZvciB0aGlzIG5ld0l0ZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF0eVRvQWRkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnZlbnRvcnkgPSBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogTnVtYmVyKG5ld0l0ZW0ucHJvZHVjdElkKSwgc2hvcElkOiB0YXJnZXRTaG9wSWQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsUXVhbnRpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRJbnZRdHkgPSBpbnZlbnRvcnk/LnF1YW50aXR5IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdTaG9wU3BlY2lmaWNDb3N0VmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtUHJpY2UgPSBOdW1iZXIobmV3SXRlbS5wcmljZSB8fCAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52ZW50b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFF1YW50aXR5ID0gaW52ZW50b3J5LnF1YW50aXR5ICsgcXR5VG9BZGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRTaG9wVG90YWxWYWx1ZSA9IChpbnZlbnRvcnkucXVhbnRpdHkgfHwgMCkgKiAoaW52ZW50b3J5LnNob3BTcGVjaWZpY0Nvc3QgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZU9mVGhpc0JhdGNoID0gcXR5VG9BZGQgKiBpdGVtUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxRdWFudGl0eSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTaG9wU3BlY2lmaWNDb3N0VmFsdWUgPSAob2xkU2hvcFRvdGFsVmFsdWUgKyB2YWx1ZU9mVGhpc0JhdGNoKSAvIGZpbmFsUXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Nob3BTcGVjaWZpY0Nvc3RWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGludmVudG9yeS5pZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcXVhbnRpdHk6IGZpbmFsUXVhbnRpdHksIHNob3BTcGVjaWZpY0Nvc3Q6IG5ld1Nob3BTcGVjaWZpY0Nvc3RWYWx1ZSA+PSAwID8gbmV3U2hvcFNwZWNpZmljQ29zdFZhbHVlIDogMCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsUXVhbnRpdHkgPSBxdHlUb0FkZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Nob3BTcGVjaWZpY0Nvc3RWYWx1ZSA9IGl0ZW1QcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52ZW50b3J5SXRlbSBmb3IgcHJvZHVjdCAke25ld0l0ZW0ucHJvZHVjdElkfSBpbiB0YXJnZXRTaG9wSWQgJHt0YXJnZXRTaG9wSWR9IG5vdCBmb3VuZCBkdXJpbmcgdXBkYXRlLCBhdHRlbXB0aW5nIGNyZWF0ZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogTnVtYmVyKG5ld0l0ZW0ucHJvZHVjdElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcElkOiB0YXJnZXRTaG9wSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBmaW5hbFF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wU3BlY2lmaWNDb3N0OiBuZXdTaG9wU3BlY2lmaWNDb3N0VmFsdWUgPj0gMCA/IG5ld1Nob3BTcGVjaWZpY0Nvc3RWYWx1ZSA6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZlbnRvcnlVcGRhdGVzLnB1c2goeyBwcm9kdWN0SWQ6IE51bWJlcihuZXdJdGVtLnByb2R1Y3RJZCksIHNob3BJZDogTnVtYmVyKHRhcmdldFNob3BJZCksIG5ld1F1YW50aXR5OiBmaW5hbFF1YW50aXR5LCBvbGRRdWFudGl0eTogb2xkSW52UXR5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUXVhbnRpdHkgZm9yIHByb2R1Y3QgJHtuZXdJdGVtLnByb2R1Y3RJZH0gaXMgemVybyBvciBuZWdhdGl2ZS4gTm8gaW52ZW50b3J5IHVwZGF0ZSBwZXJmb3JtZWQgZm9yIHRoaXMgaXRlbS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBXQUMgYmFzZWQgb24gYWxsIHB1cmNoYXNlIGhpc3RvcnkgZm9yIHRoaXMgcHJvZHVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgYWNjdXJhY3kgcmVnYXJkbGVzcyBvZiB1cGRhdGUgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsUHVyY2hhc2VJdGVtcyA9IGF3YWl0IHR4LnB1cmNoYXNlSW52b2ljZUl0ZW0uZmluZE1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBOdW1iZXIobmV3SXRlbS5wcm9kdWN0SWQpIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsUHVyY2hhc2VRdWFudGl0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbFB1cmNoYXNlVmFsdWUgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbFB1cmNoYXNlSXRlbXMuZm9yRWFjaChwdXJjaGFzZUl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxQdXJjaGFzZVF1YW50aXR5ICs9IHB1cmNoYXNlSXRlbS5xdWFudGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUHVyY2hhc2VWYWx1ZSArPSBwdXJjaGFzZUl0ZW0ucXVhbnRpdHkgKiBwdXJjaGFzZUl0ZW0ucHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdXZWlnaHRlZEF2ZXJhZ2VDb3N0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsUHVyY2hhc2VRdWFudGl0eSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1dlaWdodGVkQXZlcmFnZUNvc3QgPSB0b3RhbFB1cmNoYXNlVmFsdWUgLyB0b3RhbFB1cmNoYXNlUXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgV0FDIGlzIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdXZWlnaHRlZEF2ZXJhZ2VDb3N0IDw9IDAgfHwgaXNOYU4obmV3V2VpZ2h0ZWRBdmVyYWdlQ29zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1dlaWdodGVkQXZlcmFnZUNvc3QgPSBOdW1iZXIobmV3SXRlbS5wcmljZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5wcm9kdWN0LnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogTnVtYmVyKG5ld0l0ZW0ucHJvZHVjdElkKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB3ZWlnaHRlZEF2ZXJhZ2VDb3N0OiBuZXdXZWlnaHRlZEF2ZXJhZ2VDb3N0IH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnVsbFVwZGF0ZWRJbnZvaWNlID0gYXdhaXQgdHgucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBwdXJjaGFzZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBzdXBwbGllcjogdHJ1ZSwgaXRlbXM6IHsgaW5jbHVkZTogeyBwcm9kdWN0OiB0cnVlIH0gfSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGZ1bGxVcGRhdGVkSW52b2ljZSwgaW52ZW50b3J5VXBkYXRlcyB9O1xuICAgICAgICB9LCB7IHRpbWVvdXQ6IDMwMDAwIH0pO1xuXG4gICAgICAgIC8vIFJlYWwtdGltZSB1cGRhdGVzIG5vdyBoYW5kbGVkIGJ5IHBvbGxpbmcgc3lzdGVtXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmZ1bGxVcGRhdGVkSW52b2ljZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1B1cmNoYXNlIGludm9pY2UgdXBkYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFmdGVyIHN1Y2Nlc3NmdWwgdHJhbnNhY3Rpb24sIGludmFsaWRhdGUgcmVsZXZhbnQgY2FjaGVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2UuaW52YWxpZGF0ZUludmVudG9yeSgpOyAvLyBIYW5kbGVzICdpbnZlbnRvcnk6c3VtbWFyeToqJyBhbmQgJ3Byb2R1Y3RzOionXG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2UuZGVsKCdkYXNoYm9hcmQ6aW52ZW50b3J5Jyk7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2UuZGVsKCdkYXNoYm9hcmQ6aW52ZW50b3J5LXZhbHVlJyk7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2UuZGVsKCdkYXNoYm9hcmQ6c2hvcHMnKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5kZWwoJ2Rhc2hib2FyZDphbGwnKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5kZWwoJ2Rhc2hib2FyZDpzdW1tYXJ5Jyk7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHB1cmNoYXNlcy1zcGVjaWZpYyBjYWNoZXNcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5pbnZhbGlkYXRlUGF0dGVybigncHVyY2hhc2VzLW9wdGltaXplZConKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5pbnZhbGlkYXRlUGF0dGVybigncHVyY2hhc2Utc3RhdHMqJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVsZXZhbnQgY2FjaGVzIGludmFsaWRhdGVkIGFmdGVyIHB1cmNoYXNlIHVwZGF0ZS4nKTtcbiAgICAgICAgfSBjYXRjaCAoY2FjaGVFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW52YWxpZGF0aW5nIGNhY2hlcyBhZnRlciBwdXJjaGFzZSB1cGRhdGU6JywgY2FjaGVFcnJvcik7XG4gICAgICAgICAgICAvLyBEbyBub3QgbGV0IGNhY2hlIGludmFsaWRhdGlvbiBlcnJvciBmYWlsIHRoZSBtYWluIG9wZXJhdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV2YWxpZGF0ZSBOZXh0LmpzIGNhY2hlZCBwYWdlc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV2YWxpZGF0ZVRhZygncHVyY2hhc2UtaW52b2ljZXMnKTtcbiAgICAgICAgICAgIHJldmFsaWRhdGVUYWcoYHB1cmNoYXNlLSR7cHVyY2hhc2VJZH1gKTtcbiAgICAgICAgICAgIHJldmFsaWRhdGVQYXRoKGAvcHVyY2hhc2VzLyR7cHVyY2hhc2VJZH1gKTtcbiAgICAgICAgICAgIHJldmFsaWRhdGVQYXRoKGAvcHVyY2hhc2VzLyR7cHVyY2hhc2VJZH0vZWRpdGApO1xuICAgICAgICAgICAgcmV2YWxpZGF0ZVBhdGgoJy9wdXJjaGFzZXMnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOZXh0LmpzIHBhZ2VzIHJldmFsaWRhdGVkIGFmdGVyIHB1cmNoYXNlIHVwZGF0ZS4nKTtcbiAgICAgICAgfSBjYXRjaCAocmV2YWxpZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXZhbGlkYXRpbmcgTmV4dC5qcyBwYWdlcyBhZnRlciBwdXJjaGFzZSB1cGRhdGU6JywgcmV2YWxpZGF0ZUVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnUHVyY2hhc2UgaW52b2ljZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseScsXG4gICAgICAgICAgICBkYXRhOiByZXN1bHQuZnVsbFVwZGF0ZWRJbnZvaWNlXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHB1cmNoYXNlIGludm9pY2UgJHtpZH06YCwgZXJyb3IpO1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICB7IGVycm9yOiB7IG1lc3NhZ2U6ICdGYWlsZWQgdG8gdXBkYXRlIHB1cmNoYXNlIGludm9pY2UnLCBkZXRhaWxzOiBkZXRhaWxzIH0gfSxcbiAgICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgfVxufVxuXG4vLyBERUxFVEUgL2FwaS9wdXJjaGFzZXMvW2lkXSAtIERlbGV0ZSBhIHB1cmNoYXNlIGludm9pY2VcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBERUxFVEUoXG4gICAgcmVxdWVzdDogTmV4dFJlcXVlc3QsXG4gICAgeyBwYXJhbXMgfTogeyBwYXJhbXM6IHsgaWQ6IHN0cmluZyB9IH1cbikge1xuICAgIGNvbnN0IHB1cmNoYXNlSWRTdHIgPSBwYXJhbXMuaWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHVyY2hhc2VJZCA9IHBhcnNlSW50KHB1cmNoYXNlSWRTdHIpO1xuICAgICAgICBpZiAoaXNOYU4ocHVyY2hhc2VJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgICAgICB7IGVycm9yOiB7IG1lc3NhZ2U6ICdJbnZhbGlkIHB1cmNoYXNlIElEIGZvcm1hdCcgfSB9LFxuICAgICAgICAgICAgICAgIHsgc3RhdHVzOiA0MDAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwdXJjaGFzZVRvRGVsZXRlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBwdXJjaGFzZUlkIH0sXG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IHsgaW5jbHVkZTogeyBwcm9kdWN0OiB0cnVlIH0gfSxcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgJ2Rpc3RyaWJ1dGlvbnMnIGlzIGluY2x1ZGVkIGlmIGl0J3MgYSByZWxhdGlvbixcbiAgICAgICAgICAgICAgICAvLyBvciBkaXJlY3RseSBhY2Nlc3NpYmxlIGlmIGl0J3MgYSBKU09OIGZpZWxkIG9uIFB1cmNoYXNlSW52b2ljZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFwdXJjaGFzZVRvRGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICAgICAgeyBlcnJvcjogeyBtZXNzYWdlOiAnUHVyY2hhc2UgaW52b2ljZSBub3QgZm91bmQgdG8gZGVsZXRlJyB9IH0sXG4gICAgICAgICAgICAgICAgeyBzdGF0dXM6IDQwNCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kdHJhbnNhY3Rpb24oYXN5bmMgKHR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnZlbnRvcnlVcGRhdGVzOiBBcnJheTx7IHByb2R1Y3RJZDogbnVtYmVyLCBzaG9wSWQ6IG51bWJlciwgbmV3UXVhbnRpdHk6IG51bWJlciwgb2xkUXVhbnRpdHk/OiBudW1iZXIgfT4gPSBbXTtcblxuICAgICAgICAgICAgaWYgKHB1cmNoYXNlVG9EZWxldGUuaXRlbXMgJiYgcHVyY2hhc2VUb0RlbGV0ZS5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHB1cmNoYXNlVG9EZWxldGUuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLnByb2R1Y3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSXRlbSAke2l0ZW0uaWR9IGZvciBwdXJjaGFzZSAke3B1cmNoYXNlSWR9IGlzIG1pc3NpbmcgcHJvZHVjdCBkYXRhLiBTa2lwcGluZyBzdG9jayBhZGp1c3RtZW50LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9kdWN0SWQgPSBpdGVtLnByb2R1Y3RJZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlUb1JlbW92ZUZvckl0ZW1Ub3RhbCA9IGl0ZW0ucXVhbnRpdHk7IC8vIFRvdGFsIHF1YW50aXR5IGZvciB0aGlzIGl0ZW0gbGluZVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtRGlzdHJpYnV0aW9uSW5mbzogeyBbc2hvcElkOiBzdHJpbmddOiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0cmlidXRpb25zT25JbnZvaWNlID0gKHB1cmNoYXNlVG9EZWxldGUgYXMgYW55KS5kaXN0cmlidXRpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IHNwZWNpZmljIGRpc3RyaWJ1dGlvbiBmb3IgdGhpcyBpdGVtXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnNPbkludm9pY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGlzdHJpYnV0aW9uc09uSW52b2ljZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1cmNoYXNlVG9EZWxldGUuaXRlbXMuaW5kZXhPZihpdGVtKSA8IGRpc3RyaWJ1dGlvbnNPbkludm9pY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdERhdGEgPSBkaXN0cmlidXRpb25zT25JbnZvaWNlW3B1cmNoYXNlVG9EZWxldGUuaXRlbXMuaW5kZXhPZihpdGVtKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdERhdGEgJiYgdHlwZW9mIGRpc3REYXRhID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhkaXN0RGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1EaXN0cmlidXRpb25JbmZvID0gZGlzdERhdGEgYXMgeyBbc2hvcElkOiBzdHJpbmddOiBudW1iZXIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtRGlzdHJpYnV0aW9uSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSAxOiBFeHBsaWNpdCBkaXN0cmlidXRpb24gZGF0YSBmb3VuZCBmb3IgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXZlcnNpbmcgaXRlbS1zcGVjaWZpYyBkaXN0cmlidXRpb24gZm9yIHByb2R1Y3QgJHtwcm9kdWN0SWR9LCBwdXJjaGFzZSAke3B1cmNoYXNlSWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzaG9wSWRTdHIsIGRpc3RyaWJ1dGVkUXVhbnRpdHlTdHJdIG9mIE9iamVjdC5lbnRyaWVzKGl0ZW1EaXN0cmlidXRpb25JbmZvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3BJZCA9IHNob3BJZFN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBxdHlJblNob3BUb1JlbW92ZSA9IE51bWJlcihkaXN0cmlidXRlZFF1YW50aXR5U3RyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihxdHlJblNob3BUb1JlbW92ZSkgfHwgcXR5SW5TaG9wVG9SZW1vdmUgPD0gMCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnZlbnRvcnlJdGVtID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kRmlyc3QoeyB3aGVyZTogeyBwcm9kdWN0SWQsIHNob3BJZDogc2hvcElkIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludmVudG9yeUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkU2hvcFF1YW50aXR5ID0gaW52ZW50b3J5SXRlbS5xdWFudGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2hvcFF1YW50aXR5ID0gTWF0aC5tYXgoMCwgaW52ZW50b3J5SXRlbS5xdWFudGl0eSAtIHF0eUluU2hvcFRvUmVtb3ZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBuZXdTaG9wUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wU3BlY2lmaWNDb3N0OiBuZXdTaG9wUXVhbnRpdHkgPT09IDAgPyAwIDogaW52ZW50b3J5SXRlbS5zaG9wU3BlY2lmaWNDb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0udXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBpbnZlbnRvcnlJdGVtLmlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB1cGRhdGVEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52ZW50b3J5VXBkYXRlcy5wdXNoKHsgcHJvZHVjdElkLCBzaG9wSWQ6IE51bWJlcihzaG9wSWQpLCBuZXdRdWFudGl0eTogbmV3U2hvcFF1YW50aXR5LCBvbGRRdWFudGl0eTogb2xkU2hvcFF1YW50aXR5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAtIFJlZHVjZWQgaW52ZW50b3J5IGZvciBwcm9kdWN0ICR7cHJvZHVjdElkfSBpbiBzaG9wICR7c2hvcElkfSBieSAke3F0eUluU2hvcFRvUmVtb3ZlfS4gT2xkOiAke29sZFNob3BRdWFudGl0eX0sIE5ldzogJHtuZXdTaG9wUXVhbnRpdHl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAgIC0gSW52ZW50b3J5IGl0ZW0gbm90IGZvdW5kIGZvciBwcm9kdWN0ICR7cHJvZHVjdElkfSBpbiBzaG9wICR7c2hvcElkfSBkdXJpbmcgcHVyY2hhc2UgZGVsZXRpb24gd2l0aCBleHBsaWNpdCBkaXN0cmlidXRpb24uIFN0b2NrIG1heSBiZSBpbmFjY3VyYXRlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMjogTm8gZXhwbGljaXQgZGlzdHJpYnV0aW9uIGZvciB0aGlzIGl0ZW0uIEF0dGVtcHQgdG8gaW5mZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYE5vIHNwZWNpZmljIGRpc3RyaWJ1dGlvbiBmb3VuZCBmb3IgaXRlbSAke3Byb2R1Y3RJZH0gaW4gZGVsZXRlZCBwdXJjaGFzZSAke3B1cmNoYXNlSWR9LiBBdHRlbXB0aW5nIHRvIGluZmVyIHNob3AocykgZm9yIHN0b2NrIHJldmVyc2FsIG9mIHRvdGFsIHF1YW50aXR5ICR7cXVhbnRpdHlUb1JlbW92ZUZvckl0ZW1Ub3RhbH0uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0ludmVudG9yaWVzRm9ySXRlbSA9IGF3YWl0IHR4LmludmVudG9yeUl0ZW0uZmluZE1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdElkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdJbnZlbnRvcmllc0Zvckl0ZW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2luZ2xlU2hvcEludmVudG9yeSA9IGV4aXN0aW5nSW52ZW50b3JpZXNGb3JJdGVtWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3BJZFRvRGVkdWN0RnJvbSA9IHNpbmdsZVNob3BJbnZlbnRvcnkuc2hvcElkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFByb2R1Y3QgJHtwcm9kdWN0SWR9IGZvdW5kIGluIHNpbmdsZSBzaG9wICR7c2hvcElkVG9EZWR1Y3RGcm9tfS4gRGVkdWN0aW5nIHRvdGFsIGl0ZW0gcXVhbnRpdHkgJHtxdWFudGl0eVRvUmVtb3ZlRm9ySXRlbVRvdGFsfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRTaG9wUXVhbnRpdHkgPSBzaW5nbGVTaG9wSW52ZW50b3J5LnF1YW50aXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Nob3BRdWFudGl0eSA9IE1hdGgubWF4KDAsIHNpbmdsZVNob3BJbnZlbnRvcnkucXVhbnRpdHkgLSBxdWFudGl0eVRvUmVtb3ZlRm9ySXRlbVRvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVEYXRhSW5mZXJyZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBuZXdTaG9wUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BTcGVjaWZpY0Nvc3Q6IG5ld1Nob3BRdWFudGl0eSA9PT0gMCA/IDAgOiBzaW5nbGVTaG9wSW52ZW50b3J5LnNob3BTcGVjaWZpY0Nvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0udXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHNpbmdsZVNob3BJbnZlbnRvcnkuaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdXBkYXRlRGF0YUluZmVycmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmVudG9yeVVwZGF0ZXMucHVzaCh7IHByb2R1Y3RJZCwgc2hvcElkOiBOdW1iZXIoc2hvcElkVG9EZWR1Y3RGcm9tKSwgbmV3UXVhbnRpdHk6IG5ld1Nob3BRdWFudGl0eSwgb2xkUXVhbnRpdHk6IG9sZFNob3BRdWFudGl0eSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAtIFJlZHVjZWQgaW52ZW50b3J5IGZvciBwcm9kdWN0ICR7cHJvZHVjdElkfSBpbiBpbmZlcnJlZCBzaG9wICR7c2hvcElkVG9EZWR1Y3RGcm9tfSBieSAke3F1YW50aXR5VG9SZW1vdmVGb3JJdGVtVG90YWx9LiBPbGQ6ICR7b2xkU2hvcFF1YW50aXR5fSwgTmV3OiAke25ld1Nob3BRdWFudGl0eX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdJbnZlbnRvcmllc0Zvckl0ZW0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUHJvZHVjdCAke3Byb2R1Y3RJZH0gKGZyb20gZGVsZXRlZCBwdXJjaGFzZSAke3B1cmNoYXNlSWR9KSBub3QgZm91bmQgaW4gYW55IGludmVudG9yeS4gQ2Fubm90IHJldmVyc2Ugc3RvY2sgZm9yIHRoaXMgaXRlbS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIFByb2R1Y3QgZXhpc3RzIGluIG11bHRpcGxlIHNob3BzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUHJvZHVjdCAke3Byb2R1Y3RJZH0gKGZyb20gZGVsZXRlZCBwdXJjaGFzZSAke3B1cmNoYXNlSWR9KSBleGlzdHMgaW4gbXVsdGlwbGUgc2hvcHMsIGJ1dCBubyBzcGVjaWZpYyBkaXN0cmlidXRpb24gZGF0YSB3YXMgZm91bmQgb24gdGhlIGludm9pY2UgZm9yIHJldmVyc2FsLiBBbWJpZ3VvdXMuIFN0b2NrIG5vdCBhdXRvbWF0aWNhbGx5IHJldmVyc2VkIGZvciB0aGlzIGl0ZW0uIE1hbnVhbCBhZGp1c3RtZW50IG1heSBiZSBuZWVkZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyAtLS0tIEJFR0lOIFdBQyBSZWNhbGN1bGF0aW9uIGZvciB0aGUgZGVsZXRlZCBpdGVtIC0tLS1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nUHVyY2hhc2VJdGVtcyA9IGF3YWl0IHR4LnB1cmNoYXNlSW52b2ljZUl0ZW0uZmluZE1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXJjaGFzZUludm9pY2VJZDogeyBub3Q6IHB1cmNoYXNlSWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxSZW1haW5pbmdRdWFudGl0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbFJlbWFpbmluZ1ZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nUHVyY2hhc2VJdGVtcy5mb3JFYWNoKHBJdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUmVtYWluaW5nUXVhbnRpdHkgKz0gcEl0ZW0ucXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFJlbWFpbmluZ1ZhbHVlICs9IHBJdGVtLnF1YW50aXR5ICogcEl0ZW0ucHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdDYWxjdWxhdGVkV0FDID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsUmVtYWluaW5nUXVhbnRpdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkV0FDID0gdG90YWxSZW1haW5pbmdWYWx1ZSAvIHRvdGFsUmVtYWluaW5nUXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdHgucHJvZHVjdC51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHByb2R1Y3RJZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB3ZWlnaHRlZEF2ZXJhZ2VDb3N0OiBuZXdDYWxjdWxhdGVkV0FDID49IDAgPyBuZXdDYWxjdWxhdGVkV0FDIDogMCB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyAtLS0tIEVORCBXQUMgUmVjYWxjdWxhdGlvbiAtLS0tXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCB0eC5wdXJjaGFzZUludm9pY2VJdGVtLmRlbGV0ZU1hbnkoeyB3aGVyZTogeyBwdXJjaGFzZUludm9pY2VJZDogcHVyY2hhc2VJZCB9IH0pO1xuICAgICAgICAgICAgYXdhaXQgdHgucHVyY2hhc2VJbnZvaWNlLmRlbGV0ZSh7IHdoZXJlOiB7IGlkOiBwdXJjaGFzZUlkIH0gfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGRlbGV0ZWRJbnZvaWNlSWQ6IHB1cmNoYXNlSWQsIGludmVudG9yeVVwZGF0ZXMgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVhbC10aW1lIHVwZGF0ZXMgbm93IGhhbmRsZWQgYnkgcG9sbGluZyBzeXN0ZW1cbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZGVsZXRlZEludm9pY2VJZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFB1cmNoYXNlIGludm9pY2UgJHtyZXN1bHQuZGVsZXRlZEludm9pY2VJZH0gZGVsZXRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFmdGVyIHN1Y2Nlc3NmdWwgdHJhbnNhY3Rpb24sIGludmFsaWRhdGUgcmVsZXZhbnQgY2FjaGVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2UuaW52YWxpZGF0ZUludmVudG9yeSgpOyAvLyBIYW5kbGVzICdpbnZlbnRvcnk6c3VtbWFyeToqJyBhbmQgJ3Byb2R1Y3RzOionXG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2UuZGVsKCdkYXNoYm9hcmQ6aW52ZW50b3J5Jyk7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2UuZGVsKCdkYXNoYm9hcmQ6aW52ZW50b3J5LXZhbHVlJyk7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2UuZGVsKCdkYXNoYm9hcmQ6c2hvcHMnKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5kZWwoJ2Rhc2hib2FyZDphbGwnKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5kZWwoJ2Rhc2hib2FyZDpzdW1tYXJ5Jyk7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHB1cmNoYXNlcy1zcGVjaWZpYyBjYWNoZXNcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5pbnZhbGlkYXRlUGF0dGVybigncHVyY2hhc2VzLW9wdGltaXplZConKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5pbnZhbGlkYXRlUGF0dGVybigncHVyY2hhc2Utc3RhdHMqJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVsZXZhbnQgY2FjaGVzIGludmFsaWRhdGVkIGFmdGVyIHB1cmNoYXNlIGRlbGV0aW9uLicpO1xuICAgICAgICB9IGNhdGNoIChjYWNoZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbnZhbGlkYXRpbmcgY2FjaGVzIGFmdGVyIHB1cmNoYXNlIGRlbGV0aW9uOicsIGNhY2hlRXJyb3IpO1xuICAgICAgICAgICAgLy8gRG8gbm90IGxldCBjYWNoZSBpbnZhbGlkYXRpb24gZXJyb3IgZmFpbCB0aGUgbWFpbiBvcGVyYXRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldmFsaWRhdGUgTmV4dC5qcyBjYWNoZWQgcGFnZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldmFsaWRhdGVUYWcoJ3B1cmNoYXNlLWludm9pY2VzJyk7XG4gICAgICAgICAgICByZXZhbGlkYXRlVGFnKGBwdXJjaGFzZS0ke3B1cmNoYXNlSWR9YCk7XG4gICAgICAgICAgICByZXZhbGlkYXRlUGF0aChgL3B1cmNoYXNlcy8ke3B1cmNoYXNlSWR9YCk7XG4gICAgICAgICAgICByZXZhbGlkYXRlUGF0aChgL3B1cmNoYXNlcy8ke3B1cmNoYXNlSWR9L2VkaXRgKTtcbiAgICAgICAgICAgIHJldmFsaWRhdGVQYXRoKCcvcHVyY2hhc2VzJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTmV4dC5qcyBwYWdlcyByZXZhbGlkYXRlZCBhZnRlciBwdXJjaGFzZSBkZWxldGlvbi4nKTtcbiAgICAgICAgfSBjYXRjaCAocmV2YWxpZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXZhbGlkYXRpbmcgTmV4dC5qcyBwYWdlcyBhZnRlciBwdXJjaGFzZSBkZWxldGlvbjonLCByZXZhbGlkYXRlRXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgbWVzc2FnZTogJ1B1cmNoYXNlIGludm9pY2UgZGVsZXRlZCBzdWNjZXNzZnVsbHknIH0pO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGVsZXRpbmcgcHVyY2hhc2UgaW52b2ljZSAke3B1cmNoYXNlSWRTdHJ9OmAsIGVycm9yKTtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICB7IGVycm9yOiB7IG1lc3NhZ2U6ICdGYWlsZWQgdG8gZGVsZXRlIHB1cmNoYXNlIGludm9pY2UnLCBkZXRhaWxzOiBkZXRhaWxzIH0gfSxcbiAgICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgfVxufSJdLCJuYW1lcyI6WyJERUxFVEUiLCJHRVQiLCJQVVQiLCJyZXF1ZXN0IiwicGFyYW1zIiwiaWQiLCJwdXJjaGFzZUlkIiwicGFyc2VJbnQiLCJpc05hTiIsIk5leHRSZXNwb25zZSIsImpzb24iLCJlcnJvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJwdXJjaGFzZSIsInByaXNtYSIsInB1cmNoYXNlSW52b2ljZSIsImZpbmRVbmlxdWUiLCJ3aGVyZSIsImluY2x1ZGUiLCJzdXBwbGllciIsIml0ZW1zIiwicHJvZHVjdCIsImNvbnNvbGUiLCJkZXRhaWxzIiwiRXJyb3IiLCJib2R5Iiwib3JpZ2luYWxQdXJjaGFzZSIsIm5ld0l0ZW1zRGF0YSIsImRpc3RyaWJ1dGlvbnMiLCJuZXdEaXN0cmlidXRpb25zRGF0YSIsImludm9pY2VEYXRhIiwiXyIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsIm5vdGVzIiwiZGlydHlEYXRhIiwiY2xlYW5lZEludm9pY2VEYXRhIiwiaW52b2ljZU51bWJlciIsImRhdGUiLCJEYXRlIiwiZHVlRGF0ZSIsInVuZGVmaW5lZCIsInRvdGFsQW1vdW50IiwidG90YWwiLCJOdW1iZXIiLCJzdXBwbGllcklkIiwiY29ubmVjdCIsImRpc2Nvbm5lY3QiLCJyZXN1bHQiLCIkdHJhbnNhY3Rpb24iLCJ0eCIsImludmVudG9yeVVwZGF0ZXMiLCJsZW5ndGgiLCJvbGRJdGVtIiwicHJvZHVjdFRvVXBkYXRlIiwicHJvZHVjdElkIiwib2xkSXRlbURpc3RyaWJ1dGlvbiIsIkFycmF5IiwiaXNBcnJheSIsImluZGV4T2YiLCJPYmplY3QiLCJrZXlzIiwic2hvcElkU3RyIiwicXVhbnRpdHlJblNob3AiLCJlbnRyaWVzIiwic2hvcElkIiwicXR5VG9SZW1vdmUiLCJpbnZlbnRvcnkiLCJpbnZlbnRvcnlJdGVtIiwiZmluZEZpcnN0Iiwib2xkU2hvcFF1YW50aXR5IiwicXVhbnRpdHkiLCJuZXdRdWFudGl0eSIsIk1hdGgiLCJtYXgiLCJ1cGRhdGUiLCJkYXRhIiwic2hvcFNwZWNpZmljQ29zdCIsInB1c2giLCJvbGRRdWFudGl0eSIsIndhcm4iLCJleGlzdGluZ0ludmVudG9yaWVzRm9yT2xkSXRlbSIsImZpbmRNYW55Iiwic2hvcElkVG9SZXZlcnNlRnJvbSIsImxvZyIsImN1cnJlbnRUb3RhbFByb2R1Y3RRdWFudGl0eSIsImFsbEludmVudG9yeUZvclByb2R1Y3RBZnRlclJldmVyc2FsIiwicmVkdWNlIiwic3VtIiwiaW52IiwicmVtYWluaW5nUHVyY2hhc2VJdGVtcyIsInB1cmNoYXNlSW52b2ljZUl0ZW0iLCJwdXJjaGFzZUludm9pY2VJZCIsIm5vdCIsInRvdGFsUmVtYWluaW5nUXVhbnRpdHkiLCJ0b3RhbFJlbWFpbmluZ1ZhbHVlIiwiZm9yRWFjaCIsInB1cmNoYXNlSXRlbSIsInByaWNlIiwibmV3V0FDIiwid2VpZ2h0ZWRBdmVyYWdlQ29zdCIsImRlbGV0ZU1hbnkiLCJuZXdUb3RhbEludm9pY2VBbW91bnQiLCJpdGVtIiwidXBkYXRlZEludm9pY2UiLCJpIiwibmV3SXRlbSIsImNyZWF0ZSIsIm5ld0l0ZW1EaXN0cmlidXRpb24iLCJpdGVtUXVhbnRpdHlUb3RhbCIsInF0eVRvQWRkIiwiZmluYWxRdWFudGl0eSIsIm9sZEludlF0eSIsIm5ld1Nob3BTcGVjaWZpY0Nvc3RWYWx1ZSIsIml0ZW1QcmljZSIsIm9sZFNob3BUb3RhbFZhbHVlIiwidmFsdWVPZlRoaXNCYXRjaCIsImV4aXN0aW5nSW52ZW50b3J5SXRlbXMiLCJ0YXJnZXRTaG9wSWQiLCJhbGxQdXJjaGFzZUl0ZW1zIiwidG90YWxQdXJjaGFzZVF1YW50aXR5IiwidG90YWxQdXJjaGFzZVZhbHVlIiwibmV3V2VpZ2h0ZWRBdmVyYWdlQ29zdCIsImZ1bGxVcGRhdGVkSW52b2ljZSIsInRpbWVvdXQiLCJjYWNoZVNlcnZpY2UiLCJpbnZhbGlkYXRlSW52ZW50b3J5IiwiZGVsIiwiaW52YWxpZGF0ZVBhdHRlcm4iLCJjYWNoZUVycm9yIiwicmV2YWxpZGF0ZVRhZyIsInJldmFsaWRhdGVQYXRoIiwicmV2YWxpZGF0ZUVycm9yIiwiU3RyaW5nIiwicHVyY2hhc2VJZFN0ciIsInB1cmNoYXNlVG9EZWxldGUiLCJxdWFudGl0eVRvUmVtb3ZlRm9ySXRlbVRvdGFsIiwiaXRlbURpc3RyaWJ1dGlvbkluZm8iLCJkaXN0cmlidXRpb25zT25JbnZvaWNlIiwiZGlzdERhdGEiLCJkaXN0cmlidXRlZFF1YW50aXR5U3RyIiwicXR5SW5TaG9wVG9SZW1vdmUiLCJuZXdTaG9wUXVhbnRpdHkiLCJ1cGRhdGVEYXRhIiwiZXhpc3RpbmdJbnZlbnRvcmllc0Zvckl0ZW0iLCJzaW5nbGVTaG9wSW52ZW50b3J5Iiwic2hvcElkVG9EZWR1Y3RGcm9tIiwidXBkYXRlRGF0YUluZmVycmVkIiwicEl0ZW0iLCJuZXdDYWxjdWxhdGVkV0FDIiwiZGVsZXRlIiwiZGVsZXRlZEludm9pY2VJZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7SUFnWnNCQSxNQUFNO2VBQU5BOztJQXhZQUMsR0FBRztlQUFIQTs7SUFnREFDLEdBQUc7ZUFBSEE7Ozt3QkF4RG9CO3VCQUNJOytEQUMzQjt3QkFHVTs7Ozs7O0FBR3RCLGVBQWVELElBQ2xCRSxPQUFvQixFQUNwQixFQUFFQyxNQUFNLEVBQThCO0lBRXRDLE1BQU1DLEtBQUtELE9BQU9DLEVBQUUsRUFBRSw4Q0FBOEM7SUFDcEUsSUFBSTtRQUNBLE1BQU1DLGFBQWFDLFNBQVNGO1FBRTVCLElBQUlHLE1BQU1GLGFBQWE7WUFDbkIsT0FBT0csb0JBQVksQ0FBQ0MsSUFBSSxDQUNwQjtnQkFBRUMsT0FBTztvQkFBRUMsU0FBUztnQkFBNkI7WUFBRSxHQUNuRDtnQkFBRUMsUUFBUTtZQUFJO1FBRXRCO1FBRUEsTUFBTUMsV0FBVyxNQUFNQyxlQUFNLENBQUNDLGVBQWUsQ0FBQ0MsVUFBVSxDQUFDO1lBQ3JEQyxPQUFPO2dCQUNIYixJQUFJQztZQUNSO1lBQ0FhLFNBQVM7Z0JBQ0xDLFVBQVU7Z0JBQ1ZDLE9BQU87b0JBQ0hGLFNBQVM7d0JBQ0xHLFNBQVM7b0JBQ2I7Z0JBQ0o7WUFDSjtRQUNKO1FBRUEsSUFBSSxDQUFDUixVQUFVO1lBQ1gsT0FBT0wsb0JBQVksQ0FBQ0MsSUFBSSxDQUNwQjtnQkFBRUMsT0FBTztvQkFBRUMsU0FBUztnQkFBNkI7WUFBRSxHQUNuRDtnQkFBRUMsUUFBUTtZQUFJO1FBRXRCO1FBRUEsT0FBT0osb0JBQVksQ0FBQ0MsSUFB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