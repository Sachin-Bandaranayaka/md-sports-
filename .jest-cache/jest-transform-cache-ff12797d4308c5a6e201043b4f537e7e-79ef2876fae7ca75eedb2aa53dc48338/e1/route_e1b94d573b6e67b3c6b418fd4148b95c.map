{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/app/api/products/bulk-import/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\nimport * as XLSX from 'xlsx';\n\ninterface ProductRow {\n    Name?: string;\n    SKU?: string;\n    Description?: string;\n    RetailPrice?: number | string; // Can be string from Excel, needs parsing\n    CostPrice?: number | string;   // Can be string from Excel, needs parsing\n    Barcode?: string;\n    CategoryName?: string;\n    InitialQuantity?: number | string; // Can be string from Excel, needs parsing\n    ShopName?: string;\n}\n\nexport async function POST(request: NextRequest) {\n    try {\n        const formData = await request.formData();\n        const file = formData.get('file') as File | null;\n\n        if (!file) {\n            return NextResponse.json({ success: false, message: 'No file uploaded.' }, { status: 400 });\n        }\n\n        const bytes = await file.arrayBuffer();\n        const buffer = Buffer.from(bytes);\n\n        const workbook = XLSX.read(buffer, { type: 'buffer' });\n        const sheetName = workbook.SheetNames[0];\n        const worksheet = workbook.Sheets[sheetName];\n        const jsonData = XLSX.utils.sheet_to_json<ProductRow>(worksheet);\n\n        if (!jsonData || jsonData.length === 0) {\n            return NextResponse.json({ success: false, message: 'Excel file is empty or data could not be read.' }, { status: 400 });\n        }\n\n        const results: { row: number; success: boolean; message: string; productName?: string }[] = [];\n        let successfullyImportedCount = 0;\n\n        // Prepare a list of operations for the transaction\n        const operations: any[] = [];\n        const createdProductSKUs = new Set<string>(); // To track SKUs within the current batch for uniqueness\n\n        for (let i = 0; i < jsonData.length; i++) {\n            const row = jsonData[i];\n            const rowIndex = i + 2; // Excel row number (1-based, +1 for header)\n\n            // --- Data Validation and Transformation ---\n            const name = row.Name?.trim();\n            if (!name) {\n                results.push({ row: rowIndex, success: false, message: 'Product Name is required.' });\n                continue;\n            }\n\n            let retailPrice = parseFloat(String(row.RetailPrice));\n            if (isNaN(retailPrice) || retailPrice < 0) {\n                results.push({ row: rowIndex, success: false, productName: name, message: 'Invalid or missing Retail Price. It must be a non-negative number.' });\n                continue;\n            }\n\n            const sku = row.SKU?.trim() || null;\n            if (sku) {\n                if (createdProductSKUs.has(sku)) {\n                    results.push({ row: rowIndex, success: false, productName: name, message: `SKU '${sku}' is duplicated within the import file.` });\n                    continue;\n                }\n                const existingProductBySKU = await prisma.product.findUnique({ where: { sku } });\n                if (existingProductBySKU) {\n                    results.push({ row: rowIndex, success: false, productName: name, message: `SKU '${sku}' already exists in the database.` });\n                    continue;\n                }\n                createdProductSKUs.add(sku);\n            }\n\n\n            const description = row.Description?.trim() || null;\n            const costPrice = row.CostPrice !== undefined && String(row.CostPrice).trim() !== '' ? parseFloat(String(row.CostPrice)) : null;\n            if (costPrice !== null && (isNaN(costPrice) || costPrice < 0)) {\n                results.push({ row: rowIndex, success: false, productName: name, message: 'Cost Price, if provided, must be a non-negative number.' });\n                continue;\n            }\n            const barcode = row.Barcode?.trim() || null;\n\n            let categoryId: number | null = null;\n            if (row.CategoryName?.trim()) {\n                const category = await prisma.category.findFirst({ where: { name: row.CategoryName.trim() } });\n                if (!category) {\n                    results.push({ row: rowIndex, success: false, productName: name, message: `Category '${row.CategoryName.trim()}' not found.` });\n                    continue;\n                }\n                categoryId = category.id;\n            }\n\n            const initialQuantity = row.InitialQuantity !== undefined && String(row.InitialQuantity).trim() !== '' ? parseInt(String(row.InitialQuantity), 10) : 0;\n            if (isNaN(initialQuantity) || initialQuantity < 0) {\n                results.push({ row: rowIndex, success: false, productName: name, message: 'Initial Quantity, if provided, must be a non-negative integer.' });\n                continue;\n            }\n\n            let shopId: string | null = null;\n            if (initialQuantity > 0) {\n                if (!row.ShopName?.trim()) {\n                    results.push({ row: rowIndex, success: false, productName: name, message: 'Shop Name is required when Initial Quantity is greater than 0. Either provide a valid shop name or set Initial Quantity to 0.' });\n                    continue;\n                }\n                const shop = await prisma.shop.findFirst({ where: { name: row.ShopName.trim() } });\n                if (!shop) {\n                    // Get available shop names for better error message\n                    const availableShops = await prisma.shop.findMany({ select: { name: true } });\n                    const shopNames = availableShops.map(s => s.name).join(', ');\n                    results.push({ row: rowIndex, success: false, productName: name, message: `Shop '${row.ShopName.trim()}' not found. Available shops: ${shopNames}` });\n                    continue;\n                }\n                shopId = shop.id;\n            }\n\n            // --- Prepare Prisma Operations ---\n            // Note: We can't use createMany with nested creates for InventoryItem easily if we need the productId.\n            // So, we'll create product first, then inventory item if needed, all within the transaction.\n            // This approach processes products one by one within the transaction for clarity.\n\n            try {\n                await prisma.$transaction(async (tx) => {\n                    const newProduct = await tx.product.create({\n                        data: {\n                            name,\n                            sku,\n                            description,\n                            price: retailPrice,\n                            weightedAverageCost: costPrice,\n                            barcode,\n                            categoryId,\n                            // shopId for Product model is not used here, assuming it's for something else\n                        },\n                    });\n\n                    if (initialQuantity > 0 && shopId) {\n                        await tx.inventoryItem.create({\n                            data: {\n                                productId: newProduct.id,\n                                quantity: initialQuantity,\n                                shopId: shopId,\n                            },\n                        });\n                    }\n                    results.push({ row: rowIndex, success: true, productName: name, message: 'Product imported successfully.' });\n                    successfullyImportedCount++;\n                });\n\n            } catch (dbError: any) {\n                console.error(`Error processing row ${rowIndex} (${name}):`, dbError);\n                let message = 'Database error during import.';\n                if (dbError.code === 'P2002' && dbError.meta?.target?.includes('sku')) { // Prisma unique constraint violation for SKU\n                    message = `SKU '${sku}' already exists.`;\n                }\n                results.push({ row: rowIndex, success: false, productName: name, message });\n            }\n        }\n\n        const totalRows = jsonData.length;\n        let summaryMessage = `${successfullyImportedCount} out of ${totalRows} products imported successfully.`;\n        if (successfullyImportedCount < totalRows) {\n            summaryMessage += ' Please check the details for errors.';\n        }\n\n        // Invalidate inventory cache if any products were successfully imported\n        if (successfullyImportedCount > 0) {\n            const { cacheService } = await import('@/lib/cache');\n            await cacheService.invalidateInventory();\n        }\n\n        return NextResponse.json({\n            success: successfullyImportedCount > 0 || totalRows === 0, // Overall success if at least one or no rows\n            message: summaryMessage,\n            details: results,\n        });\n\n    } catch (error: any) {\n        console.error('Bulk product import error:', error);\n        return NextResponse.json(\n            { success: false, message: error.message || 'An unexpected error occurred during bulk import.' },\n            { status: 500 }\n        );\n    }\n}"],"names":["POST","request","formData","file","get","NextResponse","json","success","message","status","bytes","arrayBuffer","buffer","Buffer","from","workbook","XLSX","read","type","sheetName","SheetNames","worksheet","Sheets","jsonData","utils","sheet_to_json","length","results","successfullyImportedCount","operations","createdProductSKUs","Set","i","row","rowIndex","name","Name","trim","push","retailPrice","parseFloat","String","RetailPrice","isNaN","productName","sku","SKU","has","existingProductBySKU","prisma","product","findUnique","where","add","description","Description","costPrice","CostPrice","undefined","barcode","Barcode","categoryId","CategoryName","category","findFirst","id","initialQuantity","InitialQuantity","parseInt","shopId","ShopName","shop","availableShops","findMany","select","shopNames","map","s","join","$transaction","tx","newProduct","create","data","price","weightedAverageCost","inventoryItem","productId","quantity","dbError","console","error","code","meta","target","includes","totalRows","summaryMessage","cacheService","invalidateInventory","details"],"mappings":"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"}