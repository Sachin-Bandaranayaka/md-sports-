e174ca9c62bf8b310ba453425efc8b00
"use strict";
jest.mock("@/hooks/useAuth", ()=>({
        useAuth: ()=>mockUseAuth()
    }));
// Mock next/navigation
jest.mock("next/navigation", ()=>({
        useRouter: ()=>({
                push: jest.fn(),
                replace: jest.fn(),
                back: jest.fn(),
                forward: jest.fn(),
                refresh: jest.fn(),
                prefetch: jest.fn()
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
require("@testing-library/jest-dom");
// Mock the useAuth hook
const mockUseAuth = jest.fn();
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
describe("API Routes Testing", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock localStorage
        Object.defineProperty(window, "localStorage", {
            value: {
                getItem: jest.fn(()=>"mock-token"),
                setItem: jest.fn(),
                removeItem: jest.fn()
            },
            writable: true
        });
        // Mock user with API access permissions
        mockUseAuth.mockReturnValue({
            user: {
                id: "1",
                name: "API User",
                email: "api@test.com",
                permissions: [
                    "api:access",
                    "sales:all",
                    "inventory:all",
                    "customers:all"
                ]
            },
            isLoading: false,
            isAuthenticated: true,
            login: jest.fn(),
            logout: jest.fn(),
            hasPermission: jest.fn(()=>true)
        });
    });
    describe("Authentication API Routes", ()=>{
        test("should handle POST /api/auth/login", async ()=>{
            const testLogin = async (credentials)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            token: "jwt-token-123",
                            user: {
                                id: "1",
                                email: credentials.email,
                                name: "Test User",
                                permissions: [
                                    "sales:view"
                                ]
                            },
                            expiresIn: 3600
                        })
                });
                const response = await fetch("/api/auth/login", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(credentials)
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testLogin({
                email: "test@example.com",
                password: "password123"
            });
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
            expect(result.data.token).toBe("jwt-token-123");
            expect(mockFetch).toHaveBeenCalledWith("/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                })
            });
        });
        test("should handle POST /api/auth/logout", async ()=>{
            const testLogout = async (token)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            message: "Logged out successfully"
                        })
                });
                const response = await fetch("/api/auth/logout", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${token}`
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testLogout("mock-token");
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
        });
        test("should handle POST /api/auth/refresh", async ()=>{
            const testRefresh = async (token)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            token: "new-jwt-token-456",
                            expiresIn: 3600
                        })
                });
                const response = await fetch("/api/auth/refresh", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${token}`
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testRefresh("old-token");
            expect(result.status).toBe(200);
            expect(result.data.token).toBe("new-jwt-token-456");
        });
        test("should handle authentication errors", async ()=>{
            const testAuthError = async ()=>{
                mockFetch.mockResolvedValueOnce({
                    ok: false,
                    status: 401,
                    json: async ()=>({
                            success: false,
                            message: "Invalid credentials",
                            error: "UNAUTHORIZED"
                        })
                });
                const response = await fetch("/api/auth/login", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        email: "wrong@example.com",
                        password: "wrongpass"
                    })
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testAuthError();
            expect(result.status).toBe(401);
            expect(result.data.success).toBe(false);
            expect(result.data.error).toBe("UNAUTHORIZED");
        });
    });
    describe("Sales Invoice API Routes", ()=>{
        test("should handle GET /api/sales/invoices", async ()=>{
            const testGetInvoices = async (params = {})=>{
                const queryString = new URLSearchParams(params).toString();
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            invoices: [
                                {
                                    id: "inv-1",
                                    invoiceNumber: "INV-001",
                                    customerId: "cust-1",
                                    amount: 1000,
                                    status: "paid",
                                    createdAt: "2024-01-01T00:00:00Z"
                                },
                                {
                                    id: "inv-2",
                                    invoiceNumber: "INV-002",
                                    customerId: "cust-2",
                                    amount: 1500,
                                    status: "pending",
                                    createdAt: "2024-01-02T00:00:00Z"
                                }
                            ],
                            pagination: {
                                page: 1,
                                limit: 10,
                                total: 2,
                                pages: 1
                            }
                        })
                });
                const url = queryString ? `/api/sales/invoices?${queryString}` : "/api/sales/invoices";
                const response = await fetch(url, {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testGetInvoices({
                page: 1,
                limit: 10,
                status: "pending"
            });
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
            expect(result.data.invoices).toHaveLength(2);
            expect(result.data.pagination.total).toBe(2);
        });
        test("should handle POST /api/sales/invoices", async ()=>{
            const testCreateInvoice = async (invoiceData)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 201,
                    json: async ()=>({
                            success: true,
                            invoice: {
                                id: "inv-new",
                                ...invoiceData,
                                invoiceNumber: "INV-003",
                                createdAt: new Date().toISOString()
                            },
                            message: "Invoice created successfully"
                        })
                });
                const response = await fetch("/api/sales/invoices", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify(invoiceData)
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const invoiceData = {
                customerId: "cust-1",
                items: [
                    {
                        productId: "prod-1",
                        quantity: 2,
                        price: 500
                    }
                ],
                subtotal: 1000,
                tax: 100,
                total: 1100
            };
            const result = await testCreateInvoice(invoiceData);
            expect(result.status).toBe(201);
            expect(result.data.success).toBe(true);
            expect(result.data.invoice.id).toBe("inv-new");
        });
        test("should handle PUT /api/sales/invoices/[id]", async ()=>{
            const testUpdateInvoice = async (invoiceId, updateData)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            invoice: {
                                id: invoiceId,
                                ...updateData,
                                updatedAt: new Date().toISOString()
                            },
                            message: "Invoice updated successfully"
                        })
                });
                const response = await fetch(`/api/sales/invoices/${invoiceId}`, {
                    method: "PUT",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify(updateData)
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testUpdateInvoice("inv-1", {
                status: "paid"
            });
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
            expect(result.data.invoice.status).toBe("paid");
        });
        test("should handle DELETE /api/sales/invoices/[id]", async ()=>{
            const testDeleteInvoice = async (invoiceId)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            message: "Invoice deleted successfully"
                        })
                });
                const response = await fetch(`/api/sales/invoices/${invoiceId}`, {
                    method: "DELETE",
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testDeleteInvoice("inv-1");
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
        });
    });
    describe("Inventory API Routes", ()=>{
        test("should handle GET /api/inventory/products", async ()=>{
            const testGetProducts = async (params = {})=>{
                const queryString = new URLSearchParams(params).toString();
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            products: [
                                {
                                    id: "prod-1",
                                    name: "Product A",
                                    sku: "SKU-001",
                                    price: 100,
                                    stock: 50,
                                    category: "Electronics"
                                },
                                {
                                    id: "prod-2",
                                    name: "Product B",
                                    sku: "SKU-002",
                                    price: 200,
                                    stock: 25,
                                    category: "Clothing"
                                }
                            ],
                            pagination: {
                                page: 1,
                                limit: 10,
                                total: 2,
                                pages: 1
                            }
                        })
                });
                const url = queryString ? `/api/inventory/products?${queryString}` : "/api/inventory/products";
                const response = await fetch(url, {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testGetProducts({
                category: "Electronics",
                inStock: true
            });
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
            expect(result.data.products).toHaveLength(2);
        });
        test("should handle POST /api/inventory/products", async ()=>{
            const testCreateProduct = async (productData)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 201,
                    json: async ()=>({
                            success: true,
                            product: {
                                id: "prod-new",
                                ...productData,
                                createdAt: new Date().toISOString()
                            },
                            message: "Product created successfully"
                        })
                });
                const response = await fetch("/api/inventory/products", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify(productData)
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const productData = {
                name: "New Product",
                sku: "SKU-NEW",
                price: 150,
                stock: 100,
                category: "Books"
            };
            const result = await testCreateProduct(productData);
            expect(result.status).toBe(201);
            expect(result.data.success).toBe(true);
            expect(result.data.product.name).toBe("New Product");
        });
        test("should handle PUT /api/inventory/stock/[id]", async ()=>{
            const testUpdateStock = async (productId, stockData)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            product: {
                                id: productId,
                                stock: stockData.newStock,
                                updatedAt: new Date().toISOString()
                            },
                            stockMovement: {
                                id: "mov-1",
                                productId,
                                type: stockData.type,
                                quantity: stockData.quantity,
                                reason: stockData.reason
                            },
                            message: "Stock updated successfully"
                        })
                });
                const response = await fetch(`/api/inventory/stock/${productId}`, {
                    method: "PUT",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify(stockData)
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const stockData = {
                type: "adjustment",
                quantity: 10,
                newStock: 60,
                reason: "Stock count correction"
            };
            const result = await testUpdateStock("prod-1", stockData);
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
            expect(result.data.product.stock).toBe(60);
        });
    });
    describe("Customer API Routes", ()=>{
        test("should handle GET /api/customers", async ()=>{
            const testGetCustomers = async (params = {})=>{
                const queryString = new URLSearchParams(params).toString();
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            customers: [
                                {
                                    id: "cust-1",
                                    name: "John Doe",
                                    email: "john@example.com",
                                    phone: "+1234567890",
                                    creditLimit: 5000,
                                    currentBalance: 1200
                                },
                                {
                                    id: "cust-2",
                                    name: "Jane Smith",
                                    email: "jane@example.com",
                                    phone: "+1987654321",
                                    creditLimit: 3000,
                                    currentBalance: 800
                                }
                            ],
                            pagination: {
                                page: 1,
                                limit: 10,
                                total: 2,
                                pages: 1
                            }
                        })
                });
                const url = queryString ? `/api/customers?${queryString}` : "/api/customers";
                const response = await fetch(url, {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testGetCustomers({
                search: "john",
                creditStatus: "good"
            });
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
            expect(result.data.customers).toHaveLength(2);
        });
        test("should handle POST /api/customers", async ()=>{
            const testCreateCustomer = async (customerData)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 201,
                    json: async ()=>({
                            success: true,
                            customer: {
                                id: "cust-new",
                                ...customerData,
                                currentBalance: 0,
                                createdAt: new Date().toISOString()
                            },
                            message: "Customer created successfully"
                        })
                });
                const response = await fetch("/api/customers", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify(customerData)
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const customerData = {
                name: "New Customer",
                email: "new@example.com",
                phone: "+1555666777",
                creditLimit: 2000
            };
            const result = await testCreateCustomer(customerData);
            expect(result.status).toBe(201);
            expect(result.data.success).toBe(true);
            expect(result.data.customer.name).toBe("New Customer");
        });
        test("should handle GET /api/customers/[id]/transactions", async ()=>{
            const testGetCustomerTransactions = async (customerId, params = {})=>{
                const queryString = new URLSearchParams(params).toString();
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            transactions: [
                                {
                                    id: "txn-1",
                                    type: "invoice",
                                    amount: 1000,
                                    date: "2024-01-01T00:00:00Z",
                                    description: "Invoice INV-001"
                                },
                                {
                                    id: "txn-2",
                                    type: "payment",
                                    amount: 500,
                                    date: "2024-01-05T00:00:00Z",
                                    description: "Payment received"
                                }
                            ],
                            summary: {
                                totalInvoiced: 1000,
                                totalPaid: 500,
                                currentBalance: 500
                            }
                        })
                });
                const url = queryString ? `/api/customers/${customerId}/transactions?${queryString}` : `/api/customers/${customerId}/transactions`;
                const response = await fetch(url, {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testGetCustomerTransactions("cust-1", {
                startDate: "2024-01-01",
                endDate: "2024-01-31"
            });
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
            expect(result.data.transactions).toHaveLength(2);
            expect(result.data.summary.currentBalance).toBe(500);
        });
    });
    describe("Dashboard API Routes", ()=>{
        test("should handle GET /api/dashboard", async ()=>{
            const testGetDashboard = async (params = {})=>{
                const queryString = new URLSearchParams(params).toString();
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            data: {
                                sales: {
                                    totalRevenue: 125000,
                                    totalTransactions: 450,
                                    averageOrderValue: 277.78,
                                    growth: 15.5
                                },
                                inventory: {
                                    totalItems: 1250,
                                    lowStockItems: 23,
                                    outOfStockItems: 5,
                                    inventoryValue: 85000
                                },
                                customers: {
                                    totalCustomers: 890,
                                    newCustomers: 45,
                                    activeCustomers: 234
                                }
                            }
                        })
                });
                const url = queryString ? `/api/dashboard?${queryString}` : "/api/dashboard";
                const response = await fetch(url, {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testGetDashboard({
                range: "30d"
            });
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
            expect(result.data.data.sales.totalRevenue).toBe(125000);
        });
        test("should handle GET /api/analytics/charts/[type]", async ()=>{
            const testGetChartData = async (chartType, params = {})=>{
                const queryString = new URLSearchParams(params).toString();
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    status: 200,
                    json: async ()=>({
                            success: true,
                            chartData: {
                                labels: [
                                    "Jan",
                                    "Feb",
                                    "Mar",
                                    "Apr",
                                    "May"
                                ],
                                datasets: [
                                    {
                                        label: "Revenue",
                                        data: [
                                            12000,
                                            15000,
                                            18000,
                                            16000,
                                            20000
                                        ],
                                        backgroundColor: "rgba(54, 162, 235, 0.2)",
                                        borderColor: "rgba(54, 162, 235, 1)"
                                    }
                                ]
                            },
                            metadata: {
                                total: 81000,
                                average: 16200,
                                growth: 12.5
                            }
                        })
                });
                const url = queryString ? `/api/analytics/charts/${chartType}?${queryString}` : `/api/analytics/charts/${chartType}`;
                const response = await fetch(url, {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testGetChartData("revenue", {
                period: "6m",
                groupBy: "month"
            });
            expect(result.status).toBe(200);
            expect(result.data.success).toBe(true);
            expect(result.data.chartData.labels).toHaveLength(5);
            expect(result.data.metadata.total).toBe(81000);
        });
    });
    describe("Error Handling", ()=>{
        test("should handle 404 errors", async ()=>{
            const testNotFound = async ()=>{
                mockFetch.mockResolvedValueOnce({
                    ok: false,
                    status: 404,
                    json: async ()=>({
                            success: false,
                            message: "Resource not found",
                            error: "NOT_FOUND"
                        })
                });
                const response = await fetch("/api/nonexistent/route", {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testNotFound();
            expect(result.status).toBe(404);
            expect(result.data.success).toBe(false);
            expect(result.data.error).toBe("NOT_FOUND");
        });
        test("should handle validation errors", async ()=>{
            const testValidationError = async ()=>{
                mockFetch.mockResolvedValueOnce({
                    ok: false,
                    status: 400,
                    json: async ()=>({
                            success: false,
                            message: "Validation failed",
                            error: "VALIDATION_ERROR",
                            details: [
                                {
                                    field: "email",
                                    message: "Invalid email format"
                                },
                                {
                                    field: "name",
                                    message: "Name is required"
                                }
                            ]
                        })
                });
                const response = await fetch("/api/customers", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify({
                        email: "invalid-email"
                    })
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testValidationError();
            expect(result.status).toBe(400);
            expect(result.data.success).toBe(false);
            expect(result.data.error).toBe("VALIDATION_ERROR");
            expect(result.data.details).toHaveLength(2);
        });
        test("should handle server errors", async ()=>{
            const testServerError = async ()=>{
                mockFetch.mockResolvedValueOnce({
                    ok: false,
                    status: 500,
                    json: async ()=>({
                            success: false,
                            message: "Internal server error",
                            error: "INTERNAL_ERROR"
                        })
                });
                const response = await fetch("/api/sales/invoices", {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testServerError();
            expect(result.status).toBe(500);
            expect(result.data.success).toBe(false);
            expect(result.data.error).toBe("INTERNAL_ERROR");
        });
        test("should handle rate limiting", async ()=>{
            const testRateLimit = async ()=>{
                mockFetch.mockResolvedValueOnce({
                    ok: false,
                    status: 429,
                    json: async ()=>({
                            success: false,
                            message: "Too many requests",
                            error: "RATE_LIMIT_EXCEEDED",
                            retryAfter: 60
                        })
                });
                const response = await fetch("/api/sales/invoices", {
                    headers: {
                        "Authorization": "Bearer mock-token"
                    }
                });
                return {
                    status: response.status,
                    data: await response.json()
                };
            };
            const result = await testRateLimit();
            expect(result.status).toBe(429);
            expect(result.data.success).toBe(false);
            expect(result.data.error).toBe("RATE_LIMIT_EXCEEDED");
            expect(result.data.retryAfter).toBe(60);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvYXBpL2FwaVJvdXRlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCAnQHRlc3RpbmctbGlicmFyeS9qZXN0LWRvbSc7XG5cbi8vIE1vY2sgdGhlIHVzZUF1dGggaG9va1xuY29uc3QgbW9ja1VzZUF1dGggPSBqZXN0LmZuKCk7XG5qZXN0Lm1vY2soJ0AvaG9va3MvdXNlQXV0aCcsICgpID0+ICh7XG4gIHVzZUF1dGg6ICgpID0+IG1vY2tVc2VBdXRoKCksXG59KSk7XG5cbi8vIE1vY2sgbmV4dC9uYXZpZ2F0aW9uXG5qZXN0Lm1vY2soJ25leHQvbmF2aWdhdGlvbicsICgpID0+ICh7XG4gIHVzZVJvdXRlcjogKCkgPT4gKHtcbiAgICBwdXNoOiBqZXN0LmZuKCksXG4gICAgcmVwbGFjZTogamVzdC5mbigpLFxuICAgIGJhY2s6IGplc3QuZm4oKSxcbiAgICBmb3J3YXJkOiBqZXN0LmZuKCksXG4gICAgcmVmcmVzaDogamVzdC5mbigpLFxuICAgIHByZWZldGNoOiBqZXN0LmZuKCksXG4gIH0pLFxufSkpO1xuXG4vLyBNb2NrIGZldGNoIGdsb2JhbGx5XG5jb25zdCBtb2NrRmV0Y2ggPSBqZXN0LmZuKCk7XG5nbG9iYWwuZmV0Y2ggPSBtb2NrRmV0Y2g7XG5cbmRlc2NyaWJlKCdBUEkgUm91dGVzIFRlc3RpbmcnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIE1vY2sgbG9jYWxTdG9yYWdlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2xvY2FsU3RvcmFnZScsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGdldEl0ZW06IGplc3QuZm4oKCkgPT4gJ21vY2stdG9rZW4nKSxcbiAgICAgICAgc2V0SXRlbTogamVzdC5mbigpLFxuICAgICAgICByZW1vdmVJdGVtOiBqZXN0LmZuKCksXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLyBNb2NrIHVzZXIgd2l0aCBBUEkgYWNjZXNzIHBlcm1pc3Npb25zXG4gICAgbW9ja1VzZUF1dGgubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgbmFtZTogJ0FQSSBVc2VyJyxcbiAgICAgICAgZW1haWw6ICdhcGlAdGVzdC5jb20nLFxuICAgICAgICBwZXJtaXNzaW9uczogWydhcGk6YWNjZXNzJywgJ3NhbGVzOmFsbCcsICdpbnZlbnRvcnk6YWxsJywgJ2N1c3RvbWVyczphbGwnXVxuICAgICAgfSxcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICBsb2dpbjogamVzdC5mbigpLFxuICAgICAgbG9nb3V0OiBqZXN0LmZuKCksXG4gICAgICBoYXNQZXJtaXNzaW9uOiBqZXN0LmZuKCgpID0+IHRydWUpXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBdXRoZW50aWNhdGlvbiBBUEkgUm91dGVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgUE9TVCAvYXBpL2F1dGgvbG9naW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0TG9naW4gPSBhc3luYyAoY3JlZGVudGlhbHM6IGFueSkgPT4ge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHRva2VuOiAnand0LXRva2VuLTEyMycsXG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgIGlkOiAnMScsXG4gICAgICAgICAgICAgIGVtYWlsOiBjcmVkZW50aWFscy5lbWFpbCxcbiAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgICAgICAgIHBlcm1pc3Npb25zOiBbJ3NhbGVzOnZpZXcnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cGlyZXNJbjogMzYwMFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjcmVkZW50aWFscylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIGRhdGE6IGF3YWl0IHJlc3BvbnNlLmpzb24oKSB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVzdExvZ2luKHsgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJywgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b2tlbikudG9CZSgnand0LXRva2VuLTEyMycpO1xuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJywgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycgfSlcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBQT1NUIC9hcGkvYXV0aC9sb2dvdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0TG9nb3V0ID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiAnTG9nZ2VkIG91dCBzdWNjZXNzZnVsbHknXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hdXRoL2xvZ291dCcsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgZGF0YTogYXdhaXQgcmVzcG9uc2UuanNvbigpIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0TG9nb3V0KCdtb2NrLXRva2VuJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgUE9TVCAvYXBpL2F1dGgvcmVmcmVzaCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RSZWZyZXNoID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICB0b2tlbjogJ25ldy1qd3QtdG9rZW4tNDU2JyxcbiAgICAgICAgICAgIGV4cGlyZXNJbjogMzYwMFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvYXV0aC9yZWZyZXNoJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBkYXRhOiBhd2FpdCByZXNwb25zZS5qc29uKCkgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlc3RSZWZyZXNoKCdvbGQtdG9rZW4nKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b2tlbikudG9CZSgnbmV3LWp3dC10b2tlbi00NTYnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgYXV0aGVudGljYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdEF1dGhFcnJvciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgIHN0YXR1czogNDAxLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGNyZWRlbnRpYWxzJyxcbiAgICAgICAgICAgIGVycm9yOiAnVU5BVVRIT1JJWkVEJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsOiAnd3JvbmdAZXhhbXBsZS5jb20nLCBwYXNzd29yZDogJ3dyb25ncGFzcycgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIGRhdGE6IGF3YWl0IHJlc3BvbnNlLmpzb24oKSB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVzdEF1dGhFcnJvcigpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmVycm9yKS50b0JlKCdVTkFVVEhPUklaRUQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NhbGVzIEludm9pY2UgQVBJIFJvdXRlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIEdFVCAvYXBpL3NhbGVzL2ludm9pY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdEdldEludm9pY2VzID0gYXN5bmMgKHBhcmFtczogYW55ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykudG9TdHJpbmcoKTtcbiAgICAgICAgXG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgaW52b2ljZXM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnaW52LTEnLFxuICAgICAgICAgICAgICAgIGludm9pY2VOdW1iZXI6ICdJTlYtMDAxJyxcbiAgICAgICAgICAgICAgICBjdXN0b21lcklkOiAnY3VzdC0xJyxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IDEwMDAsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogJ2ludi0yJyxcbiAgICAgICAgICAgICAgICBpbnZvaWNlTnVtYmVyOiAnSU5WLTAwMicsXG4gICAgICAgICAgICAgICAgY3VzdG9tZXJJZDogJ2N1c3QtMicsXG4gICAgICAgICAgICAgICAgYW1vdW50OiAxNTAwLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjQtMDEtMDJUMDA6MDA6MDBaJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICBwYWdlOiAxLFxuICAgICAgICAgICAgICBsaW1pdDogMTAsXG4gICAgICAgICAgICAgIHRvdGFsOiAyLFxuICAgICAgICAgICAgICBwYWdlczogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYC9hcGkvc2FsZXMvaW52b2ljZXM/JHtxdWVyeVN0cmluZ31gIDogJy9hcGkvc2FsZXMvaW52b2ljZXMnO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIGRhdGE6IGF3YWl0IHJlc3BvbnNlLmpzb24oKSB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVzdEdldEludm9pY2VzKHsgcGFnZTogMSwgbGltaXQ6IDEwLCBzdGF0dXM6ICdwZW5kaW5nJyB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmludm9pY2VzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEucGFnaW5hdGlvbi50b3RhbCkudG9CZSgyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgUE9TVCAvYXBpL3NhbGVzL2ludm9pY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdENyZWF0ZUludm9pY2UgPSBhc3luYyAoaW52b2ljZURhdGE6IGFueSkgPT4ge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGludm9pY2U6IHtcbiAgICAgICAgICAgICAgaWQ6ICdpbnYtbmV3JyxcbiAgICAgICAgICAgICAgLi4uaW52b2ljZURhdGEsXG4gICAgICAgICAgICAgIGludm9pY2VOdW1iZXI6ICdJTlYtMDAzJyxcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiAnSW52b2ljZSBjcmVhdGVkIHN1Y2Nlc3NmdWxseSdcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhbGVzL2ludm9pY2VzJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9jay10b2tlbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGludm9pY2VEYXRhKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgZGF0YTogYXdhaXQgcmVzcG9uc2UuanNvbigpIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbnZvaWNlRGF0YSA9IHtcbiAgICAgICAgY3VzdG9tZXJJZDogJ2N1c3QtMScsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgeyBwcm9kdWN0SWQ6ICdwcm9kLTEnLCBxdWFudGl0eTogMiwgcHJpY2U6IDUwMCB9XG4gICAgICAgIF0sXG4gICAgICAgIHN1YnRvdGFsOiAxMDAwLFxuICAgICAgICB0YXg6IDEwMCxcbiAgICAgICAgdG90YWw6IDExMDBcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlc3RDcmVhdGVJbnZvaWNlKGludm9pY2VEYXRhKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmludm9pY2UuaWQpLnRvQmUoJ2ludi1uZXcnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgUFVUIC9hcGkvc2FsZXMvaW52b2ljZXMvW2lkXScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RVcGRhdGVJbnZvaWNlID0gYXN5bmMgKGludm9pY2VJZDogc3RyaW5nLCB1cGRhdGVEYXRhOiBhbnkpID0+IHtcbiAgICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBpbnZvaWNlOiB7XG4gICAgICAgICAgICAgIGlkOiBpbnZvaWNlSWQsXG4gICAgICAgICAgICAgIC4uLnVwZGF0ZURhdGEsXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ludm9pY2UgdXBkYXRlZCBzdWNjZXNzZnVsbHknXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9zYWxlcy9pbnZvaWNlcy8ke2ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgZGF0YTogYXdhaXQgcmVzcG9uc2UuanNvbigpIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0VXBkYXRlSW52b2ljZSgnaW52LTEnLCB7IHN0YXR1czogJ3BhaWQnIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEuaW52b2ljZS5zdGF0dXMpLnRvQmUoJ3BhaWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgREVMRVRFIC9hcGkvc2FsZXMvaW52b2ljZXMvW2lkXScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REZWxldGVJbnZvaWNlID0gYXN5bmMgKGludm9pY2VJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ludm9pY2UgZGVsZXRlZCBzdWNjZXNzZnVsbHknXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9zYWxlcy9pbnZvaWNlcy8ke2ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9jay10b2tlbidcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBkYXRhOiBhd2FpdCByZXNwb25zZS5qc29uKCkgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlc3REZWxldGVJbnZvaWNlKCdpbnYtMScpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnZlbnRvcnkgQVBJIFJvdXRlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIEdFVCAvYXBpL2ludmVudG9yeS9wcm9kdWN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RHZXRQcm9kdWN0cyA9IGFzeW5jIChwYXJhbXM6IGFueSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpLnRvU3RyaW5nKCk7XG4gICAgICAgIFxuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHByb2R1Y3RzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogJ3Byb2QtMScsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1Byb2R1Y3QgQScsXG4gICAgICAgICAgICAgICAgc2t1OiAnU0tVLTAwMScsXG4gICAgICAgICAgICAgICAgcHJpY2U6IDEwMCxcbiAgICAgICAgICAgICAgICBzdG9jazogNTAsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdFbGVjdHJvbmljcydcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAncHJvZC0yJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBCJyxcbiAgICAgICAgICAgICAgICBza3U6ICdTS1UtMDAyJyxcbiAgICAgICAgICAgICAgICBwcmljZTogMjAwLFxuICAgICAgICAgICAgICAgIHN0b2NrOiAyNSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ0Nsb3RoaW5nJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICBwYWdlOiAxLFxuICAgICAgICAgICAgICBsaW1pdDogMTAsXG4gICAgICAgICAgICAgIHRvdGFsOiAyLFxuICAgICAgICAgICAgICBwYWdlczogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYC9hcGkvaW52ZW50b3J5L3Byb2R1Y3RzPyR7cXVlcnlTdHJpbmd9YCA6ICcvYXBpL2ludmVudG9yeS9wcm9kdWN0cyc7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgZGF0YTogYXdhaXQgcmVzcG9uc2UuanNvbigpIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0R2V0UHJvZHVjdHMoeyBjYXRlZ29yeTogJ0VsZWN0cm9uaWNzJywgaW5TdG9jazogdHJ1ZSB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnByb2R1Y3RzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIFBPU1QgL2FwaS9pbnZlbnRvcnkvcHJvZHVjdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q3JlYXRlUHJvZHVjdCA9IGFzeW5jIChwcm9kdWN0RGF0YTogYW55KSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgcHJvZHVjdDoge1xuICAgICAgICAgICAgICBpZDogJ3Byb2QtbmV3JyxcbiAgICAgICAgICAgICAgLi4ucHJvZHVjdERhdGEsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZTogJ1Byb2R1Y3QgY3JlYXRlZCBzdWNjZXNzZnVsbHknXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9pbnZlbnRvcnkvcHJvZHVjdHMnLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHJvZHVjdERhdGEpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBkYXRhOiBhd2FpdCByZXNwb25zZS5qc29uKCkgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb2R1Y3REYXRhID0ge1xuICAgICAgICBuYW1lOiAnTmV3IFByb2R1Y3QnLFxuICAgICAgICBza3U6ICdTS1UtTkVXJyxcbiAgICAgICAgcHJpY2U6IDE1MCxcbiAgICAgICAgc3RvY2s6IDEwMCxcbiAgICAgICAgY2F0ZWdvcnk6ICdCb29rcydcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlc3RDcmVhdGVQcm9kdWN0KHByb2R1Y3REYXRhKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnByb2R1Y3QubmFtZSkudG9CZSgnTmV3IFByb2R1Y3QnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgUFVUIC9hcGkvaW52ZW50b3J5L3N0b2NrL1tpZF0nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0VXBkYXRlU3RvY2sgPSBhc3luYyAocHJvZHVjdElkOiBzdHJpbmcsIHN0b2NrRGF0YTogYW55KSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgcHJvZHVjdDoge1xuICAgICAgICAgICAgICBpZDogcHJvZHVjdElkLFxuICAgICAgICAgICAgICBzdG9jazogc3RvY2tEYXRhLm5ld1N0b2NrLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b2NrTW92ZW1lbnQ6IHtcbiAgICAgICAgICAgICAgaWQ6ICdtb3YtMScsXG4gICAgICAgICAgICAgIHByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgdHlwZTogc3RvY2tEYXRhLnR5cGUsXG4gICAgICAgICAgICAgIHF1YW50aXR5OiBzdG9ja0RhdGEucXVhbnRpdHksXG4gICAgICAgICAgICAgIHJlYXNvbjogc3RvY2tEYXRhLnJlYXNvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdTdG9jayB1cGRhdGVkIHN1Y2Nlc3NmdWxseSdcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2ludmVudG9yeS9zdG9jay8ke3Byb2R1Y3RJZH1gLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzdG9ja0RhdGEpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBkYXRhOiBhd2FpdCByZXNwb25zZS5qc29uKCkgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHN0b2NrRGF0YSA9IHtcbiAgICAgICAgdHlwZTogJ2FkanVzdG1lbnQnLFxuICAgICAgICBxdWFudGl0eTogMTAsXG4gICAgICAgIG5ld1N0b2NrOiA2MCxcbiAgICAgICAgcmVhc29uOiAnU3RvY2sgY291bnQgY29ycmVjdGlvbidcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlc3RVcGRhdGVTdG9jaygncHJvZC0xJywgc3RvY2tEYXRhKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnByb2R1Y3Quc3RvY2spLnRvQmUoNjApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ3VzdG9tZXIgQVBJIFJvdXRlcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIEdFVCAvYXBpL2N1c3RvbWVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RHZXRDdXN0b21lcnMgPSBhc3luYyAocGFyYW1zOiBhbnkgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBxdWVyeVN0cmluZyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpO1xuICAgICAgICBcbiAgICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBjdXN0b21lcnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnY3VzdC0xJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9obiBEb2UnLFxuICAgICAgICAgICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICAgICAgcGhvbmU6ICcrMTIzNDU2Nzg5MCcsXG4gICAgICAgICAgICAgICAgY3JlZGl0TGltaXQ6IDUwMDAsXG4gICAgICAgICAgICAgICAgY3VycmVudEJhbGFuY2U6IDEyMDBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnY3VzdC0yJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSmFuZSBTbWl0aCcsXG4gICAgICAgICAgICAgICAgZW1haWw6ICdqYW5lQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgICAgICBwaG9uZTogJysxOTg3NjU0MzIxJyxcbiAgICAgICAgICAgICAgICBjcmVkaXRMaW1pdDogMzAwMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50QmFsYW5jZTogODAwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgICAgICAgIHBhZ2U6IDEsXG4gICAgICAgICAgICAgIGxpbWl0OiAxMCxcbiAgICAgICAgICAgICAgdG90YWw6IDIsXG4gICAgICAgICAgICAgIHBhZ2VzOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdXJsID0gcXVlcnlTdHJpbmcgPyBgL2FwaS9jdXN0b21lcnM/JHtxdWVyeVN0cmluZ31gIDogJy9hcGkvY3VzdG9tZXJzJztcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9jay10b2tlbidcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBkYXRhOiBhd2FpdCByZXNwb25zZS5qc29uKCkgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlc3RHZXRDdXN0b21lcnMoeyBzZWFyY2g6ICdqb2huJywgY3JlZGl0U3RhdHVzOiAnZ29vZCcgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5jdXN0b21lcnMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgUE9TVCAvYXBpL2N1c3RvbWVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDcmVhdGVDdXN0b21lciA9IGFzeW5jIChjdXN0b21lckRhdGE6IGFueSkgPT4ge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGN1c3RvbWVyOiB7XG4gICAgICAgICAgICAgIGlkOiAnY3VzdC1uZXcnLFxuICAgICAgICAgICAgICAuLi5jdXN0b21lckRhdGEsXG4gICAgICAgICAgICAgIGN1cnJlbnRCYWxhbmNlOiAwLFxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDdXN0b21lciBjcmVhdGVkIHN1Y2Nlc3NmdWxseSdcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2N1c3RvbWVycycsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjdXN0b21lckRhdGEpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBkYXRhOiBhd2FpdCByZXNwb25zZS5qc29uKCkgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGN1c3RvbWVyRGF0YSA9IHtcbiAgICAgICAgbmFtZTogJ05ldyBDdXN0b21lcicsXG4gICAgICAgIGVtYWlsOiAnbmV3QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGhvbmU6ICcrMTU1NTY2Njc3NycsXG4gICAgICAgIGNyZWRpdExpbWl0OiAyMDAwXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0Q3JlYXRlQ3VzdG9tZXIoY3VzdG9tZXJEYXRhKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmN1c3RvbWVyLm5hbWUpLnRvQmUoJ05ldyBDdXN0b21lcicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBHRVQgL2FwaS9jdXN0b21lcnMvW2lkXS90cmFuc2FjdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0R2V0Q3VzdG9tZXJUcmFuc2FjdGlvbnMgPSBhc3luYyAoY3VzdG9tZXJJZDogc3RyaW5nLCBwYXJhbXM6IGFueSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpLnRvU3RyaW5nKCk7XG4gICAgICAgIFxuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6ICd0eG4tMScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2ludm9pY2UnLFxuICAgICAgICAgICAgICAgIGFtb3VudDogMTAwMCxcbiAgICAgICAgICAgICAgICBkYXRlOiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW52b2ljZSBJTlYtMDAxJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6ICd0eG4tMicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3BheW1lbnQnLFxuICAgICAgICAgICAgICAgIGFtb3VudDogNTAwLFxuICAgICAgICAgICAgICAgIGRhdGU6ICcyMDI0LTAxLTA1VDAwOjAwOjAwWicsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdQYXltZW50IHJlY2VpdmVkJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc3VtbWFyeToge1xuICAgICAgICAgICAgICB0b3RhbEludm9pY2VkOiAxMDAwLFxuICAgICAgICAgICAgICB0b3RhbFBhaWQ6IDUwMCxcbiAgICAgICAgICAgICAgY3VycmVudEJhbGFuY2U6IDUwMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYC9hcGkvY3VzdG9tZXJzLyR7Y3VzdG9tZXJJZH0vdHJhbnNhY3Rpb25zPyR7cXVlcnlTdHJpbmd9YCA6IGAvYXBpL2N1c3RvbWVycy8ke2N1c3RvbWVySWR9L3RyYW5zYWN0aW9uc2A7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgZGF0YTogYXdhaXQgcmVzcG9uc2UuanNvbigpIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0R2V0Q3VzdG9tZXJUcmFuc2FjdGlvbnMoJ2N1c3QtMScsIHsgc3RhcnREYXRlOiAnMjAyNC0wMS0wMScsIGVuZERhdGU6ICcyMDI0LTAxLTMxJyB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnRyYW5zYWN0aW9ucykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnN1bW1hcnkuY3VycmVudEJhbGFuY2UpLnRvQmUoNTAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Rhc2hib2FyZCBBUEkgUm91dGVzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgR0VUIC9hcGkvZGFzaGJvYXJkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdEdldERhc2hib2FyZCA9IGFzeW5jIChwYXJhbXM6IGFueSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpLnRvU3RyaW5nKCk7XG4gICAgICAgIFxuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgc2FsZXM6IHtcbiAgICAgICAgICAgICAgICB0b3RhbFJldmVudWU6IDEyNTAwMCxcbiAgICAgICAgICAgICAgICB0b3RhbFRyYW5zYWN0aW9uczogNDUwLFxuICAgICAgICAgICAgICAgIGF2ZXJhZ2VPcmRlclZhbHVlOiAyNzcuNzgsXG4gICAgICAgICAgICAgICAgZ3Jvd3RoOiAxNS41XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGludmVudG9yeToge1xuICAgICAgICAgICAgICAgIHRvdGFsSXRlbXM6IDEyNTAsXG4gICAgICAgICAgICAgICAgbG93U3RvY2tJdGVtczogMjMsXG4gICAgICAgICAgICAgICAgb3V0T2ZTdG9ja0l0ZW1zOiA1LFxuICAgICAgICAgICAgICAgIGludmVudG9yeVZhbHVlOiA4NTAwMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjdXN0b21lcnM6IHtcbiAgICAgICAgICAgICAgICB0b3RhbEN1c3RvbWVyczogODkwLFxuICAgICAgICAgICAgICAgIG5ld0N1c3RvbWVyczogNDUsXG4gICAgICAgICAgICAgICAgYWN0aXZlQ3VzdG9tZXJzOiAyMzRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYC9hcGkvZGFzaGJvYXJkPyR7cXVlcnlTdHJpbmd9YCA6ICcvYXBpL2Rhc2hib2FyZCc7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgZGF0YTogYXdhaXQgcmVzcG9uc2UuanNvbigpIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0R2V0RGFzaGJvYXJkKHsgcmFuZ2U6ICczMGQnIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGF0YS5zYWxlcy50b3RhbFJldmVudWUpLnRvQmUoMTI1MDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgR0VUIC9hcGkvYW5hbHl0aWNzL2NoYXJ0cy9bdHlwZV0nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0R2V0Q2hhcnREYXRhID0gYXN5bmMgKGNoYXJ0VHlwZTogc3RyaW5nLCBwYXJhbXM6IGFueSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpLnRvU3RyaW5nKCk7XG4gICAgICAgIFxuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGNoYXJ0RGF0YToge1xuICAgICAgICAgICAgICBsYWJlbHM6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heSddLFxuICAgICAgICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1JldmVudWUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IFsxMjAwMCwgMTUwMDAsIDE4MDAwLCAxNjAwMCwgMjAwMDBdLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoNTQsIDE2MiwgMjM1LCAwLjIpJyxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoNTQsIDE2MiwgMjM1LCAxKSdcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICB0b3RhbDogODEwMDAsXG4gICAgICAgICAgICAgIGF2ZXJhZ2U6IDE2MjAwLFxuICAgICAgICAgICAgICBncm93dGg6IDEyLjVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB1cmwgPSBxdWVyeVN0cmluZyA/IGAvYXBpL2FuYWx5dGljcy9jaGFydHMvJHtjaGFydFR5cGV9PyR7cXVlcnlTdHJpbmd9YCA6IGAvYXBpL2FuYWx5dGljcy9jaGFydHMvJHtjaGFydFR5cGV9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9jay10b2tlbidcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBkYXRhOiBhd2FpdCByZXNwb25zZS5qc29uKCkgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlc3RHZXRDaGFydERhdGEoJ3JldmVudWUnLCB7IHBlcmlvZDogJzZtJywgZ3JvdXBCeTogJ21vbnRoJyB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmNoYXJ0RGF0YS5sYWJlbHMpLnRvSGF2ZUxlbmd0aCg1KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5tZXRhZGF0YS50b3RhbCkudG9CZSg4MTAwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIDQwNCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Tm90Rm91bmQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiAnUmVzb3VyY2Ugbm90IGZvdW5kJyxcbiAgICAgICAgICAgIGVycm9yOiAnTk9UX0ZPVU5EJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvbm9uZXhpc3RlbnQvcm91dGUnLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgZGF0YTogYXdhaXQgcmVzcG9uc2UuanNvbigpIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0Tm90Rm91bmQoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoNDA0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5lcnJvcikudG9CZSgnTk9UX0ZPVU5EJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFZhbGlkYXRpb25FcnJvciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdWYWxpZGF0aW9uIGZhaWxlZCcsXG4gICAgICAgICAgICBlcnJvcjogJ1ZBTElEQVRJT05fRVJST1InLFxuICAgICAgICAgICAgZGV0YWlsczogW1xuICAgICAgICAgICAgICB7IGZpZWxkOiAnZW1haWwnLCBtZXNzYWdlOiAnSW52YWxpZCBlbWFpbCBmb3JtYXQnIH0sXG4gICAgICAgICAgICAgIHsgZmllbGQ6ICduYW1lJywgbWVzc2FnZTogJ05hbWUgaXMgcmVxdWlyZWQnIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2N1c3RvbWVycycsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsOiAnaW52YWxpZC1lbWFpbCcgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIGRhdGE6IGF3YWl0IHJlc3BvbnNlLmpzb24oKSB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVzdFZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmVycm9yKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGV0YWlscykudG9IYXZlTGVuZ3RoKDIpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBzZXJ2ZXIgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFNlcnZlckVycm9yID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ludGVybmFsIHNlcnZlciBlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogJ0lOVEVSTkFMX0VSUk9SJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2FsZXMvaW52b2ljZXMnLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgZGF0YTogYXdhaXQgcmVzcG9uc2UuanNvbigpIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0U2VydmVyRXJyb3IoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoNTAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5lcnJvcikudG9CZSgnSU5URVJOQUxfRVJST1InKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgcmF0ZSBsaW1pdGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RSYXRlTGltaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICBzdGF0dXM6IDQyOSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiAnVG9vIG1hbnkgcmVxdWVzdHMnLFxuICAgICAgICAgICAgZXJyb3I6ICdSQVRFX0xJTUlUX0VYQ0VFREVEJyxcbiAgICAgICAgICAgIHJldHJ5QWZ0ZXI6IDYwXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYWxlcy9pbnZvaWNlcycsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9jay10b2tlbidcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBkYXRhOiBhd2FpdCByZXNwb25zZS5qc29uKCkgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlc3RSYXRlTGltaXQoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoNDI5KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5lcnJvcikudG9CZSgnUkFURV9MSU1JVF9FWENFRURFRCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnJldHJ5QWZ0ZXIpLnRvQmUoNjApO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZUF1dGgiLCJtb2NrVXNlQXV0aCIsInVzZVJvdXRlciIsInB1c2giLCJmbiIsInJlcGxhY2UiLCJiYWNrIiwiZm9yd2FyZCIsInJlZnJlc2giLCJwcmVmZXRjaCIsIm1vY2tGZXRjaCIsImdsb2JhbCIsImZldGNoIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid2luZG93IiwidmFsdWUiLCJnZXRJdGVtIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJ3cml0YWJsZSIsIm1vY2tSZXR1cm5WYWx1ZSIsInVzZXIiLCJpZCIsIm5hbWUiLCJlbWFpbCIsInBlcm1pc3Npb25zIiwiaXNMb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwibG9naW4iLCJsb2dvdXQiLCJoYXNQZXJtaXNzaW9uIiwidGVzdCIsInRlc3RMb2dpbiIsImNyZWRlbnRpYWxzIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJzdGF0dXMiLCJqc29uIiwic3VjY2VzcyIsInRva2VuIiwiZXhwaXJlc0luIiwicmVzcG9uc2UiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwicmVzdWx0IiwicGFzc3dvcmQiLCJleHBlY3QiLCJ0b0JlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0ZXN0TG9nb3V0IiwibWVzc2FnZSIsInRlc3RSZWZyZXNoIiwidGVzdEF1dGhFcnJvciIsImVycm9yIiwidGVzdEdldEludm9pY2VzIiwicGFyYW1zIiwicXVlcnlTdHJpbmciLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsImludm9pY2VzIiwiaW52b2ljZU51bWJlciIsImN1c3RvbWVySWQiLCJhbW91bnQiLCJjcmVhdGVkQXQiLCJwYWdpbmF0aW9uIiwicGFnZSIsImxpbWl0IiwidG90YWwiLCJwYWdlcyIsInVybCIsInRvSGF2ZUxlbmd0aCIsInRlc3RDcmVhdGVJbnZvaWNlIiwiaW52b2ljZURhdGEiLCJpbnZvaWNlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiaXRlbXMiLCJwcm9kdWN0SWQiLCJxdWFudGl0eSIsInByaWNlIiwic3VidG90YWwiLCJ0YXgiLCJ0ZXN0VXBkYXRlSW52b2ljZSIsImludm9pY2VJZCIsInVwZGF0ZURhdGEiLCJ1cGRhdGVkQXQiLCJ0ZXN0RGVsZXRlSW52b2ljZSIsInRlc3RHZXRQcm9kdWN0cyIsInByb2R1Y3RzIiwic2t1Iiwic3RvY2siLCJjYXRlZ29yeSIsImluU3RvY2siLCJ0ZXN0Q3JlYXRlUHJvZHVjdCIsInByb2R1Y3REYXRhIiwicHJvZHVjdCIsInRlc3RVcGRhdGVTdG9jayIsInN0b2NrRGF0YSIsIm5ld1N0b2NrIiwic3RvY2tNb3ZlbWVudCIsInR5cGUiLCJyZWFzb24iLCJ0ZXN0R2V0Q3VzdG9tZXJzIiwiY3VzdG9tZXJzIiwicGhvbmUiLCJjcmVkaXRMaW1pdCIsImN1cnJlbnRCYWxhbmNlIiwic2VhcmNoIiwiY3JlZGl0U3RhdHVzIiwidGVzdENyZWF0ZUN1c3RvbWVyIiwiY3VzdG9tZXJEYXRhIiwiY3VzdG9tZXIiLCJ0ZXN0R2V0Q3VzdG9tZXJUcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJkYXRlIiwiZGVzY3JpcHRpb24iLCJzdW1tYXJ5IiwidG90YWxJbnZvaWNlZCIsInRvdGFsUGFpZCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJ0ZXN0R2V0RGFzaGJvYXJkIiwic2FsZXMiLCJ0b3RhbFJldmVudWUiLCJ0b3RhbFRyYW5zYWN0aW9ucyIsImF2ZXJhZ2VPcmRlclZhbHVlIiwiZ3Jvd3RoIiwiaW52ZW50b3J5IiwidG90YWxJdGVtcyIsImxvd1N0b2NrSXRlbXMiLCJvdXRPZlN0b2NrSXRlbXMiLCJpbnZlbnRvcnlWYWx1ZSIsInRvdGFsQ3VzdG9tZXJzIiwibmV3Q3VzdG9tZXJzIiwiYWN0aXZlQ3VzdG9tZXJzIiwicmFuZ2UiLCJ0ZXN0R2V0Q2hhcnREYXRhIiwiY2hhcnRUeXBlIiwiY2hhcnREYXRhIiwibGFiZWxzIiwiZGF0YXNldHMiLCJsYWJlbCIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwibWV0YWRhdGEiLCJhdmVyYWdlIiwicGVyaW9kIiwiZ3JvdXBCeSIsInRlc3ROb3RGb3VuZCIsInRlc3RWYWxpZGF0aW9uRXJyb3IiLCJkZXRhaWxzIiwiZmllbGQiLCJ0ZXN0U2VydmVyRXJyb3IiLCJ0ZXN0UmF0ZUxpbWl0IiwicmV0cnlBZnRlciJdLCJtYXBwaW5ncyI6IjtBQUtBQSxLQUFLQyxJQUFJLENBQUMsbUJBQW1CLElBQU8sQ0FBQTtRQUNsQ0MsU0FBUyxJQUFNQztJQUNqQixDQUFBO0FBRUEsdUJBQXVCO0FBQ3ZCSCxLQUFLQyxJQUFJLENBQUMs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