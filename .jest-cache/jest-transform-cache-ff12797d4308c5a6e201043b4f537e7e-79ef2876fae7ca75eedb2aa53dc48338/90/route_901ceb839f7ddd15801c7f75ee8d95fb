70416bdd33af5aa69609a650b309f85f
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    GET: function() {
        return GET;
    },
    POST: function() {
        return POST;
    }
});
const _server = require("next/server");
const _middleware = require("../../../../lib/utils/middleware");
const _prisma = require("../../../../lib/prisma");
const _auth = require("../../../../lib/auth");
const _PermissionService = require("../../../../lib/services/PermissionService");
const _transferCache = require("../../../../lib/transferCache");
const _transferPerformanceMonitor = require("../../../../lib/transferPerformanceMonitor");
const _requestdeduplication = require("../../../../lib/request-deduplication");
const _auditService = require("../../../../services/auditService");
// Default fallback data for transfers
const defaultTransfersData = [
    {
        id: 1,
        status: "pending",
        created_at: "2025-05-20T10:00:00Z",
        completed_at: null,
        source_shop_name: "Colombo Shop",
        destination_shop_name: "Kandy Shop",
        initiated_by: "System User",
        item_count: 5,
        total_items: 25
    },
    {
        id: 2,
        status: "completed",
        created_at: "2025-05-19T09:30:00Z",
        completed_at: "2025-05-19T16:00:00Z",
        source_shop_name: "Galle Shop",
        destination_shop_name: "Colombo Shop",
        initiated_by: "System User",
        item_count: 3,
        total_items: 15
    },
    {
        id: 3,
        status: "cancelled",
        created_at: "2025-05-18T14:00:00Z",
        completed_at: null,
        source_shop_name: "Kandy Shop",
        destination_shop_name: "Jaffna Shop",
        initiated_by: "System User",
        item_count: 2,
        total_items: 10
    }
];
async function GET(req) {
    const operation = (0, _transferPerformanceMonitor.trackTransferOperation)("list");
    console.log("GET /api/inventory/transfers - Checking permission: inventory:transfer");
    // Check for inventory:transfer permission (shop staff should have this)
    const permissionError = await (0, _middleware.requirePermission)("inventory:transfer")(req);
    if (permissionError) {
        console.error("Permission denied for inventory:transfer:", permissionError.status);
        operation.end(false, "unauthorized");
        return permissionError;
    }
    // Get user context for shop filtering
    const authHeader = req.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
        operation.end(false, "unauthorized");
        return _server.NextResponse.json({
            success: false,
            message: "Authentication required"
        }, {
            status: 401
        });
    }
    const token = authHeader.split(" ")[1];
    const decodedToken = await (0, _auth.verifyToken)(token);
    if (!decodedToken) {
        operation.end(false, "unauthorized");
        return _server.NextResponse.json({
            success: false,
            message: "Invalid token"
        }, {
            status: 401
        });
    }
    const userShopId = decodedToken.shopId;
    const userPermissions = Array.isArray(decodedToken.permissions) ? decodedToken.permissions : [];
    const isAdmin = _PermissionService.permissionService.hasPermission({
        permissions: userPermissions
    }, "admin:all") || _PermissionService.permissionService.hasPermission({
        permissions: userPermissions
    }, "shop:manage") || token === "dev-token";
    console.log("User shop filtering - shopId:", userShopId, "isAdmin:", isAdmin);
    try {
        console.log("Executing query to fetch transfers...");
        // Generate cache key based on request parameters
        const { searchParams } = new URL(req.url);
        const cacheKey = _transferCache.transferCacheService.generateTransferCacheKey("transfers:list", {
            page: parseInt(searchParams.get("page") || "1"),
            limit: parseInt(searchParams.get("limit") || "10"),
            status: searchParams.get("status") || undefined,
            sourceShopId: searchParams.get("sourceShopId") ? parseInt(searchParams.get("sourceShopId")) : undefined,
            destinationShopId: searchParams.get("destinationShopId") ? parseInt(searchParams.get("destinationShopId")) : undefined,
            search: searchParams.get("search") || undefined,
            startDate: searchParams.get("startDate") || undefined,
            endDate: searchParams.get("endDate") || undefined
        });
        // Try to get from cache first
        const cached = await _transferCache.transferCacheService.get(cacheKey);
        if (cached) {
            operation.end(true, undefined, true);
            return _server.NextResponse.json(cached);
        }
        // Use request deduplication for identical requests
        const result = await (0, _requestdeduplication.deduplicateRequest)(async ()=>{
            const transfers = await (0, _prisma.safeQuery)(async ()=>{
                // Build where clause for shop filtering
                let whereClause = {};
                // If user is not admin and has a specific shop, filter transfers
                if (!isAdmin && userShopId) {
                    whereClause = {
                        OR: [
                            {
                                fromShopId: userShopId
                            },
                            {
                                toShopId: userShopId
                            }
                        ]
                    };
                    console.log("Applying shop filter for shopId:", userShopId);
                } else {
                    console.log("No shop filtering applied - admin user or no shop assigned");
                }
                const result = await _prisma.prisma.inventoryTransfer.findMany({
                    where: whereClause,
                    select: {
                        id: true,
                        status: true,
                        createdAt: true,
                        updatedAt: true,
                        notes: true,
                        fromShop: {
                            select: {
                                id: true,
                                name: true
                            }
                        },
                        toShop: {
                            select: {
                                id: true,
                                name: true
                            }
                        },
                        fromUser: {
                            select: {
                                id: true,
                                name: true
                            }
                        },
                        transferItems: {
                            select: {
                                id: true,
                                quantity: true
                            }
                        }
                    },
                    orderBy: {
                        createdAt: "desc"
                    }
                });
                // Format the data to match the expected format from the SQL query
                return result.map((transfer)=>({
                        id: transfer.id,
                        status: transfer.status,
                        created_at: transfer.createdAt.toISOString(),
                        completed_at: null,
                        source_shop_name: transfer.fromShop.name,
                        destination_shop_name: transfer.toShop.name,
                        initiated_by: transfer.fromUser.name,
                        item_count: transfer.transferItems.length,
                        total_items: transfer.transferItems.reduce((sum, item)=>sum + item.quantity, 0)
                    }));
            }, defaultTransfersData, "Failed to fetch inventory transfers");
            return {
                success: true,
                data: transfers
            };
        }, cacheKey, "GET");
        // Cache the result
        await _transferCache.transferCacheService.set(cacheKey, result);
        console.log("Query executed successfully. Results:", result.data);
        console.log(`Retrieved ${result.data.length} transfers successfully`);
        operation.end(true, undefined, false);
        return _server.NextResponse.json(result);
    } catch (error) {
        console.error("Error fetching transfers:", error);
        operation.end(false, "fetch_error");
        return _server.NextResponse.json({
            success: false,
            message: "Error fetching transfers",
            error: error instanceof Error ? error.message : String(error)
        }, {
            status: 500
        });
    }
}
async function POST(req) {
    console.log("POST /api/inventory/transfers - Checking permission: inventory:transfer");
    // Check for inventory:transfer permission
    const permissionError = await (0, _middleware.requirePermission)("inventory:transfer")(req);
    if (permissionError) {
        console.error("Permission denied for inventory:transfer:", permissionError.status);
        return permissionError;
    }
    // Create operation with metadata first
    let operation;
    try {
        const body = await req.json();
        const { sourceShopId, destinationShopId, items } = body;
        const operationMetadata = {
            itemCount: items?.length || 0,
            shopCount: 2 // source + destination
        };
        operation = (0, _transferPerformanceMonitor.trackTransferOperation)("create", operationMetadata);
        // Get user ID from authorization token
        const authHeader = req.headers.get("authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
            operation.end(false, "unauthorized");
            return _server.NextResponse.json({
                success: false,
                message: "Authentication required"
            }, {
                status: 401
            });
        }
        const token = authHeader.split(" ")[1];
        const decodedToken = await (0, _auth.verifyToken)(token);
        if (!decodedToken || !decodedToken.sub) {
            operation.end(false, "unauthorized");
            return _server.NextResponse.json({
                success: false,
                message: "Invalid token: signature verification failed"
            }, {
                status: 401
            });
        }
        const userId = decodedToken.sub;
        console.log("Creating transfer for user ID:", userId);
        // Validate request data
        if (!sourceShopId || !destinationShopId || !items || !items.length) {
            operation.end(false, "validation_error");
            return _server.NextResponse.json({
                success: false,
                message: "Missing required fields"
            }, {
                status: 400
            });
        }
        const result = await (0, _prisma.safeQuery)(async ()=>{
            const newTransfer = await _prisma.prisma.$transaction(async (tx)=>{
                // 1. Reserve inventory in source shop
                for (const item of items){
                    const productIdNum = parseInt(item.productId);
                    const qtyNum = parseInt(item.quantity);
                    const inventory = await tx.inventoryItem.findFirst({
                        where: {
                            productId: productIdNum,
                            shopId: sourceShopId
                        }
                    });
                    if (!inventory || inventory.quantity < qtyNum) {
                        throw new Error(`Insufficient stock for product ${productIdNum} in source shop`);
                    }
                    await tx.inventoryItem.update({
                        where: {
                            id: inventory.id
                        },
                        data: {
                            quantity: {
                                decrement: qtyNum
                            }
                        }
                    });
                }
                // 2. Insert transfer & items
                return await tx.inventoryTransfer.create({
                    data: {
                        fromShopId: sourceShopId,
                        toShopId: destinationShopId,
                        fromUserId: userId,
                        toUserId: userId,
                        status: "pending",
                        transferItems: {
                            create: items.map((item)=>({
                                    productId: parseInt(item.productId),
                                    quantity: parseInt(item.quantity)
                                }))
                        }
                    }
                });
            }, {
                timeout: 30000
            });
            return newTransfer;
        }, null, "Failed to create inventory transfer");
        if (!result) {
            throw new Error("Failed to create transfer");
        }
        // Invalidate relevant caches
        await _transferCache.transferCacheService.invalidateTransferCache(result.id, [
            sourceShopId,
            destinationShopId
        ]);
        // Log audit trail for inventory transfer creation
        try {
            await _auditService.auditService.logAction({
                action: "CREATE",
                entityType: "inventorytransfer",
                entityId: result.id,
                userId: userId,
                details: {
                    fromShopId: sourceShopId,
                    toShopId: destinationShopId,
                    status: "pending",
                    itemCount: items.length,
                    items: items.map((item)=>({
                            productId: item.productId,
                            quantity: item.quantity
                        }))
                }
            });
        } catch (auditError) {
            console.error("Failed to log audit trail for inventory transfer creation:", auditError);
        }
        console.log("Transfer created successfully with ID:", result.id);
        operation.end(true);
        return _server.NextResponse.json({
            success: true,
            message: "Inventory transfer created successfully",
            data: {
                id: result.id
            }
        }, {
            status: 201
        });
    } catch (error) {
        console.error("Error creating transfer:", error);
        if (operation) {
            operation.end(false, "creation_error");
        }
        return _server.NextResponse.json({
            success: false,
            message: "Error creating transfer",
            error: error instanceof Error ? error.message : String(error)
        }, {
            status: 500
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vc3JjL2FwcC9hcGkvaW52ZW50b3J5L3RyYW5zZmVycy9yb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgcmVxdWlyZVBlcm1pc3Npb24gfSBmcm9tICdAL2xpYi91dGlscy9taWRkbGV3YXJlJztcbmltcG9ydCB7IHByaXNtYSwgc2FmZVF1ZXJ5IH0gZnJvbSAnQC9saWIvcHJpc21hJztcbmltcG9ydCB7IHZlcmlmeVRva2VuIH0gZnJvbSAnQC9saWIvYXV0aCc7XG5pbXBvcnQgeyBwZXJtaXNzaW9uU2VydmljZSB9IGZyb20gJ0AvbGliL3NlcnZpY2VzL1Blcm1pc3Npb25TZXJ2aWNlJztcbmltcG9ydCB7IHRyYW5zZmVyQ2FjaGVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvdHJhbnNmZXJDYWNoZSc7XG5pbXBvcnQgeyB0cmFja1RyYW5zZmVyT3BlcmF0aW9uIH0gZnJvbSAnQC9saWIvdHJhbnNmZXJQZXJmb3JtYW5jZU1vbml0b3InO1xuaW1wb3J0IHsgZGVkdXBsaWNhdGVSZXF1ZXN0IH0gZnJvbSAnQC9saWIvcmVxdWVzdC1kZWR1cGxpY2F0aW9uJztcbmltcG9ydCB7IGF1ZGl0U2VydmljZSB9IGZyb20gJ0Avc2VydmljZXMvYXVkaXRTZXJ2aWNlJztcblxuLy8gVHlwZSBkZWZpbml0aW9uIGZvciB0cmFuc2ZlciBpdGVtc1xuaW50ZXJmYWNlIFRyYW5zZmVySXRlbSB7XG4gICAgcHJvZHVjdElkOiBzdHJpbmc7XG4gICAgcXVhbnRpdHk6IHN0cmluZztcbn1cblxuLy8gRGVmYXVsdCBmYWxsYmFjayBkYXRhIGZvciB0cmFuc2ZlcnNcbmNvbnN0IGRlZmF1bHRUcmFuc2ZlcnNEYXRhID0gW1xuICAgIHsgaWQ6IDEsIHN0YXR1czogJ3BlbmRpbmcnLCBjcmVhdGVkX2F0OiAnMjAyNS0wNS0yMFQxMDowMDowMFonLCBjb21wbGV0ZWRfYXQ6IG51bGwsIHNvdXJjZV9zaG9wX25hbWU6ICdDb2xvbWJvIFNob3AnLCBkZXN0aW5hdGlvbl9zaG9wX25hbWU6ICdLYW5keSBTaG9wJywgaW5pdGlhdGVkX2J5OiAnU3lzdGVtIFVzZXInLCBpdGVtX2NvdW50OiA1LCB0b3RhbF9pdGVtczogMjUgfSxcbiAgICB7IGlkOiAyLCBzdGF0dXM6ICdjb21wbGV0ZWQnLCBjcmVhdGVkX2F0OiAnMjAyNS0wNS0xOVQwOTozMDowMFonLCBjb21wbGV0ZWRfYXQ6ICcyMDI1LTA1LTE5VDE2OjAwOjAwWicsIHNvdXJjZV9zaG9wX25hbWU6ICdHYWxsZSBTaG9wJywgZGVzdGluYXRpb25fc2hvcF9uYW1lOiAnQ29sb21ibyBTaG9wJywgaW5pdGlhdGVkX2J5OiAnU3lzdGVtIFVzZXInLCBpdGVtX2NvdW50OiAzLCB0b3RhbF9pdGVtczogMTUgfSxcbiAgICB7IGlkOiAzLCBzdGF0dXM6ICdjYW5jZWxsZWQnLCBjcmVhdGVkX2F0OiAnMjAyNS0wNS0xOFQxNDowMDowMFonLCBjb21wbGV0ZWRfYXQ6IG51bGwsIHNvdXJjZV9zaG9wX25hbWU6ICdLYW5keSBTaG9wJywgZGVzdGluYXRpb25fc2hvcF9uYW1lOiAnSmFmZm5hIFNob3AnLCBpbml0aWF0ZWRfYnk6ICdTeXN0ZW0gVXNlcicsIGl0ZW1fY291bnQ6IDIsIHRvdGFsX2l0ZW1zOiAxMCB9XG5dO1xuXG4vLyBHRVQ6IEZldGNoIGFsbCBpbnZlbnRvcnkgdHJhbnNmZXJzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcTogTmV4dFJlcXVlc3QpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0cmFja1RyYW5zZmVyT3BlcmF0aW9uKCdsaXN0Jyk7XG5cbiAgICBjb25zb2xlLmxvZygnR0VUIC9hcGkvaW52ZW50b3J5L3RyYW5zZmVycyAtIENoZWNraW5nIHBlcm1pc3Npb246IGludmVudG9yeTp0cmFuc2ZlcicpO1xuICAgIC8vIENoZWNrIGZvciBpbnZlbnRvcnk6dHJhbnNmZXIgcGVybWlzc2lvbiAoc2hvcCBzdGFmZiBzaG91bGQgaGF2ZSB0aGlzKVxuICAgIGNvbnN0IHBlcm1pc3Npb25FcnJvciA9IGF3YWl0IHJlcXVpcmVQZXJtaXNzaW9uKCdpbnZlbnRvcnk6dHJhbnNmZXInKShyZXEpO1xuICAgIGlmIChwZXJtaXNzaW9uRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUGVybWlzc2lvbiBkZW5pZWQgZm9yIGludmVudG9yeTp0cmFuc2ZlcjonLCBwZXJtaXNzaW9uRXJyb3Iuc3RhdHVzKTtcbiAgICAgICAgb3BlcmF0aW9uLmVuZChmYWxzZSwgJ3VuYXV0aG9yaXplZCcpO1xuICAgICAgICByZXR1cm4gcGVybWlzc2lvbkVycm9yO1xuICAgIH1cblxuICAgIC8vIEdldCB1c2VyIGNvbnRleHQgZm9yIHNob3AgZmlsdGVyaW5nXG4gICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcS5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpO1xuICAgIGlmICghYXV0aEhlYWRlciB8fCAhYXV0aEhlYWRlci5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgICAgb3BlcmF0aW9uLmVuZChmYWxzZSwgJ3VuYXV0aG9yaXplZCcpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQXV0aGVudGljYXRpb24gcmVxdWlyZWQnXG4gICAgICAgIH0sIHsgc3RhdHVzOiA0MDEgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW4gPSBhdXRoSGVhZGVyLnNwbGl0KCcgJylbMV07XG4gICAgY29uc3QgZGVjb2RlZFRva2VuID0gYXdhaXQgdmVyaWZ5VG9rZW4odG9rZW4pO1xuXG4gICAgaWYgKCFkZWNvZGVkVG9rZW4pIHtcbiAgICAgICAgb3BlcmF0aW9uLmVuZChmYWxzZSwgJ3VuYXV0aG9yaXplZCcpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCB0b2tlbidcbiAgICAgICAgfSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyU2hvcElkID0gZGVjb2RlZFRva2VuLnNob3BJZDtcbiAgICBjb25zdCB1c2VyUGVybWlzc2lvbnMgPSBBcnJheS5pc0FycmF5KGRlY29kZWRUb2tlbi5wZXJtaXNzaW9ucykgPyBkZWNvZGVkVG9rZW4ucGVybWlzc2lvbnMgOiBbXTtcbiAgICBjb25zdCBpc0FkbWluID0gcGVybWlzc2lvblNlcnZpY2UuaGFzUGVybWlzc2lvbih7IHBlcm1pc3Npb25zOiB1c2VyUGVybWlzc2lvbnMgfSwgJ2FkbWluOmFsbCcpIHx8IFxuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uU2VydmljZS5oYXNQZXJtaXNzaW9uKHsgcGVybWlzc2lvbnM6IHVzZXJQZXJtaXNzaW9ucyB9LCAnc2hvcDptYW5hZ2UnKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPT09ICdkZXYtdG9rZW4nO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdVc2VyIHNob3AgZmlsdGVyaW5nIC0gc2hvcElkOicsIHVzZXJTaG9wSWQsICdpc0FkbWluOicsIGlzQWRtaW4pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0V4ZWN1dGluZyBxdWVyeSB0byBmZXRjaCB0cmFuc2ZlcnMuLi4nKTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSBjYWNoZSBrZXkgYmFzZWQgb24gcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IHsgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKHJlcS51cmwpO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRyYW5zZmVyQ2FjaGVTZXJ2aWNlLmdlbmVyYXRlVHJhbnNmZXJDYWNoZUtleSgndHJhbnNmZXJzOmxpc3QnLCB7XG4gICAgICAgICAgICBwYWdlOiBwYXJzZUludChzZWFyY2hQYXJhbXMuZ2V0KCdwYWdlJykgfHwgJzEnKSxcbiAgICAgICAgICAgIGxpbWl0OiBwYXJzZUludChzZWFyY2hQYXJhbXMuZ2V0KCdsaW1pdCcpIHx8ICcxMCcpLFxuICAgICAgICAgICAgc3RhdHVzOiBzZWFyY2hQYXJhbXMuZ2V0KCdzdGF0dXMnKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBzb3VyY2VTaG9wSWQ6IHNlYXJjaFBhcmFtcy5nZXQoJ3NvdXJjZVNob3BJZCcpID8gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgnc291cmNlU2hvcElkJykhKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uU2hvcElkOiBzZWFyY2hQYXJhbXMuZ2V0KCdkZXN0aW5hdGlvblNob3BJZCcpID8gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgnZGVzdGluYXRpb25TaG9wSWQnKSEpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VhcmNoOiBzZWFyY2hQYXJhbXMuZ2V0KCdzZWFyY2gnKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGFydERhdGU6IHNlYXJjaFBhcmFtcy5nZXQoJ3N0YXJ0RGF0ZScpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVuZERhdGU6IHNlYXJjaFBhcmFtcy5nZXQoJ2VuZERhdGUnKSB8fCB1bmRlZmluZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVHJ5IHRvIGdldCBmcm9tIGNhY2hlIGZpcnN0XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IHRyYW5zZmVyQ2FjaGVTZXJ2aWNlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5lbmQodHJ1ZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihjYWNoZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHJlcXVlc3QgZGVkdXBsaWNhdGlvbiBmb3IgaWRlbnRpY2FsIHJlcXVlc3RzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlZHVwbGljYXRlUmVxdWVzdChcbiAgICAgICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlcnMgPSBhd2FpdCBzYWZlUXVlcnkoXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHdoZXJlIGNsYXVzZSBmb3Igc2hvcCBmaWx0ZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aGVyZUNsYXVzZTogYW55ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHVzZXIgaXMgbm90IGFkbWluIGFuZCBoYXMgYSBzcGVjaWZpYyBzaG9wLCBmaWx0ZXIgdHJhbnNmZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQWRtaW4gJiYgdXNlclNob3BJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlQ2xhdXNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPUjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBmcm9tU2hvcElkOiB1c2VyU2hvcElkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHRvU2hvcElkOiB1c2VyU2hvcElkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FwcGx5aW5nIHNob3AgZmlsdGVyIGZvciBzaG9wSWQ6JywgdXNlclNob3BJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBzaG9wIGZpbHRlcmluZyBhcHBsaWVkIC0gYWRtaW4gdXNlciBvciBubyBzaG9wIGFzc2lnbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlUcmFuc2Zlci5maW5kTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHdoZXJlQ2xhdXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21TaG9wOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU2hvcDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tVXNlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zlckl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlckJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogJ2Rlc2MnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCB0aGUgZGF0YSB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgZm9ybWF0IGZyb20gdGhlIFNRTCBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAodHJhbnNmZXIgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdHJhbnNmZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB0cmFuc2Zlci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogdHJhbnNmZXIuY3JlYXRlZEF0LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkX2F0OiBudWxsLCAvLyBUaGlzIGZpZWxkIGRvZXNuJ3QgZXhpc3QgaW4gUHJpc21hIHNjaGVtYSwgY291bGQgYmUgYWRkZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Vfc2hvcF9uYW1lOiB0cmFuc2Zlci5mcm9tU2hvcC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uX3Nob3BfbmFtZTogdHJhbnNmZXIudG9TaG9wLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhdGVkX2J5OiB0cmFuc2Zlci5mcm9tVXNlci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1fY291bnQ6IHRyYW5zZmVyLnRyYW5zZmVySXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX2l0ZW1zOiB0cmFuc2Zlci50cmFuc2Zlckl0ZW1zLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiBzdW0gKyBpdGVtLnF1YW50aXR5LCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VHJhbnNmZXJzRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBmZXRjaCBpbnZlbnRvcnkgdHJhbnNmZXJzJ1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0cmFuc2ZlcnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgJ0dFVCdcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0XG4gICAgICAgIGF3YWl0IHRyYW5zZmVyQ2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgcmVzdWx0KTtcblxuICAgICAgICBjb25zb2xlLmxvZygnUXVlcnkgZXhlY3V0ZWQgc3VjY2Vzc2Z1bGx5LiBSZXN1bHRzOicsIHJlc3VsdC5kYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2coYFJldHJpZXZlZCAke3Jlc3VsdC5kYXRhLmxlbmd0aH0gdHJhbnNmZXJzIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgICBvcGVyYXRpb24uZW5kKHRydWUsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0cmFuc2ZlcnM6JywgZXJyb3IpO1xuICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAnZmV0Y2hfZXJyb3InKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0Vycm9yIGZldGNoaW5nIHRyYW5zZmVycycsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgfVxufVxuXG4vLyBQT1NUOiBDcmVhdGUgYSBuZXcgaW52ZW50b3J5IHRyYW5zZmVyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXE6IE5leHRSZXF1ZXN0KSB7XG4gICAgY29uc29sZS5sb2coJ1BPU1QgL2FwaS9pbnZlbnRvcnkvdHJhbnNmZXJzIC0gQ2hlY2tpbmcgcGVybWlzc2lvbjogaW52ZW50b3J5OnRyYW5zZmVyJyk7XG4gICAgLy8gQ2hlY2sgZm9yIGludmVudG9yeTp0cmFuc2ZlciBwZXJtaXNzaW9uXG4gICAgY29uc3QgcGVybWlzc2lvbkVycm9yID0gYXdhaXQgcmVxdWlyZVBlcm1pc3Npb24oJ2ludmVudG9yeTp0cmFuc2ZlcicpKHJlcSk7XG4gICAgaWYgKHBlcm1pc3Npb25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdQZXJtaXNzaW9uIGRlbmllZCBmb3IgaW52ZW50b3J5OnRyYW5zZmVyOicsIHBlcm1pc3Npb25FcnJvci5zdGF0dXMpO1xuICAgICAgICByZXR1cm4gcGVybWlzc2lvbkVycm9yO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBvcGVyYXRpb24gd2l0aCBtZXRhZGF0YSBmaXJzdFxuICAgIGxldCBvcGVyYXRpb246IGFueTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxLmpzb24oKTtcbiAgICAgICAgY29uc3QgeyBzb3VyY2VTaG9wSWQsIGRlc3RpbmF0aW9uU2hvcElkLCBpdGVtcyB9ID0gYm9keTtcblxuICAgICAgICBjb25zdCBvcGVyYXRpb25NZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIGl0ZW1Db3VudDogaXRlbXM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgc2hvcENvdW50OiAyIC8vIHNvdXJjZSArIGRlc3RpbmF0aW9uXG4gICAgICAgIH07XG4gICAgICAgIG9wZXJhdGlvbiA9IHRyYWNrVHJhbnNmZXJPcGVyYXRpb24oJ2NyZWF0ZScsIG9wZXJhdGlvbk1ldGFkYXRhKTtcblxuICAgICAgICAvLyBHZXQgdXNlciBJRCBmcm9tIGF1dGhvcml6YXRpb24gdG9rZW5cbiAgICAgICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcS5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpO1xuICAgICAgICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAndW5hdXRob3JpemVkJyk7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCdcbiAgICAgICAgICAgIH0sIHsgc3RhdHVzOiA0MDEgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IGF1dGhIZWFkZXIuc3BsaXQoJyAnKVsxXTtcbiAgICAgICAgY29uc3QgZGVjb2RlZFRva2VuID0gYXdhaXQgdmVyaWZ5VG9rZW4odG9rZW4pO1xuXG4gICAgICAgIGlmICghZGVjb2RlZFRva2VuIHx8ICFkZWNvZGVkVG9rZW4uc3ViKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAndW5hdXRob3JpemVkJyk7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHRva2VuOiBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCdcbiAgICAgICAgICAgIH0sIHsgc3RhdHVzOiA0MDEgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1c2VySWQgPSBkZWNvZGVkVG9rZW4uc3ViO1xuICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgdHJhbnNmZXIgZm9yIHVzZXIgSUQ6JywgdXNlcklkKTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSByZXF1ZXN0IGRhdGFcbiAgICAgICAgaWYgKCFzb3VyY2VTaG9wSWQgfHwgIWRlc3RpbmF0aW9uU2hvcElkIHx8ICFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAndmFsaWRhdGlvbl9lcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTWlzc2luZyByZXF1aXJlZCBmaWVsZHMnXG4gICAgICAgICAgICB9LCB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KFxuICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyYW5zZmVyID0gYXdhaXQgcHJpc21hLiR0cmFuc2FjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMgKHR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxLiBSZXNlcnZlIGludmVudG9yeSBpbiBzb3VyY2Ugc2hvcFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZHVjdElkTnVtID0gcGFyc2VJbnQoaXRlbS5wcm9kdWN0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF0eU51bSA9IHBhcnNlSW50KGl0ZW0ucXVhbnRpdHkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW52ZW50b3J5ID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RJZE51bSwgc2hvcElkOiBzb3VyY2VTaG9wSWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnZlbnRvcnkgfHwgaW52ZW50b3J5LnF1YW50aXR5IDwgcXR5TnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IHN0b2NrIGZvciBwcm9kdWN0ICR7cHJvZHVjdElkTnVtfSBpbiBzb3VyY2Ugc2hvcGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0udXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGludmVudG9yeS5pZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHF1YW50aXR5OiB7IGRlY3JlbWVudDogcXR5TnVtIH0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBJbnNlcnQgdHJhbnNmZXIgJiBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHR4LmludmVudG9yeVRyYW5zZmVyLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tU2hvcElkOiBzb3VyY2VTaG9wSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU2hvcElkOiBkZXN0aW5hdGlvblNob3BJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVVzZXJJZDogdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1VzZXJJZDogdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJJdGVtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiBpdGVtcy5tYXAoKGl0ZW06IFRyYW5zZmVySXRlbSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHBhcnNlSW50KGl0ZW0ucHJvZHVjdElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcGFyc2VJbnQoaXRlbS5xdWFudGl0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdGltZW91dDogMzAwMDAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VHJhbnNmZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIGludmVudG9yeSB0cmFuc2ZlcidcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHRyYW5zZmVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZhbGlkYXRlIHJlbGV2YW50IGNhY2hlc1xuICAgICAgICBhd2FpdCB0cmFuc2ZlckNhY2hlU2VydmljZS5pbnZhbGlkYXRlVHJhbnNmZXJDYWNoZShyZXN1bHQuaWQsIFtzb3VyY2VTaG9wSWQsIGRlc3RpbmF0aW9uU2hvcElkXSk7XG5cbiAgICAgICAgLy8gTG9nIGF1ZGl0IHRyYWlsIGZvciBpbnZlbnRvcnkgdHJhbnNmZXIgY3JlYXRpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGF1ZGl0U2VydmljZS5sb2dBY3Rpb24oe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ0NSRUFURScsXG4gICAgICAgICAgICAgICAgZW50aXR5VHlwZTogJ2ludmVudG9yeXRyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICBlbnRpdHlJZDogcmVzdWx0LmlkLFxuICAgICAgICAgICAgICAgIHVzZXJJZDogdXNlcklkLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVNob3BJZDogc291cmNlU2hvcElkLFxuICAgICAgICAgICAgICAgICAgICB0b1Nob3BJZDogZGVzdGluYXRpb25TaG9wSWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgICAgICAgICBpdGVtQ291bnQ6IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zLm1hcCgoaXRlbTogVHJhbnNmZXJJdGVtKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5XG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChhdWRpdEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9nIGF1ZGl0IHRyYWlsIGZvciBpbnZlbnRvcnkgdHJhbnNmZXIgY3JlYXRpb246JywgYXVkaXRFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNmZXIgY3JlYXRlZCBzdWNjZXNzZnVsbHkgd2l0aCBJRDonLCByZXN1bHQuaWQpO1xuICAgICAgICBvcGVyYXRpb24uZW5kKHRydWUpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZlbnRvcnkgdHJhbnNmZXIgY3JlYXRlZCBzdWNjZXNzZnVsbHknLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlkOiByZXN1bHQuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBzdGF0dXM6IDIwMSB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB0cmFuc2ZlcjonLCBlcnJvcik7XG4gICAgICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICdjcmVhdGlvbl9lcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdFcnJvciBjcmVhdGluZyB0cmFuc2ZlcicsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgfVxufSJdLCJuYW1lcyI6WyJHRVQiLCJQT1NUIiwiZGVmYXVsdFRyYW5zZmVyc0RhdGEiLCJpZCIsInN0YXR1cyIsImNyZWF0ZWRfYXQiLCJjb21wbGV0ZWRfYXQiLCJzb3VyY2Vfc2hvcF9uYW1lIiwiZGVzdGluYXRpb25fc2hvcF9uYW1lIiwiaW5pdGlhdGVkX2J5IiwiaXRlbV9jb3VudCIsInRvdGFsX2l0ZW1zIiwicmVxIiwib3BlcmF0aW9uIiwidHJhY2tUcmFuc2Zlck9wZXJhdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJwZXJtaXNzaW9uRXJyb3IiLCJyZXF1aXJlUGVybWlzc2lvbiIsImVycm9yIiwiZW5kIiwiYXV0aEhlYWRlciIsImhlYWRlcnMiLCJnZXQiLCJzdGFydHNXaXRoIiwiTmV4dFJlc3BvbnNlIiwianNvbiIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwidG9rZW4iLCJzcGxpdCIsImRlY29kZWRUb2tlbiIsInZlcmlmeVRva2VuIiwidXNlclNob3BJZCIsInNob3BJZCIsInVzZXJQZXJtaXNzaW9ucyIsIkFycmF5IiwiaXNBcnJheSIsInBlcm1pc3Npb25zIiwiaXNBZG1pbiIsInBlcm1pc3Npb25TZXJ2aWNlIiwiaGFzUGVybWlzc2lvbiIsInNlYXJjaFBhcmFtcyIsIlVSTCIsInVybCIsImNhY2hlS2V5IiwidHJhbnNmZXJDYWNoZVNlcnZpY2UiLCJnZW5lcmF0ZVRyYW5zZmVyQ2FjaGVLZXkiLCJwYWdlIiwicGFyc2VJbnQiLCJsaW1pdCIsInVuZGVmaW5lZCIsInNvdXJjZVNob3BJZCIsImRlc3RpbmF0aW9uU2hvcElkIiwic2VhcmNoIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImNhY2hlZCIsInJlc3VsdCIsImRlZHVwbGljYXRlUmVxdWVzdCIsInRyYW5zZmVycyIsInNhZmVRdWVyeSIsIndoZXJlQ2xhdXNlIiwiT1IiLCJmcm9tU2hvcElkIiwidG9TaG9wSWQiLCJwcmlzbWEiLCJpbnZlbnRvcnlUcmFuc2ZlciIsImZpbmRNYW55Iiwid2hlcmUiLCJzZWxlY3QiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJub3RlcyIsImZyb21TaG9wIiwibmFtZSIsInRvU2hvcCIsImZyb21Vc2VyIiwidHJhbnNmZXJJdGVtcyIsInF1YW50aXR5Iiwib3JkZXJCeSIsIm1hcCIsInRyYW5zZmVyIiwidG9JU09TdHJpbmciLCJsZW5ndGgiLCJyZWR1Y2UiLCJzdW0iLCJpdGVtIiwiZGF0YSIsInNldCIsIkVycm9yIiwiU3RyaW5nIiwiYm9keSIsIml0ZW1zIiwib3BlcmF0aW9uTWV0YWRhdGEiLCJpdGVtQ291bnQiLCJzaG9wQ291bnQiLCJzdWIiLCJ1c2VySWQiLCJuZXdUcmFuc2ZlciIsIiR0cmFuc2FjdGlvbiIsInR4IiwicHJvZHVjdElkTnVtIiwicHJvZHVjdElkIiwicXR5TnVtIiwiaW52ZW50b3J5IiwiaW52ZW50b3J5SXRlbSIsImZpbmRGaXJzdCIsInVwZGF0ZSIsImRlY3JlbWVudCIsImNyZWF0ZSIsImZyb21Vc2VySWQiLCJ0b1VzZXJJZCIsInRpbWVvdXQiLCJpbnZhbGlkYXRlVHJhbnNmZXJDYWNoZSIsImF1ZGl0U2VydmljZSIsImxvZ0FjdGlvbiIsImFjdGlvbiIsImVudGl0eVR5cGUiLCJlbnRpdHlJZCIsImRldGFpbHMiLCJhdWRpdEVycm9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztJQXdCc0JBLEdBQUc7ZUFBSEE7O0lBd0tBQyxJQUFJO2VBQUpBOzs7d0JBaE1vQjs0QkFDUjt3QkFDQTtzQkFDTjttQ0FDTTsrQkFDRzs0Q0FDRTtzQ0FDSjs4QkFDTjtBQVE3QixzQ0FBc0M7QUFDdEMsTUFBTUMsdUJBQXVCO0lBQ3pCO1FBQUVDLElBQUk7UUFBR0MsUUFBUTtRQUFXQyxZQUFZO1FBQXdCQyxjQUFjO1FBQU1DLGtCQUFrQjtRQUFnQkMsdUJBQXVCO1FBQWNDLGNBQWM7UUFBZUMsWUFBWTtRQUFHQyxhQUFhO0lBQUc7SUFDdk47UUFBRVIsSUFBSTtRQUFHQyxRQUFRO1FBQWFDLFlBQVk7UUFBd0JDLGNBQWM7UUFBd0JDLGtC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