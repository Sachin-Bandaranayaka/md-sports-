4959d76bfc98e3619c122ceff3441727
// Fixed Unit tests for AuthService
// This file tests the authentication service functionality
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _authService = require("../../src/services/authService");
// Mock dependencies BEFORE importing the service
const mockCacheService = {
    get: _globals.jest.fn(),
    set: _globals.jest.fn(),
    delete: _globals.jest.fn(),
    increment: _globals.jest.fn(),
    generateKey: _globals.jest.fn(),
    clear: _globals.jest.fn()
};
const mockPrisma = {
    user: {
        findUnique: _globals.jest.fn(),
        findFirst: _globals.jest.fn(),
        create: _globals.jest.fn(),
        update: _globals.jest.fn(),
        findMany: _globals.jest.fn(),
        delete: _globals.jest.fn()
    },
    permission: {
        findMany: _globals.jest.fn()
    },
    session: {
        create: _globals.jest.fn(),
        findUnique: _globals.jest.fn(),
        update: _globals.jest.fn(),
        deleteMany: _globals.jest.fn()
    },
    auditLog: {
        create: _globals.jest.fn()
    }
};
const mockBcrypt = {
    compare: _globals.jest.fn(),
    hash: _globals.jest.fn(),
    genSalt: _globals.jest.fn()
};
// Mock modules
_globals.jest.mock("@/lib/prisma", ()=>({
        __esModule: true,
        default: mockPrisma
    }));
_globals.jest.mock("@/lib/cache", ()=>({
        cacheService: mockCacheService,
        CACHE_CONFIG: {
            KEYS: {
                USER_SESSION: "user_session",
                TOKEN_VALIDATION: "token_validation"
            },
            TTL: {
                USER_SESSION: 3600,
                TOKEN_VALIDATION: 1800
            }
        }
    }));
_globals.jest.mock("bcryptjs", ()=>mockBcrypt);
_globals.jest.mock("jsonwebtoken", ()=>({
        __esModule: true,
        default: {
            sign: _globals.jest.fn(),
            verify: _globals.jest.fn(),
            TokenExpiredError: class TokenExpiredError extends Error {
                constructor(message, expiredAt){
                    super(message);
                    this.name = "TokenExpiredError";
                    this.expiredAt = expiredAt;
                }
            },
            JsonWebTokenError: class JsonWebTokenError extends Error {
                constructor(message){
                    super(message);
                    this.name = "JsonWebTokenError";
                }
            }
        }
    }));
// Create proper mock types for easier access
const mockUserFindFirst = mockPrisma.user.findFirst;
const mockPermissionFindMany = mockPrisma.permission.findMany;
const mockJwt = require("jsonwebtoken").default;
describe("AuthService", ()=>{
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        process.env.JWT_SECRET = "test-secret-key";
        process.env.JWT_ACCESS_TOKEN_EXPIRES_IN = "12h";
        // Setup default cache mocks
        mockCacheService.generateKey.mockReturnValue("mock-cache-key");
        mockCacheService.get.mockResolvedValue(null);
        mockCacheService.set.mockResolvedValue(true);
        mockCacheService.delete.mockResolvedValue(true);
        // Reset Prisma mocks
        mockUserFindFirst.mockResolvedValue(null);
        mockPermissionFindMany.mockResolvedValue([]);
        // Reset JWT mocks
        mockJwt.sign.mockReturnValue("mocked-jwt-token");
        mockJwt.verify.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
        mockJwt.decode.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
    });
    describe("parseTimeStringToSeconds", ()=>{
        test("should parse seconds correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("30s")).toBe(30);
        });
        test("should parse minutes correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("5m")).toBe(300);
        });
        test("should parse hours correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("2h")).toBe(7200);
        });
        test("should parse days correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("1d")).toBe(86400);
        });
        test("should return 0 for invalid input", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("invalid")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("abc")).toBe(0);
        });
        test("should handle edge cases", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("0s")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("100x")).toBe(100); // Falls back to parsing the number part
        });
    });
    describe("authenticateUser", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            password: "hashedpassword",
            isActive: true,
            roleId: 1,
            shopId: 1,
            roleName: "admin",
            permissions: null,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should authenticate valid user credentials", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(true);
            mockJwt.sign.mockReturnValue("mock-jwt-token");
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(true);
            expect(result.token).toBe("mock-jwt-token");
            expect(result.user).toEqual({
                id: 1,
                email: "test@example.com",
                username: "testuser",
                fullName: "testuser",
                roleId: 1,
                roleName: "admin",
                shopId: 1,
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockUserFindFirst).toHaveBeenCalledWith({
                where: {
                    email: "test@example.com",
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            });
        });
        test("should reject invalid email", async ()=>{
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.authenticateUser)("invalid@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject invalid password", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(false);
            const result = await (0, _authService.authenticateUser)("test@example.com", "wrongpassword");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject inactive user", async ()=>{
            mockUserFindFirst.mockResolvedValue(null); // findFirst with isActive: true returns null
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should handle database errors gracefully", async ()=>{
            mockUserFindFirst.mockRejectedValue(new Error("Database connection failed"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
        test("should handle bcrypt errors gracefully", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockRejectedValue(new Error("Bcrypt error"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
    });
    describe("generateToken", ()=>{
        const mockPayload = {
            sub: "1",
            username: "testuser",
            email: "test@example.com",
            roleId: 1,
            shopId: 1,
            permissions: [
                "read_products",
                "write_products"
            ]
        };
        test("should generate JWT token", ()=>{
            const mockToken = "mock-jwt-token";
            mockJwt.sign.mockReturnValue(mockToken);
            const result = (0, _authService.generateToken)(mockPayload);
            expect(result).toBe(mockToken);
            expect(mockJwt.sign).toHaveBeenCalledWith(mockPayload, "test-secret-key", {
                expiresIn: "12h"
            });
        });
    });
    describe("verifyToken", ()=>{
        test("should verify valid token from cache", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should verify valid token and cache result", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockJwt.verify.mockReturnValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockJwt.verify).toHaveBeenCalledWith("valid-token", "test-secret-key");
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("Invalid token");
            });
            await expect((0, _authService.verifyToken)("invalid-token")).rejects.toThrow("Invalid token");
        });
        test("should throw error for expired token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                const error = new Error("Token expired");
                error.name = "TokenExpiredError";
                error.expiredAt = new Date();
                throw error;
            });
            await expect((0, _authService.verifyToken)("expired-token")).rejects.toThrow("Token expired");
        });
    });
    describe("getUserFromDecodedPayload", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            isActive: true,
            roleId: 1,
            shopId: 1,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should return user from cache", async ()=>{
            const payload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const cachedUser = {
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            };
            mockCacheService.get.mockResolvedValue(cachedUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual(cachedUser);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should return user from database and cache it", async ()=>{
            const payload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockUserFindFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should return null for null payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)(null);
            expect(result).toBeNull();
        });
        test("should return null for invalid payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)({});
            expect(result).toBeNull();
        });
        test("should return null when user not found", async ()=>{
            const payload = {
                sub: "999",
                username: "nonexistent",
                email: "nonexistent@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null);
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toBeNull();
        });
    });
    describe("getUserFromToken", ()=>{
        test("should return user from valid token", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const mockUser = {
                id: 1,
                email: "test@example.com",
                name: "testuser",
                isActive: true,
                roleId: 1,
                shopId: 1,
                role: {
                    id: 1,
                    name: "admin",
                    permissions: [
                        {
                            name: "read_products"
                        }
                    ]
                }
            };
            // Mock verifyToken to return payload
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>mockPayload);
            // Mock getUserFromDecodedPayload
            mockUserFindFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromToken)("valid-token");
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products"
                ]
            });
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockCacheService.generateKey.mockReturnValue("test-cache-key");
            const jwt = require("jsonwebtoken");
            // Mock jwt.verify to throw JsonWebTokenError
            mockJwt.verify.mockImplementation(()=>{
                const error = new Error("jwt malformed");
                error.name = "JsonWebTokenError";
                throw error;
            });
            await expect((0, _authService.getUserFromToken)("invalid")).rejects.toThrow("jwt malformed");
        });
    });
    describe("Error Handling", ()=>{
        test("should handle missing JWT_SECRET", async ()=>{
            const originalSecret = process.env.JWT_SECRET;
            delete process.env.JWT_SECRET;
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("secretOrPrivateKey must have a value");
            });
            await expect((0, _authService.verifyToken)("any-token")).rejects.toThrow();
            // Restore the secret
            process.env.JWT_SECRET = originalSecret;
        });
        test("should handle malformed tokens gracefully", async ()=>{
            // Use a shorter token to avoid cache key generation
            mockCacheService.get.mockResolvedValue(null);
            // Clear any previous mocks and set up fresh mock
            mockJwt.verify.mockClear();
            mockJwt.verify.mockImplementation((token, secret)=>{
                console.log("jwt.verify mock called with token:", token, "secret:", secret);
                const error = new Error("jwt malformed");
                error.name = "JsonWebTokenError";
                throw error;
            });
            console.log("Mock implementation set, calling verifyToken...");
            await expect((0, _authService.verifyToken)("short")).rejects.toThrow("jwt malformed");
        });
        test("should handle empty token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            await expect((0, _authService.verifyToken)("")).rejects.toThrow("jwt must be provided");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9hdXRoU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpeGVkIFVuaXQgdGVzdHMgZm9yIEF1dGhTZXJ2aWNlXG4vLyBUaGlzIGZpbGUgdGVzdHMgdGhlIGF1dGhlbnRpY2F0aW9uIHNlcnZpY2UgZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzIEJFRk9SRSBpbXBvcnRpbmcgdGhlIHNlcnZpY2VcbmNvbnN0IG1vY2tDYWNoZVNlcnZpY2UgPSB7XG4gIGdldDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgc2V0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBkZWxldGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGluY3JlbWVudDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgZ2VuZXJhdGVLZXk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGNsZWFyOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxufTtcblxuY29uc3QgbW9ja1ByaXNtYSA9IHtcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZEZpcnN0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICAgIGNyZWF0ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICB9LFxuICBwZXJtaXNzaW9uOiB7XG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG4gIHNlc3Npb246IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlTWFueTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgfSxcbiAgYXVkaXRMb2c6IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG59O1xuXG5jb25zdCBtb2NrQmNyeXB0ID0ge1xuICBjb21wYXJlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBoYXNoOiBqZXN0LmZuKCksXG4gIGdlblNhbHQ6IGplc3QuZm4oKSxcbn07XG5cbi8vIE1vY2sgbW9kdWxlc1xuamVzdC5tb2NrKCdAL2xpYi9wcmlzbWEnLCAoKSA9PiAoe1xuICBfX2VzTW9kdWxlOiB0cnVlLFxuICBkZWZhdWx0OiBtb2NrUHJpc21hLFxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvbGliL2NhY2hlJywgKCkgPT4gKHtcbiAgY2FjaGVTZXJ2aWNlOiBtb2NrQ2FjaGVTZXJ2aWNlLFxuICBDQUNIRV9DT05GSUc6IHtcbiAgICBLRVlTOiB7XG4gICAgICBVU0VSX1NFU1NJT046ICd1c2VyX3Nlc3Npb24nLFxuICAgICAgVE9LRU5fVkFMSURBVElPTjogJ3Rva2VuX3ZhbGlkYXRpb24nLFxuICAgIH0sXG4gICAgVFRMOiB7XG4gICAgICBVU0VSX1NFU1NJT046IDM2MDAsXG4gICAgICBUT0tFTl9WQUxJREFUSU9OOiAxODAwLFxuICAgIH0sXG4gIH0sXG59KSk7XG5cbmplc3QubW9jaygnYmNyeXB0anMnLCAoKSA9PiBtb2NrQmNyeXB0KTtcbmplc3QubW9jaygnanNvbndlYnRva2VuJywgKCkgPT4gKHtcbiAgX19lc01vZHVsZTogdHJ1ZSxcbiAgZGVmYXVsdDoge1xuICAgIHNpZ246IGplc3QuZm4oKSxcbiAgICB2ZXJpZnk6IGplc3QuZm4oKSxcbiAgICBUb2tlbkV4cGlyZWRFcnJvcjogY2xhc3MgVG9rZW5FeHBpcmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGV4cGlyZWRBdDogRGF0ZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuRXhwaXJlZEVycm9yJztcbiAgICAgICAgdGhpcy5leHBpcmVkQXQgPSBleHBpcmVkQXQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBKc29uV2ViVG9rZW5FcnJvcjogY2xhc3MgSnNvbldlYlRva2VuRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdKc29uV2ViVG9rZW5FcnJvcic7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn0pKTtcblxuLy8gSW1wb3J0IGFmdGVyIG1vY2tpbmdcbmltcG9ydCB7IGF1dGhlbnRpY2F0ZVVzZXIsIGdlbmVyYXRlVG9rZW4sIHZlcmlmeVRva2VuLCBwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMsIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQsIGdldFVzZXJGcm9tVG9rZW4gfSBmcm9tICdAL3NlcnZpY2VzL2F1dGhTZXJ2aWNlJztcblxuLy8gQ3JlYXRlIHByb3BlciBtb2NrIHR5cGVzIGZvciBlYXNpZXIgYWNjZXNzXG5jb25zdCBtb2NrVXNlckZpbmRGaXJzdCA9IG1vY2tQcmlzbWEudXNlci5maW5kRmlyc3QgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuY29uc3QgbW9ja1Blcm1pc3Npb25GaW5kTWFueSA9IG1vY2tQcmlzbWEucGVybWlzc2lvbi5maW5kTWFueSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG5jb25zdCBtb2NrSnd0ID0gcmVxdWlyZSgnanNvbndlYnRva2VuJykuZGVmYXVsdCBhcyBhbnk7XG5cbmRlc2NyaWJlKCdBdXRoU2VydmljZScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCA9ICd0ZXN0LXNlY3JldC1rZXknO1xuICAgIHByb2Nlc3MuZW52LkpXVF9BQ0NFU1NfVE9LRU5fRVhQSVJFU19JTiA9ICcxMmgnO1xuICAgIFxuICAgIC8vIFNldHVwIGRlZmF1bHQgY2FjaGUgbW9ja3NcbiAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5Lm1vY2tSZXR1cm5WYWx1ZSgnbW9jay1jYWNoZS1rZXknKTtcbiAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICBtb2NrQ2FjaGVTZXJ2aWNlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgICBtb2NrQ2FjaGVTZXJ2aWNlLmRlbGV0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgICBcbiAgICAvLyBSZXNldCBQcmlzbWEgbW9ja3NcbiAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICBtb2NrUGVybWlzc2lvbkZpbmRNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcbiAgICBcbiAgICAvLyBSZXNldCBKV1QgbW9ja3NcbiAgICBtb2NrSnd0LnNpZ24ubW9ja1JldHVyblZhbHVlKCdtb2NrZWQtand0LXRva2VuJyk7XG4gICAgbW9ja0p3dC52ZXJpZnkubW9ja1JldHVyblZhbHVlKHsgdXNlcklkOiAxLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0pO1xuICAgIG1vY2tKd3QuZGVjb2RlLm1vY2tSZXR1cm5WYWx1ZSh7IHVzZXJJZDogMSwgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3BhcnNlVGltZVN0cmluZ1RvU2Vjb25kcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcGFyc2Ugc2Vjb25kcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCczMHMnKSkudG9CZSgzMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgbWludXRlcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCc1bScpKS50b0JlKDMwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgaG91cnMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMmgnKSkudG9CZSg3MjAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwYXJzZSBkYXlzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzFkJykpLnRvQmUoODY0MDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiAwIGZvciBpbnZhbGlkIGlucHV0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnJykpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCdpbnZhbGlkJykpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCdhYmMnKSkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZWRnZSBjYXNlcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzBzJykpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcxMDB4JykpLnRvQmUoMTAwKTsgLy8gRmFsbHMgYmFjayB0byBwYXJzaW5nIHRoZSBudW1iZXIgcGFydFxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnYXV0aGVudGljYXRlVXNlcicsICgpID0+IHtcbiAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgIGlkOiAxLFxuICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIG5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBwYXNzd29yZDogJ2hhc2hlZHBhc3N3b3JkJyxcbiAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgcm9sZUlkOiAxLFxuICAgICAgc2hvcElkOiAxLFxuICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICBwZXJtaXNzaW9uczogbnVsbCxcbiAgICAgIHJvbGU6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbXG4gICAgICAgICAgeyBuYW1lOiAncmVhZF9wcm9kdWN0cycgfSxcbiAgICAgICAgICB7IG5hbWU6ICd3cml0ZV9wcm9kdWN0cycgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhdXRoZW50aWNhdGUgdmFsaWQgdXNlciBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIG1vY2tCY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlIGFzIGFueSk7XG4gICAgICBtb2NrSnd0LnNpZ24ubW9ja1JldHVyblZhbHVlKCdtb2NrLWp3dC10b2tlbicgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnRva2VuKS50b0JlKCdtb2NrLWp3dC10b2tlbicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC51c2VyKS50b0VxdWFsKHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBmdWxsTmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgcm9sZUlkOiAxLFxuICAgICAgICByb2xlTmFtZTogJ2FkbWluJyxcbiAgICAgICAgc2hvcElkOiAxLFxuICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJywgJ3dyaXRlX3Byb2R1Y3RzJ11cbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KG1vY2tVc2VyRmluZEZpcnN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgcm9sZToge1xuICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICBwZXJtaXNzaW9uczoge1xuICAgICAgICAgICAgICAgIHNlbGVjdDogeyBuYW1lOiB0cnVlIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgZW1haWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcignaW52YWxpZEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgcGFzc3dvcmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgICBtb2NrQmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUoZmFsc2UgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICd3cm9uZ3Bhc3N3b3JkJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgaW5hY3RpdmUgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBmaW5kRmlyc3Qgd2l0aCBpc0FjdGl2ZTogdHJ1ZSByZXR1cm5zIG51bGxcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdBdXRoZW50aWNhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgYmNyeXB0IGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuICAgICAgbW9ja0JjcnlwdC5jb21wYXJlLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQmNyeXB0IGVycm9yJykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2VuZXJhdGVUb2tlbicsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUGF5bG9hZCA9IHtcbiAgICAgIHN1YjogJzEnLFxuICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgcm9sZUlkOiAxLFxuICAgICAgc2hvcElkOiAxLFxuICAgICAgcGVybWlzc2lvbnM6IFsncmVhZF9wcm9kdWN0cycsICd3cml0ZV9wcm9kdWN0cyddXG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSBKV1QgdG9rZW4nLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVG9rZW4gPSAnbW9jay1qd3QtdG9rZW4nO1xuICAgICAgbW9ja0p3dC5zaWduLm1vY2tSZXR1cm5WYWx1ZShtb2NrVG9rZW4pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBnZW5lcmF0ZVRva2VuKG1vY2tQYXlsb2FkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShtb2NrVG9rZW4pO1xuICAgICAgZXhwZWN0KG1vY2tKd3Quc2lnbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgbW9ja1BheWxvYWQsXG4gICAgICAgICAgJ3Rlc3Qtc2VjcmV0LWtleScsXG4gICAgICAgICAgeyBleHBpcmVzSW46ICcxMmgnIH1cbiAgICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3ZlcmlmeVRva2VuJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB2ZXJpZnkgdmFsaWQgdG9rZW4gZnJvbSBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgICBzdWI6ICcxJyxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgaWF0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDM2MDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQYXlsb2FkKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJ3ZhbGlkLXRva2VuJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1BheWxvYWQpO1xuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2UuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdmVyaWZ5IHZhbGlkIHRva2VuIGFuZCBjYWNoZSByZXN1bHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUGF5bG9hZCA9IHtcbiAgICAgICAgc3ViOiAnMScsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDEsXG4gICAgICAgIGlhdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgIGV4cDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAzNjAwXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTsgLy8gTm90IGluIGNhY2hlXG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrUmV0dXJuVmFsdWUobW9ja1BheWxvYWQgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJ3ZhbGlkLXRva2VuJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1BheWxvYWQpO1xuICAgICAgZXhwZWN0KG1vY2tKd3QudmVyaWZ5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndmFsaWQtdG9rZW4nLCAndGVzdC1zZWNyZXQta2V5Jyk7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5zZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgaW52YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuJyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdpbnZhbGlkLXRva2VuJykpLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCB0b2tlbicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBleHBpcmVkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVG9rZW4gZXhwaXJlZCcpIGFzIGFueTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdUb2tlbkV4cGlyZWRFcnJvcic7XG4gICAgICAgIGVycm9yLmV4cGlyZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbignZXhwaXJlZC10b2tlbicpKS5yZWplY3RzLnRvVGhyb3coJ1Rva2VuIGV4cGlyZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICBuYW1lOiAndGVzdHVzZXInLFxuICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICByb2xlSWQ6IDEsXG4gICAgICBzaG9wSWQ6IDEsXG4gICAgICByb2xlOiB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBuYW1lOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczogW1xuICAgICAgICAgIHsgbmFtZTogJ3JlYWRfcHJvZHVjdHMnIH0sXG4gICAgICAgICAgeyBuYW1lOiAnd3JpdGVfcHJvZHVjdHMnIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIHVzZXIgZnJvbSBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogJzEnLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBjYWNoZWRVc2VyID0ge1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUoY2FjaGVkVXNlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoY2FjaGVkVXNlcik7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIGRhdGFiYXNlIGFuZCBjYWNoZSBpdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogJzEnLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTsgLy8gTm90IGluIGNhY2hlXG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5zZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgbnVsbCBwYXlsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChudWxsKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGludmFsaWQgcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQoe30gYXMgYW55KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgd2hlbiB1c2VyIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogJzk5OScsXG4gICAgICAgIHVzZXJuYW1lOiAnbm9uZXhpc3RlbnQnLFxuICAgICAgICBlbWFpbDogJ25vbmV4aXN0ZW50QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFVzZXJGcm9tVG9rZW4nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiB1c2VyIGZyb20gdmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUGF5bG9hZCA9IHtcbiAgICAgICAgc3ViOiAnMScsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgc2hvcElkOiAxLFxuICAgICAgICByb2xlOiB7XG4gICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgbmFtZTogJ2FkbWluJyxcbiAgICAgICAgICBwZXJtaXNzaW9uczogW3sgbmFtZTogJ3JlYWRfcHJvZHVjdHMnIH1dXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgdmVyaWZ5VG9rZW4gdG8gcmV0dXJuIHBheWxvYWRcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tQYXlsb2FkKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkXG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tVG9rZW4oJ3ZhbGlkLXRva2VuJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnXVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGludmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkubW9ja1JldHVyblZhbHVlKCd0ZXN0LWNhY2hlLWtleScpO1xuICAgICAgY29uc3Qgand0ID0gcmVxdWlyZSgnanNvbndlYnRva2VuJyk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgand0LnZlcmlmeSB0byB0aHJvdyBKc29uV2ViVG9rZW5FcnJvclxuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdKc29uV2ViVG9rZW5FcnJvcic7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChnZXRVc2VyRnJvbVRva2VuKCdpbnZhbGlkJykpLnJlamVjdHMudG9UaHJvdygnand0IG1hbGZvcm1lZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIEpXVF9TRUNSRVQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbFNlY3JldCA9IHByb2Nlc3MuZW52LkpXVF9TRUNSRVQ7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVDtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY3JldE9yUHJpdmF0ZUtleSBtdXN0IGhhdmUgYSB2YWx1ZScpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbignYW55LXRva2VuJykpLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIHRoZSBzZWNyZXRcbiAgICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgPSBvcmlnaW5hbFNlY3JldDtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWFsZm9ybWVkIHRva2VucyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVXNlIGEgc2hvcnRlciB0b2tlbiB0byBhdm9pZCBjYWNoZSBrZXkgZ2VuZXJhdGlvblxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGFueSBwcmV2aW91cyBtb2NrcyBhbmQgc2V0IHVwIGZyZXNoIG1vY2tcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tDbGVhcigpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCh0b2tlbiwgc2VjcmV0KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdqd3QudmVyaWZ5IG1vY2sgY2FsbGVkIHdpdGggdG9rZW46JywgdG9rZW4sICdzZWNyZXQ6Jywgc2VjcmV0KTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdKc29uV2ViVG9rZW5FcnJvcic7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdNb2NrIGltcGxlbWVudGF0aW9uIHNldCwgY2FsbGluZyB2ZXJpZnlUb2tlbi4uLicpO1xuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJ3Nob3J0JykpLnJlamVjdHMudG9UaHJvdygnand0IG1hbGZvcm1lZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJycpKS5yZWplY3RzLnRvVGhyb3coJ2p3dCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbIm1vY2tDYWNoZVNlcnZpY2UiLCJnZXQiLCJqZXN0IiwiZm4iLCJzZXQiLCJkZWxldGUiLCJpbmNyZW1lbnQiLCJnZW5lcmF0ZUtleSIsImNsZWFyIiwibW9ja1ByaXNtYSIsInVzZXIiLCJmaW5kVW5pcXVlIiwiZmluZEZpcnN0IiwiY3JlYXRlIiwidXBkYXRlIiwiZmluZE1hbnkiLCJwZXJtaXNzaW9uIiwic2Vzc2lvbiIsImRlbGV0ZU1hbnkiLCJhdWRpdExvZyIsIm1vY2tCY3J5cHQiLCJjb21wYXJlIiwiaGFzaCIsImdlblNhbHQiLCJtb2NrIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjYWNoZVNlcnZpY2UiLCJDQUNIRV9DT05GSUciLCJLRVlTIiwiVVNFUl9TRVNTSU9OIiwiVE9LRU5fVkFMSURBVElPTiIsIlRUTCIsInNpZ24iLCJ2ZXJpZnkiLCJUb2tlbkV4cGlyZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiZXhwaXJlZEF0IiwibmFtZSIsIkpzb25XZWJUb2tlbkVycm9yIiwibW9ja1VzZXJGaW5kRmlyc3QiLCJtb2NrUGVybWlzc2lvbkZpbmRNYW55IiwibW9ja0p3dCIsInJlcXVpcmUiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJKV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4iLCJtb2NrUmV0dXJuVmFsdWUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInVzZXJJZCIsImVtYWlsIiwiZGVjb2RlIiwidGVzdCIsImV4cGVjdCIsInBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcyIsInRvQmUiLCJtb2NrVXNlciIsImlkIiwicGFzc3dvcmQiLCJpc0FjdGl2ZSIsInJvbGVJZCIsInNob3BJZCIsInJvbGVOYW1lIiwicGVybWlzc2lvbnMiLCJyb2xlIiwicmVzdWx0IiwiYXV0aGVudGljYXRlVXNlciIsInN1Y2Nlc3MiLCJ0b2tlbiIsInRvRXF1YWwiLCJ1c2VybmFtZSIsImZ1bGxOYW1lIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ3aGVyZSIsImluY2x1ZGUiLCJzZWxlY3QiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIm1vY2tQYXlsb2FkIiwic3ViIiwibW9ja1Rva2VuIiwiZ2VuZXJhdGVUb2tlbiIsImV4cGlyZXNJbiIsImlhdCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJleHAiLCJ2ZXJpZnlUb2tlbiIsInRvSGF2ZUJlZW5DYWxsZWQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJyZWplY3RzIiwidG9UaHJvdyIsImVycm9yIiwicGF5bG9hZCIsImNhY2hlZFVzZXIiLCJnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkIiwidG9CZU51bGwiLCJnZXRVc2VyRnJvbVRva2VuIiwiand0Iiwib3JpZ2luYWxTZWNyZXQiLCJtb2NrQ2xlYXIiLCJzZWNyZXQiLCJjb25zb2xlIiwibG9nIl0sIm1hcHBpbmdzIjoiQUFBQSxtQ0FBbUM7QUFDbkMsMkRBQTJEOzs7Ozt5QkFFdEM7NkJBb0YrRztBQWxGcEksaURBQWlEO0FBQ2pELE1BQU1BLG1CQUFtQjtJQUN2QkMsS0FBS0MsYUFBSSxDQUFDQyxFQUFFO0lBQ1pDLEtBQUtGLGFBQUksQ0FBQ0MsRUFBRTtJQUNaRSxRQUFRSCxhQUFJLENBQUNDLEVBQUU7SUFDZkcsV0FBV0osYUFBSSxDQUFDQyxFQUFFO0lBQ2xCSSxhQUFhTCxhQUFJLENBQUNDLEVBQUU7SUFDcEJLLE9BQU9OLGFBQUksQ0FBQ0MsRUFBRTtBQUNoQjtBQUVBLE1BQU1NLGFBQWE7SUFDakJDLE1BQU07UUFDSkMsWUFBWVQsYUFBSSxDQUFDQyxFQUFFO1FBQ25CUyxXQUFXVixhQUFJLENBQUNDLEVBQUU7UUFDbEJVLFFBQVFYLGFBQUksQ0FBQ0MsRUFB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