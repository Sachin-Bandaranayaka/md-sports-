{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/lib/transferPerformanceMonitor.ts"],"sourcesContent":["/**\n * Transfer Performance Monitor\n * Tracks and analyzes performance metrics for inventory transfer operations\n */\n\nimport { PerformanceMonitor } from './performance';\nimport { transferCacheService } from './transferCache';\n\ninterface TransferMetrics {\n  operationType: 'create' | 'complete' | 'cancel' | 'list' | 'detail' | 'batch';\n  duration: number;\n  itemCount?: number;\n  shopCount?: number;\n  success: boolean;\n  errorType?: string;\n  cacheHit?: boolean;\n  timestamp: number;\n}\n\ninterface TransferPerformanceStats {\n  totalOperations: number;\n  averageDuration: number;\n  successRate: number;\n  cacheHitRate: number;\n  operationBreakdown: Record<string, {\n    count: number;\n    averageDuration: number;\n    successRate: number;\n  }>;\n  recentErrors: Array<{\n    timestamp: number;\n    operation: string;\n    error: string;\n    duration: number;\n  }>;\n  performanceTrends: Array<{\n    timestamp: number;\n    averageDuration: number;\n    operationCount: number;\n  }>;\n}\n\nclass TransferPerformanceMonitor {\n  private metrics: TransferMetrics[] = [];\n  private maxMetricsHistory = 1000;\n  private performanceMonitor: PerformanceMonitor;\n  private alertThresholds = {\n    slowOperationMs: 5000, // 5 seconds\n    highErrorRate: 0.1, // 10%\n    lowCacheHitRate: 0.5 // 50%\n  };\n\n  constructor() {\n    this.performanceMonitor = new PerformanceMonitor();\n    this.startPeriodicCleanup();\n  }\n\n  /**\n   * Start tracking a transfer operation\n   */\n  startOperation(operationType: TransferMetrics['operationType'], metadata?: {\n    itemCount?: number;\n    shopCount?: number;\n  }) {\n    const timerName = `transfer-${operationType}`;\n    this.performanceMonitor.startTimer(timerName);\n\n    return {\n      timer: timerName,\n      end: (success: boolean, errorType?: string, cacheHit?: boolean) => {\n        const duration = this.performanceMonitor.endTimer(timerName);\n\n        this.recordMetric({\n          operationType,\n          duration,\n          itemCount: metadata?.itemCount,\n          shopCount: metadata?.shopCount,\n          success,\n          errorType,\n          cacheHit,\n          timestamp: Date.now()\n        });\n\n        // Check for performance alerts\n        this.checkPerformanceAlerts(operationType, duration, success);\n\n        return duration;\n      }\n    };\n  }\n\n  /**\n   * Record a transfer operation metric\n   */\n  private recordMetric(metric: TransferMetrics) {\n    this.metrics.push(metric);\n\n    // Keep only recent metrics\n    if (this.metrics.length > this.maxMetricsHistory) {\n      this.metrics = this.metrics.slice(-this.maxMetricsHistory);\n    }\n\n    // Log slow operations\n    if (metric.duration > this.alertThresholds.slowOperationMs) {\n      console.warn(`ðŸŒ Slow transfer operation detected:`, {\n        operation: metric.operationType,\n        duration: `${metric.duration}ms`,\n        itemCount: metric.itemCount,\n        shopCount: metric.shopCount,\n        success: metric.success\n      });\n    }\n  }\n\n  /**\n   * Check for performance alerts\n   */\n  private checkPerformanceAlerts(operationType: string, _duration: number, _success: boolean) {\n    const recentMetrics = this.getRecentMetrics(5 * 60 * 1000); // Last 5 minutes\n    const operationMetrics = recentMetrics.filter(m => m.operationType === operationType);\n\n    if (operationMetrics.length >= 5) {\n      const errorRate = operationMetrics.filter(m => !m.success).length / operationMetrics.length;\n\n      if (errorRate > this.alertThresholds.highErrorRate) {\n        console.error(`ðŸš¨ High error rate detected for ${operationType}:`, {\n          errorRate: `${(errorRate * 100).toFixed(1)}%`,\n          recentOperations: operationMetrics.length,\n          timeWindow: '5 minutes'\n        });\n      }\n    }\n\n    // Check cache hit rate\n    const cacheableOperations = recentMetrics.filter(m =>\n      ['list', 'detail'].includes(m.operationType) && m.cacheHit !== undefined\n    );\n\n    if (cacheableOperations.length >= 10) {\n      const cacheHitRate = cacheableOperations.filter(m => m.cacheHit).length / cacheableOperations.length;\n\n      if (cacheHitRate < this.alertThresholds.lowCacheHitRate) {\n        console.warn(`ðŸ“Š Low cache hit rate detected:`, {\n          cacheHitRate: `${(cacheHitRate * 100).toFixed(1)}%`,\n          operations: cacheableOperations.length,\n          timeWindow: '5 minutes'\n        });\n      }\n    }\n  }\n\n  /**\n   * Get metrics from a specific time window\n   */\n  private getRecentMetrics(timeWindowMs: number): TransferMetrics[] {\n    const cutoff = Date.now() - timeWindowMs;\n    return this.metrics.filter(m => m.timestamp > cutoff);\n  }\n\n  /**\n   * Get comprehensive performance statistics\n   */\n  getPerformanceStats(timeWindowMs: number = 60 * 60 * 1000): TransferPerformanceStats {\n    const recentMetrics = this.getRecentMetrics(timeWindowMs);\n\n    if (recentMetrics.length === 0) {\n      return {\n        totalOperations: 0,\n        averageDuration: 0,\n        successRate: 0,\n        cacheHitRate: 0,\n        operationBreakdown: {},\n        recentErrors: [],\n        performanceTrends: []\n      };\n    }\n\n    const totalOperations = recentMetrics.length;\n    const averageDuration = recentMetrics.reduce((sum, m) => sum + m.duration, 0) / totalOperations;\n    const successRate = recentMetrics.filter(m => m.success).length / totalOperations;\n\n    const cacheableMetrics = recentMetrics.filter(m => m.cacheHit !== undefined);\n    const cacheHitRate = cacheableMetrics.length > 0\n      ? cacheableMetrics.filter(m => m.cacheHit).length / cacheableMetrics.length\n      : 0;\n\n    // Operation breakdown\n    const operationBreakdown: Record<string, any> = {};\n    const operationTypes = [...new Set(recentMetrics.map(m => m.operationType))];\n\n    for (const opType of operationTypes) {\n      const opMetrics = recentMetrics.filter(m => m.operationType === opType);\n      operationBreakdown[opType] = {\n        count: opMetrics.length,\n        averageDuration: opMetrics.reduce((sum, m) => sum + m.duration, 0) / opMetrics.length,\n        successRate: opMetrics.filter(m => m.success).length / opMetrics.length\n      };\n    }\n\n    // Recent errors\n    const recentErrors = recentMetrics\n      .filter(m => !m.success)\n      .slice(-10)\n      .map(m => ({\n        timestamp: m.timestamp,\n        operation: m.operationType,\n        error: m.errorType || 'Unknown error',\n        duration: m.duration\n      }));\n\n    // Performance trends (hourly buckets)\n    const performanceTrends = this.calculatePerformanceTrends(recentMetrics);\n\n    return {\n      totalOperations,\n      averageDuration,\n      successRate,\n      cacheHitRate,\n      operationBreakdown,\n      recentErrors,\n      performanceTrends\n    };\n  }\n\n  /**\n   * Calculate performance trends over time\n   */\n  private calculatePerformanceTrends(metrics: TransferMetrics[]): Array<{\n    timestamp: number;\n    averageDuration: number;\n    operationCount: number;\n  }> {\n    const hourlyBuckets = new Map<number, TransferMetrics[]>();\n\n    // Group metrics by hour\n    for (const metric of metrics) {\n      const hourBucket = Math.floor(metric.timestamp / (60 * 60 * 1000)) * (60 * 60 * 1000);\n      if (!hourlyBuckets.has(hourBucket)) {\n        hourlyBuckets.set(hourBucket, []);\n      }\n      hourlyBuckets.get(hourBucket)!.push(metric);\n    }\n\n    // Calculate trends\n    const trends = Array.from(hourlyBuckets.entries())\n      .map(([timestamp, bucketMetrics]) => ({\n        timestamp,\n        averageDuration: bucketMetrics.reduce((sum, m) => sum + m.duration, 0) / bucketMetrics.length,\n        operationCount: bucketMetrics.length\n      }))\n      .sort((a, b) => a.timestamp - b.timestamp);\n\n    return trends;\n  }\n\n  /**\n   * Get performance recommendations\n   */\n  getPerformanceRecommendations(): Array<{\n    type: 'warning' | 'info' | 'critical';\n    message: string;\n    action?: string;\n  }> {\n    const stats = this.getPerformanceStats();\n    const recommendations: Array<{\n      type: 'warning' | 'info' | 'critical';\n      message: string;\n      action?: string;\n    }> = [];\n\n    // Check average duration\n    if (stats.averageDuration > 3000) {\n      recommendations.push({\n        type: 'warning',\n        message: `Average operation duration is ${stats.averageDuration.toFixed(0)}ms`,\n        action: 'Consider optimizing database queries or adding more caching'\n      });\n    }\n\n    // Check success rate\n    if (stats.successRate < 0.95) {\n      recommendations.push({\n        type: 'critical',\n        message: `Success rate is ${(stats.successRate * 100).toFixed(1)}%`,\n        action: 'Investigate recent errors and improve error handling'\n      });\n    }\n\n    // Check cache hit rate\n    if (stats.cacheHitRate < 0.7) {\n      recommendations.push({\n        type: 'info',\n        message: `Cache hit rate is ${(stats.cacheHitRate * 100).toFixed(1)}%`,\n        action: 'Consider increasing cache TTL or warming cache more frequently'\n      });\n    }\n\n    // Check for slow operations\n    const slowOperations = Object.entries(stats.operationBreakdown)\n      .filter(([_, data]) => data.averageDuration > 2000);\n\n    if (slowOperations.length > 0) {\n      recommendations.push({\n        type: 'warning',\n        message: `Slow operations detected: ${slowOperations.map(([op]) => op).join(', ')}`,\n        action: 'Optimize these specific operations with batch processing or better indexing'\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Export metrics for analysis\n   */\n  exportMetrics(timeWindowMs?: number): TransferMetrics[] {\n    return timeWindowMs ? this.getRecentMetrics(timeWindowMs) : [...this.metrics];\n  }\n\n  /**\n   * Clear all metrics\n   */\n  clearMetrics(): void {\n    this.metrics = [];\n  }\n\n  /**\n   * Start periodic cleanup of old metrics\n   */\n  private startPeriodicCleanup(): void {\n    setInterval(() => {\n      const cutoff = Date.now() - (24 * 60 * 60 * 1000); // 24 hours\n      this.metrics = this.metrics.filter(m => m.timestamp > cutoff);\n    }, 60 * 60 * 1000); // Run every hour\n  }\n\n  /**\n   * Get real-time performance dashboard data\n   */\n  getDashboardData() {\n    const last5Minutes = this.getPerformanceStats(5 * 60 * 1000);\n    const lastHour = this.getPerformanceStats(60 * 60 * 1000);\n    const last24Hours = this.getPerformanceStats(24 * 60 * 60 * 1000);\n\n    return {\n      current: {\n        activeOperations: this.performanceMonitor.getActiveTimers().length,\n        cacheStats: transferCacheService.getStats()\n      },\n      last5Minutes,\n      lastHour,\n      last24Hours,\n      recommendations: this.getPerformanceRecommendations()\n    };\n  }\n}\n\n// Global instance\nexport const transferPerformanceMonitor = new TransferPerformanceMonitor();\n\n// Utility functions for easy usage\nexport const trackTransferOperation = (\n  operationType: TransferMetrics['operationType'],\n  metadata?: { itemCount?: number; shopCount?: number }\n) => {\n  return transferPerformanceMonitor.startOperation(operationType, metadata);\n};\n\nexport const getTransferPerformanceStats = (timeWindowMs?: number) => {\n  return transferPerformanceMonitor.getPerformanceStats(timeWindowMs);\n};\n\nexport const getTransferDashboardData = () => {\n  return transferPerformanceMonitor.getDashboardData();\n};\n\n// Export types\nexport type {\n  TransferMetrics,\n  TransferPerformanceStats\n};"],"names":["getTransferDashboardData","getTransferPerformanceStats","trackTransferOperation","transferPerformanceMonitor","TransferPerformanceMonitor","constructor","metrics","maxMetricsHistory","alertThresholds","slowOperationMs","highErrorRate","lowCacheHitRate","performanceMonitor","PerformanceMonitor","startPeriodicCleanup","startOperation","operationType","metadata","timerName","startTimer","timer","end","success","errorType","cacheHit","duration","endTimer","recordMetric","itemCount","shopCount","timestamp","Date","now","checkPerformanceAlerts","metric","push","length","slice","console","warn","operation","_duration","_success","recentMetrics","getRecentMetrics","operationMetrics","filter","m","errorRate","error","toFixed","recentOperations","timeWindow","cacheableOperations","includes","undefined","cacheHitRate","operations","timeWindowMs","cutoff","getPerformanceStats","totalOperations","averageDuration","successRate","operationBreakdown","recentErrors","performanceTrends","reduce","sum","cacheableMetrics","operationTypes","Set","map","opType","opMetrics","count","calculatePerformanceTrends","hourlyBuckets","Map","hourBucket","Math","floor","has","set","get","trends","Array","from","entries","bucketMetrics","operationCount","sort","a","b","getPerformanceRecommendations","stats","recommendations","type","message","action","slowOperations","Object","_","data","op","join","exportMetrics","clearMetrics","setInterval","getDashboardData","last5Minutes","lastHour","last24Hours","current","activeOperations","getActiveTimers","cacheStats","transferCacheService","getStats"],"mappings":"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"}