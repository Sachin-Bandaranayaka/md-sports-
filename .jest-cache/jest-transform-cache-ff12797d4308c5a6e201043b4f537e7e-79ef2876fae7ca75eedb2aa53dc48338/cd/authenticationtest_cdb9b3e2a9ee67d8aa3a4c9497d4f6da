4e3998e1aad1ca71f3d052a78d2147dd
"use strict";
jest.mock("@/hooks/useAuth", ()=>({
        useAuth: ()=>mockUseAuth()
    }));
// Mock next/navigation
jest.mock("next/navigation", ()=>({
        useRouter: ()=>({
                push: jest.fn(),
                replace: jest.fn(),
                back: jest.fn(),
                forward: jest.fn(),
                refresh: jest.fn(),
                prefetch: jest.fn()
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
require("@testing-library/jest-dom");
// Mock the useAuth hook
const mockUseAuth = jest.fn();
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
// Mock crypto for token generation
Object.defineProperty(global, "crypto", {
    value: {
        randomUUID: ()=>"mock-uuid-123",
        getRandomValues: (arr)=>{
            for(let i = 0; i < arr.length; i++){
                arr[i] = Math.floor(Math.random() * 256);
            }
            return arr;
        }
    }
});
describe("Authentication and Authorization System", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock localStorage
        Object.defineProperty(window, "localStorage", {
            value: {
                getItem: jest.fn(),
                setItem: jest.fn(),
                removeItem: jest.fn(),
                clear: jest.fn()
            },
            writable: true
        });
        // Mock sessionStorage
        Object.defineProperty(window, "sessionStorage", {
            value: {
                getItem: jest.fn(),
                setItem: jest.fn(),
                removeItem: jest.fn(),
                clear: jest.fn()
            },
            writable: true
        });
    });
    describe("User Authentication", ()=>{
        test("should validate login credentials", ()=>{
            const validateLoginCredentials = (email, password)=>{
                const errors = [];
                if (!email || email.trim().length === 0) {
                    errors.push("Email is required");
                } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
                    errors.push("Invalid email format");
                }
                if (!password || password.length === 0) {
                    errors.push("Password is required");
                } else if (password.length < 6) {
                    errors.push("Password must be at least 6 characters");
                }
                return errors;
            };
            expect(validateLoginCredentials("user@example.com", "password123")).toEqual([]);
            expect(validateLoginCredentials("", "password123")).toContain("Email is required");
            expect(validateLoginCredentials("invalid-email", "password123")).toContain("Invalid email format");
            expect(validateLoginCredentials("user@example.com", "")).toContain("Password is required");
            expect(validateLoginCredentials("user@example.com", "123")).toContain("Password must be at least 6 characters");
        });
        test("should handle successful login", async ()=>{
            const login = async (email, password)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            token: "mock-jwt-token",
                            user: {
                                id: "1",
                                email: "user@example.com",
                                name: "Test User",
                                permissions: [
                                    "sales:view",
                                    "inventory:view"
                                ]
                            },
                            expiresIn: 3600
                        })
                });
                const response = await fetch("/api/auth/login", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        email,
                        password
                    })
                });
                return response.json();
            };
            const result = await login("user@example.com", "password123");
            expect(result.success).toBe(true);
            expect(result.token).toBe("mock-jwt-token");
            expect(result.user.email).toBe("user@example.com");
            expect(mockFetch).toHaveBeenCalledWith("/api/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email: "user@example.com",
                    password: "password123"
                })
            });
        });
        test("should handle login failure", async ()=>{
            const login = async (email, password)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: false,
                    status: 401,
                    json: async ()=>({
                            success: false,
                            message: "Invalid credentials"
                        })
                });
                const response = await fetch("/api/auth/login", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        email,
                        password
                    })
                });
                return {
                    ok: response.ok,
                    data: await response.json()
                };
            };
            const result = await login("user@example.com", "wrongpassword");
            expect(result.ok).toBe(false);
            expect(result.data.success).toBe(false);
            expect(result.data.message).toBe("Invalid credentials");
        });
        test("should handle logout", async ()=>{
            const logout = async (token)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            message: "Logged out successfully"
                        })
                });
                const response = await fetch("/api/auth/logout", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${token}`
                    }
                });
                // Clear local storage
                localStorage.removeItem("token");
                localStorage.removeItem("user");
                sessionStorage.clear();
                return response.json();
            };
            const result = await logout("mock-token");
            expect(result.success).toBe(true);
            expect(localStorage.removeItem).toHaveBeenCalledWith("token");
            expect(localStorage.removeItem).toHaveBeenCalledWith("user");
            expect(sessionStorage.clear).toHaveBeenCalled();
        });
    });
    describe("Token Management", ()=>{
        test("should validate JWT token format", ()=>{
            const isValidJWTFormat = (token)=>{
                if (!token) return false;
                const parts = token.split(".");
                return parts.length === 3;
            };
            expect(isValidJWTFormat("header.payload.signature")).toBe(true);
            expect(isValidJWTFormat("invalid-token")).toBe(false);
            expect(isValidJWTFormat("")).toBe(false);
        });
        test("should check token expiration", ()=>{
            const isTokenExpired = (token)=>{
                try {
                    // Mock JWT decode
                    const payload = JSON.parse(atob(token.split(".")[1]));
                    const currentTime = Math.floor(Date.now() / 1000);
                    return payload.exp < currentTime;
                } catch  {
                    return true; // Invalid token is considered expired
                }
            };
            // Mock valid token (expires in future)
            const futureExp = Math.floor(Date.now() / 1000) + 3600; // 1 hour from now
            const validToken = `header.${btoa(JSON.stringify({
                exp: futureExp
            }))}.signature`;
            // Mock expired token
            const pastExp = Math.floor(Date.now() / 1000) - 3600; // 1 hour ago
            const expiredToken = `header.${btoa(JSON.stringify({
                exp: pastExp
            }))}.signature`;
            expect(isTokenExpired(validToken)).toBe(false);
            expect(isTokenExpired(expiredToken)).toBe(true);
            expect(isTokenExpired("invalid-token")).toBe(true);
        });
        test("should refresh token when near expiration", async ()=>{
            const refreshToken = async (currentToken)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            token: "new-jwt-token",
                            expiresIn: 3600
                        })
                });
                const response = await fetch("/api/auth/refresh", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${currentToken}`
                    }
                });
                return response.json();
            };
            const result = await refreshToken("old-token");
            expect(result.success).toBe(true);
            expect(result.token).toBe("new-jwt-token");
        });
        test("should store and retrieve tokens securely", ()=>{
            const storeToken = (token, rememberMe = false)=>{
                if (rememberMe) {
                    localStorage.setItem("token", token);
                } else {
                    sessionStorage.setItem("token", token);
                }
            };
            const getStoredToken = ()=>{
                return localStorage.getItem("token") || sessionStorage.getItem("token");
            };
            const clearStoredToken = ()=>{
                localStorage.removeItem("token");
                sessionStorage.removeItem("token");
            };
            // Test persistent storage
            storeToken("persistent-token", true);
            expect(localStorage.setItem).toHaveBeenCalledWith("token", "persistent-token");
            // Test session storage
            storeToken("session-token", false);
            expect(sessionStorage.setItem).toHaveBeenCalledWith("token", "session-token");
            // Mock return values for retrieval test
            localStorage.getItem.mockReturnValue("stored-token");
            expect(getStoredToken()).toBe("stored-token");
            // Test clearing
            clearStoredToken();
            expect(localStorage.removeItem).toHaveBeenCalledWith("token");
            expect(sessionStorage.removeItem).toHaveBeenCalledWith("token");
        });
    });
    describe("Permission System", ()=>{
        test("should check user permissions correctly", ()=>{
            const hasPermission = (userPermissions, requiredPermission)=>{
                return userPermissions.includes(requiredPermission) || userPermissions.includes("admin:all");
            };
            const userPermissions = [
                "sales:view",
                "sales:create",
                "inventory:view"
            ];
            expect(hasPermission(userPermissions, "sales:view")).toBe(true);
            expect(hasPermission(userPermissions, "sales:create")).toBe(true);
            expect(hasPermission(userPermissions, "sales:delete")).toBe(false);
            expect(hasPermission([
                "admin:all"
            ], "any:permission")).toBe(true);
        });
        test("should check multiple permissions (AND logic)", ()=>{
            const hasAllPermissions = (userPermissions, requiredPermissions)=>{
                return requiredPermissions.every((permission)=>userPermissions.includes(permission) || userPermissions.includes("admin:all"));
            };
            const userPermissions = [
                "sales:view",
                "sales:create",
                "inventory:view"
            ];
            expect(hasAllPermissions(userPermissions, [
                "sales:view",
                "inventory:view"
            ])).toBe(true);
            expect(hasAllPermissions(userPermissions, [
                "sales:view",
                "sales:delete"
            ])).toBe(false);
        });
        test("should check any permission (OR logic)", ()=>{
            const hasAnyPermission = (userPermissions, requiredPermissions)=>{
                return requiredPermissions.some((permission)=>userPermissions.includes(permission) || userPermissions.includes("admin:all"));
            };
            const userPermissions = [
                "sales:view",
                "inventory:view"
            ];
            expect(hasAnyPermission(userPermissions, [
                "sales:view",
                "sales:delete"
            ])).toBe(true);
            expect(hasAnyPermission(userPermissions, [
                "admin:delete",
                "admin:create"
            ])).toBe(false);
        });
        test("should validate role-based permissions", ()=>{
            const getRolePermissions = (role)=>{
                const rolePermissions = {
                    "admin": [
                        "admin:all"
                    ],
                    "manager": [
                        "sales:all",
                        "inventory:all",
                        "customers:all"
                    ],
                    "sales": [
                        "sales:view",
                        "sales:create",
                        "customers:view",
                        "customers:create"
                    ],
                    "inventory": [
                        "inventory:view",
                        "inventory:create",
                        "inventory:edit"
                    ],
                    "viewer": [
                        "sales:view",
                        "inventory:view",
                        "customers:view"
                    ]
                };
                return rolePermissions[role] || [];
            };
            expect(getRolePermissions("admin")).toContain("admin:all");
            expect(getRolePermissions("sales")).toContain("sales:view");
            expect(getRolePermissions("sales")).toContain("customers:create");
            expect(getRolePermissions("viewer")).not.toContain("sales:create");
            expect(getRolePermissions("unknown")).toEqual([]);
        });
    });
    describe("Session Management", ()=>{
        test("should track user session activity", ()=>{
            const updateLastActivity = ()=>{
                const timestamp = Date.now();
                sessionStorage.setItem("lastActivity", timestamp.toString());
                return timestamp;
            };
            const getLastActivity = ()=>{
                const timestamp = sessionStorage.getItem("lastActivity");
                return timestamp ? parseInt(timestamp) : null;
            };
            const isSessionExpired = (maxInactiveTime = 30 * 60 * 1000)=>{
                const lastActivity = getLastActivity();
                if (!lastActivity) return true;
                return Date.now() - lastActivity > maxInactiveTime;
            };
            // Mock sessionStorage behavior
            let mockStorage = {};
            sessionStorage.setItem.mockImplementation((key, value)=>{
                mockStorage[key] = value;
            });
            sessionStorage.getItem.mockImplementation((key)=>{
                return mockStorage[key] || null;
            });
            const timestamp = updateLastActivity();
            expect(sessionStorage.setItem).toHaveBeenCalledWith("lastActivity", timestamp.toString());
            // Test session not expired
            expect(isSessionExpired(60 * 60 * 1000)).toBe(false); // 1 hour limit
            // Test session expired
            mockStorage["lastActivity"] = (Date.now() - 60 * 60 * 1000).toString(); // 1 hour ago
            expect(isSessionExpired(30 * 60 * 1000)).toBe(true); // 30 minute limit
        });
        test("should handle concurrent sessions", ()=>{
            const generateSessionId = ()=>{
                return crypto.randomUUID();
            };
            const validateSessionId = (sessionId, userSessions)=>{
                return userSessions.includes(sessionId);
            };
            const addSession = (userSessions, sessionId, maxSessions = 3)=>{
                const updatedSessions = [
                    ...userSessions,
                    sessionId
                ];
                // Remove oldest sessions if limit exceeded
                if (updatedSessions.length > maxSessions) {
                    return updatedSessions.slice(-maxSessions);
                }
                return updatedSessions;
            };
            const sessionId1 = generateSessionId();
            const sessionId2 = generateSessionId();
            expect(sessionId1).toBe("mock-uuid-123");
            expect(validateSessionId(sessionId1, [
                sessionId1,
                sessionId2
            ])).toBe(true);
            expect(validateSessionId("invalid-session", [
                sessionId1,
                sessionId2
            ])).toBe(false);
            const sessions = addSession([
                "session1",
                "session2",
                "session3"
            ], "session4", 3);
            expect(sessions).toEqual([
                "session2",
                "session3",
                "session4"
            ]);
        });
    });
    describe("Password Security", ()=>{
        test("should validate password strength", ()=>{
            const validatePasswordStrength = (password)=>{
                const errors = [];
                if (password.length < 8) {
                    errors.push("Password must be at least 8 characters long");
                }
                if (!/[A-Z]/.test(password)) {
                    errors.push("Password must contain at least one uppercase letter");
                }
                if (!/[a-z]/.test(password)) {
                    errors.push("Password must contain at least one lowercase letter");
                }
                if (!/\d/.test(password)) {
                    errors.push("Password must contain at least one number");
                }
                if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
                    errors.push("Password must contain at least one special character");
                }
                return {
                    isValid: errors.length === 0,
                    errors,
                    strength: errors.length === 0 ? "strong" : errors.length <= 2 ? "medium" : "weak"
                };
            };
            const strongPassword = validatePasswordStrength("StrongPass123!");
            expect(strongPassword.isValid).toBe(true);
            expect(strongPassword.strength).toBe("strong");
            const weakPassword = validatePasswordStrength("weak");
            expect(weakPassword.isValid).toBe(false);
            expect(weakPassword.strength).toBe("weak");
            expect(weakPassword.errors).toContain("Password must be at least 8 characters long");
        });
        test("should handle password reset flow", async ()=>{
            const requestPasswordReset = async (email)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            message: "Password reset email sent",
                            resetToken: "reset-token-123"
                        })
                });
                const response = await fetch("/api/auth/forgot-password", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        email
                    })
                });
                return response.json();
            };
            const resetPassword = async (token, newPassword)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            message: "Password reset successfully"
                        })
                });
                const response = await fetch("/api/auth/reset-password", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        token,
                        newPassword
                    })
                });
                return response.json();
            };
            const resetRequest = await requestPasswordReset("user@example.com");
            expect(resetRequest.success).toBe(true);
            expect(resetRequest.resetToken).toBe("reset-token-123");
            const passwordReset = await resetPassword("reset-token-123", "NewPassword123!");
            expect(passwordReset.success).toBe(true);
        });
    });
    describe("Two-Factor Authentication", ()=>{
        test("should generate and validate TOTP codes", ()=>{
            // Mock TOTP generation (simplified)
            const generateTOTP = (secret, timeStep = 30)=>{
                const time = Math.floor(Date.now() / 1000 / timeStep);
                // Simplified TOTP generation for testing
                return ((time + secret.length) % 1000000).toString().padStart(6, "0");
            };
            const validateTOTP = (code, secret, tolerance = 1)=>{
                const currentTime = Math.floor(Date.now() / 1000 / 30);
                for(let i = -tolerance; i <= tolerance; i++){
                    const timeStep = currentTime + i;
                    const expectedCode = ((timeStep + secret.length) % 1000000).toString().padStart(6, "0");
                    if (code === expectedCode) {
                        return true;
                    }
                }
                return false;
            };
            const secret = "user-secret-key";
            const code = generateTOTP(secret);
            expect(code).toHaveLength(6);
            expect(validateTOTP(code, secret)).toBe(true);
            expect(validateTOTP("000000", secret)).toBe(false);
        });
        test("should handle 2FA setup and verification", async ()=>{
            const setup2FA = async (userId)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            secret: "JBSWY3DPEHPK3PXP",
                            qrCode: "data:image/png;base64,mock-qr-code",
                            backupCodes: [
                                "123456",
                                "789012",
                                "345678"
                            ]
                        })
                });
                const response = await fetch("/api/auth/2fa/setup", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify({
                        userId
                    })
                });
                return response.json();
            };
            const verify2FA = async (userId, code)=>{
                mockFetch.mockResolvedValueOnce({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            message: "2FA enabled successfully"
                        })
                });
                const response = await fetch("/api/auth/2fa/verify", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer mock-token"
                    },
                    body: JSON.stringify({
                        userId,
                        code
                    })
                });
                return response.json();
            };
            const setupResult = await setup2FA("user123");
            expect(setupResult.success).toBe(true);
            expect(setupResult.secret).toBe("JBSWY3DPEHPK3PXP");
            expect(setupResult.backupCodes).toHaveLength(3);
            const verifyResult = await verify2FA("user123", "123456");
            expect(verifyResult.success).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvaW50ZWdyYXRpb24vYXV0aGVudGljYXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgZmlyZUV2ZW50LCB3YWl0Rm9yIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvamVzdC1kb20nO1xuXG4vLyBNb2NrIHRoZSB1c2VBdXRoIGhvb2tcbmNvbnN0IG1vY2tVc2VBdXRoID0gamVzdC5mbigpO1xuamVzdC5tb2NrKCdAL2hvb2tzL3VzZUF1dGgnLCAoKSA9PiAoe1xuICB1c2VBdXRoOiAoKSA9PiBtb2NrVXNlQXV0aCgpLFxufSkpO1xuXG4vLyBNb2NrIG5leHQvbmF2aWdhdGlvblxuamVzdC5tb2NrKCduZXh0L25hdmlnYXRpb24nLCAoKSA9PiAoe1xuICB1c2VSb3V0ZXI6ICgpID0+ICh7XG4gICAgcHVzaDogamVzdC5mbigpLFxuICAgIHJlcGxhY2U6IGplc3QuZm4oKSxcbiAgICBiYWNrOiBqZXN0LmZuKCksXG4gICAgZm9yd2FyZDogamVzdC5mbigpLFxuICAgIHJlZnJlc2g6IGplc3QuZm4oKSxcbiAgICBwcmVmZXRjaDogamVzdC5mbigpLFxuICB9KSxcbn0pKTtcblxuLy8gTW9jayBmZXRjaCBnbG9iYWxseVxuY29uc3QgbW9ja0ZldGNoID0gamVzdC5mbigpO1xuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoO1xuXG4vLyBNb2NrIGNyeXB0byBmb3IgdG9rZW4gZ2VuZXJhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbCwgJ2NyeXB0bycsIHtcbiAgdmFsdWU6IHtcbiAgICByYW5kb21VVUlEOiAoKSA9PiAnbW9jay11dWlkLTEyMycsXG4gICAgZ2V0UmFuZG9tVmFsdWVzOiAoYXJyOiBhbnkpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgfVxufSk7XG5cbmRlc2NyaWJlKCdBdXRoZW50aWNhdGlvbiBhbmQgQXV0aG9yaXphdGlvbiBTeXN0ZW0nLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIE1vY2sgbG9jYWxTdG9yYWdlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2xvY2FsU3RvcmFnZScsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGdldEl0ZW06IGplc3QuZm4oKSxcbiAgICAgICAgc2V0SXRlbTogamVzdC5mbigpLFxuICAgICAgICByZW1vdmVJdGVtOiBqZXN0LmZuKCksXG4gICAgICAgIGNsZWFyOiBqZXN0LmZuKCksXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLyBNb2NrIHNlc3Npb25TdG9yYWdlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ3Nlc3Npb25TdG9yYWdlJywge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgZ2V0SXRlbTogamVzdC5mbigpLFxuICAgICAgICBzZXRJdGVtOiBqZXN0LmZuKCksXG4gICAgICAgIHJlbW92ZUl0ZW06IGplc3QuZm4oKSxcbiAgICAgICAgY2xlYXI6IGplc3QuZm4oKSxcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1VzZXIgQXV0aGVudGljYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHZhbGlkYXRlIGxvZ2luIGNyZWRlbnRpYWxzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGVMb2dpbkNyZWRlbnRpYWxzID0gKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFlbWFpbCB8fCBlbWFpbC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ0VtYWlsIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIS9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvLnRlc3QoZW1haWwpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ0ludmFsaWQgZW1haWwgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghcGFzc3dvcmQgfHwgcGFzc3dvcmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFzc3dvcmQubGVuZ3RoIDwgNikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycycpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgfTtcblxuICAgICAgZXhwZWN0KHZhbGlkYXRlTG9naW5DcmVkZW50aWFscygndXNlckBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZUxvZ2luQ3JlZGVudGlhbHMoJycsICdwYXNzd29yZDEyMycpKS50b0NvbnRhaW4oJ0VtYWlsIGlzIHJlcXVpcmVkJyk7XG4gICAgICBleHBlY3QodmFsaWRhdGVMb2dpbkNyZWRlbnRpYWxzKCdpbnZhbGlkLWVtYWlsJywgJ3Bhc3N3b3JkMTIzJykpLnRvQ29udGFpbignSW52YWxpZCBlbWFpbCBmb3JtYXQnKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZUxvZ2luQ3JlZGVudGlhbHMoJ3VzZXJAZXhhbXBsZS5jb20nLCAnJykpLnRvQ29udGFpbignUGFzc3dvcmQgaXMgcmVxdWlyZWQnKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZUxvZ2luQ3JlZGVudGlhbHMoJ3VzZXJAZXhhbXBsZS5jb20nLCAnMTIzJykpLnRvQ29udGFpbignUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgc3VjY2Vzc2Z1bCBsb2dpbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2luID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICB0b2tlbjogJ21vY2stand0LXRva2VuJyxcbiAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgICAgICAgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgICAgICAgIHBlcm1pc3Npb25zOiBbJ3NhbGVzOnZpZXcnLCAnaW52ZW50b3J5OnZpZXcnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cGlyZXNJbjogMzYwMFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBwYXNzd29yZCB9KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9naW4oJ3VzZXJAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC50b2tlbikudG9CZSgnbW9jay1qd3QtdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5lbWFpbCkudG9CZSgndXNlckBleGFtcGxlLmNvbScpO1xuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJywgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycgfSlcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBsb2dpbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgc3RhdHVzOiA0MDEsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgY3JlZGVudGlhbHMnXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IG9rOiByZXNwb25zZS5vaywgZGF0YTogYXdhaXQgcmVzcG9uc2UuanNvbigpIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2dpbigndXNlckBleGFtcGxlLmNvbScsICd3cm9uZ3Bhc3N3b3JkJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQub2spLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgY3JlZGVudGlhbHMnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbG9nb3V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nb3V0ID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiAnTG9nZ2VkIG91dCBzdWNjZXNzZnVsbHknXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hdXRoL2xvZ291dCcsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDbGVhciBsb2NhbCBzdG9yYWdlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd0b2tlbicpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcicpO1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5jbGVhcigpO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2dvdXQoJ21vY2stdG9rZW4nKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndG9rZW4nKTtcbiAgICAgIGV4cGVjdChsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3VzZXInKTtcbiAgICAgIGV4cGVjdChzZXNzaW9uU3RvcmFnZS5jbGVhcikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVG9rZW4gTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdmFsaWRhdGUgSldUIHRva2VuIGZvcm1hdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGlzVmFsaWRKV1RGb3JtYXQgPSAodG9rZW46IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIXRva2VuKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMztcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdChpc1ZhbGlkSldURm9ybWF0KCdoZWFkZXIucGF5bG9hZC5zaWduYXR1cmUnKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChpc1ZhbGlkSldURm9ybWF0KCdpbnZhbGlkLXRva2VuJykpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGlzVmFsaWRKV1RGb3JtYXQoJycpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBjaGVjayB0b2tlbiBleHBpcmF0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgaXNUb2tlbkV4cGlyZWQgPSAodG9rZW46IHN0cmluZykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIE1vY2sgSldUIGRlY29kZVxuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGF0b2IodG9rZW4uc3BsaXQoJy4nKVsxXSkpO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgICAgcmV0dXJuIHBheWxvYWQuZXhwIDwgY3VycmVudFRpbWU7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBJbnZhbGlkIHRva2VuIGlzIGNvbnNpZGVyZWQgZXhwaXJlZFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIHZhbGlkIHRva2VuIChleHBpcmVzIGluIGZ1dHVyZSlcbiAgICAgIGNvbnN0IGZ1dHVyZUV4cCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgMzYwMDsgLy8gMSBob3VyIGZyb20gbm93XG4gICAgICBjb25zdCB2YWxpZFRva2VuID0gYGhlYWRlci4ke2J0b2EoSlNPTi5zdHJpbmdpZnkoeyBleHA6IGZ1dHVyZUV4cCB9KSl9LnNpZ25hdHVyZWA7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgZXhwaXJlZCB0b2tlblxuICAgICAgY29uc3QgcGFzdEV4cCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gMzYwMDsgLy8gMSBob3VyIGFnb1xuICAgICAgY29uc3QgZXhwaXJlZFRva2VuID0gYGhlYWRlci4ke2J0b2EoSlNPTi5zdHJpbmdpZnkoeyBleHA6IHBhc3RFeHAgfSkpfS5zaWduYXR1cmVgO1xuXG4gICAgICBleHBlY3QoaXNUb2tlbkV4cGlyZWQodmFsaWRUb2tlbikpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGlzVG9rZW5FeHBpcmVkKGV4cGlyZWRUb2tlbikpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoaXNUb2tlbkV4cGlyZWQoJ2ludmFsaWQtdG9rZW4nKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWZyZXNoIHRva2VuIHdoZW4gbmVhciBleHBpcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gYXN5bmMgKGN1cnJlbnRUb2tlbjogc3RyaW5nKSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgdG9rZW46ICduZXctand0LXRva2VuJyxcbiAgICAgICAgICAgIGV4cGlyZXNJbjogMzYwMFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvYXV0aC9yZWZyZXNoJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2N1cnJlbnRUb2tlbn1gXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuKCdvbGQtdG9rZW4nKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC50b2tlbikudG9CZSgnbmV3LWp3dC10b2tlbicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHN0b3JlIGFuZCByZXRyaWV2ZSB0b2tlbnMgc2VjdXJlbHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdG9yZVRva2VuID0gKHRva2VuOiBzdHJpbmcsIHJlbWVtYmVyTWU6IGJvb2xlYW4gPSBmYWxzZSkgPT4ge1xuICAgICAgICBpZiAocmVtZW1iZXJNZSkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2tlbicsIHRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCd0b2tlbicsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgZ2V0U3RvcmVkVG9rZW4gPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSB8fCBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY2xlYXJTdG9yZWRUb2tlbiA9ICgpID0+IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Rva2VuJyk7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ3Rva2VuJyk7XG4gICAgICB9O1xuXG4gICAgICAvLyBUZXN0IHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAgc3RvcmVUb2tlbigncGVyc2lzdGVudC10b2tlbicsIHRydWUpO1xuICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZS5zZXRJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndG9rZW4nLCAncGVyc2lzdGVudC10b2tlbicpO1xuXG4gICAgICAvLyBUZXN0IHNlc3Npb24gc3RvcmFnZVxuICAgICAgc3RvcmVUb2tlbignc2Vzc2lvbi10b2tlbicsIGZhbHNlKTtcbiAgICAgIGV4cGVjdChzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndG9rZW4nLCAnc2Vzc2lvbi10b2tlbicpO1xuXG4gICAgICAvLyBNb2NrIHJldHVybiB2YWx1ZXMgZm9yIHJldHJpZXZhbCB0ZXN0XG4gICAgICAobG9jYWxTdG9yYWdlLmdldEl0ZW0gYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoJ3N0b3JlZC10b2tlbicpO1xuICAgICAgZXhwZWN0KGdldFN0b3JlZFRva2VuKCkpLnRvQmUoJ3N0b3JlZC10b2tlbicpO1xuXG4gICAgICAvLyBUZXN0IGNsZWFyaW5nXG4gICAgICBjbGVhclN0b3JlZFRva2VuKCk7XG4gICAgICBleHBlY3QobG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0b2tlbicpO1xuICAgICAgZXhwZWN0KHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0b2tlbicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVybWlzc2lvbiBTeXN0ZW0nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNoZWNrIHVzZXIgcGVybWlzc2lvbnMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgaGFzUGVybWlzc2lvbiA9ICh1c2VyUGVybWlzc2lvbnM6IHN0cmluZ1tdLCByZXF1aXJlZFBlcm1pc3Npb246IHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gdXNlclBlcm1pc3Npb25zLmluY2x1ZGVzKHJlcXVpcmVkUGVybWlzc2lvbikgfHwgdXNlclBlcm1pc3Npb25zLmluY2x1ZGVzKCdhZG1pbjphbGwnKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVzZXJQZXJtaXNzaW9ucyA9IFsnc2FsZXM6dmlldycsICdzYWxlczpjcmVhdGUnLCAnaW52ZW50b3J5OnZpZXcnXTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGhhc1Blcm1pc3Npb24odXNlclBlcm1pc3Npb25zLCAnc2FsZXM6dmlldycpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGhhc1Blcm1pc3Npb24odXNlclBlcm1pc3Npb25zLCAnc2FsZXM6Y3JlYXRlJykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoaGFzUGVybWlzc2lvbih1c2VyUGVybWlzc2lvbnMsICdzYWxlczpkZWxldGUnKSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoaGFzUGVybWlzc2lvbihbJ2FkbWluOmFsbCddLCAnYW55OnBlcm1pc3Npb24nKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBjaGVjayBtdWx0aXBsZSBwZXJtaXNzaW9ucyAoQU5EIGxvZ2ljKScsICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc0FsbFBlcm1pc3Npb25zID0gKHVzZXJQZXJtaXNzaW9uczogc3RyaW5nW10sIHJlcXVpcmVkUGVybWlzc2lvbnM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIHJldHVybiByZXF1aXJlZFBlcm1pc3Npb25zLmV2ZXJ5KHBlcm1pc3Npb24gPT4gXG4gICAgICAgICAgdXNlclBlcm1pc3Npb25zLmluY2x1ZGVzKHBlcm1pc3Npb24pIHx8IHVzZXJQZXJtaXNzaW9ucy5pbmNsdWRlcygnYWRtaW46YWxsJylcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVzZXJQZXJtaXNzaW9ucyA9IFsnc2FsZXM6dmlldycsICdzYWxlczpjcmVhdGUnLCAnaW52ZW50b3J5OnZpZXcnXTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGhhc0FsbFBlcm1pc3Npb25zKHVzZXJQZXJtaXNzaW9ucywgWydzYWxlczp2aWV3JywgJ2ludmVudG9yeTp2aWV3J10pKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGhhc0FsbFBlcm1pc3Npb25zKHVzZXJQZXJtaXNzaW9ucywgWydzYWxlczp2aWV3JywgJ3NhbGVzOmRlbGV0ZSddKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgY2hlY2sgYW55IHBlcm1pc3Npb24gKE9SIGxvZ2ljKScsICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc0FueVBlcm1pc3Npb24gPSAodXNlclBlcm1pc3Npb25zOiBzdHJpbmdbXSwgcmVxdWlyZWRQZXJtaXNzaW9uczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmVkUGVybWlzc2lvbnMuc29tZShwZXJtaXNzaW9uID0+IFxuICAgICAgICAgIHVzZXJQZXJtaXNzaW9ucy5pbmNsdWRlcyhwZXJtaXNzaW9uKSB8fCB1c2VyUGVybWlzc2lvbnMuaW5jbHVkZXMoJ2FkbWluOmFsbCcpXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1c2VyUGVybWlzc2lvbnMgPSBbJ3NhbGVzOnZpZXcnLCAnaW52ZW50b3J5OnZpZXcnXTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGhhc0FueVBlcm1pc3Npb24odXNlclBlcm1pc3Npb25zLCBbJ3NhbGVzOnZpZXcnLCAnc2FsZXM6ZGVsZXRlJ10pKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGhhc0FueVBlcm1pc3Npb24odXNlclBlcm1pc3Npb25zLCBbJ2FkbWluOmRlbGV0ZScsICdhZG1pbjpjcmVhdGUnXSkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHZhbGlkYXRlIHJvbGUtYmFzZWQgcGVybWlzc2lvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBnZXRSb2xlUGVybWlzc2lvbnMgPSAocm9sZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvbGVQZXJtaXNzaW9uczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge1xuICAgICAgICAgICdhZG1pbic6IFsnYWRtaW46YWxsJ10sXG4gICAgICAgICAgJ21hbmFnZXInOiBbJ3NhbGVzOmFsbCcsICdpbnZlbnRvcnk6YWxsJywgJ2N1c3RvbWVyczphbGwnXSxcbiAgICAgICAgICAnc2FsZXMnOiBbJ3NhbGVzOnZpZXcnLCAnc2FsZXM6Y3JlYXRlJywgJ2N1c3RvbWVyczp2aWV3JywgJ2N1c3RvbWVyczpjcmVhdGUnXSxcbiAgICAgICAgICAnaW52ZW50b3J5JzogWydpbnZlbnRvcnk6dmlldycsICdpbnZlbnRvcnk6Y3JlYXRlJywgJ2ludmVudG9yeTplZGl0J10sXG4gICAgICAgICAgJ3ZpZXdlcic6IFsnc2FsZXM6dmlldycsICdpbnZlbnRvcnk6dmlldycsICdjdXN0b21lcnM6dmlldyddXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcm9sZVBlcm1pc3Npb25zW3JvbGVdIHx8IFtdO1xuICAgICAgfTtcblxuICAgICAgZXhwZWN0KGdldFJvbGVQZXJtaXNzaW9ucygnYWRtaW4nKSkudG9Db250YWluKCdhZG1pbjphbGwnKTtcbiAgICAgIGV4cGVjdChnZXRSb2xlUGVybWlzc2lvbnMoJ3NhbGVzJykpLnRvQ29udGFpbignc2FsZXM6dmlldycpO1xuICAgICAgZXhwZWN0KGdldFJvbGVQZXJtaXNzaW9ucygnc2FsZXMnKSkudG9Db250YWluKCdjdXN0b21lcnM6Y3JlYXRlJyk7XG4gICAgICBleHBlY3QoZ2V0Um9sZVBlcm1pc3Npb25zKCd2aWV3ZXInKSkubm90LnRvQ29udGFpbignc2FsZXM6Y3JlYXRlJyk7XG4gICAgICBleHBlY3QoZ2V0Um9sZVBlcm1pc3Npb25zKCd1bmtub3duJykpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2Vzc2lvbiBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB0cmFjayB1c2VyIHNlc3Npb24gYWN0aXZpdHknLCAoKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVMYXN0QWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ2xhc3RBY3Rpdml0eScsIHRpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRpbWVzdGFtcDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGdldExhc3RBY3Rpdml0eSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnbGFzdEFjdGl2aXR5Jyk7XG4gICAgICAgIHJldHVybiB0aW1lc3RhbXAgPyBwYXJzZUludCh0aW1lc3RhbXApIDogbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGlzU2Vzc2lvbkV4cGlyZWQgPSAobWF4SW5hY3RpdmVUaW1lOiBudW1iZXIgPSAzMCAqIDYwICogMTAwMCkgPT4geyAvLyAzMCBtaW51dGVzXG4gICAgICAgIGNvbnN0IGxhc3RBY3Rpdml0eSA9IGdldExhc3RBY3Rpdml0eSgpO1xuICAgICAgICBpZiAoIWxhc3RBY3Rpdml0eSkgcmV0dXJuIHRydWU7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxhc3RBY3Rpdml0eSA+IG1heEluYWN0aXZlVGltZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgc2Vzc2lvblN0b3JhZ2UgYmVoYXZpb3JcbiAgICAgIGxldCBtb2NrU3RvcmFnZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgICAgKHNlc3Npb25TdG9yYWdlLnNldEl0ZW0gYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgbW9ja1N0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICAoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbigoa2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBtb2NrU3RvcmFnZVtrZXldIHx8IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdGltZXN0YW1wID0gdXBkYXRlTGFzdEFjdGl2aXR5KCk7XG4gICAgICBleHBlY3Qoc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2xhc3RBY3Rpdml0eScsIHRpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCBzZXNzaW9uIG5vdCBleHBpcmVkXG4gICAgICBleHBlY3QoaXNTZXNzaW9uRXhwaXJlZCg2MCAqIDYwICogMTAwMCkpLnRvQmUoZmFsc2UpOyAvLyAxIGhvdXIgbGltaXRcbiAgICAgIFxuICAgICAgLy8gVGVzdCBzZXNzaW9uIGV4cGlyZWRcbiAgICAgIG1vY2tTdG9yYWdlWydsYXN0QWN0aXZpdHknXSA9IChEYXRlLm5vdygpIC0gNjAgKiA2MCAqIDEwMDApLnRvU3RyaW5nKCk7IC8vIDEgaG91ciBhZ29cbiAgICAgIGV4cGVjdChpc1Nlc3Npb25FeHBpcmVkKDMwICogNjAgKiAxMDAwKSkudG9CZSh0cnVlKTsgLy8gMzAgbWludXRlIGxpbWl0XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgc2Vzc2lvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBnZW5lcmF0ZVNlc3Npb25JZCA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB2YWxpZGF0ZVNlc3Npb25JZCA9IChzZXNzaW9uSWQ6IHN0cmluZywgdXNlclNlc3Npb25zOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICByZXR1cm4gdXNlclNlc3Npb25zLmluY2x1ZGVzKHNlc3Npb25JZCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBhZGRTZXNzaW9uID0gKHVzZXJTZXNzaW9uczogc3RyaW5nW10sIHNlc3Npb25JZDogc3RyaW5nLCBtYXhTZXNzaW9uczogbnVtYmVyID0gMykgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkU2Vzc2lvbnMgPSBbLi4udXNlclNlc3Npb25zLCBzZXNzaW9uSWRdO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIG9sZGVzdCBzZXNzaW9ucyBpZiBsaW1pdCBleGNlZWRlZFxuICAgICAgICBpZiAodXBkYXRlZFNlc3Npb25zLmxlbmd0aCA+IG1heFNlc3Npb25zKSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZWRTZXNzaW9ucy5zbGljZSgtbWF4U2Vzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdXBkYXRlZFNlc3Npb25zO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2Vzc2lvbklkMSA9IGdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gICAgICBjb25zdCBzZXNzaW9uSWQyID0gZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHNlc3Npb25JZDEpLnRvQmUoJ21vY2stdXVpZC0xMjMnKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVNlc3Npb25JZChzZXNzaW9uSWQxLCBbc2Vzc2lvbklkMSwgc2Vzc2lvbklkMl0pKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRlU2Vzc2lvbklkKCdpbnZhbGlkLXNlc3Npb24nLCBbc2Vzc2lvbklkMSwgc2Vzc2lvbklkMl0pKS50b0JlKGZhbHNlKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2Vzc2lvbnMgPSBhZGRTZXNzaW9uKFsnc2Vzc2lvbjEnLCAnc2Vzc2lvbjInLCAnc2Vzc2lvbjMnXSwgJ3Nlc3Npb240JywgMyk7XG4gICAgICBleHBlY3Qoc2Vzc2lvbnMpLnRvRXF1YWwoWydzZXNzaW9uMicsICdzZXNzaW9uMycsICdzZXNzaW9uNCddKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Bhc3N3b3JkIFNlY3VyaXR5JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB2YWxpZGF0ZSBwYXNzd29yZCBzdHJlbmd0aCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlUGFzc3dvcmRTdHJlbmd0aCA9IChwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCEvW0EtWl0vLnRlc3QocGFzc3dvcmQpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdXBwZXJjYXNlIGxldHRlcicpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIS9bYS16XS8udGVzdChwYXNzd29yZCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaCgnUGFzc3dvcmQgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBsb3dlcmNhc2UgbGV0dGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghL1xcZC8udGVzdChwYXNzd29yZCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaCgnUGFzc3dvcmQgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCEvWyFAIyQlXiYqKCksLj9cIjp7fXw8Pl0vLnRlc3QocGFzc3dvcmQpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgc3BlY2lhbCBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICBzdHJlbmd0aDogZXJyb3JzLmxlbmd0aCA9PT0gMCA/ICdzdHJvbmcnIDogZXJyb3JzLmxlbmd0aCA8PSAyID8gJ21lZGl1bScgOiAnd2VhaydcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHN0cm9uZ1Bhc3N3b3JkID0gdmFsaWRhdGVQYXNzd29yZFN0cmVuZ3RoKCdTdHJvbmdQYXNzMTIzIScpO1xuICAgICAgZXhwZWN0KHN0cm9uZ1Bhc3N3b3JkLmlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3Qoc3Ryb25nUGFzc3dvcmQuc3RyZW5ndGgpLnRvQmUoJ3N0cm9uZycpO1xuICAgICAgXG4gICAgICBjb25zdCB3ZWFrUGFzc3dvcmQgPSB2YWxpZGF0ZVBhc3N3b3JkU3RyZW5ndGgoJ3dlYWsnKTtcbiAgICAgIGV4cGVjdCh3ZWFrUGFzc3dvcmQuaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3Qod2Vha1Bhc3N3b3JkLnN0cmVuZ3RoKS50b0JlKCd3ZWFrJyk7XG4gICAgICBleHBlY3Qod2Vha1Bhc3N3b3JkLmVycm9ycykudG9Db250YWluKCdQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDggY2hhcmFjdGVycyBsb25nJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIHBhc3N3b3JkIHJlc2V0IGZsb3cnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0UGFzc3dvcmRSZXNldCA9IGFzeW5jIChlbWFpbDogc3RyaW5nKSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1Bhc3N3b3JkIHJlc2V0IGVtYWlsIHNlbnQnLFxuICAgICAgICAgICAgcmVzZXRUb2tlbjogJ3Jlc2V0LXRva2VuLTEyMydcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2F1dGgvZm9yZ290LXBhc3N3b3JkJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc2V0UGFzc3dvcmQgPSBhc3luYyAodG9rZW46IHN0cmluZywgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdQYXNzd29yZCByZXNldCBzdWNjZXNzZnVsbHknXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hdXRoL3Jlc2V0LXBhc3N3b3JkJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdG9rZW4sIG5ld1Bhc3N3b3JkIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNldFJlcXVlc3QgPSBhd2FpdCByZXF1ZXN0UGFzc3dvcmRSZXNldCgndXNlckBleGFtcGxlLmNvbScpO1xuICAgICAgZXhwZWN0KHJlc2V0UmVxdWVzdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc2V0UmVxdWVzdC5yZXNldFRva2VuKS50b0JlKCdyZXNldC10b2tlbi0xMjMnKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGFzc3dvcmRSZXNldCA9IGF3YWl0IHJlc2V0UGFzc3dvcmQoJ3Jlc2V0LXRva2VuLTEyMycsICdOZXdQYXNzd29yZDEyMyEnKTtcbiAgICAgIGV4cGVjdChwYXNzd29yZFJlc2V0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUd28tRmFjdG9yIEF1dGhlbnRpY2F0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSBhbmQgdmFsaWRhdGUgVE9UUCBjb2RlcycsICgpID0+IHtcbiAgICAgIC8vIE1vY2sgVE9UUCBnZW5lcmF0aW9uIChzaW1wbGlmaWVkKVxuICAgICAgY29uc3QgZ2VuZXJhdGVUT1RQID0gKHNlY3JldDogc3RyaW5nLCB0aW1lU3RlcDogbnVtYmVyID0gMzApID0+IHtcbiAgICAgICAgY29uc3QgdGltZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDAgLyB0aW1lU3RlcCk7XG4gICAgICAgIC8vIFNpbXBsaWZpZWQgVE9UUCBnZW5lcmF0aW9uIGZvciB0ZXN0aW5nXG4gICAgICAgIHJldHVybiAoKHRpbWUgKyBzZWNyZXQubGVuZ3RoKSAlIDEwMDAwMDApLnRvU3RyaW5nKCkucGFkU3RhcnQoNiwgJzAnKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRlVE9UUCA9IChjb2RlOiBzdHJpbmcsIHNlY3JldDogc3RyaW5nLCB0b2xlcmFuY2U6IG51bWJlciA9IDEpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwIC8gMzApO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IC10b2xlcmFuY2U7IGkgPD0gdG9sZXJhbmNlOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB0aW1lU3RlcCA9IGN1cnJlbnRUaW1lICsgaTtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZENvZGUgPSAoKHRpbWVTdGVwICsgc2VjcmV0Lmxlbmd0aCkgJSAxMDAwMDAwKS50b1N0cmluZygpLnBhZFN0YXJ0KDYsICcwJyk7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IGV4cGVjdGVkQ29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZWNyZXQgPSAndXNlci1zZWNyZXQta2V5JztcbiAgICAgIGNvbnN0IGNvZGUgPSBnZW5lcmF0ZVRPVFAoc2VjcmV0KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGNvZGUpLnRvSGF2ZUxlbmd0aCg2KTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVRPVFAoY29kZSwgc2VjcmV0KSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0ZVRPVFAoJzAwMDAwMCcsIHNlY3JldCkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSAyRkEgc2V0dXAgYW5kIHZlcmlmaWNhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNldHVwMkZBID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgc2VjcmV0OiAnSkJTV1kzRFBFSFBLM1BYUCcsXG4gICAgICAgICAgICBxckNvZGU6ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsbW9jay1xci1jb2RlJyxcbiAgICAgICAgICAgIGJhY2t1cENvZGVzOiBbJzEyMzQ1NicsICc3ODkwMTInLCAnMzQ1Njc4J11cbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2F1dGgvMmZhL3NldHVwJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9jay10b2tlbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB2ZXJpZnkyRkEgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIGNvZGU6IHN0cmluZykgPT4ge1xuICAgICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICcyRkEgZW5hYmxlZCBzdWNjZXNzZnVsbHknXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hdXRoLzJmYS92ZXJpZnknLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQsIGNvZGUgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gYXdhaXQgc2V0dXAyRkEoJ3VzZXIxMjMnKTtcbiAgICAgIGV4cGVjdChzZXR1cFJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHNldHVwUmVzdWx0LnNlY3JldCkudG9CZSgnSkJTV1kzRFBFSFBLM1BYUCcpO1xuICAgICAgZXhwZWN0KHNldHVwUmVzdWx0LmJhY2t1cENvZGVzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHZlcmlmeVJlc3VsdCA9IGF3YWl0IHZlcmlmeTJGQSgndXNlcjEyMycsICcxMjM0NTYnKTtcbiAgICAgIGV4cGVjdCh2ZXJpZnlSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJ1c2VBdXRoIiwibW9ja1VzZUF1dGgiLCJ1c2VSb3V0ZXIiLCJwdXNoIiwiZm4iLCJyZXBsYWNlIiwiYmFjayIsImZvcndhcmQiLCJyZWZyZXNoIiwicHJlZmV0Y2giLCJtb2NrRmV0Y2giLCJnbG9iYWwiLCJmZXRjaCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJyYW5kb21VVUlEIiwiZ2V0UmFuZG9tVmFsdWVzIiwiYXJyIiwiaSIsImxlbmd0aCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ3aW5kb3ciLCJnZXRJdGVtIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJjbGVhciIsIndyaXRhYmxlIiwidGVzdCIsInZhbGlkYXRlTG9naW5DcmVkZW50aWFscyIsImVtYWlsIiwicGFzc3dvcmQiLCJlcnJvcnMiLCJ0cmltIiwiZXhwZWN0IiwidG9FcXVhbCIsInRvQ29udGFpbiIsImxvZ2luIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJqc29uIiwic3VjY2VzcyIsInRva2VuIiwidXNlciIsImlkIiwibmFtZSIsInBlcm1pc3Npb25zIiwiZXhwaXJlc0luIiwicmVzcG9uc2UiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN1bHQiLCJ0b0JlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJzdGF0dXMiLCJtZXNzYWdlIiwiZGF0YSIsImxvZ291dCIsImxvY2FsU3RvcmFnZSIsInNlc3Npb25TdG9yYWdlIiwidG9IYXZlQmVlbkNhbGxlZCIsImlzVmFsaWRKV1RGb3JtYXQiLCJwYXJ0cyIsInNwbGl0IiwiaXNUb2tlbkV4cGlyZWQiLCJwYXlsb2FkIiwicGFyc2UiLCJhdG9iIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwiZXhwIiwiZnV0dXJlRXhwIiwidmFsaWRUb2tlbiIsImJ0b2EiLCJwYXN0RXhwIiwiZXhwaXJlZFRva2VuIiwicmVmcmVzaFRva2VuIiwiY3VycmVudFRva2VuIiwic3RvcmVUb2tlbiIsInJlbWVtYmVyTWUiLCJnZXRTdG9yZWRUb2tlbiIsImNsZWFyU3RvcmVkVG9rZW4iLCJtb2NrUmV0dXJuVmFsdWUiLCJoYXNQZXJtaXNzaW9uIiwidXNlclBlcm1pc3Npb25zIiwicmVxdWlyZWRQZXJtaXNzaW9uIiwiaW5jbHVkZXMiLCJoYXNBbGxQZXJtaXNzaW9ucyIsInJlcXVpcmVkUGVybWlzc2lvbnMiLCJldmVyeSIsInBlcm1pc3Npb24iLCJoYXNBbnlQZXJtaXNzaW9uIiwic29tZSIsImdldFJvbGVQZXJtaXNzaW9ucyIsInJvbGUiLCJyb2xlUGVybWlzc2lvbnMiLCJub3QiLCJ1cGRhdGVMYXN0QWN0aXZpdHkiLCJ0aW1lc3RhbXAiLCJ0b1N0cmluZyIsImdldExhc3RBY3Rpdml0eSIsInBhcnNlSW50IiwiaXNTZXNzaW9uRXhwaXJlZCIsIm1heEluYWN0aXZlVGltZSIsImxhc3RBY3Rpdml0eSIsIm1vY2tTdG9yYWdlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwia2V5IiwiZ2VuZXJhdGVTZXNzaW9uSWQiLCJjcnlwdG8iLCJ2YWxpZGF0ZVNlc3Npb25JZCIsInNlc3Npb25JZCIsInVzZXJTZXNzaW9ucyIsImFkZFNlc3Npb24iLCJtYXhTZXNzaW9ucyIsInVwZGF0ZWRTZXNzaW9ucyIsInNsaWNlIiwic2Vzc2lvbklkMSIsInNlc3Npb25JZDIiLCJzZXNzaW9ucyIsInZhbGlkYXRlUGFzc3dvcmRTdHJlbmd0aCIsImlzVmFsaWQiLCJzdHJlbmd0aCIsInN0cm9uZ1Bhc3N3b3JkIiwid2Vha1Bhc3N3b3JkIiwicmVxdWVzdFBhc3N3b3JkUmVzZXQiLCJyZXNldFRva2VuIiwicmVzZXRQYXNzd29yZCIsIm5ld1Bhc3N3b3JkIiwicmVzZXRSZXF1ZXN0IiwicGFzc3dvcmRSZXNldCIsImdlbmVyYXRlVE9UUCIsInNlY3JldCIsInRpbWVTdGVwIiwidGltZSIsInBhZFN0YXJ0IiwidmFsaWRhdGVUT1RQIiwiY29kZSIsInRvbGVyYW5jZSIsImV4cGVjdGVkQ29kZSIsInRvSGF2ZUxlbmd0aCIsInNldHVwMkZBIiwidXNlcklkIiwicXJDb2RlIiwiYmFja3VwQ29kZXMiLCJ2ZXJpZnkyRkEiLCJzZXR1cFJlc3VsdCIsInZlcmlmeVJlc3VsdCJdLCJtYXBwaW5ncyI6IjtBQUtBQSxLQUFLQyxJQUFJLENBQUMsbUJBQW1CLElBQU8sQ0FBQTtRQUNsQ0MsU0FBUyxJQUFNQztJQUNqQixDQUFBO0FB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