{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/services/authService.ts"],"sourcesContent":["import * as bcrypt from 'bcryptjs';\nimport * as jwt from 'jsonwebtoken';\nimport prisma, { safeQuery } from '@/lib/prisma';\nimport { cacheService, CACHE_CONFIG } from '../lib/cache';\nimport { hasPermission as checkPermission } from '../lib/utils/permissions';\n\n// Secret key for JWT - should be moved to environment variables in production\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';\n// Changed token expiration to 12h (from 24h) for better security\nconst JWT_EXPIRES_IN = process.env.JWT_ACCESS_TOKEN_EXPIRES_IN || '12h';\n\n/**\n * Parses a time string like \"15m\", \"2h\", \"1d\" into seconds.\n * @param timeStr The time string.\n * @returns The number of seconds, or 0 if parsing fails.\n */\nexport const parseTimeStringToSeconds = (timeStr: string): number => {\n    if (!timeStr) return 0;\n    const lastChar = timeStr.slice(-1);\n    const num = parseInt(timeStr.slice(0, -1));\n\n    if (isNaN(num)) return 0;\n\n    switch (lastChar) {\n        case 's': return num;\n        case 'm': return num * 60;\n        case 'h': return num * 60 * 60;\n        case 'd': return num * 60 * 60 * 24;\n        default: // If no unit, assume seconds if it's just a number string\n            if (!isNaN(parseInt(timeStr))) return parseInt(timeStr);\n            return 0;\n    }\n};\n\ninterface TokenPayload {\n    sub: number; // User ID as 'sub' claim\n    username: string;\n    email: string;\n    roleId: number;\n    roleName: string | null;\n    shopId?: number | null;\n    permissions?: string[];\n}\n\n/**\n * Authenticate a user with email and password (optimized with single query)\n */\nexport const authenticateUser = async (email: string, password: string) => {\n    try {\n        console.time('user authentication query');\n        // Optimized single query using the new composite index with retry logic\n        const user = await safeQuery(\n            () => prisma.user.findFirst({\n                where: {\n                    email: email,\n                    isActive: true\n                },\n                select: {\n                    id: true,\n                    name: true,\n                    email: true,\n                    password: true,\n                    roleId: true,\n                    roleName: true,\n                    shopId: true,\n                    permissions: true,\n                    role: {\n                        include: {\n                            permissions: {\n                                select: { name: true }\n                            }\n                        }\n                    }\n                }\n            }),\n            null,\n            'Failed to find user during authentication'\n        ) as any;\n        console.timeEnd('user authentication query');\n\n        // If user not found\n        if (!user) {\n            return {\n                success: false,\n                message: 'Invalid email or password'\n            };\n        }\n\n        // Verify password\n        const isPasswordValid = await bcrypt.compare(password, user.password);\n        if (!isPasswordValid) {\n            return {\n                success: false,\n                message: 'Invalid email or password'\n            };\n        }\n\n        // Get permissions from both the user's direct permissions and their role\n        let directPermissions: string[] = [];\n        let rolePermissions: string[] = [];\n\n        if (user.permissions && Array.isArray(user.permissions)) {\n            const permissionNames = user.permissions.filter((p: string) => isNaN(parseInt(p, 10)));\n            const permissionIds = user.permissions.filter((p: string) => !isNaN(parseInt(p, 10))).map((id: string) => parseInt(id, 10));\n\n            if (permissionIds.length > 0) {\n                const fetchedPermissions = await prisma.permission.findMany({\n                    where: { id: { in: permissionIds } },\n                    select: { name: true }\n                });\n                directPermissions = [...permissionNames, ...fetchedPermissions.map(p => p.name)];\n            } else {\n                directPermissions = permissionNames;\n            }\n        }\n\n        if (user.role?.permissions) {\n            rolePermissions = user.role.permissions.map((p: { name: string }) => p.name);\n        }\n\n        // Merge and deduplicate permissions\n        const allPermissions = Array.from(new Set([...directPermissions, ...rolePermissions]));\n\n        console.log('Final user permissions being returned:', allPermissions);\n        \n        // Generate JWT token\n        const token = generateToken({\n            sub: user.id,\n            username: user.name,\n            email: user.email,\n            roleId: user.roleId,\n            roleName: user.roleName || user.role?.name || null,\n            shopId: user.shopId,\n            permissions: allPermissions,\n        });\n\n        const userSession = {\n            id: user.id,\n            username: user.name,\n            fullName: user.name,\n            email: user.email,\n            roleId: user.roleId,\n            roleName: user.roleName || user.role?.name || null,\n            shopId: user.shopId,\n            permissions: allPermissions,\n            role: user.role\n        };\n\n        // Cache user session for faster subsequent requests\n        const cacheKey = cacheService.generateKey(CACHE_CONFIG.KEYS.USER_SESSION, { userId: user.id });\n        await cacheService.set(cacheKey, userSession, CACHE_CONFIG.TTL.USER_SESSION);\n\n        return {\n            success: true,\n            token,\n            user: {\n                id: user.id,\n                username: user.name,\n                fullName: user.name,\n                email: user.email,\n                roleId: user.roleId,\n                roleName: user.roleName || user.role?.name || null,\n                shopId: user.shopId,\n                permissions: allPermissions,\n            }\n        };\n    } catch (error) {\n        console.error('Authentication error:', error);\n        return {\n            success: false,\n            message: 'Authentication failed'\n        };\n    }\n};\n\n/**\n * Generate a JWT token\n */\nexport const generateToken = (payload: TokenPayload) => {\n    return jwt.sign(payload, JWT_SECRET as string, { expiresIn: JWT_EXPIRES_IN as any });\n};\n\n/**\n * Verify a JWT token with caching\n */\nexport const verifyToken = async (token: string) => {\n    // Validate token input\n    if (!token || token.trim() === '') {\n        throw new Error('jwt must be provided');\n    }\n\n    try {\n        // Verify token first\n        const decoded = jwt.verify(token, JWT_SECRET) as unknown as TokenPayload;\n\n        // Only generate cache key for valid tokens (ensure token is long enough for substring)\n        if (token.length >= 20) {\n            const tokenKey = cacheService.generateKey(CACHE_CONFIG.KEYS.TOKEN_VALIDATION, { token: token.substring(0, 20) });\n            \n            // Check cache first for token validation result\n            const cachedResult = await cacheService.get(tokenKey);\n            if (cachedResult) {\n                return cachedResult as TokenPayload;\n            }\n\n            // Cache the valid token payload (shorter TTL for security)\n            await cacheService.set(tokenKey, decoded, CACHE_CONFIG.TTL.TOKEN_VALIDATION);\n        }\n\n        return decoded;\n    } catch (error) {\n        // Log the error here if desired\n        if (error instanceof jwt.TokenExpiredError) {\n            console.error('Token expired during verification:', error.expiredAt);\n        } else if (error instanceof jwt.JsonWebTokenError) {\n            console.error('Invalid token during verification:', error.message);\n        } else {\n            console.error('Unknown token verification error:', error);\n        }\n        throw error; // Re-throw the error\n    }\n};\n\n/**\n * Check if a token has a specific permission with caching\n */\nexport const hasPermission = async (tokenPayload: TokenPayload, permission: string) => {\n    // Use the imported permission checking utility\n    \n    // Quick check from token payload first\n    if (tokenPayload.permissions) {\n        if (checkPermission(tokenPayload.permissions, permission)) {\n            return true;\n        }\n    }\n\n    // If not in token, check cached user permissions\n    const permissionsCacheKey = cacheService.generateKey(CACHE_CONFIG.KEYS.USER_PERMISSIONS, { userId: tokenPayload.sub });\n\n    try {\n        const cachedPermissions = await cacheService.get(permissionsCacheKey);\n        if (cachedPermissions) {\n            return checkPermission(cachedPermissions, permission);\n        }\n\n        // Fallback to database query if not cached\n        const user = await safeQuery(\n            () => prisma.user.findFirst({\n                where: { id: String(tokenPayload.sub), isActive: true },\n                include: {\n                    role: {\n                        include: {\n                            permissions: { select: { name: true } }\n                        }\n                    }\n                }\n            }),\n            null,\n            'Failed to find user for permission check'\n        ) as any;\n\n        if (user) {\n            // Combine role permissions and direct user permissions\n            const rolePermissions = user.role?.permissions?.map((p: any) => p.name) || [];\n            const directPermissions = user.permissions || [];\n            \n            // Convert permission IDs to names if needed\n            let convertedDirectPermissions: string[] = [];\n            if (directPermissions.length > 0) {\n                const firstPermission = directPermissions[0];\n                if (typeof firstPermission === 'number' || (typeof firstPermission === 'string' && !isNaN(parseInt(firstPermission)))) {\n                    // Permissions are stored as IDs, need to convert to names\n                    const permissionIds = directPermissions\n                        .map((id: any) => parseInt(id.toString()))\n                        .filter((id: number) => !isNaN(id));\n                    \n                    if (permissionIds.length > 0) {\n                        try {\n                            const permissionRecords = await safeQuery(\n                                () => prisma.permission.findMany({\n                                    where: {\n                                        id: {\n                                            in: permissionIds\n                                        }\n                                    },\n                                    select: { name: true }\n                                }),\n                                [],\n                                'Failed to find permissions by IDs'\n                            );\n                            convertedDirectPermissions = (permissionRecords as any[]).map((p: any) => p.name);\n                        } catch (error) {\n                            console.error('Error converting permission IDs to names:', error);\n                            convertedDirectPermissions = [];\n                        }\n                    }\n                } else {\n                    // Permissions are already stored as names\n                    convertedDirectPermissions = directPermissions;\n                }\n            }\n            \n            // Combine all permissions and remove duplicates\n            const allPermissions = [...rolePermissions, ...convertedDirectPermissions];\n            const permissions = Array.from(new Set(allPermissions));\n            \n            // Cache permissions for future checks\n            await cacheService.set(permissionsCacheKey, permissions, CACHE_CONFIG.TTL.USER_PERMISSIONS);\n            return checkPermission(permissions, permission);\n        }\n    } catch (error) {\n        console.error('Error checking permissions:', error);\n    }\n\n    return false;\n};\n\n/**\n * Get user details from a decoded token payload with caching\n */\nexport const getUserFromDecodedPayload = async (payload: TokenPayload | null) => {\n    console.log('getUserFromDecodedPayload received payload:', payload);\n    process.stderr.write(`DEBUG: getUserFromDecodedPayload called with payload: ${JSON.stringify(payload)}\\n`);\n\n    if (!payload) {\n        console.error('Invalid token payload provided to getUserFromDecodedPayload');\n        process.stderr.write('DEBUG: Invalid payload or missing sub, returning null\\n');\n        return null;\n    }\n\n    if (!payload.sub) {\n        console.error('Token payload missing user ID (sub claim)');\n        process.stderr.write('DEBUG: Invalid payload or missing sub, returning null\\n');\n        return null;\n    }\n\n    const userId = payload.sub;\n    process.stderr.write(`DEBUG: About to call cacheService.generateKey with userId: ${userId}\\n`);\n    const cacheKey = cacheService.generateKey(CACHE_CONFIG.KEYS.USER_SESSION, { userId });\n    process.stderr.write(`DEBUG: Generated cache key: ${cacheKey}\\n`);\n\n    try {\n        // Try to get user from cache first\n        const cachedUser = await cacheService.get(cacheKey);\n        if (cachedUser) {\n            console.log('User found in cache:', userId);\n            return cachedUser;\n        }\n\n        console.log('Looking up user with ID:', userId);\n        console.time('prisma.user.findFirst for auth'); // Start timer\n        const user = await safeQuery(\n            () => prisma.user.findFirst({\n                where: {\n                    id: String(userId),\n                    isActive: true\n                },\n                include: {\n                    role: {\n                        include: {\n                            permissions: {\n                                select: { name: true }\n                            }\n                        }\n                    }\n                }\n            }),\n            null,\n            'Failed to find user by ID for authentication'\n        ) as any;\n        console.timeEnd('prisma.user.findFirst for auth'); // End timer\n\n        if (!user) {\n            console.error('User not found for ID:', userId);\n            return null;\n        }\n\n        // Combine role permissions and direct user permissions\n        const rolePermissions = user.role?.permissions?.map((p: any) => p.name) || [];\n        const directPermissions = user.permissions || [];\n        \n        // Convert permission IDs to names if needed\n        let convertedDirectPermissions: string[] = [];\n        if (Array.isArray(directPermissions) && directPermissions.length > 0) {\n            // Check if permissions are stored as IDs (numbers) or names (strings)\n            const firstPermission = directPermissions[0];\n            if (typeof firstPermission === 'number' || (typeof firstPermission === 'string' && !isNaN(parseInt(firstPermission)))) {\n                // Permissions are stored as IDs, need to convert to names\n                const permissionIds = directPermissions\n                    .map((id: any) => parseInt(id.toString()))\n                    .filter((id: number) => !isNaN(id));\n                \n                if (permissionIds.length > 0) {\n                    try {\n                        const permissionRecords = await safeQuery(\n                            () => prisma.permission.findMany({\n                                where: {\n                                    id: {\n                                        in: permissionIds\n                                    }\n                                },\n                                select: { name: true }\n                            }),\n                            [],\n                            'Failed to find permissions by IDs'\n                        );\n                        convertedDirectPermissions = (permissionRecords as any[]).map((p: any) => p.name);\n                    } catch (error) {\n                        console.error('Error converting permission IDs to names:', error);\n                        convertedDirectPermissions = [];\n                    }\n                }\n            } else {\n                // Permissions are already stored as names\n                convertedDirectPermissions = directPermissions;\n            }\n        }\n        \n        // Combine all permissions and remove duplicates\n        const allPermissions = [...rolePermissions, ...convertedDirectPermissions];\n        const permissions = Array.from(new Set(allPermissions));\n\n        const userWithPermissions = {\n            ...user,\n            roleName: user.role?.name || user.roleName || 'Admin',\n            permissions: permissions\n        };\n\n        // Cache the user session\n        await cacheService.set(cacheKey, userWithPermissions, CACHE_CONFIG.TTL.USER_SESSION);\n\n        console.log('User found and cached:', user.id, user.name);\n        return userWithPermissions;\n    } catch (error) {\n        console.error('Error getting user from decoded payload:', error);\n        return null;\n    }\n};\n\n/**\n * Get user details from token (Legacy - consider phasing out or refactoring)\n * This function now calls verifyToken and then getUserFromDecodedPayload.\n */\nexport const getUserFromToken = async (token: string) => {\n    const payload = await verifyToken(token);\n    return getUserFromDecodedPayload(payload);\n};"],"names":["authenticateUser","generateToken","getUserFromDecodedPayload","getUserFromToken","hasPermission","parseTimeStringToSeconds","verifyToken","JWT_SECRET","process","env","JWT_EXPIRES_IN","JWT_ACCESS_TOKEN_EXPIRES_IN","timeStr","lastChar","slice","num","parseInt","isNaN","email","password","console","time","user","safeQuery","prisma","findFirst","where","isActive","select","id","name","roleId","roleName","shopId","permissions","role","include","timeEnd","success","message","isPasswordValid","bcrypt","compare","directPermissions","rolePermissions","Array","isArray","permissionNames","filter","p","permissionIds","map","length","fetchedPermissions","permission","findMany","in","allPermissions","from","Set","log","token","sub","username","userSession","fullName","cacheKey","cacheService","generateKey","CACHE_CONFIG","KEYS","USER_SESSION","userId","set","TTL","error","payload","jwt","sign","expiresIn","trim","Error","decoded","verify","tokenKey","TOKEN_VALIDATION","substring","cachedResult","get","TokenExpiredError","expiredAt","JsonWebTokenError","tokenPayload","checkPermission","permissionsCacheKey","USER_PERMISSIONS","cachedPermissions","String","convertedDirectPermissions","firstPermission","toString","permissionRecords","stderr","write","JSON","stringify","cachedUser","userWithPermissions"],"mappings":";;;;;;;;;;;IA+CaA,gBAAgB;eAAhBA;;IAmIAC,aAAa;eAAbA;;IA8IAC,yBAAyB;eAAzBA;;IA2HAC,gBAAgB;eAAhBA;;IAzNAC,aAAa;eAAbA;;IAlNAC,wBAAwB;eAAxBA;;IAyKAC,WAAW;eAAXA;;;kEAzLW;sEACH;gEACa;uBACS;6BACM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEjD,8EAA8E;AAC9E,MAAMC,aAAaC,QAAQC,GAAG,CAACF,UAAU,IAAI;AAC7C,iEAAiE;AACjE,MAAMG,iBAAiBF,QAAQC,GAAG,CAACE,2BAA2B,IAAI;AAO3D,MAAMN,2BAA2B,CAACO;IACrC,IAAI,CAACA,SAAS,OAAO;IACrB,MAAMC,WAAWD,QAAQE,KAAK,CAAC,CAAC;IAChC,MAAMC,MAAMC,SAASJ,QAAQE,KAAK,CAAC,GAAG,CAAC;IAEvC,IAAIG,MAAMF,MAAM,OAAO;IAEvB,OAAQF;QACJ,KAAK;YAAK,OAAOE;QACjB,KAAK;YAAK,OAAOA,MAAM;QACvB,KAAK;YAAK,OAAOA,MAAM,KAAK;QAC5B,KAAK;YAAK,OAAOA,MAAM,KAAK,KAAK;QACjC;YACI,IAAI,CAACE,MAAMD,SAASJ,WAAW,OAAOI,SAASJ;YAC/C,OAAO;IACf;AACJ;AAeO,MAAMZ,mBAAmB,OAAOkB,OAAeC;IAClD,IAAI;QACAC,QAAQC,IAAI,CAAC;QACb,wEAAwE;QACxE,MAAMC,OAAO,MAAMC,IAAAA,iBAAS,EACxB,IAAMC,eAAM,CAACF,IAAI,CAACG,SAAS,CAAC;gBACxBC,OAAO;oBACHR,OAAOA;oBACPS,UAAU;gBACd;gBACAC,QAAQ;oBACJC,IAAI;oBACJC,MAAM;oBACNZ,OAAO;oBACPC,UAAU;oBACVY,QAAQ;oBACRC,UAAU;oBACVC,QAAQ;oBACRC,aAAa;oBACbC,MAAM;wBACFC,SAAS;4BACLF,aAAa;gCACTN,QAAQ;oCAAEE,MAAM;gCAAK;4BACzB;wBACJ;oBACJ;gBACJ;YACJ,IACA,MACA;QAEJV,QAAQiB,OAAO,CAAC;QAEhB,oBAAoB;QACpB,IAAI,CAACf,MAAM;YACP,OAAO;gBACHgB,SAAS;gBACTC,SAAS;YACb;QACJ;QAEA,kBAAkB;QAClB,MAAMC,kBAAkB,MAAMC,UAAOC,OAAO,CAACvB,UAAUG,KAAKH,QAAQ;QACpE,IAAI,CAACqB,iBAAiB;YAClB,OAAO;gBACHF,SAAS;gBACTC,SAAS;YACb;QACJ;QAEA,yEAAyE;QACzE,IAAII,oBAA8B,EAAE;QACpC,IAAIC,kBAA4B,EAAE;QAElC,IAAItB,KAAKY,WAAW,IAAIW,MAAMC,OAAO,CAACxB,KAAKY,WAAW,GAAG;YACrD,MAAMa,kBAAkBzB,KAAKY,WAAW,CAACc,MAAM,CAAC,CAACC,IAAchC,MAAMD,SAASiC,GAAG;YACjF,MAAMC,gBAAgB5B,KAAKY,WAAW,CAACc,MAAM,CAAC,CAACC,IAAc,CAAChC,MAAMD,SAASiC,GAAG,MAAME,GAAG,CAAC,CAACtB,KAAeb,SAASa,IAAI;YAEvH,IAAIqB,cAAcE,MAAM,GAAG,GAAG;gBAC1B,MAAMC,qBAAqB,MAAM7B,eAAM,CAAC8B,UAAU,CAACC,QAAQ,CAAC;oBACxD7B,OAAO;wBAAEG,IAAI;4BAAE2B,IAAIN;wBAAc;oBAAE;oBACnCtB,QAAQ;wBAAEE,MAAM;oBAAK;gBACzB;gBACAa,oBAAoB;uBAAII;uBAAoBM,mBAAmBF,GAAG,CAACF,CAAAA,IAAKA,EAAEnB,IAAI;iBAAE;YACpF,OAAO;gBACHa,oBAAoBI;YACxB;QACJ;QAEA,IAAIzB,KAAKa,IAAI,EAAED,aAAa;YACxBU,kBAAkBtB,KAAKa,IAAI,CAACD,WAAW,CAACiB,GAAG,CAAC,CAACF,IAAwBA,EAAEnB,IAAI;QAC/E;QAEA,oCAAoC;QACpC,MAAM2B,iBAAiBZ,MAAMa,IAAI,CAAC,IAAIC,IAAI;eAAIhB;eAAsBC;SAAgB;QAEpFxB,QAAQwC,GAAG,CAAC,0CAA0CH;QAEtD,qBAAqB;QACrB,MAAMI,QAAQ5D,cAAc;YACxB6D,KAAKxC,KAAKO,EAAE;YACZkC,UAAUzC,KAAKQ,IAAI;YACnBZ,OAAOI,KAAKJ,KAAK;YACjBa,QAAQT,KAAKS,MAAM;YACnBC,UAAUV,KAAKU,QAAQ,IAAIV,KAAKa,IAAI,EAAEL,QAAQ;YAC9CG,QAAQX,KAAKW,MAAM;YACnBC,aAAauB;QACjB;QAEA,MAAMO,cAAc;YAChBnC,IAAIP,KAAKO,EAAE;YACXkC,UAAUzC,KAAKQ,IAAI;YACnBmC,UAAU3C,KAAKQ,IAAI;YACnBZ,OAAOI,KAAKJ,KAAK;YACjBa,QAAQT,KAAKS,MAAM;YACnBC,UAAUV,KAAKU,QAAQ,IAAIV,KAAKa,IAAI,EAAEL,QAAQ;YAC9CG,QAAQX,KAAKW,MAAM;YACnBC,aAAauB;YACbtB,MAAMb,KAAKa,IAAI;QACnB;QAEA,oDAAoD;QACpD,MAAM+B,WAAWC,mBAAY,CAACC,WAAW,CAACC,mBAAY,CAACC,IAAI,CAACC,YAAY,EAAE;YAAEC,QAAQlD,KAAKO,EAAE;QAAC;QAC5F,MAAMsC,mBAAY,CAACM,GAAG,CAACP,UAAUF,aAAaK,mBAAY,CAACK,GAAG,CAACH,YAAY;QAE3E,OAAO;YACHjC,SAAS;YACTuB;YACAvC,MAAM;gBACFO,IAAIP,KAAKO,EAAE;gBACXkC,UAAUzC,KAAKQ,IAAI;gBACnBmC,UAAU3C,KAAKQ,IAAI;gBACnBZ,OAAOI,KAAKJ,KAAK;gBACjBa,QAAQT,KAAKS,MAAM;gBACnBC,UAAUV,KAAKU,QAAQ,IAAIV,KAAKa,IAAI,EAAEL,QAAQ;gBAC9CG,QAAQX,KAAKW,MAAM;gBACnBC,aAAauB;YACjB;QACJ;IACJ,EAAE,OAAOkB,OAAO;QACZvD,QAAQuD,KAAK,CAAC,yBAAyBA;QACvC,OAAO;YACHrC,SAAS;YACTC,SAAS;QACb;IACJ;AACJ;AAKO,MAAMtC,gBAAgB,CAAC2E;IAC1B,OAAOC,cAAIC,IAAI,CAACF,SAASrE,YAAsB;QAAEwE,WAAWrE;IAAsB;AACtF;AAKO,MAAMJ,cAAc,OAAOuD;IAC9B,uBAAuB;IACvB,IAAI,CAACA,SAASA,MAAMmB,IAAI,OAAO,IAAI;QAC/B,MAAM,IAAIC,MAAM;IACpB;IAEA,IAAI;QACA,qBAAqB;QACrB,MAAMC,UAAUL,cAAIM,MAAM,CAACtB,OAAOtD;QAElC,uFAAuF;QACvF,IAAIsD,MAAMT,MAAM,IAAI,IAAI;YACpB,MAAMgC,WAAWjB,mBAAY,CAACC,WAAW,CAACC,mBAAY,CAACC,IAAI,CAACe,gBAAgB,EAAE;gBAAExB,OAAOA,MAAMyB,SAAS,CAAC,GAAG;YAAI;YAE9G,gDAAgD;YAChD,MAAMC,eAAe,MAAMpB,mBAAY,CAACqB,GAAG,CAACJ;YAC5C,IAAIG,cAAc;gBACd,OAAOA;YACX;YAEA,2DAA2D;YAC3D,MAAMpB,mBAAY,CAACM,GAAG,CAACW,UAAUF,SAASb,mBAAY,CAACK,GAAG,CAACW,gBAAgB;QAC/E;QAEA,OAAOH;IACX,EAAE,OAAOP,OAAO;QACZ,gCAAgC;QAChC,IAAIA,iBAAiBE,cAAIY,iBAAiB,EAAE;YACxCrE,QAAQuD,KAAK,CAAC,sCAAsCA,MAAMe,SAAS;QACvE,OAAO,IAAIf,iBAAiBE,cAAIc,iBAAiB,EAAE;YAC/CvE,QAAQuD,KAAK,CAAC,sCAAsCA,MAAMpC,OAAO;QACrE,OAAO;YACHnB,QAAQuD,KAAK,CAAC,qCAAqCA;QACvD;QACA,MAAMA,OAAO,qBAAqB;IACtC;AACJ;AAKO,MAAMvE,gBAAgB,OAAOwF,cAA4BtC;IAC5D,+CAA+C;IAE/C,uCAAuC;IACvC,IAAIsC,aAAa1D,WAAW,EAAE;QAC1B,IAAI2D,IAAAA,0BAAe,EAACD,aAAa1D,WAAW,EAAEoB,aAAa;YACvD,OAAO;QACX;IACJ;IAEA,iDAAiD;IACjD,MAAMwC,sBAAsB3B,mBAAY,CAACC,WAAW,CAACC,mBAAY,CAACC,IAAI,CAACyB,gBAAgB,EAAE;QAAEvB,QAAQoB,aAAa9B,GAAG;IAAC;IAEpH,IAAI;QACA,MAAMkC,oBAAoB,MAAM7B,mBAAY,CAACqB,GAAG,CAACM;QACjD,IAAIE,mBAAmB;YACnB,OAAOH,IAAAA,0BAAe,EAACG,mBAAmB1C;QAC9C;QAEA,2CAA2C;QAC3C,MAAMhC,OAAO,MAAMC,IAAAA,iBAAS,EACxB,IAAMC,eAAM,CAACF,IAAI,CAACG,SAAS,CAAC;gBACxBC,OAAO;oBAAEG,IAAIoE,OAAOL,aAAa9B,GAAG;oBAAGnC,UAAU;gBAAK;gBACtDS,SAAS;oBACLD,MAAM;wBACFC,SAAS;4BACLF,aAAa;gCAAEN,QAAQ;oCAAEE,MAAM;gCAAK;4BAAE;wBAC1C;oBACJ;gBACJ;YACJ,IACA,MACA;QAGJ,IAAIR,MAAM;YACN,uDAAuD;YACvD,MAAMsB,kBAAkBtB,KAAKa,IAAI,EAAED,aAAaiB,IAAI,CAACF,IAAWA,EAAEnB,IAAI,KAAK,EAAE;YAC7E,MAAMa,oBAAoBrB,KAAKY,WAAW,IAAI,EAAE;YAEhD,4CAA4C;YAC5C,IAAIgE,6BAAuC,EAAE;YAC7C,IAAIvD,kBAAkBS,MAAM,GAAG,GAAG;gBAC9B,MAAM+C,kBAAkBxD,iBAAiB,CAAC,EAAE;gBAC5C,IAAI,OAAOwD,oBAAoB,YAAa,OAAOA,oBAAoB,YAAY,CAAClF,MAAMD,SAASmF,mBAAoB;oBACnH,0DAA0D;oBAC1D,MAAMjD,gBAAgBP,kBACjBQ,GAAG,CAAC,CAACtB,KAAYb,SAASa,GAAGuE,QAAQ,KACrCpD,MAAM,CAAC,CAACnB,KAAe,CAACZ,MAAMY;oBAEnC,IAAIqB,cAAcE,MAAM,GAAG,GAAG;wBAC1B,IAAI;4BACA,MAAMiD,oBAAoB,MAAM9E,IAAAA,iBAAS,EACrC,IAAMC,eAAM,CAAC8B,UAAU,CAACC,QAAQ,CAAC;oCAC7B7B,OAAO;wCACHG,IAAI;4CACA2B,IAAIN;wCACR;oCACJ;oCACAtB,QAAQ;wCAAEE,MAAM;oCAAK;gCACzB,IACA,EAAE,EACF;4BAEJoE,6BAA6B,AAACG,kBAA4BlD,GAAG,CAAC,CAACF,IAAWA,EAAEnB,IAAI;wBACpF,EAAE,OAAO6C,OAAO;4BACZvD,QAAQuD,KAAK,CAAC,6CAA6CA;4BAC3DuB,6BAA6B,EAAE;wBACnC;oBACJ;gBACJ,OAAO;oBACH,0CAA0C;oBAC1CA,6BAA6BvD;gBACjC;YACJ;YAEA,gDAAgD;YAChD,MAAMc,iBAAiB;mBAAIb;mBAAoBsD;aAA2B;YAC1E,MAAMhE,cAAcW,MAAMa,IAAI,CAAC,IAAIC,IAAIF;YAEvC,sCAAsC;YACtC,MAAMU,mBAAY,CAACM,GAAG,CAACqB,qBAAqB5D,aAAamC,mBAAY,CAACK,GAAG,CAACqB,gBAAgB;YAC1F,OAAOF,IAAAA,0BAAe,EAAC3D,aAAaoB;QACxC;IACJ,EAAE,OAAOqB,OAAO;QACZvD,QAAQuD,KAAK,CAAC,+BAA+BA;IACjD;IAEA,OAAO;AACX;AAKO,MAAMzE,4BAA4B,OAAO0E;IAC5CxD,QAAQwC,GAAG,CAAC,+CAA+CgB;IAC3DpE,QAAQ8F,MAAM,CAACC,KAAK,CAAC,CAAC,sDAAsD,EAAEC,KAAKC,SAAS,CAAC7B,SAAS,EAAE,CAAC;IAEzG,IAAI,CAACA,SAAS;QACVxD,QAAQuD,KAAK,CAAC;QACdnE,QAAQ8F,MAAM,CAACC,KAAK,CAAC;QACrB,OAAO;IACX;IAEA,IAAI,CAAC3B,QAAQd,GAAG,EAAE;QACd1C,QAAQuD,KAAK,CAAC;QACdnE,QAAQ8F,MAAM,CAACC,KAAK,CAAC;QACrB,OAAO;IACX;IAEA,MAAM/B,SAASI,QAAQd,GAAG;IAC1BtD,QAAQ8F,MAAM,CAACC,KAAK,CAAC,CAAC,2DAA2D,EAAE/B,OAAO,EAAE,CAAC;IAC7F,MAAMN,WAAWC,mBAAY,CAACC,WAAW,CAACC,mBAAY,CAACC,IAAI,CAACC,YAAY,EAAE;QAAEC;IAAO;IACnFhE,QAAQ8F,MAAM,CAACC,KAAK,CAAC,CAAC,4BAA4B,EAAErC,SAAS,EAAE,CAAC;IAEhE,IAAI;QACA,mCAAmC;QACnC,MAAMwC,aAAa,MAAMvC,mBAAY,CAACqB,GAAG,CAACtB;QAC1C,IAAIwC,YAAY;YACZtF,QAAQwC,GAAG,CAAC,wBAAwBY;YACpC,OAAOkC;QACX;QAEAtF,QAAQwC,GAAG,CAAC,4BAA4BY;QACxCpD,QAAQC,IAAI,CAAC,mCAAmC,cAAc;QAC9D,MAAMC,OAAO,MAAMC,IAAAA,iBAAS,EACxB,IAAMC,eAAM,CAACF,IAAI,CAACG,SAAS,CAAC;gBACxBC,OAAO;oBACHG,IAAIoE,OAAOzB;oBACX7C,UAAU;gBACd;gBACAS,SAAS;oBACLD,MAAM;wBACFC,SAAS;4BACLF,aAAa;gCACTN,QAAQ;oCAAEE,MAAM;gCAAK;4BACzB;wBACJ;oBACJ;gBACJ;YACJ,IACA,MACA;QAEJV,QAAQiB,OAAO,CAAC,mCAAmC,YAAY;QAE/D,IAAI,CAACf,MAAM;YACPF,QAAQuD,KAAK,CAAC,0BAA0BH;YACxC,OAAO;QACX;QAEA,uDAAuD;QACvD,MAAM5B,kBAAkBtB,KAAKa,IAAI,EAAED,aAAaiB,IAAI,CAACF,IAAWA,EAAEnB,IAAI,KAAK,EAAE;QAC7E,MAAMa,oBAAoBrB,KAAKY,WAAW,IAAI,EAAE;QAEhD,4CAA4C;QAC5C,IAAIgE,6BAAuC,EAAE;QAC7C,IAAIrD,MAAMC,OAAO,CAACH,sBAAsBA,kBAAkBS,MAAM,GAAG,GAAG;YAClE,sEAAsE;YACtE,MAAM+C,kBAAkBxD,iBAAiB,CAAC,EAAE;YAC5C,IAAI,OAAOwD,oBAAoB,YAAa,OAAOA,oBAAoB,YAAY,CAAClF,MAAMD,SAASmF,mBAAoB;gBACnH,0DAA0D;gBAC1D,MAAMjD,gBAAgBP,kBACjBQ,GAAG,CAAC,CAACtB,KAAYb,SAASa,GAAGuE,QAAQ,KACrCpD,MAAM,CAAC,CAACnB,KAAe,CAACZ,MAAMY;gBAEnC,IAAIqB,cAAcE,MAAM,GAAG,GAAG;oBAC1B,IAAI;wBACA,MAAMiD,oBAAoB,MAAM9E,IAAAA,iBAAS,EACrC,IAAMC,eAAM,CAAC8B,UAAU,CAACC,QAAQ,CAAC;gCAC7B7B,OAAO;oCACHG,IAAI;wCACA2B,IAAIN;oCACR;gCACJ;gCACAtB,QAAQ;oCAAEE,MAAM;gCAAK;4BACzB,IACA,EAAE,EACF;wBAEJoE,6BAA6B,AAACG,kBAA4BlD,GAAG,CAAC,CAACF,IAAWA,EAAEnB,IAAI;oBACpF,EAAE,OAAO6C,OAAO;wBACZvD,QAAQuD,KAAK,CAAC,6CAA6CA;wBAC3DuB,6BAA6B,EAAE;oBACnC;gBACJ;YACJ,OAAO;gBACH,0CAA0C;gBAC1CA,6BAA6BvD;YACjC;QACJ;QAEA,gDAAgD;QAChD,MAAMc,iBAAiB;eAAIb;eAAoBsD;SAA2B;QAC1E,MAAMhE,cAAcW,MAAMa,IAAI,CAAC,IAAIC,IAAIF;QAEvC,MAAMkD,sBAAsB;YACxB,GAAGrF,IAAI;YACPU,UAAUV,KAAKa,IAAI,EAAEL,QAAQR,KAAKU,QAAQ,IAAI;YAC9CE,aAAaA;QACjB;QAEA,yBAAyB;QACzB,MAAMiC,mBAAY,CAACM,GAAG,CAACP,UAAUyC,qBAAqBtC,mBAAY,CAACK,GAAG,CAACH,YAAY;QAEnFnD,QAAQwC,GAAG,CAAC,0BAA0BtC,KAAKO,EAAE,EAAEP,KAAKQ,IAAI;QACxD,OAAO6E;IACX,EAAE,OAAOhC,OAAO;QACZvD,QAAQuD,KAAK,CAAC,4CAA4CA;QAC1D,OAAO;IACX;AACJ;AAMO,MAAMxE,mBAAmB,OAAO0D;IACnC,MAAMe,UAAU,MAAMtE,YAAYuD;IAClC,OAAO3D,0BAA0B0E;AACrC"}