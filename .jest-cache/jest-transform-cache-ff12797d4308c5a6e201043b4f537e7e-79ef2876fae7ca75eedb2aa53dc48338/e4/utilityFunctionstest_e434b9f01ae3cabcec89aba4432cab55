37c29dca648952f0edc0df4c366a3580
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Utility Functions Tests", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("Formatting Functions", ()=>{
        describe("formatCurrency", ()=>{
            it("should format currency with default settings", ()=>{
                const mockFormatCurrency = jest.fn((amount, currency = "USD", locale = "en-US")=>{
                    return new Intl.NumberFormat(locale, {
                        style: "currency",
                        currency: currency
                    }).format(amount);
                });
                expect(mockFormatCurrency(1234.56)).toBe("$1,234.56");
                expect(mockFormatCurrency(0)).toBe("$0.00");
                expect(mockFormatCurrency(-500.25)).toBe("-$500.25");
            });
            it("should format currency with different currencies", ()=>{
                const mockFormatCurrency = jest.fn((amount, currency = "USD", locale = "en-US")=>{
                    return new Intl.NumberFormat(locale, {
                        style: "currency",
                        currency: currency
                    }).format(amount);
                });
                expect(mockFormatCurrency(1000, "EUR", "de-DE")).toBe("1.000,00 â‚¬");
                expect(mockFormatCurrency(1000, "GBP", "en-GB")).toBe("\xa31,000.00");
                expect(mockFormatCurrency(1000, "JPY", "ja-JP")).toBe("\xa51,000");
            });
            it("should handle edge cases", ()=>{
                const mockFormatCurrency = jest.fn((amount, currency = "USD", locale = "en-US")=>{
                    if (isNaN(amount) || !isFinite(amount)) {
                        return "$0.00";
                    }
                    return new Intl.NumberFormat(locale, {
                        style: "currency",
                        currency: currency
                    }).format(amount);
                });
                expect(mockFormatCurrency(NaN)).toBe("$0.00");
                expect(mockFormatCurrency(Infinity)).toBe("$0.00");
                expect(mockFormatCurrency(-Infinity)).toBe("$0.00");
            });
        });
        describe("formatDate", ()=>{
            it("should format dates with default settings", ()=>{
                const mockFormatDate = jest.fn((date, format = "MM/dd/yyyy")=>{
                    const d = new Date(date);
                    if (isNaN(d.getTime())) return "Invalid Date";
                    const month = String(d.getMonth() + 1).padStart(2, "0");
                    const day = String(d.getDate()).padStart(2, "0");
                    const year = d.getFullYear();
                    return `${month}/${day}/${year}`;
                });
                const testDate = new Date("2024-01-15");
                expect(mockFormatDate(testDate)).toBe("01/15/2024");
                expect(mockFormatDate("2024-12-25")).toBe("12/25/2024");
            });
            it("should format dates with different formats", ()=>{
                const mockFormatDate = jest.fn((date, format)=>{
                    const d = new Date(date);
                    if (isNaN(d.getTime())) return "Invalid Date";
                    const formatMap = {
                        "yyyy-MM-dd": `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`,
                        "dd/MM/yyyy": `${String(d.getDate()).padStart(2, "0")}/${String(d.getMonth() + 1).padStart(2, "0")}/${d.getFullYear()}`,
                        "MMM dd, yyyy": d.toLocaleDateString("en-US", {
                            year: "numeric",
                            month: "short",
                            day: "numeric"
                        })
                    };
                    return formatMap[format] || formatMap["MM/dd/yyyy"];
                });
                const testDate = new Date("2024-01-15");
                expect(mockFormatDate(testDate, "yyyy-MM-dd")).toBe("2024-01-15");
                expect(mockFormatDate(testDate, "dd/MM/yyyy")).toBe("15/01/2024");
                expect(mockFormatDate(testDate, "MMM dd, yyyy")).toBe("Jan 15, 2024");
            });
            it("should handle invalid dates", ()=>{
                const mockFormatDate = jest.fn((date)=>{
                    const d = new Date(date);
                    return isNaN(d.getTime()) ? "Invalid Date" : d.toLocaleDateString();
                });
                expect(mockFormatDate("invalid-date")).toBe("Invalid Date");
                expect(mockFormatDate("")).toBe("Invalid Date");
            });
        });
        describe("formatPhoneNumber", ()=>{
            it("should format US phone numbers", ()=>{
                const mockFormatPhoneNumber = jest.fn((phone, country = "US")=>{
                    const cleaned = phone.replace(/\D/g, "");
                    if (country === "US" && cleaned.length === 10) {
                        return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
                    }
                    return phone;
                });
                expect(mockFormatPhoneNumber("1234567890")).toBe("(123) 456-7890");
                expect(mockFormatPhoneNumber("123-456-7890")).toBe("(123) 456-7890");
                expect(mockFormatPhoneNumber("(123) 456-7890")).toBe("(123) 456-7890");
            });
            it("should handle international phone numbers", ()=>{
                const mockFormatPhoneNumber = jest.fn((phone, country)=>{
                    const cleaned = phone.replace(/\D/g, "");
                    if (country === "UK" && cleaned.length === 11) {
                        return `+44 ${cleaned.slice(1, 5)} ${cleaned.slice(5, 8)} ${cleaned.slice(8)}`;
                    }
                    return phone;
                });
                expect(mockFormatPhoneNumber("01234567890", "UK")).toBe("+44 1234 567 890");
            });
            it("should handle invalid phone numbers", ()=>{
                const mockFormatPhoneNumber = jest.fn((phone)=>{
                    const cleaned = phone.replace(/\D/g, "");
                    return cleaned.length < 10 ? phone : `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
                });
                expect(mockFormatPhoneNumber("123")).toBe("123");
                expect(mockFormatPhoneNumber("")).toBe("");
                expect(mockFormatPhoneNumber("abc")).toBe("abc");
            });
        });
    });
    describe("Validation Functions", ()=>{
        describe("validateEmail", ()=>{
            it("should validate correct email addresses", ()=>{
                const mockValidateEmail = jest.fn((email)=>{
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    return emailRegex.test(email);
                });
                expect(mockValidateEmail("test@example.com")).toBe(true);
                expect(mockValidateEmail("user.name@domain.co.uk")).toBe(true);
                expect(mockValidateEmail("user+tag@example.org")).toBe(true);
            });
            it("should reject invalid email addresses", ()=>{
                const mockValidateEmail = jest.fn((email)=>{
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    return emailRegex.test(email);
                });
                expect(mockValidateEmail("invalid-email")).toBe(false);
                expect(mockValidateEmail("test@")).toBe(false);
                expect(mockValidateEmail("@example.com")).toBe(false);
                expect(mockValidateEmail("test@.com")).toBe(false);
                expect(mockValidateEmail("")).toBe(false);
            });
        });
        describe("validatePassword", ()=>{
            it("should validate strong passwords", ()=>{
                const mockValidatePassword = jest.fn((password)=>{
                    const minLength = password.length >= 8;
                    const hasUpper = /[A-Z]/.test(password);
                    const hasLower = /[a-z]/.test(password);
                    const hasNumber = /\d/.test(password);
                    const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
                    return minLength && hasUpper && hasLower && hasNumber && hasSpecial;
                });
                expect(mockValidatePassword("Password123!")).toBe(true);
                expect(mockValidatePassword("MySecure@Pass1")).toBe(true);
                expect(mockValidatePassword("Complex#Password9")).toBe(true);
            });
            it("should reject weak passwords", ()=>{
                const mockValidatePassword = jest.fn((password)=>{
                    const minLength = password.length >= 8;
                    const hasUpper = /[A-Z]/.test(password);
                    const hasLower = /[a-z]/.test(password);
                    const hasNumber = /\d/.test(password);
                    const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
                    return minLength && hasUpper && hasLower && hasNumber && hasSpecial;
                });
                expect(mockValidatePassword("weak")).toBe(false);
                expect(mockValidatePassword("password")).toBe(false);
                expect(mockValidatePassword("Password")).toBe(false);
                expect(mockValidatePassword("Password123")).toBe(false);
                expect(mockValidatePassword("")).toBe(false);
            });
        });
        describe("validatePhoneNumber", ()=>{
            it("should validate US phone numbers", ()=>{
                const mockValidatePhoneNumber = jest.fn((phone, country = "US")=>{
                    const cleaned = phone.replace(/\D/g, "");
                    if (country === "US") {
                        return cleaned.length === 10 || cleaned.length === 11 && cleaned.startsWith("1");
                    }
                    return cleaned.length >= 10;
                });
                expect(mockValidatePhoneNumber("(123) 456-7890")).toBe(true);
                expect(mockValidatePhoneNumber("123-456-7890")).toBe(true);
                expect(mockValidatePhoneNumber("1234567890")).toBe(true);
                expect(mockValidatePhoneNumber("11234567890")).toBe(true);
            });
            it("should reject invalid phone numbers", ()=>{
                const mockValidatePhoneNumber = jest.fn((phone)=>{
                    const cleaned = phone.replace(/\D/g, "");
                    return cleaned.length === 10 || cleaned.length === 11 && cleaned.startsWith("1");
                });
                expect(mockValidatePhoneNumber("123")).toBe(false);
                expect(mockValidatePhoneNumber("123-456")).toBe(false);
                expect(mockValidatePhoneNumber("")).toBe(false);
                expect(mockValidatePhoneNumber("abc-def-ghij")).toBe(false);
            });
        });
        describe("validateRequired", ()=>{
            it("should validate required fields", ()=>{
                const mockValidateRequired = jest.fn((value)=>{
                    if (typeof value === "string") {
                        return value.trim().length > 0;
                    }
                    return value !== null && value !== undefined;
                });
                expect(mockValidateRequired("test")).toBe(true);
                expect(mockValidateRequired("  test  ")).toBe(true);
                expect(mockValidateRequired(123)).toBe(true);
                expect(mockValidateRequired(0)).toBe(true);
                expect(mockValidateRequired(false)).toBe(true);
            });
            it("should reject empty or null values", ()=>{
                const mockValidateRequired = jest.fn((value)=>{
                    if (typeof value === "string") {
                        return value.trim().length > 0;
                    }
                    return value !== null && value !== undefined;
                });
                expect(mockValidateRequired("")).toBe(false);
                expect(mockValidateRequired("   ")).toBe(false);
                expect(mockValidateRequired(null)).toBe(false);
                expect(mockValidateRequired(undefined)).toBe(false);
            });
        });
    });
    describe("Utility Helper Functions", ()=>{
        describe("generateId", ()=>{
            it("should generate unique IDs", ()=>{
                const mockGenerateId = jest.fn((prefix = "", length = 8)=>{
                    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    let result = prefix;
                    for(let i = 0; i < length; i++){
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return result;
                });
                const id1 = mockGenerateId();
                const id2 = mockGenerateId();
                expect(id1).toHaveLength(8);
                expect(id2).toHaveLength(8);
                expect(id1).not.toBe(id2);
            });
            it("should generate IDs with custom prefix and length", ()=>{
                const mockGenerateId = jest.fn((prefix = "", length = 8)=>{
                    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    let result = prefix;
                    for(let i = 0; i < length; i++){
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return result;
                });
                const id = mockGenerateId("USER_", 12);
                expect(id).toHaveLength(17); // 5 (prefix) + 12 (generated)
                expect(id).toStartWith("USER_");
            });
        });
        describe("slugify", ()=>{
            it("should create URL-friendly slugs", ()=>{
                const mockSlugify = jest.fn((text)=>{
                    return text.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
                });
                expect(mockSlugify("Hello World")).toBe("hello-world");
                expect(mockSlugify("Product Name & Description")).toBe("product-name-description");
                expect(mockSlugify("  Multiple   Spaces  ")).toBe("multiple-spaces");
                expect(mockSlugify("Special!@#$%Characters")).toBe("specialcharacters");
            });
            it("should handle edge cases", ()=>{
                const mockSlugify = jest.fn((text)=>{
                    return text.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
                });
                expect(mockSlugify("")).toBe("");
                expect(mockSlugify("   ")).toBe("");
                expect(mockSlugify("!@#$%^&*()")).toBe("");
                expect(mockSlugify("123-456-789")).toBe("123-456-789");
            });
        });
        describe("truncateText", ()=>{
            it("should truncate long text", ()=>{
                const mockTruncateText = jest.fn((text, maxLength, suffix = "...")=>{
                    if (text.length <= maxLength) return text;
                    return text.slice(0, maxLength - suffix.length) + suffix;
                });
                const longText = "This is a very long text that should be truncated";
                expect(mockTruncateText(longText, 20)).toBe("This is a very lo...");
                expect(mockTruncateText(longText, 10)).toBe("This is...");
                expect(mockTruncateText("Short", 20)).toBe("Short");
            });
            it("should handle custom suffix", ()=>{
                const mockTruncateText = jest.fn((text, maxLength, suffix = "...")=>{
                    if (text.length <= maxLength) return text;
                    return text.slice(0, maxLength - suffix.length) + suffix;
                });
                const text = "This is a long text";
                expect(mockTruncateText(text, 15, " [more]")).toBe("This is [more]");
                expect(mockTruncateText(text, 10, "")).toBe("This is a ");
            });
        });
        describe("debounce", ()=>{
            it("should debounce function calls", async ()=>{
                let callCount = 0;
                const mockFunction = jest.fn(()=>callCount++);
                const mockDebounce = jest.fn((func, delay)=>{
                    let timeoutId;
                    return (...args)=>{
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(()=>func.apply(null, args), delay);
                    };
                });
                const debouncedFunction = mockDebounce(mockFunction, 100);
                // Call multiple times quickly
                debouncedFunction();
                debouncedFunction();
                debouncedFunction();
                // Should not have been called yet
                expect(mockFunction).not.toHaveBeenCalled();
                // Wait for debounce delay
                await new Promise((resolve)=>setTimeout(resolve, 150));
                // Should have been called only once
                expect(mockFunction).toHaveBeenCalledTimes(1);
            });
        });
        describe("throttle", ()=>{
            it("should throttle function calls", async ()=>{
                let callCount = 0;
                const mockFunction = jest.fn(()=>callCount++);
                const mockThrottle = jest.fn((func, delay)=>{
                    let lastCall = 0;
                    return (...args)=>{
                        const now = Date.now();
                        if (now - lastCall >= delay) {
                            lastCall = now;
                            return func.apply(null, args);
                        }
                    };
                });
                const throttledFunction = mockThrottle(mockFunction, 100);
                // Call multiple times quickly
                throttledFunction();
                throttledFunction();
                throttledFunction();
                // Should have been called only once immediately
                expect(mockFunction).toHaveBeenCalledTimes(1);
                // Wait for throttle delay
                await new Promise((resolve)=>setTimeout(resolve, 150));
                // Call again
                throttledFunction();
                // Should have been called twice total
                expect(mockFunction).toHaveBeenCalledTimes(2);
            });
        });
    });
    describe("Calculation Functions", ()=>{
        describe("calculateTax", ()=>{
            it("should calculate tax correctly", ()=>{
                const mockCalculateTax = jest.fn((amount, taxRate)=>{
                    return Math.round(amount * taxRate * 100) / 100;
                });
                expect(mockCalculateTax(100, 0.08)).toBe(8);
                expect(mockCalculateTax(250.50, 0.075)).toBe(18.79);
                expect(mockCalculateTax(0, 0.08)).toBe(0);
            });
            it("should handle edge cases", ()=>{
                const mockCalculateTax = jest.fn((amount, taxRate)=>{
                    if (amount < 0 || taxRate < 0) return 0;
                    return Math.round(amount * taxRate * 100) / 100;
                });
                expect(mockCalculateTax(-100, 0.08)).toBe(0);
                expect(mockCalculateTax(100, -0.08)).toBe(0);
                expect(mockCalculateTax(100, 0)).toBe(0);
            });
        });
        describe("calculateDiscount", ()=>{
            it("should calculate percentage discount", ()=>{
                const mockCalculateDiscount = jest.fn((amount, discount, isPercentage = true)=>{
                    if (isPercentage) {
                        return Math.round(amount * (discount / 100) * 100) / 100;
                    }
                    return Math.min(discount, amount);
                });
                expect(mockCalculateDiscount(100, 10, true)).toBe(10);
                expect(mockCalculateDiscount(250, 15, true)).toBe(37.5);
                expect(mockCalculateDiscount(50, 20, true)).toBe(10);
            });
            it("should calculate fixed discount", ()=>{
                const mockCalculateDiscount = jest.fn((amount, discount, isPercentage = true)=>{
                    if (isPercentage) {
                        return Math.round(amount * (discount / 100) * 100) / 100;
                    }
                    return Math.min(discount, amount);
                });
                expect(mockCalculateDiscount(100, 15, false)).toBe(15);
                expect(mockCalculateDiscount(50, 75, false)).toBe(50); // Can't discount more than amount
                expect(mockCalculateDiscount(200, 25, false)).toBe(25);
            });
        });
        describe("calculateTotal", ()=>{
            it("should calculate total with tax and discount", ()=>{
                const mockCalculateTotal = jest.fn((subtotal, tax, discount)=>{
                    const afterDiscount = subtotal - discount;
                    return Math.round((afterDiscount + tax) * 100) / 100;
                });
                expect(mockCalculateTotal(100, 8, 10)).toBe(98); // 100 - 10 + 8
                expect(mockCalculateTotal(250, 20, 25)).toBe(245); // 250 - 25 + 20
                expect(mockCalculateTotal(50, 0, 0)).toBe(50);
            });
            it("should handle negative results", ()=>{
                const mockCalculateTotal = jest.fn((subtotal, tax, discount)=>{
                    const afterDiscount = subtotal - discount;
                    const total = afterDiscount + tax;
                    return Math.max(0, Math.round(total * 100) / 100);
                });
                expect(mockCalculateTotal(10, 1, 15)).toBe(0); // Can't go negative
                expect(mockCalculateTotal(0, 0, 5)).toBe(0);
            });
        });
    });
    describe("Sanitization Functions", ()=>{
        describe("sanitizeInput", ()=>{
            it("should sanitize user input", ()=>{
                const mockSanitizeInput = jest.fn((input)=>{
                    return input.replace(/<script[^>]*>.*?<\/script>/gi, "").replace(/<[^>]*>/g, "").trim();
                });
                expect(mockSanitizeInput('Hello <script>alert("xss")</script> World')).toBe("Hello  World");
                expect(mockSanitizeInput("<b>Bold</b> text")).toBe("Bold text");
                expect(mockSanitizeInput("  Normal text  ")).toBe("Normal text");
            });
            it("should handle malicious input", ()=>{
                const mockSanitizeInput = jest.fn((input)=>{
                    return input.replace(/<script[^>]*>.*?<\/script>/gi, "").replace(/javascript:/gi, "").replace(/on\w+\s*=/gi, "").replace(/<[^>]*>/g, "").trim();
                });
                expect(mockSanitizeInput('<img src="x" onerror="alert(1)">')).toBe("");
                expect(mockSanitizeInput('javascript:alert("xss")')).toBe('alert("xss")');
                expect(mockSanitizeInput('<a href="javascript:void(0)">Link</a>')).toBe("Link");
            });
        });
        describe("escapeHtml", ()=>{
            it("should escape HTML entities", ()=>{
                const mockEscapeHtml = jest.fn((text)=>{
                    const entityMap = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    return text.replace(/[&<>"']/g, (char)=>entityMap[char]);
                });
                expect(mockEscapeHtml('<div>Hello & "World"</div>')).toBe("&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;");
                expect(mockEscapeHtml("It's a 'test'")).toBe("It&#39;s a &#39;test&#39;");
                expect(mockEscapeHtml("Normal text")).toBe("Normal text");
            });
        });
        describe("parseQueryParams", ()=>{
            it("should parse URL query parameters", ()=>{
                const mockParseQueryParams = jest.fn((queryString)=>{
                    const params = {};
                    const urlParams = new URLSearchParams(queryString);
                    for (const [key, value] of urlParams){
                        params[key] = value;
                    }
                    return params;
                });
                expect(mockParseQueryParams("?name=John&age=30&city=NYC")).toEqual({
                    name: "John",
                    age: "30",
                    city: "NYC"
                });
                expect(mockParseQueryParams("search=test&page=1&limit=10")).toEqual({
                    search: "test",
                    page: "1",
                    limit: "10"
                });
            });
            it("should handle empty or malformed query strings", ()=>{
                const mockParseQueryParams = jest.fn((queryString)=>{
                    const params = {};
                    // Handle empty strings
                    if (!queryString || queryString === "?") {
                        return params;
                    }
                    // Handle malformed query strings (no = sign)
                    if (!queryString.includes("=") && !queryString.startsWith("?")) {
                        return params;
                    }
                    try {
                        const urlParams = new URLSearchParams(queryString);
                        for (const [key, value] of urlParams){
                            params[key] = value;
                        }
                    } catch (error) {
                    // Return empty object for malformed queries
                    }
                    return params;
                });
                expect(mockParseQueryParams("")).toEqual({});
                expect(mockParseQueryParams("?")).toEqual({});
                expect(mockParseQueryParams("invalid")).toEqual({});
            });
            it("should handle URL encoding", ()=>{
                const mockParseQueryParams = jest.fn((queryString)=>{
                    const params = {};
                    const urlParams = new URLSearchParams(queryString);
                    for (const [key, value] of urlParams){
                        params[key] = decodeURIComponent(value);
                    }
                    return params;
                });
                expect(mockParseQueryParams("search=hello%20world&special=%21%40%23")).toEqual({
                    search: "hello world",
                    special: "!@#"
                });
            });
        });
    });
    describe("Error Handling in Utilities", ()=>{
        it("should handle errors in formatting functions", ()=>{
            const mockFormatCurrencyWithError = jest.fn((amount)=>{
                try {
                    if (typeof amount !== "number") {
                        throw new Error("Invalid amount type");
                    }
                    return `$${amount.toFixed(2)}`;
                } catch (error) {
                    consoleSpy.error("Currency formatting error:", error);
                    return "$0.00";
                }
            });
            expect(mockFormatCurrencyWithError("invalid")).toBe("$0.00");
            expect(consoleSpy.error).toHaveBeenCalledWith("Currency formatting error:", expect.any(Error));
        });
        it("should handle errors in validation functions", ()=>{
            const mockValidateEmailWithError = jest.fn((email)=>{
                try {
                    if (typeof email !== "string") {
                        throw new Error("Email must be a string");
                    }
                    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
                } catch (error) {
                    consoleSpy.error("Email validation error:", error);
                    return false;
                }
            });
            expect(mockValidateEmailWithError(null)).toBe(false);
            expect(mockValidateEmailWithError(123)).toBe(false);
            expect(consoleSpy.error).toHaveBeenCalledWith("Email validation error:", expect.any(Error));
        });
        it("should handle errors in utility functions", ()=>{
            const mockSlugifyWithError = jest.fn((text)=>{
                try {
                    if (typeof text !== "string") {
                        throw new Error("Text must be a string");
                    }
                    return text.toLowerCase().replace(/[^a-z0-9]/g, "-");
                } catch (error) {
                    consoleSpy.error("Slugify error:", error);
                    return "";
                }
            });
            expect(mockSlugifyWithError(null)).toBe("");
            expect(mockSlugifyWithError({})).toBe("");
            expect(consoleSpy.error).toHaveBeenCalledWith("Slugify error:", expect.any(Error));
        });
    });
    describe("Performance Tests for Utilities", ()=>{
        it("should handle large datasets efficiently", ()=>{
            const mockBatchProcess = jest.fn((items, batchSize = 100)=>{
                const results = [];
                for(let i = 0; i < items.length; i += batchSize){
                    const batch = items.slice(i, i + batchSize);
                    results.push(...batch.map((item)=>item.id));
                }
                return results;
            });
            const largeDataset = Array.from({
                length: 10000
            }, (_, i)=>({
                    id: i,
                    name: `Item ${i}`
                }));
            const startTime = Date.now();
            const result = mockBatchProcess(largeDataset);
            const endTime = Date.now();
            expect(result).toHaveLength(10000);
            expect(endTime - startTime).toBeLessThan(100); // Should process quickly
        });
        it("should handle concurrent utility operations", async ()=>{
            const mockAsyncUtility = jest.fn(async (data)=>{
                await new Promise((resolve)=>setTimeout(resolve, 10));
                return data.toUpperCase();
            });
            const operations = Array.from({
                length: 100
            }, (_, i)=>mockAsyncUtility(`test-${i}`));
            const startTime = Date.now();
            const results = await Promise.all(operations);
            const endTime = Date.now();
            expect(results).toHaveLength(100);
            expect(results[0]).toBe("TEST-0");
            expect(endTime - startTime).toBeLessThan(500); // Should handle concurrency well
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC91dGlsaXR5RnVuY3Rpb25zLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0Q3VycmVuY3ksIGZvcm1hdERhdGUsIGZvcm1hdFBob25lTnVtYmVyIH0gZnJvbSAnQC9saWIvZm9ybWF0dGVycyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUVtYWlsLCB2YWxpZGF0ZVBhc3N3b3JkLCB2YWxpZGF0ZVBob25lTnVtYmVyLCB2YWxpZGF0ZVJlcXVpcmVkIH0gZnJvbSAnQC9saWIvdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkLCBzbHVnaWZ5LCB0cnVuY2F0ZVRleHQsIGRlYm91bmNlLCB0aHJvdHRsZSB9IGZyb20gJ0AvbGliL3V0aWxzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVRheCwgY2FsY3VsYXRlRGlzY291bnQsIGNhbGN1bGF0ZVRvdGFsIH0gZnJvbSAnQC9saWIvY2FsY3VsYXRpb25zJztcbmltcG9ydCB7IHNhbml0aXplSW5wdXQsIGVzY2FwZUh0bWwsIHBhcnNlUXVlcnlQYXJhbXMgfSBmcm9tICdAL2xpYi9zYW5pdGl6ZXJzJztcblxuLy8gTW9jayBjb25zb2xlIG1ldGhvZHNcbmNvbnN0IGNvbnNvbGVTcHkgPSB7XG4gIGxvZzogamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbiAgZXJyb3I6IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbiAgd2FybjogamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG59O1xuXG5kZXNjcmliZSgnVXRpbGl0eSBGdW5jdGlvbnMgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkuZXJyb3IubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgY29uc29sZVNweS5sb2cubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGb3JtYXR0aW5nIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICBkZXNjcmliZSgnZm9ybWF0Q3VycmVuY3knLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBjdXJyZW5jeSB3aXRoIGRlZmF1bHQgc2V0dGluZ3MnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRDdXJyZW5jeSA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCBjdXJyZW5jeSA9ICdVU0QnLCBsb2NhbGUgPSAnZW4tVVMnKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgICAgIHN0eWxlOiAnY3VycmVuY3knLFxuICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LFxuICAgICAgICAgIH0pLmZvcm1hdChhbW91bnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KDEyMzQuNTYpKS50b0JlKCckMSwyMzQuNTYnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeSgwKSkudG9CZSgnJDAuMDAnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeSgtNTAwLjI1KSkudG9CZSgnLSQ1MDAuMjUnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBjdXJyZW5jeSB3aXRoIGRpZmZlcmVudCBjdXJyZW5jaWVzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrRm9ybWF0Q3VycmVuY3kgPSBqZXN0LmZuKChhbW91bnQ6IG51bWJlciwgY3VycmVuY3kgPSAnVVNEJywgbG9jYWxlID0gJ2VuLVVTJykgPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB7XG4gICAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5JyxcbiAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICAgICAgICB9KS5mb3JtYXQoYW1vdW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeSgxMDAwLCAnRVVSJywgJ2RlLURFJykpLnRvQmUoJzEuMDAwLDAwIOKCrCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KDEwMDAsICdHQlAnLCAnZW4tR0InKSkudG9CZSgnwqMxLDAwMC4wMCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KDEwMDAsICdKUFknLCAnamEtSlAnKSkudG9CZSgnwqUxLDAwMCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRDdXJyZW5jeSA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCBjdXJyZW5jeSA9ICdVU0QnLCBsb2NhbGUgPSAnZW4tVVMnKSA9PiB7XG4gICAgICAgICAgaWYgKGlzTmFOKGFtb3VudCkgfHwgIWlzRmluaXRlKGFtb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJDAuMDAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwge1xuICAgICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXG4gICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3ksXG4gICAgICAgICAgfSkuZm9ybWF0KGFtb3VudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0Q3VycmVuY3koTmFOKSkudG9CZSgnJDAuMDAnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeShJbmZpbml0eSkpLnRvQmUoJyQwLjAwJyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0Q3VycmVuY3koLUluZmluaXR5KSkudG9CZSgnJDAuMDAnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2Zvcm1hdERhdGUnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBkYXRlcyB3aXRoIGRlZmF1bHQgc2V0dGluZ3MnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXREYXRlID0gamVzdC5mbigoZGF0ZTogRGF0ZSB8IHN0cmluZywgZm9ybWF0ID0gJ01NL2RkL3l5eXknKSA9PiB7XG4gICAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgIGlmIChpc05hTihkLmdldFRpbWUoKSkpIHJldHVybiAnSW52YWxpZCBEYXRlJztcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBtb250aCA9IFN0cmluZyhkLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICAgIGNvbnN0IGRheSA9IFN0cmluZyhkLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgICBjb25zdCB5ZWFyID0gZC5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBgJHttb250aH0vJHtkYXl9LyR7eWVhcn1gO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0ZXN0RGF0ZSA9IG5ldyBEYXRlKCcyMDI0LTAxLTE1Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0RGF0ZSh0ZXN0RGF0ZSkpLnRvQmUoJzAxLzE1LzIwMjQnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXREYXRlKCcyMDI0LTEyLTI1JykpLnRvQmUoJzEyLzI1LzIwMjQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBkYXRlcyB3aXRoIGRpZmZlcmVudCBmb3JtYXRzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrRm9ybWF0RGF0ZSA9IGplc3QuZm4oKGRhdGU6IERhdGUgfCBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgIGlmIChpc05hTihkLmdldFRpbWUoKSkpIHJldHVybiAnSW52YWxpZCBEYXRlJztcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBmb3JtYXRNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICAgICAneXl5eS1NTS1kZCc6IGAke2QuZ2V0RnVsbFllYXIoKX0tJHtTdHJpbmcoZC5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKX0tJHtTdHJpbmcoZC5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyl9YCxcbiAgICAgICAgICAgICdkZC9NTS95eXl5JzogYCR7U3RyaW5nKGQuZ2V0RGF0ZSgpKS5wYWRTdGFydCgyLCAnMCcpfS8ke1N0cmluZyhkLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpfS8ke2QuZ2V0RnVsbFllYXIoKX1gLFxuICAgICAgICAgICAgJ01NTSBkZCwgeXl5eSc6IGQudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycgfSksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gZm9ybWF0TWFwW2Zvcm1hdF0gfHwgZm9ybWF0TWFwWydNTS9kZC95eXl5J107XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRlc3REYXRlID0gbmV3IERhdGUoJzIwMjQtMDEtMTUnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXREYXRlKHRlc3REYXRlLCAneXl5eS1NTS1kZCcpKS50b0JlKCcyMDI0LTAxLTE1Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0RGF0ZSh0ZXN0RGF0ZSwgJ2RkL01NL3l5eXknKSkudG9CZSgnMTUvMDEvMjAyNCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdERhdGUodGVzdERhdGUsICdNTU0gZGQsIHl5eXknKSkudG9CZSgnSmFuIDE1LCAyMDI0Jyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW52YWxpZCBkYXRlcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0Zvcm1hdERhdGUgPSBqZXN0LmZuKChkYXRlOiBEYXRlIHwgc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgIHJldHVybiBpc05hTihkLmdldFRpbWUoKSkgPyAnSW52YWxpZCBEYXRlJyA6IGQudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0RGF0ZSgnaW52YWxpZC1kYXRlJykpLnRvQmUoJ0ludmFsaWQgRGF0ZScpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdERhdGUoJycpKS50b0JlKCdJbnZhbGlkIERhdGUnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2Zvcm1hdFBob25lTnVtYmVyJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBmb3JtYXQgVVMgcGhvbmUgbnVtYmVycycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0Zvcm1hdFBob25lTnVtYmVyID0gamVzdC5mbigocGhvbmU6IHN0cmluZywgY291bnRyeSA9ICdVUycpID0+IHtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gcGhvbmUucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICAgICAgICBpZiAoY291bnRyeSA9PT0gJ1VTJyAmJiBjbGVhbmVkLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgICAgIHJldHVybiBgKCR7Y2xlYW5lZC5zbGljZSgwLCAzKX0pICR7Y2xlYW5lZC5zbGljZSgzLCA2KX0tJHtjbGVhbmVkLnNsaWNlKDYpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwaG9uZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRQaG9uZU51bWJlcignMTIzNDU2Nzg5MCcpKS50b0JlKCcoMTIzKSA0NTYtNzg5MCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdFBob25lTnVtYmVyKCcxMjMtNDU2LTc4OTAnKSkudG9CZSgnKDEyMykgNDU2LTc4OTAnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRQaG9uZU51bWJlcignKDEyMykgNDU2LTc4OTAnKSkudG9CZSgnKDEyMykgNDU2LTc4OTAnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnRlcm5hdGlvbmFsIHBob25lIG51bWJlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRQaG9uZU51bWJlciA9IGplc3QuZm4oKHBob25lOiBzdHJpbmcsIGNvdW50cnk6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGNsZWFuZWQgPSBwaG9uZS5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgICAgICAgIGlmIChjb3VudHJ5ID09PSAnVUsnICYmIGNsZWFuZWQubGVuZ3RoID09PSAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGArNDQgJHtjbGVhbmVkLnNsaWNlKDEsIDUpfSAke2NsZWFuZWQuc2xpY2UoNSwgOCl9ICR7Y2xlYW5lZC5zbGljZSg4KX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGhvbmU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0UGhvbmVOdW1iZXIoJzAxMjM0NTY3ODkwJywgJ1VLJykpLnRvQmUoJys0NCAxMjM0IDU2NyA4OTAnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHBob25lIG51bWJlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRQaG9uZU51bWJlciA9IGplc3QuZm4oKHBob25lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gcGhvbmUucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICAgICAgICByZXR1cm4gY2xlYW5lZC5sZW5ndGggPCAxMCA/IHBob25lIDogYCgke2NsZWFuZWQuc2xpY2UoMCwgMyl9KSAke2NsZWFuZWQuc2xpY2UoMywgNil9LSR7Y2xlYW5lZC5zbGljZSg2KX1gO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdFBob25lTnVtYmVyKCcxMjMnKSkudG9CZSgnMTIzJyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0UGhvbmVOdW1iZXIoJycpKS50b0JlKCcnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRQaG9uZU51bWJlcignYWJjJykpLnRvQmUoJ2FiYycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdWYWxpZGF0aW9uIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICBkZXNjcmliZSgndmFsaWRhdGVFbWFpbCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgY29ycmVjdCBlbWFpbCBhZGRyZXNzZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZUVtYWlsID0gamVzdC5mbigoZW1haWw6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskLztcbiAgICAgICAgICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsKCd0ZXN0QGV4YW1wbGUuY29tJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbCgndXNlci5uYW1lQGRvbWFpbi5jby51aycpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlRW1haWwoJ3VzZXIrdGFnQGV4YW1wbGUub3JnJykpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBlbWFpbCBhZGRyZXNzZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZUVtYWlsID0gamVzdC5mbigoZW1haWw6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskLztcbiAgICAgICAgICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsKCdpbnZhbGlkLWVtYWlsJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlRW1haWwoJ3Rlc3RAJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlRW1haWwoJ0BleGFtcGxlLmNvbScpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsKCd0ZXN0QC5jb20nKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbCgnJykpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndmFsaWRhdGVQYXNzd29yZCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgc3Ryb25nIHBhc3N3b3JkcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlUGFzc3dvcmQgPSBqZXN0LmZuKChwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWluTGVuZ3RoID0gcGFzc3dvcmQubGVuZ3RoID49IDg7XG4gICAgICAgICAgY29uc3QgaGFzVXBwZXIgPSAvW0EtWl0vLnRlc3QocGFzc3dvcmQpO1xuICAgICAgICAgIGNvbnN0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNOdW1iZXIgPSAvXFxkLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNTcGVjaWFsID0gL1shQCMkJV4mKigpLC4/XCI6e318PD5dLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gbWluTGVuZ3RoICYmIGhhc1VwcGVyICYmIGhhc0xvd2VyICYmIGhhc051bWJlciAmJiBoYXNTcGVjaWFsO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ1Bhc3N3b3JkMTIzIScpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ015U2VjdXJlQFBhc3MxJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgnQ29tcGxleCNQYXNzd29yZDknKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCB3ZWFrIHBhc3N3b3JkcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlUGFzc3dvcmQgPSBqZXN0LmZuKChwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWluTGVuZ3RoID0gcGFzc3dvcmQubGVuZ3RoID49IDg7XG4gICAgICAgICAgY29uc3QgaGFzVXBwZXIgPSAvW0EtWl0vLnRlc3QocGFzc3dvcmQpO1xuICAgICAgICAgIGNvbnN0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNOdW1iZXIgPSAvXFxkLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNTcGVjaWFsID0gL1shQCMkJV4mKigpLC4/XCI6e318PD5dLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gbWluTGVuZ3RoICYmIGhhc1VwcGVyICYmIGhhc0xvd2VyICYmIGhhc051bWJlciAmJiBoYXNTcGVjaWFsO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ3dlYWsnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgncGFzc3dvcmQnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgnUGFzc3dvcmQnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgnUGFzc3dvcmQxMjMnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgnJykpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndmFsaWRhdGVQaG9uZU51bWJlcicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgVVMgcGhvbmUgbnVtYmVycycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIgPSBqZXN0LmZuKChwaG9uZTogc3RyaW5nLCBjb3VudHJ5ID0gJ1VTJykgPT4ge1xuICAgICAgICAgIGNvbnN0IGNsZWFuZWQgPSBwaG9uZS5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgICAgICAgIGlmIChjb3VudHJ5ID09PSAnVVMnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xlYW5lZC5sZW5ndGggPT09IDEwIHx8IChjbGVhbmVkLmxlbmd0aCA9PT0gMTEgJiYgY2xlYW5lZC5zdGFydHNXaXRoKCcxJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2xlYW5lZC5sZW5ndGggPj0gMTA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignKDEyMykgNDU2LTc4OTAnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVBob25lTnVtYmVyKCcxMjMtNDU2LTc4OTAnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVBob25lTnVtYmVyKCcxMjM0NTY3ODkwJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignMTEyMzQ1Njc4OTAnKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIHBob25lIG51bWJlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZVBob25lTnVtYmVyID0gamVzdC5mbigocGhvbmU6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGNsZWFuZWQgPSBwaG9uZS5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgICAgICAgIHJldHVybiBjbGVhbmVkLmxlbmd0aCA9PT0gMTAgfHwgKGNsZWFuZWQubGVuZ3RoID09PSAxMSAmJiBjbGVhbmVkLnN0YXJ0c1dpdGgoJzEnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignMTIzJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIoJzEyMy00NTYnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIoJ2FiYy1kZWYtZ2hpaicpKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3ZhbGlkYXRlUmVxdWlyZWQnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlUmVxdWlyZWQgPSBqZXN0LmZuKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmltKCkubGVuZ3RoID4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZCgndGVzdCcpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQoJyAgdGVzdCAgJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZCgxMjMpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQoMCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZChmYWxzZSkpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgZW1wdHkgb3IgbnVsbCB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZVJlcXVpcmVkID0gamVzdC5mbigodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQoJycpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVJlcXVpcmVkKCcgICAnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZChudWxsKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZCh1bmRlZmluZWQpKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVXRpbGl0eSBIZWxwZXIgRnVuY3Rpb25zJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCdnZW5lcmF0ZUlkJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSB1bmlxdWUgSURzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrR2VuZXJhdGVJZCA9IGplc3QuZm4oKHByZWZpeCA9ICcnLCBsZW5ndGggPSA4KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBwcmVmaXg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgaWQxID0gbW9ja0dlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgaWQyID0gbW9ja0dlbmVyYXRlSWQoKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChpZDEpLnRvSGF2ZUxlbmd0aCg4KTtcbiAgICAgICAgZXhwZWN0KGlkMikudG9IYXZlTGVuZ3RoKDgpO1xuICAgICAgICBleHBlY3QoaWQxKS5ub3QudG9CZShpZDIpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgSURzIHdpdGggY3VzdG9tIHByZWZpeCBhbmQgbGVuZ3RoJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrR2VuZXJhdGVJZCA9IGplc3QuZm4oKHByZWZpeCA9ICcnLCBsZW5ndGggPSA4KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBwcmVmaXg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgaWQgPSBtb2NrR2VuZXJhdGVJZCgnVVNFUl8nLCAxMik7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoaWQpLnRvSGF2ZUxlbmd0aCgxNyk7IC8vIDUgKHByZWZpeCkgKyAxMiAoZ2VuZXJhdGVkKVxuICAgICAgICBleHBlY3QoaWQpLnRvU3RhcnRXaXRoKCdVU0VSXycpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc2x1Z2lmeScsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY3JlYXRlIFVSTC1mcmllbmRseSBzbHVncycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1NsdWdpZnkgPSBqZXN0LmZuKCh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxcd1xccy1dL2csICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHNfLV0rL2csICctJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eLSt8LSskL2csICcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5KCdIZWxsbyBXb3JsZCcpKS50b0JlKCdoZWxsby13b3JsZCcpO1xuICAgICAgICBleHBlY3QobW9ja1NsdWdpZnkoJ1Byb2R1Y3QgTmFtZSAmIERlc2NyaXB0aW9uJykpLnRvQmUoJ3Byb2R1Y3QtbmFtZS1kZXNjcmlwdGlvbicpO1xuICAgICAgICBleHBlY3QobW9ja1NsdWdpZnkoJyAgTXVsdGlwbGUgICBTcGFjZXMgICcpKS50b0JlKCdtdWx0aXBsZS1zcGFjZXMnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5KCdTcGVjaWFsIUAjJCVDaGFyYWN0ZXJzJykpLnRvQmUoJ3NwZWNpYWxjaGFyYWN0ZXJzJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZWRnZSBjYXNlcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1NsdWdpZnkgPSBqZXN0LmZuKCh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxcd1xccy1dL2csICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHNfLV0rL2csICctJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eLSt8LSskL2csICcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5KCcnKSkudG9CZSgnJyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeSgnICAgJykpLnRvQmUoJycpO1xuICAgICAgICBleHBlY3QobW9ja1NsdWdpZnkoJyFAIyQlXiYqKCknKSkudG9CZSgnJyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeSgnMTIzLTQ1Ni03ODknKSkudG9CZSgnMTIzLTQ1Ni03ODknKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3RydW5jYXRlVGV4dCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdHJ1bmNhdGUgbG9uZyB0ZXh0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVHJ1bmNhdGVUZXh0ID0gamVzdC5mbigodGV4dDogc3RyaW5nLCBtYXhMZW5ndGg6IG51bWJlciwgc3VmZml4ID0gJy4uLicpID0+IHtcbiAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoKSByZXR1cm4gdGV4dDtcbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZSgwLCBtYXhMZW5ndGggLSBzdWZmaXgubGVuZ3RoKSArIHN1ZmZpeDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbG9uZ1RleHQgPSAnVGhpcyBpcyBhIHZlcnkgbG9uZyB0ZXh0IHRoYXQgc2hvdWxkIGJlIHRydW5jYXRlZCc7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QobW9ja1RydW5jYXRlVGV4dChsb25nVGV4dCwgMjApKS50b0JlKCdUaGlzIGlzIGEgdmVyeSBsby4uLicpO1xuICAgICAgICBleHBlY3QobW9ja1RydW5jYXRlVGV4dChsb25nVGV4dCwgMTApKS50b0JlKCdUaGlzIGlzLi4uJyk7XG4gICAgICAgIGV4cGVjdChtb2NrVHJ1bmNhdGVUZXh0KCdTaG9ydCcsIDIwKSkudG9CZSgnU2hvcnQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBjdXN0b20gc3VmZml4JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVHJ1bmNhdGVUZXh0ID0gamVzdC5mbigodGV4dDogc3RyaW5nLCBtYXhMZW5ndGg6IG51bWJlciwgc3VmZml4ID0gJy4uLicpID0+IHtcbiAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoKSByZXR1cm4gdGV4dDtcbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZSgwLCBtYXhMZW5ndGggLSBzdWZmaXgubGVuZ3RoKSArIHN1ZmZpeDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdGV4dCA9ICdUaGlzIGlzIGEgbG9uZyB0ZXh0JztcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChtb2NrVHJ1bmNhdGVUZXh0KHRleHQsIDE1LCAnIFttb3JlXScpKS50b0JlKCdUaGlzIGlzIFttb3JlXScpO1xuICAgICAgICBleHBlY3QobW9ja1RydW5jYXRlVGV4dCh0ZXh0LCAxMCwgJycpKS50b0JlKCdUaGlzIGlzIGEgJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdkZWJvdW5jZScsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZGVib3VuY2UgZnVuY3Rpb24gY2FsbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBjYWxsQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBtb2NrRnVuY3Rpb24gPSBqZXN0LmZuKCgpID0+IGNhbGxDb3VudCsrKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG1vY2tEZWJvdW5jZSA9IGplc3QuZm4oKGZ1bmM6IEZ1bmN0aW9uLCBkZWxheTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgbGV0IHRpbWVvdXRJZDogTm9kZUpTLlRpbWVvdXQ7XG4gICAgICAgICAgcmV0dXJuICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGZ1bmMuYXBwbHkobnVsbCwgYXJncyksIGRlbGF5KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBkZWJvdW5jZWRGdW5jdGlvbiA9IG1vY2tEZWJvdW5jZShtb2NrRnVuY3Rpb24sIDEwMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxsIG11bHRpcGxlIHRpbWVzIHF1aWNrbHlcbiAgICAgICAgZGVib3VuY2VkRnVuY3Rpb24oKTtcbiAgICAgICAgZGVib3VuY2VkRnVuY3Rpb24oKTtcbiAgICAgICAgZGVib3VuY2VkRnVuY3Rpb24oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBub3QgaGF2ZSBiZWVuIGNhbGxlZCB5ZXRcbiAgICAgICAgZXhwZWN0KG1vY2tGdW5jdGlvbikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIGRlYm91bmNlIGRlbGF5XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBoYXZlIGJlZW4gY2FsbGVkIG9ubHkgb25jZVxuICAgICAgICBleHBlY3QobW9ja0Z1bmN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd0aHJvdHRsZScsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdGhyb3R0bGUgZnVuY3Rpb24gY2FsbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBjYWxsQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBtb2NrRnVuY3Rpb24gPSBqZXN0LmZuKCgpID0+IGNhbGxDb3VudCsrKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG1vY2tUaHJvdHRsZSA9IGplc3QuZm4oKGZ1bmM6IEZ1bmN0aW9uLCBkZWxheTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgbGV0IGxhc3RDYWxsID0gMDtcbiAgICAgICAgICByZXR1cm4gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKG5vdyAtIGxhc3RDYWxsID49IGRlbGF5KSB7XG4gICAgICAgICAgICAgIGxhc3RDYWxsID0gbm93O1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0aHJvdHRsZWRGdW5jdGlvbiA9IG1vY2tUaHJvdHRsZShtb2NrRnVuY3Rpb24sIDEwMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxsIG11bHRpcGxlIHRpbWVzIHF1aWNrbHlcbiAgICAgICAgdGhyb3R0bGVkRnVuY3Rpb24oKTtcbiAgICAgICAgdGhyb3R0bGVkRnVuY3Rpb24oKTtcbiAgICAgICAgdGhyb3R0bGVkRnVuY3Rpb24oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBoYXZlIGJlZW4gY2FsbGVkIG9ubHkgb25jZSBpbW1lZGlhdGVseVxuICAgICAgICBleHBlY3QobW9ja0Z1bmN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciB0aHJvdHRsZSBkZWxheVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTUwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxsIGFnYWluXG4gICAgICAgIHRocm90dGxlZEZ1bmN0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG91bGQgaGF2ZSBiZWVuIGNhbGxlZCB0d2ljZSB0b3RhbFxuICAgICAgICBleHBlY3QobW9ja0Z1bmN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhbGN1bGF0aW9uIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICBkZXNjcmliZSgnY2FsY3VsYXRlVGF4JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgdGF4IGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0NhbGN1bGF0ZVRheCA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCB0YXhSYXRlOiBudW1iZXIpID0+IHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgoYW1vdW50ICogdGF4UmF0ZSkgKiAxMDApIC8gMTAwO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRheCgxMDAsIDAuMDgpKS50b0JlKDgpO1xuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRheCgyNTAuNTAsIDAuMDc1KSkudG9CZSgxOC43OSk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVGF4KDAsIDAuMDgpKS50b0JlKDApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tDYWxjdWxhdGVUYXggPSBqZXN0LmZuKChhbW91bnQ6IG51bWJlciwgdGF4UmF0ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgaWYgKGFtb3VudCA8IDAgfHwgdGF4UmF0ZSA8IDApIHJldHVybiAwO1xuICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbW91bnQgKiB0YXhSYXRlKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVGF4KC0xMDAsIDAuMDgpKS50b0JlKDApO1xuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRheCgxMDAsIC0wLjA4KSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUYXgoMTAwLCAwKSkudG9CZSgwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NhbGN1bGF0ZURpc2NvdW50JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgcGVyY2VudGFnZSBkaXNjb3VudCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0NhbGN1bGF0ZURpc2NvdW50ID0gamVzdC5mbigoYW1vdW50OiBudW1iZXIsIGRpc2NvdW50OiBudW1iZXIsIGlzUGVyY2VudGFnZSA9IHRydWUpID0+IHtcbiAgICAgICAgICBpZiAoaXNQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgoYW1vdW50ICogKGRpc2NvdW50IC8gMTAwKSkgKiAxMDApIC8gMTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4oZGlzY291bnQsIGFtb3VudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlRGlzY291bnQoMTAwLCAxMCwgdHJ1ZSkpLnRvQmUoMTApO1xuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZURpc2NvdW50KDI1MCwgMTUsIHRydWUpKS50b0JlKDM3LjUpO1xuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZURpc2NvdW50KDUwLCAyMCwgdHJ1ZSkpLnRvQmUoMTApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgY2FsY3VsYXRlIGZpeGVkIGRpc2NvdW50JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrQ2FsY3VsYXRlRGlzY291bnQgPSBqZXN0LmZuKChhbW91bnQ6IG51bWJlciwgZGlzY291bnQ6IG51bWJlciwgaXNQZXJjZW50YWdlID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgIGlmIChpc1BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbW91bnQgKiAoZGlzY291bnQgLyAxMDApKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbihkaXNjb3VudCwgYW1vdW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVEaXNjb3VudCgxMDAsIDE1LCBmYWxzZSkpLnRvQmUoMTUpO1xuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZURpc2NvdW50KDUwLCA3NSwgZmFsc2UpKS50b0JlKDUwKTsgLy8gQ2FuJ3QgZGlzY291bnQgbW9yZSB0aGFuIGFtb3VudFxuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZURpc2NvdW50KDIwMCwgMjUsIGZhbHNlKSkudG9CZSgyNSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdjYWxjdWxhdGVUb3RhbCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY2FsY3VsYXRlIHRvdGFsIHdpdGggdGF4IGFuZCBkaXNjb3VudCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0NhbGN1bGF0ZVRvdGFsID0gamVzdC5mbigoc3VidG90YWw6IG51bWJlciwgdGF4OiBudW1iZXIsIGRpc2NvdW50OiBudW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBhZnRlckRpc2NvdW50ID0gc3VidG90YWwgLSBkaXNjb3VudDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgoYWZ0ZXJEaXNjb3VudCArIHRheCkgKiAxMDApIC8gMTAwO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRvdGFsKDEwMCwgOCwgMTApKS50b0JlKDk4KTsgLy8gMTAwIC0gMTAgKyA4XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVG90YWwoMjUwLCAyMCwgMjUpKS50b0JlKDI0NSk7IC8vIDI1MCAtIDI1ICsgMjBcbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUb3RhbCg1MCwgMCwgMCkpLnRvQmUoNTApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIG5lZ2F0aXZlIHJlc3VsdHMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tDYWxjdWxhdGVUb3RhbCA9IGplc3QuZm4oKHN1YnRvdGFsOiBudW1iZXIsIHRheDogbnVtYmVyLCBkaXNjb3VudDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgYWZ0ZXJEaXNjb3VudCA9IHN1YnRvdGFsIC0gZGlzY291bnQ7XG4gICAgICAgICAgY29uc3QgdG90YWwgPSBhZnRlckRpc2NvdW50ICsgdGF4O1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHRvdGFsICogMTAwKSAvIDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVG90YWwoMTAsIDEsIDE1KSkudG9CZSgwKTsgLy8gQ2FuJ3QgZ28gbmVnYXRpdmVcbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUb3RhbCgwLCAwLCA1KSkudG9CZSgwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2FuaXRpemF0aW9uIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICBkZXNjcmliZSgnc2FuaXRpemVJbnB1dCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgc2FuaXRpemUgdXNlciBpbnB1dCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1Nhbml0aXplSW5wdXQgPSBqZXN0LmZuKChpbnB1dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0XG4gICAgICAgICAgICAucmVwbGFjZSgvPHNjcmlwdFtePl0qPi4qPzxcXC9zY3JpcHQ+L2dpLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88W14+XSo+L2csICcnKVxuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tTYW5pdGl6ZUlucHV0KCdIZWxsbyA8c2NyaXB0PmFsZXJ0KFwieHNzXCIpPC9zY3JpcHQ+IFdvcmxkJykpLnRvQmUoJ0hlbGxvICBXb3JsZCcpO1xuICAgICAgICBleHBlY3QobW9ja1Nhbml0aXplSW5wdXQoJzxiPkJvbGQ8L2I+IHRleHQnKSkudG9CZSgnQm9sZCB0ZXh0Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2FuaXRpemVJbnB1dCgnICBOb3JtYWwgdGV4dCAgJykpLnRvQmUoJ05vcm1hbCB0ZXh0Jyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWFsaWNpb3VzIGlucHV0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrU2FuaXRpemVJbnB1dCA9IGplc3QuZm4oKGlucHV0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICByZXR1cm4gaW5wdXRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88c2NyaXB0W14+XSo+Lio/PFxcL3NjcmlwdD4vZ2ksICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL2phdmFzY3JpcHQ6L2dpLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9vblxcdytcXHMqPS9naSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPFtePl0qPi9nLCAnJylcbiAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrU2FuaXRpemVJbnB1dCgnPGltZyBzcmM9XCJ4XCIgb25lcnJvcj1cImFsZXJ0KDEpXCI+JykpLnRvQmUoJycpO1xuICAgICAgICBleHBlY3QobW9ja1Nhbml0aXplSW5wdXQoJ2phdmFzY3JpcHQ6YWxlcnQoXCJ4c3NcIiknKSkudG9CZSgnYWxlcnQoXCJ4c3NcIiknKTtcbiAgICAgICAgZXhwZWN0KG1vY2tTYW5pdGl6ZUlucHV0KCc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCI+TGluazwvYT4nKSkudG9CZSgnTGluaycpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZXNjYXBlSHRtbCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZXNjYXBlIEhUTUwgZW50aXRpZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tFc2NhcGVIdG1sID0gamVzdC5mbigodGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgZW50aXR5TWFwOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgICAgICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAgICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgICAgICAgXCInXCI6ICcmIzM5OycsXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bJjw+XCInXS9nLCAoY2hhcikgPT4gZW50aXR5TWFwW2NoYXJdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tFc2NhcGVIdG1sKCc8ZGl2PkhlbGxvICYgXCJXb3JsZFwiPC9kaXY+JykpLnRvQmUoJyZsdDtkaXYmZ3Q7SGVsbG8gJmFtcDsgJnF1b3Q7V29ybGQmcXVvdDsmbHQ7L2RpdiZndDsnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tFc2NhcGVIdG1sKFwiSXQncyBhICd0ZXN0J1wiKSkudG9CZSgnSXQmIzM5O3MgYSAmIzM5O3Rlc3QmIzM5OycpO1xuICAgICAgICBleHBlY3QobW9ja0VzY2FwZUh0bWwoJ05vcm1hbCB0ZXh0JykpLnRvQmUoJ05vcm1hbCB0ZXh0Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdwYXJzZVF1ZXJ5UGFyYW1zJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBwYXJzZSBVUkwgcXVlcnkgcGFyYW1ldGVycycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1BhcnNlUXVlcnlQYXJhbXMgPSBqZXN0LmZuKChxdWVyeVN0cmluZzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeVN0cmluZyk7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdXJsUGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1BhcnNlUXVlcnlQYXJhbXMoJz9uYW1lPUpvaG4mYWdlPTMwJmNpdHk9TllDJykpLnRvRXF1YWwoe1xuICAgICAgICAgIG5hbWU6ICdKb2huJyxcbiAgICAgICAgICBhZ2U6ICczMCcsXG4gICAgICAgICAgY2l0eTogJ05ZQycsXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KG1vY2tQYXJzZVF1ZXJ5UGFyYW1zKCdzZWFyY2g9dGVzdCZwYWdlPTEmbGltaXQ9MTAnKSkudG9FcXVhbCh7XG4gICAgICAgICAgc2VhcmNoOiAndGVzdCcsXG4gICAgICAgICAgcGFnZTogJzEnLFxuICAgICAgICAgIGxpbWl0OiAnMTAnLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBvciBtYWxmb3JtZWQgcXVlcnkgc3RyaW5ncycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1BhcnNlUXVlcnlQYXJhbXMgPSBqZXN0LmZuKChxdWVyeVN0cmluZzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGFuZGxlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgICBpZiAoIXF1ZXJ5U3RyaW5nIHx8IHF1ZXJ5U3RyaW5nID09PSAnPycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhhbmRsZSBtYWxmb3JtZWQgcXVlcnkgc3RyaW5ncyAobm8gPSBzaWduKVxuICAgICAgICAgIGlmICghcXVlcnlTdHJpbmcuaW5jbHVkZXMoJz0nKSAmJiAhcXVlcnlTdHJpbmcuc3RhcnRzV2l0aCgnPycpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeVN0cmluZyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB1cmxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGVtcHR5IG9iamVjdCBmb3IgbWFsZm9ybWVkIHF1ZXJpZXNcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQYXJzZVF1ZXJ5UGFyYW1zKCcnKSkudG9FcXVhbCh7fSk7XG4gICAgICAgIGV4cGVjdChtb2NrUGFyc2VRdWVyeVBhcmFtcygnPycpKS50b0VxdWFsKHt9KTtcbiAgICAgICAgZXhwZWN0KG1vY2tQYXJzZVF1ZXJ5UGFyYW1zKCdpbnZhbGlkJykpLnRvRXF1YWwoe30pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIFVSTCBlbmNvZGluZycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1BhcnNlUXVlcnlQYXJhbXMgPSBqZXN0LmZuKChxdWVyeVN0cmluZzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeVN0cmluZyk7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdXJsUGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXNba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUGFyc2VRdWVyeVBhcmFtcygnc2VhcmNoPWhlbGxvJTIwd29ybGQmc3BlY2lhbD0lMjElNDAlMjMnKSkudG9FcXVhbCh7XG4gICAgICAgICAgc2VhcmNoOiAnaGVsbG8gd29ybGQnLFxuICAgICAgICAgIHNwZWNpYWw6ICchQCMnLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcgaW4gVXRpbGl0aWVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVycm9ycyBpbiBmb3JtYXR0aW5nIGZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tGb3JtYXRDdXJyZW5jeVdpdGhFcnJvciA9IGplc3QuZm4oKGFtb3VudDogYW55KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhbW91bnQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYW1vdW50IHR5cGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGAkJHthbW91bnQudG9GaXhlZCgyKX1gO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGVTcHkuZXJyb3IoJ0N1cnJlbmN5IGZvcm1hdHRpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiAnJDAuMDAnO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeVdpdGhFcnJvcignaW52YWxpZCcpKS50b0JlKCckMC4wMCcpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnQ3VycmVuY3kgZm9ybWF0dGluZyBlcnJvcjonLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVycm9ycyBpbiB2YWxpZGF0aW9uIGZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZUVtYWlsV2l0aEVycm9yID0gamVzdC5mbigoZW1haWw6IGFueSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtYWlsIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvLnRlc3QoZW1haWwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGVTcHkuZXJyb3IoJ0VtYWlsIHZhbGlkYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbFdpdGhFcnJvcihudWxsKSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QobW9ja1ZhbGlkYXRlRW1haWxXaXRoRXJyb3IoMTIzKSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdFbWFpbCB2YWxpZGF0aW9uIGVycm9yOicsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGluIHV0aWxpdHkgZnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NsdWdpZnlXaXRoRXJyb3IgPSBqZXN0LmZuKCh0ZXh0OiBhbnkpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGV4dC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XS9nLCAnLScpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGVTcHkuZXJyb3IoJ1NsdWdpZnkgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeVdpdGhFcnJvcihudWxsKSkudG9CZSgnJyk7XG4gICAgICBleHBlY3QobW9ja1NsdWdpZnlXaXRoRXJyb3Ioe30pKS50b0JlKCcnKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ1NsdWdpZnkgZXJyb3I6JyxcbiAgICAgICAgZXhwZWN0LmFueShFcnJvcilcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBUZXN0cyBmb3IgVXRpbGl0aWVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIGRhdGFzZXRzIGVmZmljaWVudGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0JhdGNoUHJvY2VzcyA9IGplc3QuZm4oKGl0ZW1zOiBhbnlbXSwgYmF0Y2hTaXplID0gMTAwKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgY29uc3QgYmF0Y2ggPSBpdGVtcy5zbGljZShpLCBpICsgYmF0Y2hTaXplKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2goLi4uYmF0Y2gubWFwKGl0ZW0gPT4gaXRlbS5pZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGxhcmdlRGF0YXNldCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMDAwIH0sIChfLCBpKSA9PiAoeyBpZDogaSwgbmFtZTogYEl0ZW0gJHtpfWAgfSkpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gbW9ja0JhdGNoUHJvY2VzcyhsYXJnZURhdGFzZXQpO1xuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZUxlbmd0aCgxMDAwMCk7XG4gICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDEwMCk7IC8vIFNob3VsZCBwcm9jZXNzIHF1aWNrbHlcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgdXRpbGl0eSBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FzeW5jVXRpbGl0eSA9IGplc3QuZm4oYXN5bmMgKGRhdGE6IHN0cmluZykgPT4ge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgcmV0dXJuIGRhdGEudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvcGVyYXRpb25zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgbW9ja0FzeW5jVXRpbGl0eShgdGVzdC0ke2l9YClcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwob3BlcmF0aW9ucyk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aCgxMDApO1xuICAgICAgZXhwZWN0KHJlc3VsdHNbMF0pLnRvQmUoJ1RFU1QtMCcpO1xuICAgICAgZXhwZWN0KGVuZFRpbWUgLSBzdGFydFRpbWUpLnRvQmVMZXNzVGhhbig1MDApOyAvLyBTaG91bGQgaGFuZGxlIGNvbmN1cnJlbmN5IHdlbGxcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiY29uc29sZVNweSIsImxvZyIsImplc3QiLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJlcnJvciIsIndhcm4iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja0NsZWFyIiwiYWZ0ZXJBbGwiLCJtb2NrUmVzdG9yZSIsIml0IiwibW9ja0Zvcm1hdEN1cnJlbmN5IiwiZm4iLCJhbW91bnQiLCJjdXJyZW5jeSIsImxvY2FsZSIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJzdHlsZSIsImZvcm1hdCIsImV4cGVjdCIsInRvQmUiLCJpc05hTiIsImlzRmluaXRlIiwiTmFOIiwiSW5maW5pdHkiLCJtb2NrRm9ybWF0RGF0ZSIsImRhdGUiLCJkIiwiRGF0ZSIsImdldFRpbWUiLCJtb250aCIsIlN0cmluZyIsImdldE1vbnRoIiwicGFkU3RhcnQiLCJkYXkiLCJnZXREYXRlIiwieWVhciIsImdldEZ1bGxZZWFyIiwidGVzdERhdGUiLCJmb3JtYXRNYXAiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJtb2NrRm9ybWF0UGhvbmVOdW1iZXIiLCJwaG9uZSIsImNvdW50cnkiLCJjbGVhbmVkIiwicmVwbGFjZSIsImxlbmd0aCIsInNsaWNlIiwibW9ja1ZhbGlkYXRlRW1haWwiLCJlbWFpbCIsImVtYWlsUmVnZXgiLCJ0ZXN0IiwibW9ja1ZhbGlkYXRlUGFzc3dvcmQiLCJwYXNzd29yZCIsIm1pbkxlbmd0aCIsImhhc1VwcGVyIiwiaGFzTG93ZXIiLCJoYXNOdW1iZXIiLCJoYXNTcGVjaWFsIiwibW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIiLCJzdGFydHNXaXRoIiwibW9ja1ZhbGlkYXRlUmVxdWlyZWQiLCJ2YWx1ZSIsInRyaW0iLCJ1bmRlZmluZWQiLCJtb2NrR2VuZXJhdGVJZCIsInByZWZpeCIsImNoYXJzIiwicmVzdWx0IiwiaSIsImNoYXJBdCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImlkMSIsImlkMiIsInRvSGF2ZUxlbmd0aCIsIm5vdCIsImlkIiwidG9TdGFydFdpdGgiLCJtb2NrU2x1Z2lmeSIsInRleHQiLCJ0b0xvd2VyQ2FzZSIsIm1vY2tUcnVuY2F0ZVRleHQiLCJtYXhMZW5ndGgiLCJzdWZmaXgiLCJsb25nVGV4dCIsImNhbGxDb3VudCIsIm1vY2tGdW5jdGlvbiIsIm1vY2tEZWJvdW5jZSIsImZ1bmMiLCJkZWxheSIsInRpbWVvdXRJZCIsImFyZ3MiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJkZWJvdW5jZWRGdW5jdGlvbiIsInRvSGF2ZUJlZW5DYWxsZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsIm1vY2tUaHJvdHRsZSIsImxhc3RDYWxsIiwibm93IiwidGhyb3R0bGVkRnVuY3Rpb24iLCJtb2NrQ2FsY3VsYXRlVGF4IiwidGF4UmF0ZSIsInJvdW5kIiwibW9ja0NhbGN1bGF0ZURpc2NvdW50IiwiZGlzY291bnQiLCJpc1BlcmNlbnRhZ2UiLCJtaW4iLCJtb2NrQ2FsY3VsYXRlVG90YWwiLCJzdWJ0b3RhbCIsInRheCIsImFmdGVyRGlzY291bnQiLCJ0b3RhbCIsIm1heCIsIm1vY2tTYW5pdGl6ZUlucHV0IiwiaW5wdXQiLCJtb2NrRXNjYXBlSHRtbCIsImVudGl0eU1hcCIsImNoYXIiLCJtb2NrUGFyc2VRdWVyeVBhcmFtcyIsInF1ZXJ5U3RyaW5nIiwicGFyYW1zIiwidXJsUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwia2V5IiwidG9FcXVhbCIsIm5hbWUiLCJhZ2UiLCJjaXR5Iiwic2VhcmNoIiwicGFnZSIsImxpbWl0IiwiaW5jbHVkZXMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzcGVjaWFsIiwibW9ja0Zvcm1hdEN1cnJlbmN5V2l0aEVycm9yIiwiRXJyb3IiLCJ0b0ZpeGVkIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJhbnkiLCJtb2NrVmFsaWRhdGVFbWFpbFdpdGhFcnJvciIsIm1vY2tTbHVnaWZ5V2l0aEVycm9yIiwibW9ja0JhdGNoUHJvY2VzcyIsIml0ZW1zIiwiYmF0Y2hTaXplIiwicmVzdWx0cyIsImJhdGNoIiwicHVzaCIsIm1hcCIsIml0ZW0iLCJsYXJnZURhdGFzZXQiLCJBcnJheSIsImZyb20iLCJfIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInRvQmVMZXNzVGhhbiIsIm1vY2tBc3luY1V0aWxpdHkiLCJkYXRhIiwidG9VcHBlckNhc2UiLCJvcGVyYXRpb25zIiwiYWxsIl0sIm1hcHBpbmdzIjoiOzs7O0FBTUEsdUJBQXVCO0FBQ3ZCLE1BQU1BLGFBQWE7SUFDakJDLEtBQUtDLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxPQUFPQyxrQkFBa0IsQ0FBQyxLQUFPO0lBQzFEQyxPQUFPSixLQUFLQyxLQUFLLENBQUNDLFNBQVMsU0FBU0Msa0JBQWtCLENBQUMsS0FBTztJQUM5REUsTUFBTUwsS0FBS0MsS0FBSyxDQUFDQyxTQUFTLFFBQVFDLGtCQUFrQixDQUFDLEtBQU87QUFDOUQ7QUFFQUcsU0FBUywyQkFBMkI7SUFDbENDLFdBQVc7UUFDVFAsS0FBS1EsYUFBYTtRQUNsQlYsV0FBV0MsR0FBRyxDQUFD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