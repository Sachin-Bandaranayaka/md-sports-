{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/lib/transferCache.ts"],"sourcesContent":["/**\n * Transfer-specific Cache Service\n * Optimized caching for inventory transfer operations\n */\n\nimport { Redis } from 'ioredis';\nimport { cacheService } from './cache';\n\n// Cache configuration for transfers\nconst TRANSFER_CACHE_CONFIG = {\n  TTL: {\n    TRANSFER_LIST: 300,     // 5 minutes\n    TRANSFER_DETAIL: 600,   // 10 minutes\n    SHOP_INVENTORY: 180,    // 3 minutes\n    TRANSFER_STATS: 900     // 15 minutes\n  },\n  KEYS: {\n    TRANSFER_LIST: 'transfers:list',\n    TRANSFER_DETAIL: 'transfers:detail',\n    SHOP_INVENTORY: 'inventory:shop',\n    TRANSFER_STATS: 'transfers:stats'\n  }\n};\n\ninterface TransferFilters {\n  page?: number;\n  limit?: number;\n  status?: string;\n  sourceShopId?: number;\n  destinationShopId?: number;\n  search?: string;\n  startDate?: string;\n  endDate?: string;\n}\n\ninterface CacheMetrics {\n  hits: number;\n  misses: number;\n  totalRequests: number;\n  avgResponseTime: number;\n}\n\nclass TransferCacheService {\n  private redis: Redis | null = null;\n  private metrics: Map<string, CacheMetrics> = new Map();\n  private warmingInProgress: Set<string> = new Set();\n\n  constructor() {\n    this.initializeRedis();\n    this.startMetricsCollection();\n  }\n\n  private initializeRedis() {\n    if (process.env.REDIS_URL) {\n      try {\n        this.redis = new Redis(process.env.REDIS_URL);\n        console.log('âœ“ Transfer cache Redis connection established');\n      } catch (error) {\n        console.error('âœ— Transfer cache Redis connection failed:', error);\n      }\n    }\n  }\n\n  private startMetricsCollection() {\n    setInterval(() => {\n      this.logMetrics();\n    }, 60000); // Log metrics every minute\n  }\n\n  generateTransferCacheKey(baseKey: string, filters: TransferFilters): string {\n    const keyParts = [baseKey];\n\n    if (filters.page) keyParts.push(`page:${filters.page}`);\n    if (filters.limit) keyParts.push(`limit:${filters.limit}`);\n    if (filters.status) keyParts.push(`status:${filters.status}`);\n    if (filters.sourceShopId) keyParts.push(`src:${filters.sourceShopId}`);\n    if (filters.destinationShopId) keyParts.push(`dst:${filters.destinationShopId}`);\n    if (filters.search) keyParts.push(`search:${encodeURIComponent(filters.search)}`);\n    if (filters.startDate) keyParts.push(`start:${filters.startDate}`);\n    if (filters.endDate) keyParts.push(`end:${filters.endDate}`);\n\n    return keyParts.join(':');\n  }\n\n  async get<T>(key: string): Promise<T | null> {\n    const startTime = performance.now();\n\n    try {\n      let data: T | null = null;\n\n      // Try Redis first\n      if (this.redis) {\n        const cached = await this.redis.get(key);\n        if (cached) {\n          data = JSON.parse(cached);\n          this.recordMetric(key, 'hit', performance.now() - startTime);\n          return data;\n        }\n      }\n\n      // Fallback to memory cache\n      data = await cacheService.get(key);\n      if (data) {\n        this.recordMetric(key, 'hit', performance.now() - startTime);\n        return data;\n      }\n\n      this.recordMetric(key, 'miss', performance.now() - startTime);\n      return null;\n    } catch (error) {\n      console.error('Transfer cache get error:', error);\n      this.recordMetric(key, 'miss', performance.now() - startTime);\n      return null;\n    }\n  }\n\n  async set<T>(key: string, data: T, ttl: number = TRANSFER_CACHE_CONFIG.TTL.TRANSFER_LIST): Promise<void> {\n    try {\n      const serialized = JSON.stringify(data);\n\n      // Store in Redis\n      if (this.redis) {\n        await this.redis.setex(key, ttl, serialized);\n      }\n\n      // Store in memory cache as fallback\n      await cacheService.set(key, data, ttl);\n\n    } catch (error) {\n      console.error('Transfer cache set error:', error);\n    }\n  }\n\n  async getOrSet<T>(\n    key: string,\n    fetcher: () => Promise<T>,\n    ttl?: number\n  ): Promise<T> {\n    // Try to get from cache first\n    const cached = await this.get<T>(key);\n    if (cached !== null) {\n      return cached;\n    }\n\n    // Fetch fresh data\n    const data = await fetcher();\n\n    // Store in cache\n    await this.set(key, data, ttl);\n\n    return data;\n  }\n\n  async invalidateTransferCache(transferId?: number, shopIds?: number[]): Promise<void> {\n    try {\n      const patterns = [\n        `${TRANSFER_CACHE_CONFIG.KEYS.TRANSFER_LIST}*`,\n        `${TRANSFER_CACHE_CONFIG.KEYS.TRANSFER_STATS}*`\n      ];\n\n      if (transferId) {\n        patterns.push(`${TRANSFER_CACHE_CONFIG.KEYS.TRANSFER_DETAIL}:${transferId}`);\n      }\n\n      if (shopIds) {\n        shopIds.forEach(shopId => {\n          patterns.push(`${TRANSFER_CACHE_CONFIG.KEYS.SHOP_INVENTORY}:${shopId}*`);\n        });\n      }\n\n      // Invalidate Redis cache\n      if (this.redis) {\n        for (const pattern of patterns) {\n          const keys = await this.redis.keys(pattern);\n          if (keys.length > 0) {\n            await this.redis.del(...keys);\n          }\n        }\n      }\n\n      // Invalidate memory cache\n      for (const pattern of patterns) {\n        await cacheService.invalidatePattern(pattern);\n      }\n\n      console.log(`âœ“ Invalidated transfer cache for patterns: ${patterns.join(', ')}`);\n    } catch (error) {\n      console.error('Transfer cache invalidation error:', error);\n    }\n  }\n\n  async warmTransferCache(filters: TransferFilters): Promise<void> {\n    const cacheKey = this.generateTransferCacheKey(TRANSFER_CACHE_CONFIG.KEYS.TRANSFER_LIST, filters);\n\n    if (this.warmingInProgress.has(cacheKey)) {\n      return;\n    }\n\n    this.warmingInProgress.add(cacheKey);\n\n    try {\n      // This would be implemented with actual transfer fetching logic\n      console.log(`ðŸ”¥ Warming transfer cache: ${cacheKey}`);\n      // await this.fetchTransfersFromDB(filters);\n    } catch (error) {\n      console.error('Transfer cache warming error:', error);\n    } finally {\n      this.warmingInProgress.delete(cacheKey);\n    }\n  }\n\n  private recordMetric(key: string, type: 'hit' | 'miss', responseTime: number): void {\n    const existing = this.metrics.get(key) || {\n      hits: 0,\n      misses: 0,\n      totalRequests: 0,\n      avgResponseTime: 0\n    };\n\n    if (type === 'hit') {\n      existing.hits++;\n    } else {\n      existing.misses++;\n    }\n\n    existing.totalRequests++;\n    existing.avgResponseTime = (\n      (existing.avgResponseTime * (existing.totalRequests - 1)) + responseTime\n    ) / existing.totalRequests;\n\n    this.metrics.set(key, existing);\n  }\n\n  private logMetrics(): void {\n    if (this.metrics.size === 0) return;\n\n    console.log('ðŸ“Š Transfer Cache Metrics:');\n    this.metrics.forEach((metric, key) => {\n      const hitRate = (metric.hits / metric.totalRequests * 100).toFixed(2);\n      console.log(`  ${key}: ${hitRate}% hit rate, ${metric.avgResponseTime.toFixed(2)}ms avg`);\n    });\n  }\n\n  getMetrics(): Map<string, CacheMetrics> {\n    return new Map(this.metrics);\n  }\n\n  async clearAllCache(): Promise<void> {\n    try {\n      if (this.redis) {\n        const keys = await this.redis.keys('transfers:*');\n        if (keys.length > 0) {\n          await this.redis.del(...keys);\n        }\n      }\n\n      await cacheService.invalidatePattern('transfers:*');\n      console.log('âœ“ Cleared all transfer cache');\n    } catch (error) {\n      console.error('Error clearing transfer cache:', error);\n    }\n  }\n}\n\nexport const transferCacheService = new TransferCacheService();\nexport { TRANSFER_CACHE_CONFIG, TransferFilters, CacheMetrics };"],"names":["TRANSFER_CACHE_CONFIG","transferCacheService","TTL","TRANSFER_LIST","TRANSFER_DETAIL","SHOP_INVENTORY","TRANSFER_STATS","KEYS","TransferCacheService","constructor","redis","metrics","Map","warmingInProgress","Set","initializeRedis","startMetricsCollection","process","env","REDIS_URL","Redis","console","log","error","setInterval","logMetrics","generateTransferCacheKey","baseKey","filters","keyParts","page","push","limit","status","sourceShopId","destinationShopId","search","encodeURIComponent","startDate","endDate","join","get","key","startTime","performance","now","data","cached","JSON","parse","recordMetric","cacheService","set","ttl","serialized","stringify","setex","getOrSet","fetcher","invalidateTransferCache","transferId","shopIds","patterns","forEach","shopId","pattern","keys","length","del","invalidatePattern","warmTransferCache","cacheKey","has","add","delete","type","responseTime","existing","hits","misses","totalRequests","avgResponseTime","size","metric","hitRate","toFixed","getMetrics","clearAllCache"],"mappings":"AAAA;;;CAGC;;;;;;;;;;;IAsQQA,qBAAqB;eAArBA;;IADIC,oBAAoB;eAApBA;;;yBAnQS;uBACO;AAE7B,oCAAoC;AACpC,MAAMD,wBAAwB;IAC5BE,KAAK;QACHC,eAAe;QACfC,iBAAiB;QACjBC,gBAAgB;QAChBC,gBAAgB,IAAQ,aAAa;IACvC;IACAC,MAAM;QACJJ,eAAe;QACfC,iBAAiB;QACjBC,gBAAgB;QAChBC,gBAAgB;IAClB;AACF;AAoBA,MAAME;IAKJC,aAAc;aAJNC,QAAsB;aACtBC,UAAqC,IAAIC;aACzCC,oBAAiC,IAAIC;QAG3C,IAAI,CAACC,eAAe;QACpB,IAAI,CAACC,sBAAsB;IAC7B;IAEQD,kBAAkB;QACxB,IAAIE,QAAQC,GAAG,CAACC,SAAS,EAAE;YACzB,IAAI;gBACF,IAAI,CAACT,KAAK,GAAG,IAAIU,cAAK,CAACH,QAAQC,GAAG,CAACC,SAAS;gBAC5CE,QAAQC,GAAG,CAAC;YACd,EAAE,OAAOC,OAAO;gBACdF,QAAQE,KAAK,CAAC,6CAA6CA;YAC7D;QACF;IACF;IAEQP,yBAAyB;QAC/BQ,YAAY;YACV,IAAI,CAACC,UAAU;QACjB,GAAG,QAAQ,2BAA2B;IACxC;IAEAC,yBAAyBC,OAAe,EAAEC,OAAwB,EAAU;QAC1E,MAAMC,WAAW;YAACF;SAAQ;QAE1B,IAAIC,QAAQE,IAAI,EAAED,SAASE,IAAI,CAAC,CAAC,KAAK,EAAEH,QAAQE,IAAI,CAAC,CAAC;QACtD,IAAIF,QAAQI,KAAK,EAAEH,SAASE,IAAI,CAAC,CAAC,MAAM,EAAEH,QAAQI,KAAK,CAAC,CAAC;QACzD,IAAIJ,QAAQK,MAAM,EAAEJ,SAASE,IAAI,CAAC,CAAC,OAAO,EAAEH,QAAQK,MAAM,CAAC,CAAC;QAC5D,IAAIL,QAAQM,YAAY,EAAEL,SAASE,IAAI,CAAC,CAAC,IAAI,EAAEH,QAAQM,YAAY,CAAC,CAAC;QACrE,IAAIN,QAAQO,iBAAiB,EAAEN,SAASE,IAAI,CAAC,CAAC,IAAI,EAAEH,QAAQO,iBAAiB,CAAC,CAAC;QAC/E,IAAIP,QAAQQ,MAAM,EAAEP,SAASE,IAAI,CAAC,CAAC,OAAO,EAAEM,mBAAmBT,QAAQQ,MAAM,EAAE,CAAC;QAChF,IAAIR,QAAQU,SAAS,EAAET,SAASE,IAAI,CAAC,CAAC,MAAM,EAAEH,QAAQU,SAAS,CAAC,CAAC;QACjE,IAAIV,QAAQW,OAAO,EAAEV,SAASE,IAAI,CAAC,CAAC,IAAI,EAAEH,QAAQW,OAAO,CAAC,CAAC;QAE3D,OAAOV,SAASW,IAAI,CAAC;IACvB;IAEA,MAAMC,IAAOC,GAAW,EAAqB;QAC3C,MAAMC,YAAYC,YAAYC,GAAG;QAEjC,IAAI;YACF,IAAIC,OAAiB;YAErB,kBAAkB;YAClB,IAAI,IAAI,CAACpC,KAAK,EAAE;gBACd,MAAMqC,SAAS,MAAM,IAAI,CAACrC,KAAK,CAAC+B,GAAG,CAACC;gBACpC,IAAIK,QAAQ;oBACVD,OAAOE,KAAKC,KAAK,CAACF;oBAClB,IAAI,CAACG,YAAY,CAACR,KAAK,OAAOE,YAAYC,GAAG,KAAKF;oBAClD,OAAOG;gBACT;YACF;YAEA,2BAA2B;YAC3BA,OAAO,MAAMK,mBAAY,CAACV,GAAG,CAACC;YAC9B,IAAII,MAAM;gBACR,IAAI,CAACI,YAAY,CAACR,KAAK,OAAOE,YAAYC,GAAG,KAAKF;gBAClD,OAAOG;YACT;YAEA,IAAI,CAACI,YAAY,CAACR,KAAK,QAAQE,YAAYC,GAAG,KAAKF;YACnD,OAAO;QACT,EAAE,OAAOpB,OAAO;YACdF,QAAQE,KAAK,CAAC,6BAA6BA;YAC3C,IAAI,CAAC2B,YAAY,CAACR,KAAK,QAAQE,YAAYC,GAAG,KAAKF;YACnD,OAAO;QACT;IACF;IAEA,MAAMS,IAAOV,GAAW,EAAEI,IAAO,EAAEO,MAAcrD,sBAAsBE,GAAG,CAACC,aAAa,EAAiB;QACvG,IAAI;YACF,MAAMmD,aAAaN,KAAKO,SAAS,CAACT;YAElC,iBAAiB;YACjB,IAAI,IAAI,CAACpC,KAAK,EAAE;gBACd,MAAM,IAAI,CAACA,KAAK,CAAC8C,KAAK,CAACd,KAAKW,KAAKC;YACnC;YAEA,oCAAoC;YACpC,MAAMH,mBAAY,CAACC,GAAG,CAACV,KAAKI,MAAMO;QAEpC,EAAE,OAAO9B,OAAO;YACdF,QAAQE,KAAK,CAAC,6BAA6BA;QAC7C;IACF;IAEA,MAAMkC,SACJf,GAAW,EACXgB,OAAyB,EACzBL,GAAY,EACA;QACZ,8BAA8B;QAC9B,MAAMN,SAAS,MAAM,IAAI,CAACN,GAAG,CAAIC;QACjC,IAAIK,WAAW,MAAM;YACnB,OAAOA;QACT;QAEA,mBAAmB;QACnB,MAAMD,OAAO,MAAMY;QAEnB,iBAAiB;QACjB,MAAM,IAAI,CAACN,GAAG,CAACV,KAAKI,MAAMO;QAE1B,OAAOP;IACT;IAEA,MAAMa,wBAAwBC,UAAmB,EAAEC,OAAkB,EAAiB;QACpF,IAAI;YACF,MAAMC,WAAW;gBACf,CAAC,EAAE9D,sBAAsBO,IAAI,CAACJ,aAAa,CAAC,CAAC,CAAC;gBAC9C,CAAC,EAAEH,sBAAsBO,IAAI,CAACD,cAAc,CAAC,CAAC,CAAC;aAChD;YAED,IAAIsD,YAAY;gBACdE,SAAS/B,IAAI,CAAC,CAAC,EAAE/B,sBAAsBO,IAAI,CAACH,eAAe,CAAC,CAAC,EAAEwD,WAAW,CAAC;YAC7E;YAEA,IAAIC,SAAS;gBACXA,QAAQE,OAAO,CAACC,CAAAA;oBACdF,SAAS/B,IAAI,CAAC,CAAC,EAAE/B,sBAAsBO,IAAI,CAACF,cAAc,CAAC,CAAC,EAAE2D,OAAO,CAAC,CAAC;gBACzE;YACF;YAEA,yBAAyB;YACzB,IAAI,IAAI,CAACtD,KAAK,EAAE;gBACd,KAAK,MAAMuD,WAAWH,SAAU;oBAC9B,MAAMI,OAAO,MAAM,IAAI,CAACxD,KAAK,CAACwD,IAAI,CAACD;oBACnC,IAAIC,KAAKC,MAAM,GAAG,GAAG;wBACnB,MAAM,IAAI,CAACzD,KAAK,CAAC0D,GAAG,IAAIF;oBAC1B;gBACF;YACF;YAEA,0BAA0B;YAC1B,KAAK,MAAMD,WAAWH,SAAU;gBAC9B,MAAMX,mBAAY,CAACkB,iBAAiB,CAACJ;YACvC;YAEA5C,QAAQC,GAAG,CAAC,CAAC,2CAA2C,EAAEwC,SAAStB,IAAI,CAAC,MAAM,CAAC;QACjF,EAAE,OAAOjB,OAAO;YACdF,QAAQE,KAAK,CAAC,sCAAsCA;QACtD;IACF;IAEA,MAAM+C,kBAAkB1C,OAAwB,EAAiB;QAC/D,MAAM2C,WAAW,IAAI,CAAC7C,wBAAwB,CAAC1B,sBAAsBO,IAAI,CAACJ,aAAa,EAAEyB;QAEzF,IAAI,IAAI,CAACf,iBAAiB,CAAC2D,GAAG,CAACD,WAAW;YACxC;QACF;QAEA,IAAI,CAAC1D,iBAAiB,CAAC4D,GAAG,CAACF;QAE3B,IAAI;YACF,gEAAgE;YAChElD,QAAQC,GAAG,CAAC,CAAC,2BAA2B,EAAEiD,SAAS,CAAC;QACpD,4CAA4C;QAC9C,EAAE,OAAOhD,OAAO;YACdF,QAAQE,KAAK,CAAC,iCAAiCA;QACjD,SAAU;YACR,IAAI,CAACV,iBAAiB,CAAC6D,MAAM,CAACH;QAChC;IACF;IAEQrB,aAAaR,GAAW,EAAEiC,IAAoB,EAAEC,YAAoB,EAAQ;QAClF,MAAMC,WAAW,IAAI,CAAClE,OAAO,CAAC8B,GAAG,CAACC,QAAQ;YACxCoC,MAAM;YACNC,QAAQ;YACRC,eAAe;YACfC,iBAAiB;QACnB;QAEA,IAAIN,SAAS,OAAO;YAClBE,SAASC,IAAI;QACf,OAAO;YACLD,SAASE,MAAM;QACjB;QAEAF,SAASG,aAAa;QACtBH,SAASI,eAAe,GAAG,AACzB,CAAA,AAACJ,SAASI,eAAe,GAAIJ,CAAAA,SAASG,aAAa,GAAG,CAAA,IAAMJ,YAAW,IACrEC,SAASG,aAAa;QAE1B,IAAI,CAACrE,OAAO,CAACyC,GAAG,CAACV,KAAKmC;IACxB;IAEQpD,aAAmB;QACzB,IAAI,IAAI,CAACd,OAAO,CAACuE,IAAI,KAAK,GAAG;QAE7B7D,QAAQC,GAAG,CAAC;QACZ,IAAI,CAACX,OAAO,CAACoD,OAAO,CAAC,CAACoB,QAAQzC;YAC5B,MAAM0C,UAAU,AAACD,CAAAA,OAAOL,IAAI,GAAGK,OAAOH,aAAa,GAAG,GAAE,EAAGK,OAAO,CAAC;YACnEhE,QAAQC,GAAG,CAAC,CAAC,EAAE,EAAEoB,IAAI,EAAE,EAAE0C,QAAQ,YAAY,EAAED,OAAOF,eAAe,CAACI,OAAO,CAAC,GAAG,MAAM,CAAC;QAC1F;IACF;IAEAC,aAAwC;QACtC,OAAO,IAAI1E,IAAI,IAAI,CAACD,OAAO;IAC7B;IAEA,MAAM4E,gBAA+B;QACnC,IAAI;YACF,IAAI,IAAI,CAAC7E,KAAK,EAAE;gBACd,MAAMwD,OAAO,MAAM,IAAI,CAACxD,KAAK,CAACwD,IAAI,CAAC;gBACnC,IAAIA,KAAKC,MAAM,GAAG,GAAG;oBACnB,MAAM,IAAI,CAACzD,KAAK,CAAC0D,GAAG,IAAIF;gBAC1B;YACF;YAEA,MAAMf,mBAAY,CAACkB,iBAAiB,CAAC;YACrChD,QAAQC,GAAG,CAAC;QACd,EAAE,OAAOC,OAAO;YACdF,QAAQE,KAAK,CAAC,kCAAkCA;QAClD;IACF;AACF;AAEO,MAAMtB,uBAAuB,IAAIO"}