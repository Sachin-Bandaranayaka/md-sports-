e206aa0718680cbf1df8893e53b134ed
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DELETE: function() {
        return DELETE;
    },
    GET: function() {
        return GET;
    },
    PATCH: function() {
        return PATCH;
    },
    PUT: function() {
        return PUT;
    }
});
const _server = require("next/server");
const _middleware = require("../../../../../lib/utils/middleware");
const _prisma = require("../../../../../lib/prisma");
const _transferCache = require("../../../../../lib/transferCache");
const _transferPerformanceMonitor = require("../../../../../lib/transferPerformanceMonitor");
const _requestdeduplication = require("../../../../../lib/request-deduplication");
const _auth = require("../../../../../lib/auth");
// Default fallback data for a transfer
function getDefaultTransfer(id) {
    return {
        id,
        status: "pending",
        created_at: new Date().toISOString(),
        completed_at: null,
        source_shop_id: 0,
        destination_shop_id: 0,
        source_shop_name: "Unknown Shop",
        destination_shop_name: "Unknown Shop",
        initiated_by: "Unknown User",
        items: []
    };
}
// Default fallback data for transfers list
const defaultTransfersData = [
    {
        id: 1,
        status: "pending",
        created_at: new Date().toISOString(),
        completed_at: null,
        source_shop_name: "Main Store",
        destination_shop_name: "Branch Store",
        initiated_by: "System",
        item_count: 0,
        total_items: 0
    }
];
async function GET(req, { params }) {
    const operation = (0, _transferPerformanceMonitor.trackTransferOperation)("detail");
    // Check for inventory:view or inventory:transfer permission
    const viewPermission = await (0, _auth.validateTokenPermission)(req, "inventory:view");
    const transferPermission = await (0, _auth.validateTokenPermission)(req, "inventory:transfer");
    if (!viewPermission.isValid && !transferPermission.isValid) {
        operation.end(false, "unauthorized");
        return _server.NextResponse.json({
            success: false,
            message: "Permission denied"
        }, {
            status: 403
        });
    }
    const resolvedParams = await params;
    const id = parseInt(resolvedParams.id);
    if (isNaN(id)) {
        operation.end(false, "invalid_id");
        return _server.NextResponse.json({
            success: false,
            error: "Invalid transfer ID"
        }, {
            status: 400
        });
    }
    try {
        // Generate cache key
        const cacheKey = `${_transferCache.TRANSFER_CACHE_CONFIG.KEYS.TRANSFER_DETAIL}:${resolvedParams.id}`;
        // Try to get from cache first
        const cached = await _transferCache.transferCacheService.get(cacheKey);
        if (cached) {
            operation.end(true, undefined, true);
            return _server.NextResponse.json({
                success: true,
                data: cached
            });
        }
        // Use request deduplication
        const transfer = await (0, _requestdeduplication.deduplicateRequest)(async ()=>{
            return await (0, _prisma.safeQuery)(async ()=>{
                // Get transfer details with related data
                const transferData = await _prisma.prisma.inventoryTransfer.findUnique({
                    where: {
                        id
                    },
                    include: {
                        fromShop: true,
                        toShop: true,
                        fromUser: true,
                        transferItems: {
                            include: {
                                product: true
                            }
                        }
                    }
                });
                if (!transferData) {
                    return null;
                }
                // Format the transfer data to match the expected format
                return {
                    id: transferData.id,
                    status: transferData.status,
                    created_at: transferData.createdAt.toISOString(),
                    completed_at: null,
                    source_shop_id: transferData.fromShopId,
                    destination_shop_id: transferData.toShopId,
                    source_shop_name: transferData.fromShop.name,
                    destination_shop_name: transferData.toShop.name,
                    initiated_by: transferData.fromUser.name,
                    items: transferData.transferItems.map((item)=>({
                            id: item.id,
                            product_id: item.productId,
                            product_name: item.product.name,
                            sku: item.product.sku || "",
                            quantity: item.quantity,
                            notes: null,
                            price: item.product.price.toString()
                        }))
                };
            }, getDefaultTransfer(id), `Failed to fetch transfer with ID ${id}`);
        }, `/api/inventory/transfers/${resolvedParams.id}`);
        if (!transfer) {
            operation.end(false, "not_found");
            return _server.NextResponse.json({
                success: false,
                error: "Transfer not found"
            }, {
                status: 404
            });
        }
        // Cache the result
        await _transferCache.transferCacheService.set(cacheKey, transfer);
        operation.end(true, undefined, false);
        return _server.NextResponse.json({
            success: true,
            data: transfer
        });
    } catch (error) {
        console.error(`Error fetching transfer ${id}:`, error);
        operation.end(false, "fetch_error");
        return _server.NextResponse.json({
            success: false,
            error: "Failed to fetch transfer"
        }, {
            status: 500
        });
    }
}
async function PATCH(req, { params }) {
    const operation = (0, _transferPerformanceMonitor.trackTransferOperation)("complete");
    // Check for inventory:transfer permission
    const permissionError = await (0, _middleware.requirePermission)("inventory:transfer")(req);
    if (permissionError) {
        operation.end(false, "unauthorized");
        return permissionError;
    }
    const resolvedParams = await params;
    const id = parseInt(resolvedParams.id);
    if (isNaN(id)) {
        operation.end(false, "invalid_id");
        return _server.NextResponse.json({
            success: false,
            error: "Invalid transfer ID"
        }, {
            status: 400
        });
    }
    try {
        const body1 = await req.json();
        const { action } = body1;
        if (!action || ![
            "complete",
            "cancel"
        ].includes(action)) {
            operation.end(false, "invalid_action");
            return _server.NextResponse.json({
                success: false,
                error: 'Invalid action. Must be "complete" or "cancel"'
            }, {
                status: 400
            });
        }
        const result = await (0, _prisma.safeQuery)(async ()=>{
            return await _prisma.prisma.$transaction(async (tx)=>{
                // Declare affectedProductIds before using it
                const affectedProductIds = new Set();
                // Get transfer with items
                const transfer = await tx.inventoryTransfer.findUnique({
                    where: {
                        id
                    },
                    include: {
                        transferItems: {
                            include: {
                                product: true
                            }
                        }
                    }
                });
                if (!transfer) {
                    throw new Error("Transfer not found");
                }
                if (transfer.status !== "pending") {
                    throw new Error(`Cannot ${action} a transfer that is not in pending status`);
                }
                if (action === "complete") {
                    // Process each transfer item for completion
                    for (const item of transfer.transferItems){
                        // Check source inventory
                        const sourceInventory = await tx.inventoryItem.findFirst({
                            where: {
                                shopId: transfer.fromShopId,
                                productId: item.productId
                            }
                        });
                        if (!sourceInventory || sourceInventory.quantity < item.quantity) {
                            throw new Error(`Insufficient inventory for product ID ${item.productId} in source shop`);
                        }
                        // Get the shop-specific cost from source inventory
                        const transferCostPerUnit = sourceInventory.shopSpecificCost || 0;
                        // Update source inventory (decrease quantity)
                        await tx.inventoryItem.update({
                            where: {
                                id: sourceInventory.id
                            },
                            data: {
                                quantity: sourceInventory.quantity - item.quantity,
                                updatedAt: new Date()
                            }
                        });
                        // Collect items for batch processing
                        affectedProductIds.add(item.productId);
                    }
                    // Batch process inventory updates
                    const inventoryUpdates = [];
                    for (const item of transfer.transferItems){
                        // Get the shop-specific cost from source inventory
                        const sourceInventory = await tx.inventoryItem.findFirst({
                            where: {
                                shopId: transfer.fromShopId,
                                productId: item.productId
                            }
                        });
                        const transferCostPerUnit = sourceInventory?.shopSpecificCost || 0;
                        // Check if destination already has this product
                        const destInventory = await tx.inventoryItem.findFirst({
                            where: {
                                shopId: transfer.toShopId,
                                productId: item.productId
                            }
                        });
                        if (!destInventory) {
                            // Create new inventory item at destination
                            await tx.inventoryItem.create({
                                data: {
                                    shopId: transfer.toShopId,
                                    productId: item.productId,
                                    quantity: item.quantity,
                                    shopSpecificCost: transferCostPerUnit
                                }
                            });
                        } else {
                            // Calculate new WAC for destination shop using weighted average
                            const currentDestQuantity = destInventory.quantity;
                            const currentDestCost = destInventory.shopSpecificCost || 0;
                            const transferQuantity = item.quantity;
                            const currentTotalValue = currentDestQuantity * currentDestCost;
                            const transferTotalValue = transferQuantity * transferCostPerUnit;
                            const newTotalQuantity = currentDestQuantity + transferQuantity;
                            let newShopSpecificCost = 0;
                            if (newTotalQuantity > 0) {
                                newShopSpecificCost = (currentTotalValue + transferTotalValue) / newTotalQuantity;
                            }
                            inventoryUpdates.push({
                                productId: item.productId,
                                quantity: item.quantity,
                                cost: newShopSpecificCost
                            });
                        }
                    }
                    // Batch update existing inventory items
                    if (inventoryUpdates.length > 0) {
                        await Promise.all(inventoryUpdates.map((update)=>tx.inventoryItem.updateMany({
                                where: {
                                    shopId: transfer.toShopId,
                                    productId: update.productId
                                },
                                data: {
                                    quantity: {
                                        increment: update.quantity
                                    },
                                    shopSpecificCost: update.cost,
                                    updatedAt: new Date()
                                }
                            })));
                    }
                    // Batch recalculate global weighted average costs
                    const wacUpdates = await Promise.all(Array.from(affectedProductIds).map(async (productId)=>{
                        const allInventoryAfterTransfer = await tx.inventoryItem.findMany({
                            where: {
                                productId,
                                quantity: {
                                    gt: 0
                                } // Only consider inventories with stock
                            }
                        });
                        if (allInventoryAfterTransfer.length > 0) {
                            const totalQuantity = allInventoryAfterTransfer.reduce((sum, inv)=>sum + inv.quantity, 0);
                            const totalValue = allInventoryAfterTransfer.reduce((sum, inv)=>{
                                return sum + inv.quantity * (inv.shopSpecificCost || 0);
                            }, 0);
                            const globalWAC = totalQuantity > 0 ? totalValue / totalQuantity : 0;
                            return {
                                productId,
                                globalWAC
                            };
                        }
                        return null;
                    }));
                    // Update global WAC for all affected products
                    await Promise.all(wacUpdates.filter((update)=>update !== null).map((update)=>tx.product.update({
                            where: {
                                id: update.productId
                            },
                            data: {
                                weightedAverageCost: update.globalWAC
                            }
                        })));
                } else {
                    // action === 'cancel'
                    // Return reserved inventory in source shop
                    for (const item of transfer.transferItems){
                        await tx.inventoryItem.updateMany({
                            where: {
                                productId: item.productId,
                                shopId: transfer.fromShopId
                            },
                            data: {
                                quantity: {
                                    increment: item.quantity
                                },
                                updatedAt: new Date()
                            }
                        });
                    }
                // No further updates required for destination inventory or WAC
                }
                // Update transfer status
                return await tx.inventoryTransfer.update({
                    where: {
                        id
                    },
                    data: {
                        status: action === "complete" ? "completed" : "cancelled",
                        updatedAt: new Date()
                    }
                });
            }, {
                timeout: 30000
            } // 30-second timeout
            );
        }, null, `Failed to ${action} transfer`);
        if (!result) {
            operation.end(false, "update_failed");
            return _server.NextResponse.json({
                success: false,
                error: `Failed to ${action} transfer`
            }, {
                status: 500
            });
        }
        // Invalidate relevant caches
        await _transferCache.transferCacheService.invalidateTransferCache(params.id, [
            result.fromShopId,
            result.toShopId
        ]);
        operation.end(true);
        return _server.NextResponse.json({
            success: true,
            message: `Transfer ${action}d successfully`,
            data: result
        });
    } catch (error) {
        console.error(`Error ${body?.action || "updating"} transfer ${id}:`, error);
        operation.end(false, "update_error");
        return _server.NextResponse.json({
            success: false,
            error: error instanceof Error ? error.message : `Failed to update transfer`
        }, {
            status: 500
        });
    }
}
async function PUT(req, { params }) {
    const operation = (0, _transferPerformanceMonitor.trackTransferOperation)("update");
    // Token and user role check
    const token = (0, _auth.extractToken)(req);
    const payload = token ? await (0, _auth.verifyToken)(token) : null;
    const userRole = payload?.roleName ?? "";
    // Check for inventory:transfer permission
    const permissionResult = await (0, _auth.validateTokenPermission)(req, "inventory:transfer");
    if (!permissionResult.isValid) {
        operation.end(false, "unauthorized");
        return _server.NextResponse.json({
            success: false,
            message: permissionResult.message || "Permission denied"
        }, {
            status: 403
        });
    }
    const resolvedParams = await params;
    const id = parseInt(resolvedParams.id);
    if (isNaN(id)) {
        operation.end(false, "invalid_id");
        return _server.NextResponse.json({
            success: false,
            error: "Invalid transfer ID"
        }, {
            status: 400
        });
    }
    try {
        const body1 = await req.json();
        const { sourceShopId, destinationShopId, items } = body1;
        // Validate input
        if (sourceShopId == null || destinationShopId == null || !items || !Array.isArray(items)) {
            operation.end(false, "invalid_input");
            return _server.NextResponse.json({
                success: false,
                error: "Missing required fields"
            }, {
                status: 400
            });
        }
        if (sourceShopId === destinationShopId) {
            operation.end(false, "same_shop");
            return _server.NextResponse.json({
                success: false,
                error: "Source and destination shops cannot be the same"
            }, {
                status: 400
            });
        }
        if (items.length === 0) {
            operation.end(false, "no_items");
            return _server.NextResponse.json({
                success: false,
                error: "At least one item is required"
            }, {
                status: 400
            });
        }
        // Validate items
        for (const item of items){
            if (!item.productId || !item.quantity || item.quantity <= 0) {
                operation.end(false, "invalid_item");
                return _server.NextResponse.json({
                    success: false,
                    error: "Invalid item data"
                }, {
                    status: 400
                });
            }
        }
        const result = await (0, _prisma.safeQuery)(async ()=>{
            return await _prisma.prisma.$transaction(async (tx)=>{
                // Check if transfer exists and is pending
                const existingTransfer = await tx.inventoryTransfer.findUnique({
                    where: {
                        id
                    }
                });
                if (!existingTransfer) {
                    throw new Error("Transfer not found");
                }
                if (existingTransfer.status !== "pending") {
                    throw new Error("Only pending transfers can be edited");
                }
                // Verify shops exist
                const sourceShop = await tx.shop.findUnique({
                    where: {
                        id: sourceShopId
                    }
                });
                const destinationShop = await tx.shop.findUnique({
                    where: {
                        id: destinationShopId
                    }
                });
                if (!sourceShop || !destinationShop) {
                    throw new Error("Invalid shop selection");
                }
                // Verify products exist and have sufficient stock
                for (const item of items){
                    const inventory = await tx.inventoryItem.findFirst({
                        where: {
                            productId: item.productId,
                            shopId: sourceShopId
                        }
                    });
                    if (!inventory) {
                        const product = await tx.product.findUnique({
                            where: {
                                id: item.productId
                            }
                        });
                        const productName = product ? product.name : `Product ID ${item.productId}`;
                        throw new Error(`Product "${productName}" not found in source shop`);
                    }
                    if (inventory.quantity < item.quantity) {
                        const product = await tx.product.findUnique({
                            where: {
                                id: item.productId
                            }
                        });
                        const productName = product ? product.name : `Product ID ${item.productId}`;
                        throw new Error(`Insufficient stock for "${productName}". Available: ${inventory.quantity}, Requested: ${item.quantity}`);
                    }
                }
                // Update transfer
                const updatedTransfer = await tx.inventoryTransfer.update({
                    where: {
                        id
                    },
                    data: {
                        fromShopId: sourceShopId,
                        toShopId: destinationShopId,
                        updatedAt: new Date()
                    }
                });
                // Delete existing transfer items
                await tx.transferItem.deleteMany({
                    where: {
                        transferId: id
                    }
                });
                // Insert new transfer items
                const transferItemsData = items.map((item)=>({
                        transferId: id,
                        productId: item.productId,
                        quantity: item.quantity
                    }));
                await tx.transferItem.createMany({
                    data: transferItemsData
                });
                return updatedTransfer;
            }, {
                timeout: 30000
            } // 30-second timeout
            );
        }, null, "Failed to update transfer");
        if (!result) {
            operation.end(false, "update_failed");
            return _server.NextResponse.json({
                success: false,
                error: "Failed to update transfer"
            }, {
                status: 500
            });
        }
        // Invalidate relevant caches
        await _transferCache.transferCacheService.invalidateTransferCache(id, [
            result.fromShopId,
            result.toShopId
        ]);
        operation.end(true);
        return _server.NextResponse.json({
            success: true,
            message: "Transfer updated successfully",
            data: {
                id
            }
        });
    } catch (error) {
        console.error(`Error updating transfer ${id}:`, error);
        operation.end(false, "update_error");
        return _server.NextResponse.json({
            success: false,
            error: error instanceof Error ? error.message : "Failed to update transfer"
        }, {
            status: 500
        });
    }
}
async function DELETE(req, { params }) {
    const operation = (0, _transferPerformanceMonitor.trackTransferOperation)("cancel");
    // Token and user role check
    const token = (0, _auth.extractToken)(req);
    const payload = token ? await (0, _auth.verifyToken)(token) : null;
    const userRole = payload?.roleName ?? "";
    // Check for inventory:transfer permission
    const permissionResult = await (0, _auth.validateTokenPermission)(req, "inventory:transfer");
    if (!permissionResult.isValid) {
        operation.end(false, "unauthorized");
        return _server.NextResponse.json({
            success: false,
            message: permissionResult.message || "Permission denied"
        }, {
            status: 403
        });
    }
    const resolvedParams = await params;
    const id = parseInt(resolvedParams.id);
    if (isNaN(id)) {
        operation.end(false, "invalid_id");
        return _server.NextResponse.json({
            success: false,
            error: "Invalid transfer ID"
        }, {
            status: 400
        });
    }
    try {
        const result = await (0, _prisma.safeQuery)(async ()=>{
            return await _prisma.prisma.$transaction(async (tx)=>{
                // Get transfer to check status
                const transfer = await tx.inventoryTransfer.findUnique({
                    where: {
                        id
                    }
                });
                if (!transfer) {
                    throw new Error("Transfer not found");
                }
                if (transfer.status !== "pending") {
                    throw new Error("Only pending transfers can be deleted");
                }
                // Return reserved inventory to source shop before deletion
                const items = await tx.transferItem.findMany({
                    where: {
                        transferId: id
                    }
                });
                for (const item of items){
                    await tx.inventoryItem.updateMany({
                        where: {
                            productId: item.productId,
                            shopId: transfer.fromShopId
                        },
                        data: {
                            quantity: {
                                increment: item.quantity
                            }
                        }
                    });
                }
                // Delete transfer items and the transfer itself
                await tx.transferItem.deleteMany({
                    where: {
                        transferId: id
                    }
                });
                return await tx.inventoryTransfer.delete({
                    where: {
                        id
                    }
                });
            }, {
                timeout: 30000
            } // 30-second timeout
            );
        }, null, "Failed to delete transfer");
        if (!result) {
            operation.end(false, "delete_failed");
            return _server.NextResponse.json({
                success: false,
                error: "Failed to delete transfer"
            }, {
                status: 500
            });
        }
        // Invalidate relevant caches
        await _transferCache.transferCacheService.invalidateTransferCache(id, [
            result.fromShopId,
            result.toShopId
        ]);
        operation.end(true);
        return _server.NextResponse.json({
            success: true,
            message: "Transfer deleted successfully"
        });
    } catch (error) {
        console.error(`Error deleting transfer ${id}:`, error);
        operation.end(false, "delete_error");
        return _server.NextResponse.json({
            success: false,
            error: error instanceof Error ? error.message : "Failed to delete transfer"
        }, {
            status: 500
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vc3JjL2FwcC9hcGkvaW52ZW50b3J5L3RyYW5zZmVycy9baWRdL3JvdXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyByZXF1aXJlUGVybWlzc2lvbiB9IGZyb20gJ0AvbGliL3V0aWxzL21pZGRsZXdhcmUnO1xuaW1wb3J0IHsgcHJpc21hLCBzYWZlUXVlcnkgfSBmcm9tICdAL2xpYi9wcmlzbWEnO1xuaW1wb3J0IHsgdHJhbnNmZXJDYWNoZVNlcnZpY2UsIFRSQU5TRkVSX0NBQ0hFX0NPTkZJRyB9IGZyb20gJ0AvbGliL3RyYW5zZmVyQ2FjaGUnO1xuaW1wb3J0IHsgdHJhY2tUcmFuc2Zlck9wZXJhdGlvbiB9IGZyb20gJ0AvbGliL3RyYW5zZmVyUGVyZm9ybWFuY2VNb25pdG9yJztcbmltcG9ydCB7IGRlZHVwbGljYXRlUmVxdWVzdCB9IGZyb20gJ0AvbGliL3JlcXVlc3QtZGVkdXBsaWNhdGlvbic7XG5pbXBvcnQgeyB2YWxpZGF0ZVRva2VuUGVybWlzc2lvbiwgZXh0cmFjdFRva2VuLCB2ZXJpZnlUb2tlbiB9IGZyb20gJ0AvbGliL2F1dGgnO1xuXG4vLyBEZWZhdWx0IGZhbGxiYWNrIGRhdGEgZm9yIGEgdHJhbnNmZXJcbmZ1bmN0aW9uIGdldERlZmF1bHRUcmFuc2ZlcihpZDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNvbXBsZXRlZF9hdDogbnVsbCxcbiAgICAgICAgc291cmNlX3Nob3BfaWQ6IDAsXG4gICAgICAgIGRlc3RpbmF0aW9uX3Nob3BfaWQ6IDAsXG4gICAgICAgIHNvdXJjZV9zaG9wX25hbWU6ICdVbmtub3duIFNob3AnLFxuICAgICAgICBkZXN0aW5hdGlvbl9zaG9wX25hbWU6ICdVbmtub3duIFNob3AnLFxuICAgICAgICBpbml0aWF0ZWRfYnk6ICdVbmtub3duIFVzZXInLFxuICAgICAgICBpdGVtczogW11cbiAgICB9O1xufVxuXG4vLyBEZWZhdWx0IGZhbGxiYWNrIGRhdGEgZm9yIHRyYW5zZmVycyBsaXN0XG5jb25zdCBkZWZhdWx0VHJhbnNmZXJzRGF0YSA9IFtcbiAgICB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBjb21wbGV0ZWRfYXQ6IG51bGwsXG4gICAgICAgIHNvdXJjZV9zaG9wX25hbWU6ICdNYWluIFN0b3JlJyxcbiAgICAgICAgZGVzdGluYXRpb25fc2hvcF9uYW1lOiAnQnJhbmNoIFN0b3JlJyxcbiAgICAgICAgaW5pdGlhdGVkX2J5OiAnU3lzdGVtJyxcbiAgICAgICAgaXRlbV9jb3VudDogMCxcbiAgICAgICAgdG90YWxfaXRlbXM6IDBcbiAgICB9XG5dO1xuXG4vLyBHRVQ6IEZldGNoIGEgc3BlY2lmaWMgaW52ZW50b3J5IHRyYW5zZmVyIGJ5IElEXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKFxuICAgIHJlcTogTmV4dFJlcXVlc3QsXG4gICAgeyBwYXJhbXMgfTogeyBwYXJhbXM6IFByb21pc2U8eyBpZDogc3RyaW5nIH0+IH1cbikge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRyYWNrVHJhbnNmZXJPcGVyYXRpb24oJ2RldGFpbCcpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGludmVudG9yeTp2aWV3IG9yIGludmVudG9yeTp0cmFuc2ZlciBwZXJtaXNzaW9uXG4gICAgY29uc3Qgdmlld1Blcm1pc3Npb24gPSBhd2FpdCB2YWxpZGF0ZVRva2VuUGVybWlzc2lvbihyZXEsICdpbnZlbnRvcnk6dmlldycpO1xuICAgIGNvbnN0IHRyYW5zZmVyUGVybWlzc2lvbiA9IGF3YWl0IHZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uKHJlcSwgJ2ludmVudG9yeTp0cmFuc2ZlcicpO1xuXG4gICAgaWYgKCF2aWV3UGVybWlzc2lvbi5pc1ZhbGlkICYmICF0cmFuc2ZlclBlcm1pc3Npb24uaXNWYWxpZCkge1xuICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAndW5hdXRob3JpemVkJyk7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdQZXJtaXNzaW9uIGRlbmllZCdcbiAgICAgICAgfSwgeyBzdGF0dXM6IDQwMyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvbHZlZFBhcmFtcyA9IGF3YWl0IHBhcmFtcztcbiAgICBjb25zdCBpZCA9IHBhcnNlSW50KHJlc29sdmVkUGFyYW1zLmlkKTtcbiAgICBpZiAoaXNOYU4oaWQpKSB7XG4gICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICdpbnZhbGlkX2lkJyk7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCB0cmFuc2ZlciBJRCdcbiAgICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBHZW5lcmF0ZSBjYWNoZSBrZXlcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHtUUkFOU0ZFUl9DQUNIRV9DT05GSUcuS0VZUy5UUkFOU0ZFUl9ERVRBSUx9OiR7cmVzb2x2ZWRQYXJhbXMuaWR9YDtcblxuICAgICAgICAvLyBUcnkgdG8gZ2V0IGZyb20gY2FjaGUgZmlyc3RcbiAgICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgdHJhbnNmZXJDYWNoZVNlcnZpY2UuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLmVuZCh0cnVlLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGNhY2hlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgcmVxdWVzdCBkZWR1cGxpY2F0aW9uXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyID0gYXdhaXQgZGVkdXBsaWNhdGVSZXF1ZXN0KFxuICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBzYWZlUXVlcnkoXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0cmFuc2ZlciBkZXRhaWxzIHdpdGggcmVsYXRlZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlckRhdGEgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5VHJhbnNmZXIuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21TaG9wOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1Nob3A6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21Vc2VyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zlckl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJhbnNmZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCB0aGUgdHJhbnNmZXIgZGF0YSB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0cmFuc2ZlckRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB0cmFuc2ZlckRhdGEuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IHRyYW5zZmVyRGF0YS5jcmVhdGVkQXQudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRfYXQ6IG51bGwsIC8vIFRoaXMgZmllbGQgaXNuJ3QgaW4gdGhlIFByaXNtYSBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Vfc2hvcF9pZDogdHJhbnNmZXJEYXRhLmZyb21TaG9wSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25fc2hvcF9pZDogdHJhbnNmZXJEYXRhLnRvU2hvcElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZV9zaG9wX25hbWU6IHRyYW5zZmVyRGF0YS5mcm9tU2hvcC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uX3Nob3BfbmFtZTogdHJhbnNmZXJEYXRhLnRvU2hvcC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYXRlZF9ieTogdHJhbnNmZXJEYXRhLmZyb21Vc2VyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHRyYW5zZmVyRGF0YS50cmFuc2Zlckl0ZW1zLm1hcChpdGVtID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0X2lkOiBpdGVtLnByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdF9uYW1lOiBpdGVtLnByb2R1Y3QubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2t1OiBpdGVtLnByb2R1Y3Quc2t1IHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaXRlbS5xdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZXM6IG51bGwsIC8vIFRoaXMgZmllbGQgaXNuJ3QgaW4gdGhlIFByaXNtYSBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGl0ZW0ucHJvZHVjdC5wcmljZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXREZWZhdWx0VHJhbnNmZXIoaWQpLFxuICAgICAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIGZldGNoIHRyYW5zZmVyIHdpdGggSUQgJHtpZH1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBgL2FwaS9pbnZlbnRvcnkvdHJhbnNmZXJzLyR7cmVzb2x2ZWRQYXJhbXMuaWR9YFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdHJhbnNmZXIpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICdub3RfZm91bmQnKTtcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdUcmFuc2ZlciBub3QgZm91bmQnXG4gICAgICAgICAgICB9LCB7IHN0YXR1czogNDA0IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdFxuICAgICAgICBhd2FpdCB0cmFuc2ZlckNhY2hlU2VydmljZS5zZXQoY2FjaGVLZXksIHRyYW5zZmVyKTtcblxuICAgICAgICBvcGVyYXRpb24uZW5kKHRydWUsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHRyYW5zZmVyXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHRyYW5zZmVyICR7aWR9OmAsIGVycm9yKTtcbiAgICAgICAgb3BlcmF0aW9uLmVuZChmYWxzZSwgJ2ZldGNoX2Vycm9yJyk7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGZldGNoIHRyYW5zZmVyJ1xuICAgICAgICB9LCB7IHN0YXR1czogNTAwIH0pO1xuICAgIH1cbn1cblxuLy8gUEFUQ0g6IFVwZGF0ZSBhIHRyYW5zZmVyIChjb21wbGV0ZSwgY2FuY2VsKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBBVENIKFxuICAgIHJlcTogTmV4dFJlcXVlc3QsXG4gICAgeyBwYXJhbXMgfTogeyBwYXJhbXM6IFByb21pc2U8eyBpZDogc3RyaW5nIH0+IH1cbikge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRyYWNrVHJhbnNmZXJPcGVyYXRpb24oJ2NvbXBsZXRlJyk7XG5cbiAgICAvLyBDaGVjayBmb3IgaW52ZW50b3J5OnRyYW5zZmVyIHBlcm1pc3Npb25cbiAgICBjb25zdCBwZXJtaXNzaW9uRXJyb3IgPSBhd2FpdCByZXF1aXJlUGVybWlzc2lvbignaW52ZW50b3J5OnRyYW5zZmVyJykocmVxKTtcbiAgICBpZiAocGVybWlzc2lvbkVycm9yKSB7XG4gICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICd1bmF1dGhvcml6ZWQnKTtcbiAgICAgICAgcmV0dXJuIHBlcm1pc3Npb25FcnJvcjtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvbHZlZFBhcmFtcyA9IGF3YWl0IHBhcmFtcztcbiAgICBjb25zdCBpZCA9IHBhcnNlSW50KHJlc29sdmVkUGFyYW1zLmlkKTtcbiAgICBpZiAoaXNOYU4oaWQpKSB7XG4gICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICdpbnZhbGlkX2lkJyk7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCB0cmFuc2ZlciBJRCdcbiAgICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxLmpzb24oKTtcbiAgICAgICAgY29uc3QgeyBhY3Rpb24gfSA9IGJvZHk7XG5cbiAgICAgICAgaWYgKCFhY3Rpb24gfHwgIVsnY29tcGxldGUnLCAnY2FuY2VsJ10uaW5jbHVkZXMoYWN0aW9uKSkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLmVuZChmYWxzZSwgJ2ludmFsaWRfYWN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBhY3Rpb24uIE11c3QgYmUgXCJjb21wbGV0ZVwiIG9yIFwiY2FuY2VsXCInXG4gICAgICAgICAgICB9LCB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KFxuICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcmlzbWEuJHRyYW5zYWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBhc3luYyAodHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY2xhcmUgYWZmZWN0ZWRQcm9kdWN0SWRzIGJlZm9yZSB1c2luZyBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRQcm9kdWN0SWRzID0gbmV3IFNldDxudW1iZXI+KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0cmFuc2ZlciB3aXRoIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlciA9IGF3YWl0IHR4LmludmVudG9yeVRyYW5zZmVyLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zlckl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zZmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmZXIuc3RhdHVzICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCAke2FjdGlvbn0gYSB0cmFuc2ZlciB0aGF0IGlzIG5vdCBpbiBwZW5kaW5nIHN0YXR1c2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAnY29tcGxldGUnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggdHJhbnNmZXIgaXRlbSBmb3IgY29tcGxldGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0cmFuc2Zlci50cmFuc2Zlckl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHNvdXJjZSBpbnZlbnRvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlSW52ZW50b3J5ID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IHRyYW5zZmVyLmZyb21TaG9wSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZUludmVudG9yeSB8fCBzb3VyY2VJbnZlbnRvcnkucXVhbnRpdHkgPCBpdGVtLnF1YW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBpbnZlbnRvcnkgZm9yIHByb2R1Y3QgSUQgJHtpdGVtLnByb2R1Y3RJZH0gaW4gc291cmNlIHNob3BgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgc2hvcC1zcGVjaWZpYyBjb3N0IGZyb20gc291cmNlIGludmVudG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlckNvc3RQZXJVbml0ID0gc291cmNlSW52ZW50b3J5LnNob3BTcGVjaWZpY0Nvc3QgfHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc291cmNlIGludmVudG9yeSAoZGVjcmVhc2UgcXVhbnRpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0udXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBzb3VyY2VJbnZlbnRvcnkuaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogc291cmNlSW52ZW50b3J5LnF1YW50aXR5IC0gaXRlbS5xdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBpdGVtcyBmb3IgYmF0Y2ggcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZFByb2R1Y3RJZHMuYWRkKGl0ZW0ucHJvZHVjdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXRjaCBwcm9jZXNzIGludmVudG9yeSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW52ZW50b3J5VXBkYXRlczogQXJyYXk8e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IG51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IG51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29zdDogbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0+ID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdHJhbnNmZXIudHJhbnNmZXJJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHNob3Atc3BlY2lmaWMgY29zdCBmcm9tIHNvdXJjZSBpbnZlbnRvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlSW52ZW50b3J5ID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IHRyYW5zZmVyLmZyb21TaG9wSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJDb3N0UGVyVW5pdCA9IHNvdXJjZUludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCB8fCAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGRlc3RpbmF0aW9uIGFscmVhZHkgaGFzIHRoaXMgcHJvZHVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0SW52ZW50b3J5ID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IHRyYW5zZmVyLnRvU2hvcElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogaXRlbS5wcm9kdWN0SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXN0SW52ZW50b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IGludmVudG9yeSBpdGVtIGF0IGRlc3RpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IHRyYW5zZmVyLnRvU2hvcElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IGl0ZW0ucHJvZHVjdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaXRlbS5xdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcFNwZWNpZmljQ29zdDogdHJhbnNmZXJDb3N0UGVyVW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBXQUMgZm9yIGRlc3RpbmF0aW9uIHNob3AgdXNpbmcgd2VpZ2h0ZWQgYXZlcmFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudERlc3RRdWFudGl0eSA9IGRlc3RJbnZlbnRvcnkucXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGVzdENvc3QgPSBkZXN0SW52ZW50b3J5LnNob3BTcGVjaWZpY0Nvc3QgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVyUXVhbnRpdHkgPSBpdGVtLnF1YW50aXR5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VG90YWxWYWx1ZSA9IGN1cnJlbnREZXN0UXVhbnRpdHkgKiBjdXJyZW50RGVzdENvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlclRvdGFsVmFsdWUgPSB0cmFuc2ZlclF1YW50aXR5ICogdHJhbnNmZXJDb3N0UGVyVW5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RvdGFsUXVhbnRpdHkgPSBjdXJyZW50RGVzdFF1YW50aXR5ICsgdHJhbnNmZXJRdWFudGl0eTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Nob3BTcGVjaWZpY0Nvc3QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RvdGFsUXVhbnRpdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2hvcFNwZWNpZmljQ29zdCA9IChjdXJyZW50VG90YWxWYWx1ZSArIHRyYW5zZmVyVG90YWxWYWx1ZSkgLyBuZXdUb3RhbFF1YW50aXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZlbnRvcnlVcGRhdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogaXRlbS5wcm9kdWN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29zdDogbmV3U2hvcFNwZWNpZmljQ29zdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXRjaCB1cGRhdGUgZXhpc3RpbmcgaW52ZW50b3J5IGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludmVudG9yeVVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmVudG9yeVVwZGF0ZXMubWFwKHVwZGF0ZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmludmVudG9yeUl0ZW0udXBkYXRlTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IHRyYW5zZmVyLnRvU2hvcElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiB1cGRhdGUucHJvZHVjdElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiB7IGluY3JlbWVudDogdXBkYXRlLnF1YW50aXR5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wU3BlY2lmaWNDb3N0OiB1cGRhdGUuY29zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXRjaCByZWNhbGN1bGF0ZSBnbG9iYWwgd2VpZ2h0ZWQgYXZlcmFnZSBjb3N0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhY1VwZGF0ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuZnJvbShhZmZlY3RlZFByb2R1Y3RJZHMpLm1hcChhc3luYyAocHJvZHVjdElkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxJbnZlbnRvcnlBZnRlclRyYW5zZmVyID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogeyBndDogMCB9IC8vIE9ubHkgY29uc2lkZXIgaW52ZW50b3JpZXMgd2l0aCBzdG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsSW52ZW50b3J5QWZ0ZXJUcmFuc2Zlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxRdWFudGl0eSA9IGFsbEludmVudG9yeUFmdGVyVHJhbnNmZXIucmVkdWNlKChzdW0sIGludikgPT4gc3VtICsgaW52LnF1YW50aXR5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFZhbHVlID0gYWxsSW52ZW50b3J5QWZ0ZXJUcmFuc2Zlci5yZWR1Y2UoKHN1bSwgaW52KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW0gKyAoaW52LnF1YW50aXR5ICogKGludi5zaG9wU3BlY2lmaWNDb3N0IHx8IDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdsb2JhbFdBQyA9IHRvdGFsUXVhbnRpdHkgPiAwID8gdG90YWxWYWx1ZSAvIHRvdGFsUXVhbnRpdHkgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHByb2R1Y3RJZCwgZ2xvYmFsV0FDIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCBXQUMgZm9yIGFsbCBhZmZlY3RlZCBwcm9kdWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWNVcGRhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHVwZGF0ZSA9PiB1cGRhdGUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHVwZGF0ZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LnByb2R1Y3QudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHVwZGF0ZSEucHJvZHVjdElkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgd2VpZ2h0ZWRBdmVyYWdlQ29zdDogdXBkYXRlIS5nbG9iYWxXQUMgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWN0aW9uID09PSAnY2FuY2VsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiByZXNlcnZlZCBpbnZlbnRvcnkgaW4gc291cmNlIHNob3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdHJhbnNmZXIudHJhbnNmZXJJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLnVwZGF0ZU1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IGl0ZW0ucHJvZHVjdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BJZDogdHJhbnNmZXIuZnJvbVNob3BJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHsgaW5jcmVtZW50OiBpdGVtLnF1YW50aXR5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGZ1cnRoZXIgdXBkYXRlcyByZXF1aXJlZCBmb3IgZGVzdGluYXRpb24gaW52ZW50b3J5IG9yIFdBQ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdHJhbnNmZXIgc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdHguaW52ZW50b3J5VHJhbnNmZXIudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogeyBpZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBhY3Rpb24gPT09ICdjb21wbGV0ZScgPyAnY29tcGxldGVkJyA6ICdjYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0aW1lb3V0OiAzMDAwMCB9IC8vIDMwLXNlY29uZCB0aW1lb3V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgYEZhaWxlZCB0byAke2FjdGlvbn0gdHJhbnNmZXJgXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICd1cGRhdGVfZmFpbGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvICR7YWN0aW9ufSB0cmFuc2ZlcmBcbiAgICAgICAgICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZhbGlkYXRlIHJlbGV2YW50IGNhY2hlc1xuICAgICAgICBhd2FpdCB0cmFuc2ZlckNhY2hlU2VydmljZS5pbnZhbGlkYXRlVHJhbnNmZXJDYWNoZShwYXJhbXMuaWQsIFtyZXN1bHQuZnJvbVNob3BJZCwgcmVzdWx0LnRvU2hvcElkXSk7XG5cbiAgICAgICAgb3BlcmF0aW9uLmVuZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBgVHJhbnNmZXIgJHthY3Rpb259ZCBzdWNjZXNzZnVsbHlgLFxuICAgICAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yICR7Ym9keT8uYWN0aW9uIHx8ICd1cGRhdGluZyd9IHRyYW5zZmVyICR7aWR9OmAsIGVycm9yKTtcbiAgICAgICAgb3BlcmF0aW9uLmVuZChmYWxzZSwgJ3VwZGF0ZV9lcnJvcicpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBgRmFpbGVkIHRvIHVwZGF0ZSB0cmFuc2ZlcmBcbiAgICAgICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgICB9XG59XG5cbi8vIFBVVDogVXBkYXRlIGEgdHJhbnNmZXIgKG9ubHkgaWYgcGVuZGluZylcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQVVQoXG4gICAgcmVxOiBOZXh0UmVxdWVzdCxcbiAgICB7IHBhcmFtcyB9OiB7IHBhcmFtczogUHJvbWlzZTx7IGlkOiBzdHJpbmcgfT4gfVxuKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdHJhY2tUcmFuc2Zlck9wZXJhdGlvbigndXBkYXRlJyk7XG5cbiAgICAvLyBUb2tlbiBhbmQgdXNlciByb2xlIGNoZWNrXG4gICAgY29uc3QgdG9rZW4gPSBleHRyYWN0VG9rZW4ocmVxKTtcbiAgICBjb25zdCBwYXlsb2FkID0gdG9rZW4gPyBhd2FpdCB2ZXJpZnlUb2tlbih0b2tlbikgOiBudWxsO1xuICAgIGNvbnN0IHVzZXJSb2xlID0gcGF5bG9hZD8ucm9sZU5hbWUgYXMgc3RyaW5nID8/ICcnO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGludmVudG9yeTp0cmFuc2ZlciBwZXJtaXNzaW9uXG4gICAgY29uc3QgcGVybWlzc2lvblJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uKHJlcSwgJ2ludmVudG9yeTp0cmFuc2ZlcicpO1xuICAgIGlmICghcGVybWlzc2lvblJlc3VsdC5pc1ZhbGlkKSB7XG4gICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICd1bmF1dGhvcml6ZWQnKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogcGVybWlzc2lvblJlc3VsdC5tZXNzYWdlIHx8ICdQZXJtaXNzaW9uIGRlbmllZCdcbiAgICAgICAgfSwgeyBzdGF0dXM6IDQwMyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvbHZlZFBhcmFtcyA9IGF3YWl0IHBhcmFtcztcbiAgICBjb25zdCBpZCA9IHBhcnNlSW50KHJlc29sdmVkUGFyYW1zLmlkKTtcbiAgICBpZiAoaXNOYU4oaWQpKSB7XG4gICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICdpbnZhbGlkX2lkJyk7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCB0cmFuc2ZlciBJRCdcbiAgICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxLmpzb24oKTtcbiAgICAgICAgY29uc3QgeyBzb3VyY2VTaG9wSWQsIGRlc3RpbmF0aW9uU2hvcElkLCBpdGVtcyB9ID0gYm9keTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBpbnB1dFxuICAgICAgICBpZiAoc291cmNlU2hvcElkID09IG51bGwgfHwgZGVzdGluYXRpb25TaG9wSWQgPT0gbnVsbCB8fCAhaXRlbXMgfHwgIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAnaW52YWxpZF9pbnB1dCcpO1xuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzJ1xuICAgICAgICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3VyY2VTaG9wSWQgPT09IGRlc3RpbmF0aW9uU2hvcElkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAnc2FtZV9zaG9wJyk7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnU291cmNlIGFuZCBkZXN0aW5hdGlvbiBzaG9wcyBjYW5ub3QgYmUgdGhlIHNhbWUnXG4gICAgICAgICAgICB9LCB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLmVuZChmYWxzZSwgJ25vX2l0ZW1zJyk7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnQXQgbGVhc3Qgb25lIGl0ZW0gaXMgcmVxdWlyZWQnXG4gICAgICAgICAgICB9LCB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgaXRlbXNcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0ucHJvZHVjdElkIHx8ICFpdGVtLnF1YW50aXR5IHx8IGl0ZW0ucXVhbnRpdHkgPD0gMCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICdpbnZhbGlkX2l0ZW0nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIGl0ZW0gZGF0YSdcbiAgICAgICAgICAgICAgICB9LCB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KFxuICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcmlzbWEuJHRyYW5zYWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBhc3luYyAodHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRyYW5zZmVyIGV4aXN0cyBhbmQgaXMgcGVuZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUcmFuc2ZlciA9IGF3YWl0IHR4LmludmVudG9yeVRyYW5zZmVyLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zZmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUcmFuc2Zlci5zdGF0dXMgIT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBwZW5kaW5nIHRyYW5zZmVycyBjYW4gYmUgZWRpdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBzaG9wcyBleGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlU2hvcCA9IGF3YWl0IHR4LnNob3AuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBzb3VyY2VTaG9wSWQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uU2hvcCA9IGF3YWl0IHR4LnNob3AuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBkZXN0aW5hdGlvblNob3BJZCB9IH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZVNob3AgfHwgIWRlc3RpbmF0aW9uU2hvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaG9wIHNlbGVjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgcHJvZHVjdHMgZXhpc3QgYW5kIGhhdmUgc3VmZmljaWVudCBzdG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW52ZW50b3J5ID0gYXdhaXQgdHguaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BJZDogc291cmNlU2hvcElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW52ZW50b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCB0eC5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogaXRlbS5wcm9kdWN0SWQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZHVjdE5hbWUgPSBwcm9kdWN0ID8gcHJvZHVjdC5uYW1lIDogYFByb2R1Y3QgSUQgJHtpdGVtLnByb2R1Y3RJZH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2R1Y3QgXCIke3Byb2R1Y3ROYW1lfVwiIG5vdCBmb3VuZCBpbiBzb3VyY2Ugc2hvcGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnZlbnRvcnkucXVhbnRpdHkgPCBpdGVtLnF1YW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCB0eC5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogaXRlbS5wcm9kdWN0SWQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZHVjdE5hbWUgPSBwcm9kdWN0ID8gcHJvZHVjdC5uYW1lIDogYFByb2R1Y3QgSUQgJHtpdGVtLnByb2R1Y3RJZH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBzdG9jayBmb3IgXCIke3Byb2R1Y3ROYW1lfVwiLiBBdmFpbGFibGU6ICR7aW52ZW50b3J5LnF1YW50aXR5fSwgUmVxdWVzdGVkOiAke2l0ZW0ucXVhbnRpdHl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdHJhbnNmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUcmFuc2ZlciA9IGF3YWl0IHR4LmludmVudG9yeVRyYW5zZmVyLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21TaG9wSWQ6IHNvdXJjZVNob3BJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TaG9wSWQ6IGRlc3RpbmF0aW9uU2hvcElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGV4aXN0aW5nIHRyYW5zZmVyIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC50cmFuc2Zlckl0ZW0uZGVsZXRlTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgdHJhbnNmZXJJZDogaWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBuZXcgdHJhbnNmZXIgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVySXRlbXNEYXRhID0gaXRlbXMubWFwKChpdGVtOiBhbnkpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJJZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaXRlbS5xdWFudGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC50cmFuc2Zlckl0ZW0uY3JlYXRlTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdHJhbnNmZXJJdGVtc0RhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZFRyYW5zZmVyO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IHRpbWVvdXQ6IDMwMDAwIH0gLy8gMzAtc2Vjb25kIHRpbWVvdXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAnRmFpbGVkIHRvIHVwZGF0ZSB0cmFuc2ZlcidcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLmVuZChmYWxzZSwgJ3VwZGF0ZV9mYWlsZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gdXBkYXRlIHRyYW5zZmVyJ1xuICAgICAgICAgICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludmFsaWRhdGUgcmVsZXZhbnQgY2FjaGVzXG4gICAgICAgIGF3YWl0IHRyYW5zZmVyQ2FjaGVTZXJ2aWNlLmludmFsaWRhdGVUcmFuc2ZlckNhY2hlKGlkLCBbcmVzdWx0LmZyb21TaG9wSWQsIHJlc3VsdC50b1Nob3BJZF0pO1xuXG4gICAgICAgIG9wZXJhdGlvbi5lbmQodHJ1ZSk7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1RyYW5zZmVyIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgICAgICAgIGRhdGE6IHsgaWQgfVxuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1cGRhdGluZyB0cmFuc2ZlciAke2lkfTpgLCBlcnJvcik7XG4gICAgICAgIG9wZXJhdGlvbi5lbmQoZmFsc2UsICd1cGRhdGVfZXJyb3InKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byB1cGRhdGUgdHJhbnNmZXInXG4gICAgICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgfVxufVxuXG4vLyBERUxFVEU6IERlbGV0ZSBhIHRyYW5zZmVyIChvbmx5IGlmIHBlbmRpbmcpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gREVMRVRFKFxuICAgIHJlcTogTmV4dFJlcXVlc3QsXG4gICAgeyBwYXJhbXMgfTogeyBwYXJhbXM6IFByb21pc2U8eyBpZDogc3RyaW5nIH0+IH1cbikge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRyYWNrVHJhbnNmZXJPcGVyYXRpb24oJ2NhbmNlbCcpO1xuXG4gICAgLy8gVG9rZW4gYW5kIHVzZXIgcm9sZSBjaGVja1xuICAgIGNvbnN0IHRva2VuID0gZXh0cmFjdFRva2VuKHJlcSk7XG4gICAgY29uc3QgcGF5bG9hZCA9IHRva2VuID8gYXdhaXQgdmVyaWZ5VG9rZW4odG9rZW4pIDogbnVsbDtcbiAgICBjb25zdCB1c2VyUm9sZSA9IHBheWxvYWQ/LnJvbGVOYW1lIGFzIHN0cmluZyA/PyAnJztcblxuICAgIC8vIENoZWNrIGZvciBpbnZlbnRvcnk6dHJhbnNmZXIgcGVybWlzc2lvblxuICAgIGNvbnN0IHBlcm1pc3Npb25SZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVRva2VuUGVybWlzc2lvbihyZXEsICdpbnZlbnRvcnk6dHJhbnNmZXInKTtcbiAgICBpZiAoIXBlcm1pc3Npb25SZXN1bHQuaXNWYWxpZCkge1xuICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAndW5hdXRob3JpemVkJyk7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHBlcm1pc3Npb25SZXN1bHQubWVzc2FnZSB8fCAnUGVybWlzc2lvbiBkZW5pZWQnXG4gICAgICAgIH0sIHsgc3RhdHVzOiA0MDMgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZWRQYXJhbXMgPSBhd2FpdCBwYXJhbXM7XG4gICAgY29uc3QgaWQgPSBwYXJzZUludChyZXNvbHZlZFBhcmFtcy5pZCk7XG4gICAgaWYgKGlzTmFOKGlkKSkge1xuICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAnaW52YWxpZF9pZCcpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgdHJhbnNmZXIgSUQnXG4gICAgICAgIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KFxuICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcmlzbWEuJHRyYW5zYWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICBhc3luYyAodHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0cmFuc2ZlciB0byBjaGVjayBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVyID0gYXdhaXQgdHguaW52ZW50b3J5VHJhbnNmZXIuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zZmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmZXIuc3RhdHVzICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgcGVuZGluZyB0cmFuc2ZlcnMgY2FuIGJlIGRlbGV0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHJlc2VydmVkIGludmVudG9yeSB0byBzb3VyY2Ugc2hvcCBiZWZvcmUgZGVsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdHgudHJhbnNmZXJJdGVtLmZpbmRNYW55KHsgd2hlcmU6IHsgdHJhbnNmZXJJZDogaWQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0udXBkYXRlTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IGl0ZW0ucHJvZHVjdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcElkOiB0cmFuc2Zlci5mcm9tU2hvcElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcXVhbnRpdHk6IHsgaW5jcmVtZW50OiBpdGVtLnF1YW50aXR5IH0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgdHJhbnNmZXIgaXRlbXMgYW5kIHRoZSB0cmFuc2ZlciBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LnRyYW5zZmVySXRlbS5kZWxldGVNYW55KHsgd2hlcmU6IHsgdHJhbnNmZXJJZDogaWQgfSB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHR4LmludmVudG9yeVRyYW5zZmVyLmRlbGV0ZSh7IHdoZXJlOiB7IGlkIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdGltZW91dDogMzAwMDAgfSAvLyAzMC1zZWNvbmQgdGltZW91dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICdGYWlsZWQgdG8gZGVsZXRlIHRyYW5zZmVyJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBvcGVyYXRpb24uZW5kKGZhbHNlLCAnZGVsZXRlX2ZhaWxlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBkZWxldGUgdHJhbnNmZXInXG4gICAgICAgICAgICB9LCB7IHN0YXR1czogNTAwIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW52YWxpZGF0ZSByZWxldmFudCBjYWNoZXNcbiAgICAgICAgYXdhaXQgdHJhbnNmZXJDYWNoZVNlcnZpY2UuaW52YWxpZGF0ZVRyYW5zZmVyQ2FjaGUoaWQsIFtyZXN1bHQuZnJvbVNob3BJZCwgcmVzdWx0LnRvU2hvcElkXSk7XG5cbiAgICAgICAgb3BlcmF0aW9uLmVuZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiAnVHJhbnNmZXIgZGVsZXRlZCBzdWNjZXNzZnVsbHknXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nIHRyYW5zZmVyICR7aWR9OmAsIGVycm9yKTtcbiAgICAgICAgb3BlcmF0aW9uLmVuZChmYWxzZSwgJ2RlbGV0ZV9lcnJvcicpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGRlbGV0ZSB0cmFuc2ZlcidcbiAgICAgICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgICB9XG59Il0sIm5hbWVzIjpbIkRFTEVURSIsIkdFVCIsIlBBVENIIiwiUFVUIiwiZ2V0RGVmYXVsdFRyYW5zZmVyIiwiaWQiLCJzdGF0dXMiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY29tcGxldGVkX2F0Iiwic291cmNlX3Nob3BfaWQiLCJkZXN0aW5hdGlvbl9zaG9wX2lkIiwic291cmNlX3Nob3BfbmFtZSIsImRlc3RpbmF0aW9uX3Nob3BfbmFtZSIsImluaXRpYXRlZF9ieSIsIml0ZW1zIiwiZGVmYXVsdFRyYW5zZmVyc0RhdGEiLCJpdGVtX2NvdW50IiwidG90YWxfaXRlbXMiLCJyZXEiLCJwYXJhbXMiLCJvcGVyYXRpb24iLCJ0cmFja1RyYW5zZmVyT3BlcmF0aW9uIiwidmlld1Blcm1pc3Npb24iLCJ2YWxpZGF0ZVRva2VuUGVybWlzc2lvbiIsInRyYW5zZmVyUGVybWlzc2lvbiIsImlzVmFsaWQiLCJlbmQiLCJOZXh0UmVzcG9uc2UiLCJqc29uIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJyZXNvbHZlZFBhcmFtcyIsInBhcnNlSW50IiwiaXNOYU4iLCJlcnJvciIsImNhY2hlS2V5IiwiVFJBTlNGRVJfQ0FDSEVfQ09ORklHIiwiS0VZUyIsIlRSQU5TRkVSX0RFVEFJTCIsImNhY2hlZCIsInRyYW5zZmVyQ2FjaGVTZXJ2aWNlIiwiZ2V0IiwidW5kZWZpbmVkIiwiZGF0YSIsInRyYW5zZmVyIiwiZGVkdXBsaWNhdGVSZXF1ZXN0Iiwic2FmZVF1ZXJ5IiwidHJhbnNmZXJEYXRhIiwicHJpc21hIiwiaW52ZW50b3J5VHJhbnNmZXIiLCJmaW5kVW5pcXVlIiwid2hlcmUiLCJpbmNsdWRlIiwiZnJvbVNob3AiLCJ0b1Nob3AiLCJmcm9tVXNlciIsInRyYW5zZmVySXRlbXMiLCJwcm9kdWN0IiwiY3JlYXRlZEF0IiwiZnJvbVNob3BJZCIsInRvU2hvcElkIiwibmFtZSIsIm1hcCIsIml0ZW0iLCJwcm9kdWN0X2lkIiwicHJvZHVjdElkIiwicHJvZHVjdF9uYW1lIiwic2t1IiwicXVhbnRpdHkiLCJub3RlcyIsInByaWNlIiwidG9TdHJpbmciLCJzZXQiLCJjb25zb2xlIiwicGVybWlzc2lvbkVycm9yIiwicmVxdWlyZVBlcm1pc3Npb24iLCJib2R5IiwiYWN0aW9uIiwiaW5jbHVkZXMiLCJyZXN1bHQiLCIkdHJhbnNhY3Rpb24iLCJ0eCIsImFmZmVjdGVkUHJvZHVjdElkcyIsIlNldCIsIkVycm9yIiwic291cmNlSW52ZW50b3J5IiwiaW52ZW50b3J5SXRlbSIsImZpbmRGaXJzdCIsInNob3BJZCIsInRyYW5zZmVyQ29zdFBlclVuaXQiLCJzaG9wU3BlY2lmaWNDb3N0IiwidXBkYXRlIiwidXBkYXRlZEF0IiwiYWRkIiwiaW52ZW50b3J5VXBkYXRlcyIsImRlc3RJbnZlbnRvcnkiLCJjcmVhdGUiLCJjdXJyZW50RGVzdFF1YW50aXR5IiwiY3VycmVudERlc3RDb3N0IiwidHJhbnNmZXJRdWFudGl0eSIsImN1cnJlbnRUb3RhbFZhbHVlIiwidHJhbnNmZXJUb3RhbFZhbHVlIiwibmV3VG90YWxRdWFudGl0eSIsIm5ld1Nob3BTcGVjaWZpY0Nvc3QiLCJwdXNoIiwiY29zdCIsImxlbmd0aCIsIlByb21pc2UiLCJhbGwiLCJ1cGRhdGVNYW55IiwiaW5jcmVtZW50Iiwid2FjVXBkYXRlcyIsIkFycmF5IiwiZnJvbSIsImFsbEludmVudG9yeUFmdGVyVHJhbnNmZXIiLCJmaW5kTWFueSIsImd0IiwidG90YWxRdWFudGl0eSIsInJlZHVjZSIsInN1bSIsImludiIsInRvdGFsVmFsdWUiLCJnbG9iYWxXQUMiLCJmaWx0ZXIiLCJ3ZWlnaHRlZEF2ZXJhZ2VDb3N0IiwidGltZW91dCIsImludmFsaWRhdGVUcmFuc2ZlckNhY2hlIiwidG9rZW4iLCJleHRyYWN0VG9rZW4iLCJwYXlsb2FkIiwidmVyaWZ5VG9rZW4iLCJ1c2VyUm9sZSIsInJvbGVOYW1lIiwicGVybWlzc2lvblJlc3VsdCIsInNvdXJjZVNob3BJZCIsImRlc3RpbmF0aW9uU2hvcElkIiwiaXNBcnJheSIsImV4aXN0aW5nVHJhbnNmZXIiLCJzb3VyY2VTaG9wIiwic2hvcCIsImRlc3RpbmF0aW9uU2hvcCIsImludmVudG9yeSIsInByb2R1Y3ROYW1lIiwidXBkYXRlZFRyYW5zZmVyIiwidHJhbnNmZXJJdGVtIiwiZGVsZXRlTWFueSIsInRyYW5zZmVySWQiLCJ0cmFuc2Zlckl0ZW1zRGF0YSIsImNyZWF0ZU1h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