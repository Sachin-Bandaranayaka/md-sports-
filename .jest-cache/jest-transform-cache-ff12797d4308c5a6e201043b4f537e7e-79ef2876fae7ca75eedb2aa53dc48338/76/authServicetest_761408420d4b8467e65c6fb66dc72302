7ef64e11f7b53ebc8fda73770da6fe88
// Fixed Unit tests for AuthService
// This file tests the authentication service functionality
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _authService = require("../../src/services/authService");
// Mock dependencies BEFORE importing the service
const mockCacheService = {
    get: _globals.jest.fn(),
    set: _globals.jest.fn(),
    delete: _globals.jest.fn(),
    increment: _globals.jest.fn(),
    generateKey: _globals.jest.fn(),
    clear: _globals.jest.fn()
};
const mockPrisma = {
    user: {
        findUnique: _globals.jest.fn(),
        findFirst: _globals.jest.fn(),
        create: _globals.jest.fn(),
        update: _globals.jest.fn(),
        findMany: _globals.jest.fn(),
        delete: _globals.jest.fn()
    },
    permission: {
        findMany: _globals.jest.fn()
    },
    session: {
        create: _globals.jest.fn(),
        findUnique: _globals.jest.fn(),
        update: _globals.jest.fn(),
        deleteMany: _globals.jest.fn()
    },
    auditLog: {
        create: _globals.jest.fn()
    }
};
const mockBcrypt = {
    compare: _globals.jest.fn(),
    hash: _globals.jest.fn(),
    genSalt: _globals.jest.fn()
};
// Mock modules
_globals.jest.mock("@/lib/prisma", ()=>({
        __esModule: true,
        default: mockPrisma
    }));
_globals.jest.mock("@/lib/cache", ()=>({
        cacheService: mockCacheService,
        CACHE_CONFIG: {
            KEYS: {
                USER_SESSION: "user_session",
                TOKEN_VALIDATION: "token_validation"
            },
            TTL: {
                USER_SESSION: 3600,
                TOKEN_VALIDATION: 1800
            }
        }
    }));
_globals.jest.mock("bcryptjs", ()=>mockBcrypt);
_globals.jest.mock("jsonwebtoken");
// Create proper mock types for easier access
const mockUserFindFirst = mockPrisma.user.findFirst;
const mockPermissionFindMany = mockPrisma.permission.findMany;
const mockJwt = require("jsonwebtoken");
describe("AuthService", ()=>{
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        process.env.JWT_SECRET = "test-secret-key";
        process.env.JWT_ACCESS_TOKEN_EXPIRES_IN = "12h";
        // Setup default cache mocks
        mockCacheService.generateKey.mockReturnValue("mock-cache-key");
        mockCacheService.get.mockResolvedValue(null);
        mockCacheService.set.mockResolvedValue(undefined);
        mockCacheService.delete.mockResolvedValue(undefined);
        // Reset Prisma mocks
        mockUserFindFirst.mockResolvedValue(null);
        mockPermissionFindMany.mockResolvedValue([]);
        // Reset JWT mocks
        mockJwt.sign.mockReturnValue("mocked-jwt-token");
        mockJwt.verify.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
        mockJwt.decode.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
    });
    describe("parseTimeStringToSeconds", ()=>{
        test("should parse seconds correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("30s")).toBe(30);
        });
        test("should parse minutes correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("5m")).toBe(300);
        });
        test("should parse hours correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("2h")).toBe(7200);
        });
        test("should parse days correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("1d")).toBe(86400);
        });
        test("should return 0 for invalid input", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("invalid")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("abc")).toBe(0);
        });
        test("should handle edge cases", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("0s")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("100x")).toBe(100); // Falls back to parsing the number part
        });
    });
    describe("authenticateUser", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            password: "hashedpassword",
            isActive: true,
            roleId: 1,
            shopId: 1,
            roleName: "admin",
            permissions: null,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should authenticate valid user credentials", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(true);
            mockJwt.sign.mockReturnValue("mock-jwt-token");
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(true);
            expect(result.token).toBe("mock-jwt-token");
            expect(result.user).toEqual({
                id: 1,
                email: "test@example.com",
                username: "testuser",
                fullName: "testuser",
                roleId: 1,
                roleName: "admin",
                shopId: 1,
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockUserFindFirst).toHaveBeenCalledWith({
                where: {
                    email: "test@example.com",
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            });
        });
        test("should reject invalid email", async ()=>{
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.authenticateUser)("invalid@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject invalid password", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(false);
            const result = await (0, _authService.authenticateUser)("test@example.com", "wrongpassword");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject inactive user", async ()=>{
            mockUserFindFirst.mockResolvedValue(null); // findFirst with isActive: true returns null
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should handle database errors gracefully", async ()=>{
            mockUserFindFirst.mockRejectedValue(new Error("Database connection failed"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
        test("should handle bcrypt errors gracefully", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockRejectedValue(new Error("Bcrypt error"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
    });
    describe("generateToken", ()=>{
        const mockPayload = {
            sub: 1,
            username: "testuser",
            email: "test@example.com",
            roleId: 1,
            shopId: 1,
            permissions: [
                "read_products",
                "write_products"
            ]
        };
        test("should generate JWT token", ()=>{
            const mockToken = "mock-jwt-token";
            mockJwt.sign.mockReturnValue(mockToken);
            const result = (0, _authService.generateToken)(mockPayload);
            expect(result).toBe(mockToken);
            expect(mockJwt.sign).toHaveBeenCalledWith(mockPayload, "test-secret-key", {
                expiresIn: "12h"
            });
        });
    });
    describe("verifyToken", ()=>{
        test("should verify valid token from cache", async ()=>{
            const mockPayload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should verify valid token and cache result", async ()=>{
            const mockPayload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockJwt.verify.mockReturnValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockJwt.verify).toHaveBeenCalledWith("valid-token", "test-secret-key");
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("Invalid token");
            });
            await expect((0, _authService.verifyToken)("invalid-token")).rejects.toThrow("Invalid token");
        });
        test("should throw error for expired token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                const error = new Error("Token expired");
                error.name = "TokenExpiredError";
                error.expiredAt = new Date();
                throw error;
            });
            await expect((0, _authService.verifyToken)("expired-token")).rejects.toThrow("Token expired");
        });
    });
    describe("getUserFromDecodedPayload", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            isActive: true,
            roleId: 1,
            shopId: 1,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should return user from cache", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const cachedUser = {
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            };
            mockCacheService.get.mockResolvedValue(cachedUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual(cachedUser);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should return user from database and cache it", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockUserFindFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should return null for null payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)(null);
            expect(result).toBeNull();
        });
        test("should return null for invalid payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)({});
            expect(result).toBeNull();
        });
        test("should return null when user not found", async ()=>{
            const payload = {
                sub: 999,
                username: "nonexistent",
                email: "nonexistent@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null);
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toBeNull();
        });
    });
    describe("getUserFromToken", ()=>{
        test("should return user from valid token", async ()=>{
            const mockPayload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const mockUser = {
                id: 1,
                email: "test@example.com",
                name: "testuser",
                isActive: true,
                roleId: 1,
                shopId: 1,
                role: {
                    id: 1,
                    name: "admin",
                    permissions: [
                        {
                            name: "read_products"
                        }
                    ]
                }
            };
            // Mock verifyToken to return payload
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>mockPayload);
            // Mock getUserFromDecodedPayload
            mockUserFindFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromToken)("valid-token");
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products"
                ]
            });
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("jwt malformed");
            });
            await expect((0, _authService.getUserFromToken)("invalid-token")).rejects.toThrow("jwt malformed");
        });
    });
    describe("Error Handling", ()=>{
        test("should handle missing JWT_SECRET", async ()=>{
            const originalSecret = process.env.JWT_SECRET;
            delete process.env.JWT_SECRET;
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("secretOrPrivateKey must have a value");
            });
            await expect((0, _authService.verifyToken)("any-token")).rejects.toThrow();
            // Restore the secret
            process.env.JWT_SECRET = originalSecret;
        });
        test("should handle malformed tokens gracefully", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("jwt malformed");
            });
            await expect((0, _authService.verifyToken)("not.a.valid.jwt.token")).rejects.toThrow("jwt malformed");
        });
        test("should handle empty token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("jwt must be provided");
            });
            await expect((0, _authService.verifyToken)("")).rejects.toThrow("jwt must be provided");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9hdXRoU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpeGVkIFVuaXQgdGVzdHMgZm9yIEF1dGhTZXJ2aWNlXG4vLyBUaGlzIGZpbGUgdGVzdHMgdGhlIGF1dGhlbnRpY2F0aW9uIHNlcnZpY2UgZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzIEJFRk9SRSBpbXBvcnRpbmcgdGhlIHNlcnZpY2VcbmNvbnN0IG1vY2tDYWNoZVNlcnZpY2UgPSB7XG4gIGdldDogamVzdC5mbigpLFxuICBzZXQ6IGplc3QuZm4oKSxcbiAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIGluY3JlbWVudDogamVzdC5mbigpLFxuICBnZW5lcmF0ZUtleTogamVzdC5mbigpLFxuICBjbGVhcjogamVzdC5mbigpLFxufTtcblxuY29uc3QgbW9ja1ByaXNtYSA9IHtcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSxcbiAgICBmaW5kRmlyc3Q6IGplc3QuZm4oKSxcbiAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICBmaW5kTWFueTogamVzdC5mbigpLFxuICAgIGRlbGV0ZTogamVzdC5mbigpLFxuICB9LFxuICBwZXJtaXNzaW9uOiB7XG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgfSxcbiAgc2Vzc2lvbjoge1xuICAgIGNyZWF0ZTogamVzdC5mbigpLFxuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICBkZWxldGVNYW55OiBqZXN0LmZuKCksXG4gIH0sXG4gIGF1ZGl0TG9nOiB7XG4gICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gIH0sXG59O1xuXG5jb25zdCBtb2NrQmNyeXB0ID0ge1xuICBjb21wYXJlOiBqZXN0LmZuKCksXG4gIGhhc2g6IGplc3QuZm4oKSxcbiAgZ2VuU2FsdDogamVzdC5mbigpLFxufTtcblxuLy8gTW9jayBtb2R1bGVzXG5qZXN0Lm1vY2soJ0AvbGliL3ByaXNtYScsICgpID0+ICh7XG4gIF9fZXNNb2R1bGU6IHRydWUsXG4gIGRlZmF1bHQ6IG1vY2tQcmlzbWEsXG59KSk7XG5cbmplc3QubW9jaygnQC9saWIvY2FjaGUnLCAoKSA9PiAoe1xuICBjYWNoZVNlcnZpY2U6IG1vY2tDYWNoZVNlcnZpY2UsXG4gIENBQ0hFX0NPTkZJRzoge1xuICAgIEtFWVM6IHtcbiAgICAgIFVTRVJfU0VTU0lPTjogJ3VzZXJfc2Vzc2lvbicsXG4gICAgICBUT0tFTl9WQUxJREFUSU9OOiAndG9rZW5fdmFsaWRhdGlvbicsXG4gICAgfSxcbiAgICBUVEw6IHtcbiAgICAgIFVTRVJfU0VTU0lPTjogMzYwMCxcbiAgICAgIFRPS0VOX1ZBTElEQVRJT046IDE4MDAsXG4gICAgfSxcbiAgfSxcbn0pKTtcblxuamVzdC5tb2NrKCdiY3J5cHRqcycsICgpID0+IG1vY2tCY3J5cHQpO1xuamVzdC5tb2NrKCdqc29ud2VidG9rZW4nKTtcblxuLy8gSW1wb3J0IGFmdGVyIG1vY2tpbmdcbmltcG9ydCB7IGF1dGhlbnRpY2F0ZVVzZXIsIGdlbmVyYXRlVG9rZW4sIHZlcmlmeVRva2VuLCBwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMsIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQsIGdldFVzZXJGcm9tVG9rZW4gfSBmcm9tICdAL3NlcnZpY2VzL2F1dGhTZXJ2aWNlJztcblxuLy8gQ3JlYXRlIHByb3BlciBtb2NrIHR5cGVzIGZvciBlYXNpZXIgYWNjZXNzXG5jb25zdCBtb2NrVXNlckZpbmRGaXJzdCA9IG1vY2tQcmlzbWEudXNlci5maW5kRmlyc3QgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgbW9ja1ByaXNtYS51c2VyLmZpbmRGaXJzdD47XG5jb25zdCBtb2NrUGVybWlzc2lvbkZpbmRNYW55ID0gbW9ja1ByaXNtYS5wZXJtaXNzaW9uLmZpbmRNYW55IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIG1vY2tQcmlzbWEucGVybWlzc2lvbi5maW5kTWFueT47XG5jb25zdCBtb2NrSnd0ID0gcmVxdWlyZSgnanNvbndlYnRva2VuJykgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGltcG9ydCgnanNvbndlYnRva2VuJyk+O1xuXG5kZXNjcmliZSgnQXV0aFNlcnZpY2UnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgPSAndGVzdC1zZWNyZXQta2V5JztcbiAgICBwcm9jZXNzLmVudi5KV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4gPSAnMTJoJztcbiAgICBcbiAgICAvLyBTZXR1cCBkZWZhdWx0IGNhY2hlIG1vY2tzXG4gICAgbW9ja0NhY2hlU2VydmljZS5nZW5lcmF0ZUtleS5tb2NrUmV0dXJuVmFsdWUoJ21vY2stY2FjaGUta2V5Jyk7XG4gICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgbW9ja0NhY2hlU2VydmljZS5zZXQubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICBtb2NrQ2FjaGVTZXJ2aWNlLmRlbGV0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgIFxuICAgIC8vIFJlc2V0IFByaXNtYSBtb2Nrc1xuICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgIG1vY2tQZXJtaXNzaW9uRmluZE1hbnkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgIFxuICAgIC8vIFJlc2V0IEpXVCBtb2Nrc1xuICAgIG1vY2tKd3Quc2lnbi5tb2NrUmV0dXJuVmFsdWUoJ21vY2tlZC1qd3QtdG9rZW4nKTtcbiAgICBtb2NrSnd0LnZlcmlmeS5tb2NrUmV0dXJuVmFsdWUoeyB1c2VySWQ6IDEsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSk7XG4gICAgbW9ja0p3dC5kZWNvZGUubW9ja1JldHVyblZhbHVlKHsgdXNlcklkOiAxLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBwYXJzZSBzZWNvbmRzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzMwcycpKS50b0JlKDMwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwYXJzZSBtaW51dGVzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzVtJykpLnRvQmUoMzAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwYXJzZSBob3VycyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcyaCcpKS50b0JlKDcyMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIGRheXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMWQnKSkudG9CZSg4NjQwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIDAgZm9yIGludmFsaWQgaW5wdXQnLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcnKSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJ2ludmFsaWQnKSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJ2FiYycpKS50b0JlKDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBlZGdlIGNhc2VzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMHMnKSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzEwMHgnKSkudG9CZSgxMDApOyAvLyBGYWxscyBiYWNrIHRvIHBhcnNpbmcgdGhlIG51bWJlciBwYXJ0XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhdXRoZW50aWNhdGVVc2VyJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgbmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgIHBhc3N3b3JkOiAnaGFzaGVkcGFzc3dvcmQnLFxuICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICByb2xlSWQ6IDEsXG4gICAgICBzaG9wSWQ6IDEsXG4gICAgICByb2xlTmFtZTogJ2FkbWluJyxcbiAgICAgIHBlcm1pc3Npb25zOiBudWxsLFxuICAgICAgcm9sZToge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ2FkbWluJyxcbiAgICAgICAgcGVybWlzc2lvbnM6IFtcbiAgICAgICAgICB7IG5hbWU6ICdyZWFkX3Byb2R1Y3RzJyB9LFxuICAgICAgICAgIHsgbmFtZTogJ3dyaXRlX3Byb2R1Y3RzJyB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGVzdCgnc2hvdWxkIGF1dGhlbnRpY2F0ZSB2YWxpZCB1c2VyIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuICAgICAgbW9ja0JjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUgYXMgYW55KTtcbiAgICAgIG1vY2tKd3Quc2lnbi5tb2NrUmV0dXJuVmFsdWUoJ21vY2stand0LXRva2VuJyBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudG9rZW4pLnRvQmUoJ21vY2stand0LXRva2VuJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnVzZXIpLnRvRXF1YWwoe1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGZ1bGxOYW1lOiAndGVzdHVzZXInLFxuICAgICAgICByb2xlSWQ6IDEsXG4gICAgICAgIHJvbGVOYW1lOiAnYWRtaW4nLFxuICAgICAgICBzaG9wSWQ6IDEsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja1VzZXJGaW5kRmlyc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGlzQWN0aXZlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICByb2xlOiB7XG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgIHBlcm1pc3Npb25zOiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0OiB7IG5hbWU6IHRydWUgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBlbWFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCdpbnZhbGlkQGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBwYXNzd29yZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIG1vY2tCY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZShmYWxzZSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3dyb25ncGFzc3dvcmQnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlamVjdCBpbmFjdGl2ZSB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIGZpbmRGaXJzdCB3aXRoIGlzQWN0aXZlOiB0cnVlIHJldHVybnMgbnVsbFxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBiY3J5cHQgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgICBtb2NrQmNyeXB0LmNvbXBhcmUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdCY3J5cHQgZXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnQXV0aGVudGljYXRpb24gZmFpbGVkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZW5lcmF0ZVRva2VuJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgc3ViOiAxLFxuICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgcm9sZUlkOiAxLFxuICAgICAgc2hvcElkOiAxLFxuICAgICAgcGVybWlzc2lvbnM6IFsncmVhZF9wcm9kdWN0cycsICd3cml0ZV9wcm9kdWN0cyddXG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSBKV1QgdG9rZW4nLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVG9rZW4gPSAnbW9jay1qd3QtdG9rZW4nO1xuICAgICAgbW9ja0p3dC5zaWduLm1vY2tSZXR1cm5WYWx1ZShtb2NrVG9rZW4pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBnZW5lcmF0ZVRva2VuKG1vY2tQYXlsb2FkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShtb2NrVG9rZW4pO1xuICAgICAgZXhwZWN0KG1vY2tKd3Quc2lnbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgbW9ja1BheWxvYWQsXG4gICAgICAgICAgJ3Rlc3Qtc2VjcmV0LWtleScsXG4gICAgICAgICAgeyBleHBpcmVzSW46ICcxMmgnIH1cbiAgICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3ZlcmlmeVRva2VuJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB2ZXJpZnkgdmFsaWQgdG9rZW4gZnJvbSBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgICBzdWI6IDEsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDEsXG4gICAgICAgIGlhdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgIGV4cDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAzNjAwXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUGF5bG9hZCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCd2YWxpZC10b2tlbicpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tQYXlsb2FkKTtcbiAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmdldCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHZlcmlmeSB2YWxpZCB0b2tlbiBhbmQgY2FjaGUgcmVzdWx0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgaWF0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDM2MDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBOb3QgaW4gY2FjaGVcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tSZXR1cm5WYWx1ZShtb2NrUGF5bG9hZCBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbigndmFsaWQtdG9rZW4nKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUGF5bG9hZCk7XG4gICAgICBleHBlY3QobW9ja0p3dC52ZXJpZnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd2YWxpZC10b2tlbicsICd0ZXN0LXNlY3JldC1rZXknKTtcbiAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLnNldCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBpbnZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4nKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJ2ludmFsaWQtdG9rZW4nKSkucmVqZWN0cy50b1Rocm93KCdJbnZhbGlkIHRva2VuJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGV4cGlyZWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUb2tlbiBleHBpcmVkJykgYXMgYW55O1xuICAgICAgICBlcnJvci5uYW1lID0gJ1Rva2VuRXhwaXJlZEVycm9yJztcbiAgICAgICAgZXJyb3IuZXhwaXJlZEF0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdleHBpcmVkLXRva2VuJykpLnJlamVjdHMudG9UaHJvdygnVG9rZW4gZXhwaXJlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCcsICgpID0+IHtcbiAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgIGlkOiAxLFxuICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIG5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIHJvbGVJZDogMSxcbiAgICAgIHNob3BJZDogMSxcbiAgICAgIHJvbGU6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbXG4gICAgICAgICAgeyBuYW1lOiAncmVhZF9wcm9kdWN0cycgfSxcbiAgICAgICAgICB7IG5hbWU6ICd3cml0ZV9wcm9kdWN0cycgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgc3ViOiAxLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBjYWNoZWRVc2VyID0ge1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUoY2FjaGVkVXNlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoY2FjaGVkVXNlcik7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIGRhdGFiYXNlIGFuZCBjYWNoZSBpdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIE5vdCBpbiBjYWNoZVxuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHBheWxvYWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgLi4ubW9ja1VzZXIsXG4gICAgICAgIHJvbGVOYW1lOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJywgJ3dyaXRlX3Byb2R1Y3RzJ11cbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2Uuc2V0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG51bGwgcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQobnVsbCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBpbnZhbGlkIHBheWxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHt9IGFzIGFueSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiBudWxsIHdoZW4gdXNlciBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBzdWI6IDk5OSxcbiAgICAgICAgdXNlcm5hbWU6ICdub25leGlzdGVudCcsXG4gICAgICAgIGVtYWlsOiAnbm9uZXhpc3RlbnRAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VXNlckZyb21Ub2tlbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIHVzZXIgZnJvbSB2YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgICBzdWI6IDEsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgc2hvcElkOiAxLFxuICAgICAgICByb2xlOiB7XG4gICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgbmFtZTogJ2FkbWluJyxcbiAgICAgICAgICBwZXJtaXNzaW9uczogW3sgbmFtZTogJ3JlYWRfcHJvZHVjdHMnIH1dXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgdmVyaWZ5VG9rZW4gdG8gcmV0dXJuIHBheWxvYWRcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tQYXlsb2FkKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkXG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tVG9rZW4oJ3ZhbGlkLXRva2VuJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnXVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGludmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignand0IG1hbGZvcm1lZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChnZXRVc2VyRnJvbVRva2VuKCdpbnZhbGlkLXRva2VuJykpLnJlamVjdHMudG9UaHJvdygnand0IG1hbGZvcm1lZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIEpXVF9TRUNSRVQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbFNlY3JldCA9IHByb2Nlc3MuZW52LkpXVF9TRUNSRVQ7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVDtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY3JldE9yUHJpdmF0ZUtleSBtdXN0IGhhdmUgYSB2YWx1ZScpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbignYW55LXRva2VuJykpLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIHRoZSBzZWNyZXRcbiAgICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgPSBvcmlnaW5hbFNlY3JldDtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWFsZm9ybWVkIHRva2VucyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJ25vdC5hLnZhbGlkLmp3dC50b2tlbicpKS5yZWplY3RzLnRvVGhyb3coJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignand0IG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJycpKS5yZWplY3RzLnRvVGhyb3coJ2p3dCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbIm1vY2tDYWNoZVNlcnZpY2UiLCJnZXQiLCJqZXN0IiwiZm4iLCJzZXQiLCJkZWxldGUiLCJpbmNyZW1lbnQiLCJnZW5lcmF0ZUtleSIsImNsZWFyIiwibW9ja1ByaXNtYSIsInVzZXIiLCJmaW5kVW5pcXVlIiwiZmluZEZpcnN0IiwiY3JlYXRlIiwidXBkYXRlIiwiZmluZE1hbnkiLCJwZXJtaXNzaW9uIiwic2Vzc2lvbiIsImRlbGV0ZU1hbnkiLCJhdWRpdExvZyIsIm1vY2tCY3J5cHQiLCJjb21wYXJlIiwiaGFzaCIsImdlblNhbHQiLCJtb2NrIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjYWNoZVNlcnZpY2UiLCJDQUNIRV9DT05GSUciLCJLRVlTIiwiVVNFUl9TRVNTSU9OIiwiVE9LRU5fVkFMSURBVElPTiIsIlRUTCIsIm1vY2tVc2VyRmluZEZpcnN0IiwibW9ja1Blcm1pc3Npb25GaW5kTWFueSIsIm1vY2tKd3QiLCJyZXF1aXJlIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInByb2Nlc3MiLCJlbnYiLCJKV1RfU0VDUkVUIiwiSldUX0FDQ0VTU19UT0tFTl9FWFBJUkVTX0lOIiwibW9ja1JldHVyblZhbHVlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ1bmRlZmluZWQiLCJzaWduIiwidmVyaWZ5IiwidXNlcklkIiwiZW1haWwiLCJkZWNvZGUiLCJ0ZXN0IiwiZXhwZWN0IiwicGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzIiwidG9CZSIsIm1vY2tVc2VyIiwiaWQiLCJuYW1lIiwicGFzc3dvcmQiLCJpc0FjdGl2ZSIsInJvbGVJZCIsInNob3BJZCIsInJvbGVOYW1lIiwicGVybWlzc2lvbnMiLCJyb2xlIiwicmVzdWx0IiwiYXV0aGVudGljYXRlVXNlciIsInN1Y2Nlc3MiLCJ0b2tlbiIsInRvRXF1YWwiLCJ1c2VybmFtZSIsImZ1bGxOYW1lIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ3aGVyZSIsImluY2x1ZGUiLCJzZWxlY3QiLCJtZXNzYWdlIiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciIsIm1vY2tQYXlsb2FkIiwic3ViIiwibW9ja1Rva2VuIiwiZ2VuZXJhdGVUb2tlbiIsImV4cGlyZXNJbiIsImlhdCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJleHAiLCJ2ZXJpZnlUb2tlbiIsInRvSGF2ZUJlZW5DYWxsZWQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJyZWplY3RzIiwidG9UaHJvdyIsImVycm9yIiwiZXhwaXJlZEF0IiwicGF5bG9hZCIsImNhY2hlZFVzZXIiLCJnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkIiwidG9CZU51bGwiLCJnZXRVc2VyRnJvbVRva2VuIiwib3JpZ2luYWxTZWNyZXQiXSwibWFwcGluZ3MiOiJBQUFBLG1DQUFtQztBQUNuQywyREFBMkQ7Ozs7O3lCQUV0Qzs2QkFpRStHO0FBL0RwSSxpREFBaUQ7QUFDakQsTUFBTUEsbUJBQW1CO0lBQ3ZCQyxLQUFLQyxhQUFJLENBQUNDLEVBQUU7SUFDWkMsS0FBS0YsYUFBSSxDQUFDQyxFQUFFO0lBQ1pFLFFBQVFILGFBQUksQ0FBQ0MsRUFBRTtJQUNmRyxXQUFXSixhQUFJLENBQUNDLEVBQUU7SUFDbEJJLGFBQWFMLGFBQUksQ0FBQ0MsRUFBRTtJQUNwQkssT0FBT04sYUFBSSxDQUFDQyxFQUFFO0FBQ2hCO0FBRUEsTUFBTU0sYUFBYTtJQUNqQkMsTUFBTTtRQUNKQyxZQUFZVCxhQUFJLENBQUNDLEVBQUU7UUFDbkJTLFdBQVdWLGFBQUksQ0FBQ0MsRUFBRTtRQUNsQlUsUUFBUVgsYUFBSSxDQUFDQyxFQUFFO1FBQ2ZXLFFBQVFaLGFBQUksQ0FBQ0MsRUFBRTtRQUNmWSxVQUFVYixhQUFJLENBQUNDLEVBQUU7UUFDakJFLFFBQVFILGFBQUksQ0FBQ0MsRUFBRTtJQUNqQjtJQUNBYSxZQUFZO1FBQ1ZELFVBQVViLGFBQUksQ0FBQ0MsRUFBRTtJQUNuQjtJQUNBYyxTQUFTO1FBQ1BKLFFBQVFYLGFBQUksQ0FBQ0MsRUFBRTtRQUNmUSxZQUFZVCxhQUFJLENBQUNDLEVBQUU7UUFDbkJXLFFBQVFaLGFBQUksQ0FBQ0MsRUFBRTtRQUNmZSxZQUFZaEIsYUFBSSxDQUFDQyxFQUFFO0lBQ3JCO0lBQ0FnQixVQUFVO1FBQ1JOLFFBQVFYLGFBQUksQ0FBQ0MsRUFBRTtJQUNqQjtBQUNGO0FBRUEsTUFBTWlCLGFBQWE7SUFDakJDLFNBQVNuQixhQUFJLENBQUNDLEVBQUU7SUFDaEJtQixNQUFNcEIsYUFBSSxDQUFDQyxFQUFFO0lBQ2JvQixTQUFTckIsYUFBSSxDQUFDQyxFQUFFO0FBQ2xCO0FBRUEsZUFBZTtBQUNmRCxhQUFJLENBQUNzQixJQUFJLENBQUMsZ0JBQWdCLElBQU8sQ0FBQTtRQUMvQkMsWUFBWTtRQUNaQyxTQUFTakI7SUFDWCxDQUFBO0FBRUFQLGFBQUksQ0FBQ3NCLElBQUksQ0FBQyxlQUFlLElBQU8sQ0FBQTtRQUM5QkcsY0FBYzNCO1FBQ2Q0QixjQUFjO1lBQ1pDLE1BQU07Z0JBQ0pDLGNBQWM7Z0JBQ2RDLGtCQUFrQjtZQUNwQjtZQUNBQyxLQUFLO2dCQUNIRixjQUFjO2dCQUNkQyxrQkFBa0I7WUFDcEI7UUFDRjtJQUNGLENBQUE7QUFFQTdCLGFBQUksQ0FBQ3NCLElBQUksQ0FBQyxZQUFZLElBQU1KO0FBQzVCbEIsYUFBSSxDQUFDc0IsSUFBSSxDQUFDO0FBS1YsNkNBQTZDO0FBQzdDLE1BQU1TLG9CQUFvQnhCLFdBQVdDLElBQUksQ0FBQ0UsU0FBUztBQUNuRCxNQUFNc0IseUJBQXlCekIsV0FBV08sVUFBVSxDQUFDRCxRQUFRO0FBQzdELE1BQU1vQixVQUFVQyxRQUFRO0FBRXhCQyxTQUFTLGVBQWU7SUFDdEJDLFdBQVc7UUFDVHBDLGFBQUksQ0FBQ3FDLGFBQWE7UUFDbEJDLFFBQVFDLEdBQUcsQ0FBQ0MsVUFBVSxHQUFHO1FBQ3pCRixRQUFRQyxHQUFHLENBQUNFLDJCQUEyQixHQUFHO1FBRTFDLDRCQUE0QjtRQUM1QjNDLGlCQUFpQk8sV0FBVyxDQUFDcUMsZUFBZSxDQUFDO1FBQzdDNUMsaUJBQWlCQyxHQUFHLENBQUM0QyxpQkFBaUIsQ0FBQztRQUN2QzdDLGlCQUFpQkksR0FBRyxDQUFDeUMsaUJBQWlCLENBQUNDO1FBQ3ZDOUMsaUJBQWlCSyxNQUFNLENBQUN3QyxpQkFBaUIsQ0FBQ0M7UUFFMUMscUJBQXFCO1FBQ3JCYixrQkFBa0JZLGlCQUFpQixDQUFDO1FBQ3BDWCx1QkFBdUJXLGlCQUFpQixDQUFDLEVBQUU7UUFFM0Msa0JBQWtCO1FBQ2xCVixRQUFRWSxJQUFJLENBQUNILGVBQWUsQ0FBQztRQUM3QlQsUUFBUWEsTUFBTSxDQUFDSixlQUFlLENBQUM7WUFBRUssUUFBUTtZQUFHQyxPQUFPO1FBQW1CO1FBQ3RFZixRQUFRZ0IsTUFBTSxDQUFDUCxlQUFlLENBQUM7WUFBRUssUUFBUTtZQUFHQyxPQUFPO1FBQW1CO0lBQ3hFO0lBRUFiLFNBQVMsNEJBQTRCO1FBQ25DZSxLQUFLLGtDQUFrQztZQUNyQ0MsT0FBT0MsSUFBQUEscUNBQXdCLEVBQUMsUUFBUUMsSUFBSSxDQUFDO1FBQy9DO1FBRUFILEtBQUssa0NBQWtDO1lBQ3JDQyxPQUFPQyxJQUFBQSxxQ0FBd0IsRUFBQyxPQUFPQyxJQUFJLENBQUM7UUFDOUM7UUFFQUgsS0FBSyxnQ0FBZ0M7WUFDbkNDLE9BQU9DLElBQUFBLHFDQUF3QixFQUFDLE9BQU9DLElBQUksQ0FBQztRQUM5QztRQUVBSCxLQUFLLCtCQUErQjtZQUNsQ0MsT0FBT0MsSUFBQUEscUNBQXdCLEVBQUMsT0FBT0MsSUFBSSxDQUFDO1FBQzlDO1FBRUFILEtBQUsscUNBQXFDO1lBQ3hDQyxPQUFPQyxJQUFBQSxxQ0FBd0IsRUFBQyxLQUFLQyxJQUFJLENBQUM7WUFDMUNGLE9BQU9DLElBQUFBLHFDQUF3QixFQUFDLFlBQVlDLElBQUksQ0FBQztZQUNqREYsT0FBT0MsSUFBQUEscUNBQXdCLEVBQUMsUUFBUUMsSUFBSSxDQUFDO1FBQy9DO1FBRUFILEtBQUssNEJBQTRCO1lBQy9CQyxPQUFPQyxJQUFBQSxxQ0FBd0IsRUFBQyxPQUFPQyxJQUFJLENBQUM7WUFDNUNGLE9BQU9DLElBQUFBLHFDQUF3QixFQUFDLFNBQVNDLElBQUksQ0FBQyxNQUFNLHdDQUF3QztRQUM5RjtJQUNGO0lBRUFsQixTQUFTLG9CQUFvQjtRQUMzQixNQUFNbUIsV0FBVztZQUNmQyxJQUFJO1lBQ0pQLE9BQU87WUFDUFEsTUFBTTtZQUNOQyxVQUFVO1lBQ1ZDLFVBQVU7WUFDVkMsUUFBUTtZQUNSQyxRQUFRO1lBQ1JDLFVBQVU7WUFDVkMsYUFBYTtZQUNiQyxNQUFNO2dCQUNKUixJQUFJO2dCQUNKQyxNQUFNO2dCQUNOTSxhQUFhO29CQUNYO3dCQUFFTixNQUFNO29CQUFnQjtvQkFDeEI7d0JBQUVBLE1BQU07b0JBQWlCO2lCQUMxQjtZQUNIO1FBQ0Y7UUFFQU4sS0FBSyw4Q0FBOEM7WUFDakRuQixrQkFBa0JZLGlCQUFpQixDQUFDVztZQUNwQ3BDLFdBQVdDLE9BQU8sQ0FBQ3dCLGlCQUFpQixDQUFDO1lBQ3JDVixRQUFRWSxJQUFJLENBQUNILGVBQWUsQ0FBQztZQUU3QixNQUFNc0IsU0FBUyxNQUFNQyxJQUFBQSw2QkFBZ0IsRUFBQyxvQkFBb0I7WUFFMURkLE9BQU9hLE9BQU9FLE9BQU8sRUFBRWIsSUFBSSxDQUFDO1lBQzVCRixPQUFPYSxPQUFPRyxLQUFLLEVBQUVkLElBQUksQ0FBQztZQUMxQkYsT0FBT2EsT0FBT3hELElBQUksRUFBRTRELE9BQU8sQ0FBQztnQkFDMUJiLElBQUk7Z0JBQ0pQLE9BQU87Z0JBQ1BxQixVQUFVO2dCQUNWQyxVQUFVO2dCQUNWWCxRQUFRO2dCQUNSRSxVQUFVO2dCQUNWRCxRQUFRO2dCQUNSRSxhQUFhO29CQUFDO29CQUFpQjtpQkFBaUI7WUFDbEQ7WUFDQVgsT0FBT3BCLG1CQUFtQndDLG9CQUFvQixDQUFDO2dCQUM3Q0MsT0FBTztvQkFDTHhCLE9BQU87b0JBQ1BVLFVBQVU7Z0JBQ1o7Z0JBQ0FlLFNBQVM7b0JBQ1BWLE1BQU07d0JBQ0pVLFNBQVM7NEJBQ1BYLGFBQWE7Z0NBQ1hZLFFBQVE7b0NBQUVsQixNQUFNO2dDQUFLOzRCQUN2Qjt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQU4sS0FBSywrQkFBK0I7WUFDbENuQixrQkFBa0JZLGlCQUFpQixDQUFDO1lBRXBDLE1BQU1xQixTQUFTLE1BQU1DLElBQUFBLDZCQUFnQixFQUFDLHVCQUF1QjtZQUU3RGQsT0FBT2EsT0FBT0UsT0FBTyxFQUFFYixJQUFJLENBQUM7WUFDNUJGLE9BQU9hLE9BQU9XLE9BQU8sRUFBRXRCLElBQUksQ0FBQztRQUM5QjtRQUVBSCxLQUFLLGtDQUFrQztZQUNyQ25CLGtCQUFrQlksaUJBQWlCLENBQUNXO1lBQ3BDcEMsV0FBV0MsT0FBTyxDQUFDd0IsaUJBQWlCLENBQUM7WUFFckMsTUFBTXFCLFNBQVMsTUFBTUMsSUFBQUEsNkJBQWdCLEVBQUMsb0JBQW9CO1lBRTFEZCxPQUFPYSxPQUFPRSxPQUFPLEVBQUViLElBQUksQ0FBQztZQUM1QkYsT0FBT2EsT0FBT1csT0FBTyxFQUFFdEIsSUFBSSxDQUFDO1FBQzlCO1FBRUFILEtBQUssK0JBQStCO1lBQ2xDbkIsa0JBQWtCWSxpQkFBaUIsQ0FBQyxPQUFPLDZDQUE2QztZQUV4RixNQUFNcUIsU0FBUyxNQUFNQyxJQUFBQSw2QkFBZ0IsRUFBQyxvQkFBb0I7WUFFMURkLE9BQU9hLE9BQU9FLE9BQU8sRUFBRWIsSUFBSSxDQUFDO1lBQzVCRixPQUFPYSxPQUFPVyxPQUFPLEVBQUV0QixJQUFJLENBQUM7UUFDOUI7UUFFQUgsS0FBSyw0Q0FBNEM7WUFDL0NuQixrQkFBa0I2QyxpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRTlDLE1BQU1iLFNBQVMsTUFBTUMsSUFBQUEsNkJBQWdCLEVBQUMsb0JBQW9CO1lBRTFEZCxPQUFPYSxPQUFPRSxPQUFPLEVBQUViLElBQUksQ0FBQztZQUM1QkYsT0FBT2EsT0FBT1csT0FBTyxFQUFFdEIsSUFBSSxDQUFDO1FBQzlCO1FBRUFILEtBQUssMENBQTBDO1lBQzdDbkIsa0JBQWtCWSxpQkFBaUIsQ0FBQ1c7WUFDcENwQyxXQUFXQyxPQUFPLENBQUN5RCxpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRS9DLE1BQU1iLFNBQVMsTUFBTUMsSUFBQUEsNkJBQWdCLEVBQUMsb0JBQW9CO1lBRTFEZCxPQUFPYSxPQUFPRSxPQUFPLEVBQUViLElBQUksQ0FBQztZQUM1QkYsT0FBT2EsT0FBT1csT0FBTyxFQUFFdEIsSUFBSSxDQUFDO1FBQzlCO0lBQ0Y7SUFFQWxCLFNBQVMsaUJBQWlCO1FBQ3hCLE1BQU0yQyxjQUFjO1lBQ2xCQyxLQUFLO1lBQ0xWLFVBQVU7WUFDVnJCLE9BQU87WUFDUFcsUUFBUTtZQUNSQyxRQUFRO1lBQ1JFLGFBQWE7Z0JBQUM7Z0JBQWlCO2FBQWlCO1FBQ2xEO1FBRUFaLEtBQUssNkJBQTZCO1lBQ2hDLE1BQU04QixZQUFZO1lBQ2xCL0MsUUFBUVksSUFBSSxDQUFDSCxlQUFlLENBQUNzQztZQUU3QixNQUFNaEIsU0FBU2lCLElBQUFBLDBCQUFhLEVBQUNIO1lBRTdCM0IsT0FBT2EsUUFBUVgsSUFBSSxDQUFDMkI7WUFDcEI3QixPQUFPbEIsUUFBUVksSUFBSSxFQUFFMEIsb0JBQW9CLENBQ3JDTyxhQUNBLG1CQUNBO2dCQUFFSSxXQUFXO1lBQU07UUFFekI7SUFDRjtJQUVBL0MsU0FBUyxlQUFlO1FBQ3RCZSxLQUFLLHdDQUF3QztZQUMzQyxNQUFNNEIsY0FBYztnQkFDbEJDLEtBQUs7Z0JBQ0xWLFVBQVU7Z0JBQ1ZyQixPQUFPO2dCQUNQVyxRQUFRO2dCQUNSd0IsS0FBS0MsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7Z0JBQzdCQyxLQUFLSixLQUFLQyxLQUFLLENBQUNDLEtBQUtDLEdBQUcsS0FBSyxRQUFRO1lBQ3ZDO1lBRUF6RixpQkFBaUJDLEdBQUcsQ0FBQzRDLGlCQUFpQixDQUFDbUM7WUFFdkMsTUFBTWQsU0FBUyxNQUFNeUIsSUFBQUEsd0JBQVcsRUFBQztZQUVqQ3RDLE9BQU9hLFFBQVFJLE9BQU8sQ0FBQ1U7WUFDdkIzQixPQUFPckQsaUJBQWlCQyxHQUFHLEVBQUUyRixnQkFBZ0I7UUFDL0M7UUFFQXhDLEtBQUssOENBQThDO1lBQ2pELE1BQU00QixjQUFjO2dCQUNsQkMsS0FBSztnQkFDTFYsVUFBVTtnQkFDVnJCLE9BQU87Z0JBQ1BXLFFBQVE7Z0JBQ1J3QixLQUFLQyxLQUFLQyxLQUFLLENBQUNDLEtBQUtDLEdBQUcsS0FBSztnQkFDN0JDLEtBQUtKLEtBQUtDLEtBQUssQ0FBQ0MsS0FBS0MsR0FBRyxLQUFLLFFBQVE7WUFDdkM7WUFFQXpGLGlCQUFpQkMsR0FBRyxDQUFDNEMsaUJBQWlCLENBQUMsT0FBTyxlQUFlO1lBQzdEVixRQUFRYSxNQUFNLENBQUNKLGVBQWUsQ0FBQ29DO1lBRS9CLE1BQU1kLFNBQVMsTUFBTXlCLElBQUFBLHdCQUFXLEVBQUM7WUFFakN0QyxPQUFPYSxRQUFRSSxPQUFPLENBQUNVO1lBQ3ZCM0IsT0FBT2xCLFFBQVFhLE1BQU0sRUFBRXlCLG9CQUFvQixDQUFDLGVBQWU7WUFDM0RwQixPQUFPckQsaUJBQWlCSSxHQUFHLEVBQUV3RixnQkFBZ0I7UUFDL0M7UUFFQXhDLEtBQUssd0NBQXdDO1lBQzNDcEQsaUJBQWlCQyxHQUFHLENBQUM0QyxpQkFBaUIsQ0FBQztZQUN2Q1YsUUFBUWEsTUFBTSxDQUFDNkMsa0JBQWtCLENBQUM7Z0JBQ2hDLE1BQU0sSUFBSWQsTUFBTTtZQUNsQjtZQUVBLE1BQU0xQixPQUFPc0MsSUFBQUEsd0JBQVcsRUFBQyxrQkFBa0JHLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO1FBQzdEO1FBRUEzQyxLQUFLLHdDQUF3QztZQUMzQ3BELGlCQUFpQkMsR0FBRyxDQUFDNEMsaUJBQWlCLENBQUM7WUFDdkNWLFFBQVFhLE1BQU0sQ0FBQzZDLGtCQUFrQixDQUFDO2dCQUNoQyxNQUFNRyxRQUFRLElBQUlqQixNQUFNO2dCQUN4QmlCLE1BQU10QyxJQUFJLEdBQUc7Z0JBQ2JzQyxNQUFNQyxTQUFTLEdBQUcsSUFBSVQ7Z0JBQ3RCLE1BQU1RO1lBQ1I7WUFFQSxNQUFNM0MsT0FBT3NDLElBQUFBLHdCQUFXLEVBQUMsa0JBQWtCRyxPQUFPLENBQUNDLE9BQU8sQ0FBQztRQUM3RDtJQUNGO0lBRUExRCxTQUFTLDZCQUE2QjtRQUNwQyxNQUFNbUIsV0FBVztZQUNmQyxJQUFJO1lBQ0pQLE9BQU87WUFDUFEsTUFBTTtZQUNORSxVQUFVO1lBQ1ZDLFFBQVE7WUFDUkMsUUFBUTtZQUNSRyxNQUFNO2dCQUNKUixJQUFJO2dCQUNKQyxNQUFNO2dCQUNOTSxhQUFhO29CQUNYO3dCQUFFTixNQUFNO29CQUFnQjtvQkFDeEI7d0JBQUVBLE1BQU07b0JBQWlCO2lCQUMxQjtZQUNIO1FBQ0Y7UUFFQU4sS0FBSyxpQ0FBaUM7WUFDcEMsTUFBTThDLFVBQVU7Z0JBQ2RqQixLQUFLO2dCQUNMVixVQUFVO2dCQUNWckIsT0FBTztnQkFDUFcsUUFBUTtZQUNWO1lBRUEsTUFBTXNDLGFBQWE7Z0JBQ2pCLEdBQUczQyxRQUFRO2dCQUNYTyxVQUFVO2dCQUNWQyxhQUFhO29CQUFDO29CQUFpQjtpQkFBaUI7WUFDbEQ7WUFFQWhFLGlCQUFpQkMsR0FBRyxDQUFDNEMsaUJBQWlCLENBQUNzRDtZQUV2QyxNQUFNakMsU0FBUyxNQUFNa0MsSUFBQUEsc0NBQXlCLEVBQUNGO1lBRS9DN0MsT0FBT2EsUUFBUUksT0FBTyxDQUFDNkI7WUFDdkI5QyxPQUFPckQsaUJBQWlCQyxHQUFHLEVBQUUyRixnQkFBZ0I7UUFDL0M7UUFFQXhDLEtBQUssaURBQWlEO1lBQ3BELE1BQU04QyxVQUFVO2dCQUNkakIsS0FBSztnQkFDTFYsVUFBVTtnQkFDVnJCLE9BQU87Z0JBQ1BXLFFBQVE7WUFDVjtZQUVBN0QsaUJBQWlCQyxHQUFHLENBQUM0QyxpQkFBaUIsQ0FBQyxPQUFPLGVBQWU7WUFDN0RaLGtCQUFrQlksaUJBQWlCLENBQUNXO1lBRXBDLE1BQU1VLFNBQVMsTUFBTWtDLElBQUFBLHNDQUF5QixFQUFDRjtZQUUvQzdDLE9BQU9hLFFBQVFJLE9BQU8sQ0FBQztnQkFDckIsR0FBR2QsUUFBUTtnQkFDWE8sVUFBVTtnQkFDVkMsYUFBYTtvQkFBQztvQkFBaUI7aUJBQWlCO1lBQ2xEO1lBQ0FYLE9BQU9yRCxpQkFBaUJJLEdBQUcsRUFBRXdGLGdCQUFnQjtRQUMvQztRQUVBeEMsS0FBSyx1Q0FBdUM7WUFDMUMsTUFBTWMsU0FBUyxNQUFNa0MsSUFBQUEsc0NBQXlCLEVBQUM7WUFDL0MvQyxPQUFPYSxRQUFRbUMsUUFBUTtRQUN6QjtRQUVBakQsS0FBSywwQ0FBMEM7WUFDN0MsTUFBTWMsU0FBUyxNQUFNa0MsSUFBQUEsc0NBQXlCLEVBQUMsQ0FBQztZQUNoRC9DLE9BQU9hLFFBQVFtQyxRQUFRO1FBQ3pCO1FBRUFqRCxLQUFLLDBDQUEwQztZQUM3QyxNQUFNOEMsVUFBVTtnQkFDZGpCLEtBQUs7Z0JBQ0xWLFVBQVU7Z0JBQ1ZyQixPQUFPO2dCQUNQVyxRQUFRO1lBQ1Y7WUFFQTdELGlCQUFpQkMsR0FBRyxDQUFDNEMsaUJBQWlCLENBQUM7WUFDdkNaLGtCQUFrQlksaUJBQWlCLENBQUM7WUFFcEMsTUFBTXFCLFNBQVMsTUFBTWtDLElBQUFBLHNDQUF5QixFQUFDRjtZQUMvQzdDLE9BQU9hLFFBQVFtQyxRQUFRO1FBQ3pCO0lBQ0Y7SUFFQWhFLFNBQVMsb0JBQW9CO1FBQzNCZSxLQUFLLHVDQUF1QztZQUMxQyxNQUFNNEIsY0FBYztnQkFDbEJDLEtBQUs7Z0JBQ0xWLFVBQVU7Z0JBQ1ZyQixPQUFPO2dCQUNQVyxRQUFRO1lBQ1Y7WUFFQSxNQUFNTCxXQUFXO2dCQUNmQyxJQUFJO2dCQUNKUCxPQUFPO2dCQUNQUSxNQUFNO2dCQUNORSxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSQyxRQUFRO2dCQUNSRyxNQUFNO29CQUNKUixJQUFJO29CQUNKQyxNQUFNO29CQUNOTSxhQUFhO3dCQUFDOzRCQUFFTixNQUFNO3dCQUFnQjtxQkFBRTtnQkFDMUM7WUFDRjtZQUVBLHFDQUFxQztZQUNyQzFELGlCQUFpQkMsR0FBRyxDQUFDNEMsaUJBQWlCLENBQUM7WUFDdkNWLFFBQVFhLE1BQU0sQ0FBQzZDLGtCQUFrQixDQUFDLElBQU1iO1lBRXhDLGlDQUFpQztZQUNqQy9DLGtCQUFrQlksaUJBQWlCLENBQUNXO1lBRXBDLE1BQU1VLFNBQVMsTUFBTW9DLElBQUFBLDZCQUFnQixFQUFDO1lBRXRDakQsT0FBT2EsUUFBUUksT0FBTyxDQUFDO2dCQUNyQixHQUFHZCxRQUFRO2dCQUNYTyxVQUFVO2dCQUNWQyxhQUFhO29CQUFDO2lCQUFnQjtZQUNoQztRQUNGO1FBRUFaLEtBQUssd0NBQXdDO1lBQzNDcEQsaUJBQWlCQyxHQUFHLENBQUM0QyxpQkFBaUIsQ0FBQztZQUN2Q1YsUUFBUWEsTUFBTSxDQUFDNkMsa0JBQWtCLENBQUM7Z0JBQ2hDLE1BQU0sSUFBSWQsTUFBTTtZQUNsQjtZQUVBLE1BQU0xQixPQUFPaUQsSUFBQUEsNkJBQWdCLEVBQUMsa0JBQWtCUixPQUFPLENBQUNDLE9BQU8sQ0FBQztRQUNsRTtJQUNGO0lBRUExRCxTQUFTLGtCQUFrQjtRQUN6QmUsS0FBSyxvQ0FBb0M7WUFDdkMsTUFBTW1ELGlCQUFpQi9ELFFBQVFDLEdBQUcsQ0FBQ0MsVUFBVTtZQUM3QyxPQUFPRixRQUFRQyxHQUFHLENBQUNDLFVBQVU7WUFFN0IxQyxpQkFBaUJDLEdBQUcsQ0FBQzRDLGlCQUFpQixDQUFDO1lBQ3ZDVixRQUFRYSxNQUFNLENBQUM2QyxrQkFBa0IsQ0FBQztnQkFDaEMsTUFBTSxJQUFJZCxNQUFNO1lBQ2xCO1lBRUEsTUFBTTFCLE9BQU9zQyxJQUFBQSx3QkFBVyxFQUFDLGNBQWNHLE9BQU8sQ0FBQ0MsT0FBTztZQUV0RCxxQkFBcUI7WUFDckJ2RCxRQUFRQyxHQUFHLENBQUNDLFVBQVUsR0FBRzZEO1FBQzNCO1FBRUFuRCxLQUFLLDZDQUE2QztZQUNoRHBELGlCQUFpQkMsR0FBRyxDQUFDNEMsaUJBQWlCLENBQUM7WUFDdkNWLFFBQVFhLE1BQU0sQ0FBQzZDLGtCQUFrQixDQUFDO2dCQUNoQyxNQUFNLElBQUlkLE1BQU07WUFDbEI7WUFFQSxNQUFNMUIsT0FBT3NDLElBQUFBLHdCQUFXLEVBQUMsMEJBQTBCRyxPQUFPLENBQUNDLE9BQU8sQ0FBQztRQUNyRTtRQUVBM0MsS0FBSyw2QkFBNkI7WUFDaENwRCxpQkFBaUJDLEdBQUcsQ0FBQzRDLGlCQUFpQixDQUFDO1lBQ3ZDVixRQUFRYSxNQUFNLENBQUM2QyxrQkFBa0IsQ0FBQztnQkFDaEMsTUFBTSxJQUFJZCxNQUFNO1lBQ2xCO1lBRUEsTUFBTTFCLE9BQU9zQyxJQUFBQSx3QkFBVyxFQUFDLEtBQUtHLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO1FBQ2hEO0lBQ0Y7QUFDRiJ9