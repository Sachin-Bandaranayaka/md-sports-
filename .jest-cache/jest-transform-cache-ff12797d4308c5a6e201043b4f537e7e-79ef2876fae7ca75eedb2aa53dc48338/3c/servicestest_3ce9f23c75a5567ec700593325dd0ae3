0a86a316f592e7de3ce1c22c5250e8bc
// Mock the Product model
"use strict";
// Mock the models
jest.mock("@/lib/models/Product", ()=>mockProduct);
jest.mock("@/lib/prisma", ()=>({
        __esModule: true,
        default: mockPrisma
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _productService = require("../../src/services/productService");
const _auditService = require("../../src/services/auditService");
const _refreshTokenService = require("../../src/services/refreshTokenService");
const mockProduct = {
    findAll: jest.fn(),
    findOne: jest.fn(),
    findByPk: jest.fn(),
    create: jest.fn(),
    update: jest.fn(),
    destroy: jest.fn(),
    count: jest.fn()
};
// Mock Prisma client
const mockPrisma = {
    refreshToken: {
        create: jest.fn(),
        findUnique: jest.fn(),
        delete: jest.fn(),
        deleteMany: jest.fn()
    },
    auditLog: {
        create: jest.fn(),
        findMany: jest.fn()
    },
    user: {
        findUnique: jest.fn()
    }
};
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Service Layer Tests", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("ProductService", ()=>{
        const mockProductData1 = {
            id: 1,
            name: "Test Product",
            description: "Test Description",
            price: 99.99,
            costPrice: 50.00,
            sku: "TEST-001",
            isActive: true,
            createdAt: new Date(),
            updatedAt: new Date()
        };
        describe("getAllProducts", ()=>{
            it("should fetch all active products successfully", async ()=>{
                const mockProducts = [
                    mockProductData1,
                    {
                        ...mockProductData1,
                        id: 2,
                        name: "Product 2"
                    }
                ];
                mockProduct.findAll.mockResolvedValue(mockProducts);
                const result = await _productService.productService.getAllProducts();
                expect(mockProduct.findAll).toHaveBeenCalledWith({
                    where: {
                        isActive: true
                    }
                });
                expect(result).toEqual(mockProducts);
                expect(result).toHaveLength(2);
            });
            it("should handle database errors gracefully", async ()=>{
                const dbError = new Error("Database connection failed");
                mockProduct.findAll.mockRejectedValue(dbError);
                await expect(_productService.productService.getAllProducts()).rejects.toThrow("Database connection failed");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error fetching products:", dbError);
            });
            it("should return empty array when no products found", async ()=>{
                mockProduct.findAll.mockResolvedValue([]);
                const result = await _productService.productService.getAllProducts();
                expect(result).toEqual([]);
                expect(result).toHaveLength(0);
            });
        });
        describe("getProductById", ()=>{
            it("should fetch product by id successfully", async ()=>{
                mockProduct.findOne.mockResolvedValue(mockProductData1);
                const result = await _productService.productService.getProductById(1);
                expect(mockProduct.findOne).toHaveBeenCalledWith({
                    where: {
                        id: 1,
                        isActive: true
                    }
                });
                expect(result).toEqual(mockProductData1);
            });
            it("should return null for non-existent product", async ()=>{
                mockProduct.findOne.mockResolvedValue(null);
                const result = await _productService.productService.getProductById(999);
                expect(result).toBeNull();
            });
            it("should handle database errors", async ()=>{
                const dbError = new Error("Product not found");
                mockProduct.findOne.mockRejectedValue(dbError);
                await expect(_productService.productService.getProductById(1)).rejects.toThrow("Product not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error fetching product with ID 1:", dbError);
            });
        });
        describe("createProduct", ()=>{
            it("should create a new product successfully", async ()=>{
                const newProductData = {
                    name: "New Product",
                    description: "New Description",
                    price: 149.99,
                    costPrice: 75.00,
                    sku: "NEW-001"
                };
                const createdProduct = {
                    ...mockProductData1,
                    ...newProductData,
                    id: 3
                };
                mockProduct.create.mockResolvedValue(createdProduct);
                const result = await _productService.productService.createProduct(newProductData);
                expect(mockProduct.create).toHaveBeenCalledWith(newProductData);
                expect(result).toEqual(createdProduct);
            });
            it("should handle validation errors", async ()=>{
                const validationError = new Error("Validation failed: name is required");
                mockProduct.create.mockRejectedValue(validationError);
                await expect(_productService.productService.createProduct({})).rejects.toThrow("Validation failed: name is required");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error creating product:", validationError);
            });
            it("should handle duplicate SKU errors", async ()=>{
                const duplicateError = new Error("SKU already exists");
                mockProduct.create.mockRejectedValue(duplicateError);
                const duplicateData = {
                    name: "Test",
                    sku: "EXISTING-SKU"
                };
                await expect(_productService.productService.createProduct(duplicateData)).rejects.toThrow("SKU already exists");
            });
        });
        describe("updateProduct", ()=>{
            it("should update product successfully", async ()=>{
                const updateData = {
                    name: "Updated Product",
                    price: 199.99
                };
                const mockProductInstance = {
                    ...mockProductData1,
                    update: jest.fn().mockResolvedValue({
                        ...mockProductData1,
                        ...updateData
                    })
                };
                mockProduct.findByPk.mockResolvedValue(mockProductInstance);
                const result = await _productService.productService.updateProduct(1, updateData);
                expect(mockProduct.findByPk).toHaveBeenCalledWith(1);
                expect(mockProductInstance.update).toHaveBeenCalledWith(updateData);
                expect(result).toEqual({
                    ...mockProductData1,
                    ...updateData
                });
            });
            it("should throw error for non-existent product", async ()=>{
                mockProduct.findByPk.mockResolvedValue(null);
                await expect(_productService.productService.updateProduct(999, {
                    name: "Updated"
                })).rejects.toThrow("Product with ID 999 not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error updating product with ID 999:", expect.any(Error));
            });
            it("should handle database update errors", async ()=>{
                const mockProductInstance = {
                    update: jest.fn().mockRejectedValue(new Error("Update failed"))
                };
                mockProduct.findByPk.mockResolvedValue(mockProductInstance);
                await expect(_productService.productService.updateProduct(1, {
                    name: "Updated"
                })).rejects.toThrow("Update failed");
            });
        });
        describe("deleteProduct", ()=>{
            it("should soft delete product successfully", async ()=>{
                const mockProductInstance = {
                    ...mockProductData1,
                    update: jest.fn().mockResolvedValue({
                        ...mockProductData1,
                        isActive: false
                    })
                };
                mockProduct.findByPk.mockResolvedValue(mockProductInstance);
                const result = await _productService.productService.deleteProduct(1);
                expect(mockProduct.findByPk).toHaveBeenCalledWith(1);
                expect(mockProductInstance.update).toHaveBeenCalledWith({
                    isActive: false
                });
                expect(result).toEqual({
                    ...mockProductData1,
                    isActive: false
                });
            });
            it("should throw error for non-existent product", async ()=>{
                mockProduct.findByPk.mockResolvedValue(null);
                await expect(_productService.productService.deleteProduct(999)).rejects.toThrow("Product with ID 999 not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error deleting product with ID 999:", expect.any(Error));
            });
        });
    });
    describe("AuditService", ()=>{
        const mockAuditData = {
            id: 1,
            userId: 1,
            action: "CREATE",
            entity: "Product",
            entityId: 1,
            details: {
                name: "Test Product"
            },
            createdAt: new Date()
        };
        describe("logAction", ()=>{
            it("should log audit action successfully", async ()=>{
                mockPrisma.auditLog.create.mockResolvedValue(mockAuditData);
                const result = await _auditService.auditService.logAction({
                    userId: 1,
                    action: "CREATE",
                    entity: "Product",
                    entityId: 1,
                    details: {
                        name: "Test Product"
                    }
                });
                expect(mockPrisma.auditLog.create).toHaveBeenCalledWith({
                    data: {
                        userId: 1,
                        action: "CREATE",
                        entity: "Product",
                        entityId: 1,
                        details: {
                            name: "Test Product"
                        }
                    }
                });
                expect(result).toEqual(mockAuditData);
            });
            it("should handle audit logging errors gracefully", async ()=>{
                const auditError = new Error("Audit log failed");
                mockPrisma.auditLog.create.mockRejectedValue(auditError);
                // Should not throw error, just log it
                const result = await _auditService.auditService.logAction({
                    userId: 1,
                    action: "CREATE",
                    entity: "Product"
                });
                expect(result).toBeUndefined();
                expect(consoleSpy.error).toHaveBeenCalledWith("Failed to log audit action:", auditError);
            });
        });
        describe("getAuditLogs", ()=>{
            it("should fetch audit logs with filters", async ()=>{
                const mockLogs = [
                    mockAuditData,
                    {
                        ...mockAuditData,
                        id: 2,
                        action: "UPDATE"
                    }
                ];
                mockPrisma.auditLog.findMany.mockResolvedValue(mockLogs);
                const result = await _auditService.auditService.getAuditLogs({
                    userId: 1,
                    entity: "Product",
                    startDate: new Date("2024-01-01"),
                    endDate: new Date("2024-12-31")
                });
                expect(mockPrisma.auditLog.findMany).toHaveBeenCalledWith({
                    where: {
                        userId: 1,
                        entity: "Product",
                        createdAt: {
                            gte: new Date("2024-01-01"),
                            lte: new Date("2024-12-31")
                        }
                    },
                    orderBy: {
                        createdAt: "desc"
                    },
                    include: {
                        user: {
                            select: {
                                username: true,
                                email: true
                            }
                        }
                    }
                });
                expect(result).toEqual(mockLogs);
            });
            it("should handle empty results", async ()=>{
                mockPrisma.auditLog.findMany.mockResolvedValue([]);
                const result = await _auditService.auditService.getAuditLogs({});
                expect(result).toEqual([]);
            });
        });
        describe("cleanupOldLogs", ()=>{
            it("should cleanup old audit logs", async ()=>{
                const deleteResult = {
                    count: 50
                };
                mockPrisma.auditLog.deleteMany.mockResolvedValue(deleteResult);
                const result = await _auditService.auditService.cleanupOldLogs(90); // 90 days old
                const expectedCutoffDate = new Date();
                expectedCutoffDate.setDate(expectedCutoffDate.getDate() - 90);
                expect(mockPrisma.auditLog.deleteMany).toHaveBeenCalledWith({
                    where: {
                        createdAt: {
                            lt: expect.any(Date)
                        }
                    }
                });
                expect(result).toEqual(50);
            });
        });
    });
    describe("RefreshTokenService", ()=>{
        const mockRefreshToken = {
            id: 1,
            token: "refresh-token-123",
            userId: 1,
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
            createdAt: new Date()
        };
        describe("createRefreshToken", ()=>{
            it("should create refresh token successfully", async ()=>{
                mockPrisma.refreshToken.create.mockResolvedValue(mockRefreshToken);
                const result = await _refreshTokenService.refreshTokenService.createRefreshToken(1);
                expect(mockPrisma.refreshToken.create).toHaveBeenCalledWith({
                    data: {
                        userId: 1,
                        token: expect.any(String),
                        expiresAt: expect.any(Date)
                    }
                });
                expect(result).toEqual(mockRefreshToken);
            });
            it("should handle creation errors", async ()=>{
                const createError = new Error("Token creation failed");
                mockPrisma.refreshToken.create.mockRejectedValue(createError);
                await expect(_refreshTokenService.refreshTokenService.createRefreshToken(1)).rejects.toThrow("Token creation failed");
            });
        });
        describe("validateRefreshToken", ()=>{
            it("should validate valid refresh token", async ()=>{
                const mockUser = {
                    id: 1,
                    username: "testuser",
                    email: "test@example.com"
                };
                mockPrisma.refreshToken.findUnique.mockResolvedValue({
                    ...mockRefreshToken,
                    user: mockUser
                });
                const result = await _refreshTokenService.refreshTokenService.validateRefreshToken("refresh-token-123");
                expect(mockPrisma.refreshToken.findUnique).toHaveBeenCalledWith({
                    where: {
                        token: "refresh-token-123"
                    },
                    include: {
                        user: true
                    }
                });
                expect(result).toEqual({
                    ...mockRefreshToken,
                    user: mockUser
                });
            });
            it("should return null for invalid token", async ()=>{
                mockPrisma.refreshToken.findUnique.mockResolvedValue(null);
                const result = await _refreshTokenService.refreshTokenService.validateRefreshToken("invalid-token");
                expect(result).toBeNull();
            });
            it("should return null for expired token", async ()=>{
                const expiredToken = {
                    ...mockRefreshToken,
                    expiresAt: new Date(Date.now() - 1000)
                };
                mockPrisma.refreshToken.findUnique.mockResolvedValue(expiredToken);
                const result = await _refreshTokenService.refreshTokenService.validateRefreshToken("expired-token");
                expect(result).toBeNull();
            });
        });
        describe("revokeRefreshToken", ()=>{
            it("should revoke refresh token successfully", async ()=>{
                mockPrisma.refreshToken.delete.mockResolvedValue(mockRefreshToken);
                const result = await _refreshTokenService.refreshTokenService.revokeRefreshToken("refresh-token-123");
                expect(mockPrisma.refreshToken.delete).toHaveBeenCalledWith({
                    where: {
                        token: "refresh-token-123"
                    }
                });
                expect(result).toEqual(mockRefreshToken);
            });
            it("should handle non-existent token gracefully", async ()=>{
                const notFoundError = new Error("Token not found");
                mockPrisma.refreshToken.delete.mockRejectedValue(notFoundError);
                await expect(_refreshTokenService.refreshTokenService.revokeRefreshToken("non-existent")).rejects.toThrow("Token not found");
            });
        });
        describe("revokeAllUserTokens", ()=>{
            it("should revoke all tokens for user", async ()=>{
                const deleteResult = {
                    count: 3
                };
                mockPrisma.refreshToken.deleteMany.mockResolvedValue(deleteResult);
                const result = await _refreshTokenService.refreshTokenService.revokeAllUserTokens(1);
                expect(mockPrisma.refreshToken.deleteMany).toHaveBeenCalledWith({
                    where: {
                        userId: 1
                    }
                });
                expect(result).toEqual(3);
            });
        });
        describe("cleanupExpiredTokens", ()=>{
            it("should cleanup expired tokens", async ()=>{
                const deleteResult = {
                    count: 10
                };
                mockPrisma.refreshToken.deleteMany.mockResolvedValue(deleteResult);
                const result = await _refreshTokenService.refreshTokenService.cleanupExpiredTokens();
                expect(mockPrisma.refreshToken.deleteMany).toHaveBeenCalledWith({
                    where: {
                        expiresAt: {
                            lt: expect.any(Date)
                        }
                    }
                });
                expect(result).toEqual(10);
            });
        });
    });
    describe("Service Integration Tests", ()=>{
        it("should handle service dependencies correctly", async ()=>{
            // Test interaction between services
            const productData = {
                name: "Test Product",
                price: 99.99
            };
            const createdProduct = {
                ...mockProductData,
                ...productData,
                id: 5
            };
            mockProduct.create.mockResolvedValue(createdProduct);
            mockPrisma.auditLog.create.mockResolvedValue({
                id: 1,
                userId: 1,
                action: "CREATE",
                entity: "Product",
                entityId: 5,
                details: productData,
                createdAt: new Date()
            });
            // Create product
            const product = await _productService.productService.createProduct(productData);
            // Log audit action
            const auditLog = await _auditService.auditService.logAction({
                userId: 1,
                action: "CREATE",
                entity: "Product",
                entityId: product.id,
                details: productData
            });
            expect(product).toEqual(createdProduct);
            expect(auditLog).toBeDefined();
            expect(auditLog.entityId).toBe(product.id);
        });
        it("should handle service error propagation", async ()=>{
            const dbError = new Error("Database connection lost");
            mockProduct.findAll.mockRejectedValue(dbError);
            mockPrisma.auditLog.create.mockRejectedValue(dbError);
            // Both services should handle errors independently
            await expect(_productService.productService.getAllProducts()).rejects.toThrow("Database connection lost");
            const auditResult = await _auditService.auditService.logAction({
                userId: 1,
                action: "READ",
                entity: "Product"
            });
            expect(auditResult).toBeUndefined(); // Audit service handles errors gracefully
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9zZXJ2aWNlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1vY2sgdGhlIFByb2R1Y3QgbW9kZWxcbmNvbnN0IG1vY2tQcm9kdWN0ID0ge1xuICBmaW5kQWxsOiBqZXN0LmZuKCksXG4gIGZpbmRPbmU6IGplc3QuZm4oKSxcbiAgZmluZEJ5UGs6IGplc3QuZm4oKSxcbiAgY3JlYXRlOiBqZXN0LmZuKCksXG4gIHVwZGF0ZTogamVzdC5mbigpLFxuICBkZXN0cm95OiBqZXN0LmZuKCksXG4gIGNvdW50OiBqZXN0LmZuKCksXG59O1xuXG4vLyBNb2NrIFByaXNtYSBjbGllbnRcbmNvbnN0IG1vY2tQcmlzbWEgPSB7XG4gIHJlZnJlc2hUb2tlbjoge1xuICAgIGNyZWF0ZTogamVzdC5mbigpLFxuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSxcbiAgICBkZWxldGU6IGplc3QuZm4oKSxcbiAgICBkZWxldGVNYW55OiBqZXN0LmZuKCksXG4gIH0sXG4gIGF1ZGl0TG9nOiB7XG4gICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgfSxcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSxcbiAgfSxcbn0gYXMgYW55O1xuXG4vLyBNb2NrIHRoZSBtb2RlbHNcbmplc3QubW9jaygnQC9saWIvbW9kZWxzL1Byb2R1Y3QnLCAoKSA9PiBtb2NrUHJvZHVjdCk7XG5qZXN0Lm1vY2soJ0AvbGliL3ByaXNtYScsICgpID0+ICh7XG4gIF9fZXNNb2R1bGU6IHRydWUsXG4gIGRlZmF1bHQ6IG1vY2tQcmlzbWEsXG59KSk7XG5cbmltcG9ydCB7IHByb2R1Y3RTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9wcm9kdWN0U2VydmljZSc7XG5pbXBvcnQgeyBhdWRpdFNlcnZpY2UgfSBmcm9tICdAL3NlcnZpY2VzL2F1ZGl0U2VydmljZSc7XG5pbXBvcnQgeyByZWZyZXNoVG9rZW5TZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9yZWZyZXNoVG9rZW5TZXJ2aWNlJztcblxuXG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBjb25zb2xlU3B5ID0ge1xuICBsb2c6IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIGVycm9yOiBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIHdhcm46IGplc3Quc3B5T24oY29uc29sZSwgJ3dhcm4nKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pLFxufTtcblxuZGVzY3JpYmUoJ1NlcnZpY2UgTGF5ZXIgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkuZXJyb3IubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgY29uc29sZVNweS5sb2cubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9kdWN0U2VydmljZScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUHJvZHVjdERhdGEgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6ICdUZXN0IFByb2R1Y3QnLFxuICAgICAgZGVzY3JpcHRpb246ICdUZXN0IERlc2NyaXB0aW9uJyxcbiAgICAgIHByaWNlOiA5OS45OSxcbiAgICAgIGNvc3RQcmljZTogNTAuMDAsXG4gICAgICBza3U6ICdURVNULTAwMScsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9O1xuXG4gICAgZGVzY3JpYmUoJ2dldEFsbFByb2R1Y3RzJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBmZXRjaCBhbGwgYWN0aXZlIHByb2R1Y3RzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1Byb2R1Y3RzID0gW21vY2tQcm9kdWN0RGF0YSwgeyAuLi5tb2NrUHJvZHVjdERhdGEsIGlkOiAyLCBuYW1lOiAnUHJvZHVjdCAyJyB9XTtcbiAgICAgICAgbW9ja1Byb2R1Y3QuZmluZEFsbC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvZHVjdHMpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRBbGwpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB3aGVyZTogeyBpc0FjdGl2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUHJvZHVjdHMpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVMZW5ndGgoMik7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRiRXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRBbGwubW9ja1JlamVjdGVkVmFsdWUoZGJFcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCkpLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBmZXRjaGluZyBwcm9kdWN0czonLCBkYkVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIG5vIHByb2R1Y3RzIGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kQWxsLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5nZXRBbGxQcm9kdWN0cygpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdnZXRQcm9kdWN0QnlJZCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZmV0Y2ggcHJvZHVjdCBieSBpZCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2R1Y3REYXRhKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5nZXRQcm9kdWN0QnlJZCgxKTtcblxuICAgICAgICBleHBlY3QobW9ja1Byb2R1Y3QuZmluZE9uZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHdoZXJlOiB7IGlkOiAxLCBpc0FjdGl2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUHJvZHVjdERhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG5vbi1leGlzdGVudCBwcm9kdWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmdldFByb2R1Y3RCeUlkKDk5OSk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRiRXJyb3IgPSBuZXcgRXJyb3IoJ1Byb2R1Y3Qgbm90IGZvdW5kJyk7XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRPbmUubW9ja1JlamVjdGVkVmFsdWUoZGJFcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmdldFByb2R1Y3RCeUlkKDEpKS5yZWplY3RzLnRvVGhyb3coJ1Byb2R1Y3Qgbm90IGZvdW5kJyk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdCB3aXRoIElEIDE6JywgZGJFcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdjcmVhdGVQcm9kdWN0JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBuZXcgcHJvZHVjdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1Byb2R1Y3REYXRhID0ge1xuICAgICAgICAgIG5hbWU6ICdOZXcgUHJvZHVjdCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdOZXcgRGVzY3JpcHRpb24nLFxuICAgICAgICAgIHByaWNlOiAxNDkuOTksXG4gICAgICAgICAgY29zdFByaWNlOiA3NS4wMCxcbiAgICAgICAgICBza3U6ICdORVctMDAxJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3JlYXRlZFByb2R1Y3QgPSB7IC4uLm1vY2tQcm9kdWN0RGF0YSwgLi4ubmV3UHJvZHVjdERhdGEsIGlkOiAzIH07XG4gICAgICAgIG1vY2tQcm9kdWN0LmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShjcmVhdGVkUHJvZHVjdCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuY3JlYXRlUHJvZHVjdChuZXdQcm9kdWN0RGF0YSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgobmV3UHJvZHVjdERhdGEpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGNyZWF0ZWRQcm9kdWN0KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSB2YWxpZGF0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gbmV3IEVycm9yKCdWYWxpZGF0aW9uIGZhaWxlZDogbmFtZSBpcyByZXF1aXJlZCcpO1xuICAgICAgICBtb2NrUHJvZHVjdC5jcmVhdGUubW9ja1JlamVjdGVkVmFsdWUodmFsaWRhdGlvbkVycm9yKTtcblxuICAgICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuY3JlYXRlUHJvZHVjdCh7fSkpLnJlamVjdHMudG9UaHJvdygnVmFsaWRhdGlvbiBmYWlsZWQ6IG5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBjcmVhdGluZyBwcm9kdWN0OicsIHZhbGlkYXRpb25FcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZHVwbGljYXRlIFNLVSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZUVycm9yID0gbmV3IEVycm9yKCdTS1UgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgICAgbW9ja1Byb2R1Y3QuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKGR1cGxpY2F0ZUVycm9yKTtcblxuICAgICAgICBjb25zdCBkdXBsaWNhdGVEYXRhID0geyBuYW1lOiAnVGVzdCcsIHNrdTogJ0VYSVNUSU5HLVNLVScgfTtcbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3QoZHVwbGljYXRlRGF0YSkpLnJlamVjdHMudG9UaHJvdygnU0tVIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd1cGRhdGVQcm9kdWN0JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgcHJvZHVjdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7IG5hbWU6ICdVcGRhdGVkIFByb2R1Y3QnLCBwcmljZTogMTk5Ljk5IH07XG4gICAgICAgIGNvbnN0IG1vY2tQcm9kdWN0SW5zdGFuY2UgPSB7XG4gICAgICAgICAgLi4ubW9ja1Byb2R1Y3REYXRhLFxuICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgLi4ubW9ja1Byb2R1Y3REYXRhLCAuLi51cGRhdGVEYXRhIH0pLFxuICAgICAgICB9O1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvZHVjdEluc3RhbmNlKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDEsIHVwZGF0ZURhdGEpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kQnlQaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMSk7XG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdEluc3RhbmNlLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodXBkYXRlRGF0YSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyAuLi5tb2NrUHJvZHVjdERhdGEsIC4uLnVwZGF0ZURhdGEgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3Igbm9uLWV4aXN0ZW50IHByb2R1Y3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDk5OSwgeyBuYW1lOiAnVXBkYXRlZCcgfSkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgICAnUHJvZHVjdCB3aXRoIElEIDk5OSBub3QgZm91bmQnXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnRXJyb3IgdXBkYXRpbmcgcHJvZHVjdCB3aXRoIElEIDk5OTonLFxuICAgICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgdXBkYXRlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1Byb2R1Y3RJbnN0YW5jZSA9IHtcbiAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1VwZGF0ZSBmYWlsZWQnKSksXG4gICAgICAgIH07XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9kdWN0SW5zdGFuY2UpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDEsIHsgbmFtZTogJ1VwZGF0ZWQnIH0pKS5yZWplY3RzLnRvVGhyb3coJ1VwZGF0ZSBmYWlsZWQnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2RlbGV0ZVByb2R1Y3QnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHNvZnQgZGVsZXRlIHByb2R1Y3Qgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrUHJvZHVjdEluc3RhbmNlID0ge1xuICAgICAgICAgIC4uLm1vY2tQcm9kdWN0RGF0YSxcbiAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IC4uLm1vY2tQcm9kdWN0RGF0YSwgaXNBY3RpdmU6IGZhbHNlIH0pLFxuICAgICAgICB9O1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvZHVjdEluc3RhbmNlKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5kZWxldGVQcm9kdWN0KDEpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kQnlQaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMSk7XG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdEluc3RhbmNlLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBpc0FjdGl2ZTogZmFsc2UgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyAuLi5tb2NrUHJvZHVjdERhdGEsIGlzQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBub24tZXhpc3RlbnQgcHJvZHVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja1Byb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmRlbGV0ZVByb2R1Y3QoOTk5KSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAgICdQcm9kdWN0IHdpdGggSUQgOTk5IG5vdCBmb3VuZCdcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICdFcnJvciBkZWxldGluZyBwcm9kdWN0IHdpdGggSUQgOTk5OicsXG4gICAgICAgICAgZXhwZWN0LmFueShFcnJvcilcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXVkaXRTZXJ2aWNlJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tBdWRpdERhdGEgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIHVzZXJJZDogMSxcbiAgICAgIGFjdGlvbjogJ0NSRUFURScsXG4gICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgIGVudGl0eUlkOiAxLFxuICAgICAgZGV0YWlsczogeyBuYW1lOiAnVGVzdCBQcm9kdWN0JyB9LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIH07XG5cbiAgICBkZXNjcmliZSgnbG9nQWN0aW9uJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBsb2cgYXVkaXQgYWN0aW9uIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUobW9ja0F1ZGl0RGF0YSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXVkaXRTZXJ2aWNlLmxvZ0FjdGlvbih7XG4gICAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICAgIGFjdGlvbjogJ0NSRUFURScsXG4gICAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICAgICAgZW50aXR5SWQ6IDEsXG4gICAgICAgICAgZGV0YWlsczogeyBuYW1lOiAnVGVzdCBQcm9kdWN0JyB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICAgICAgICBlbnRpdHlJZDogMSxcbiAgICAgICAgICAgIGRldGFpbHM6IHsgbmFtZTogJ1Rlc3QgUHJvZHVjdCcgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrQXVkaXREYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBhdWRpdCBsb2dnaW5nIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBhdWRpdEVycm9yID0gbmV3IEVycm9yKCdBdWRpdCBsb2cgZmFpbGVkJyk7XG4gICAgICAgIG1vY2tQcmlzbWEuYXVkaXRMb2cuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKGF1ZGl0RXJyb3IpO1xuXG4gICAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgZXJyb3IsIGp1c3QgbG9nIGl0XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1ZGl0U2VydmljZS5sb2dBY3Rpb24oe1xuICAgICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICAgIGVudGl0eTogJ1Byb2R1Y3QnLFxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRmFpbGVkIHRvIGxvZyBhdWRpdCBhY3Rpb246JywgYXVkaXRFcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdnZXRBdWRpdExvZ3MnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGZldGNoIGF1ZGl0IGxvZ3Mgd2l0aCBmaWx0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrTG9ncyA9IFttb2NrQXVkaXREYXRhLCB7IC4uLm1vY2tBdWRpdERhdGEsIGlkOiAyLCBhY3Rpb246ICdVUERBVEUnIH1dO1xuICAgICAgICBtb2NrUHJpc21hLmF1ZGl0TG9nLmZpbmRNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tMb2dzKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdWRpdFNlcnZpY2UuZ2V0QXVkaXRMb2dzKHtcbiAgICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZSgnMjAyNC0wMS0wMScpLFxuICAgICAgICAgIGVuZERhdGU6IG5ldyBEYXRlKCcyMDI0LTEyLTMxJyksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLmF1ZGl0TG9nLmZpbmRNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgICAgIGVudGl0eTogJ1Byb2R1Y3QnLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiB7XG4gICAgICAgICAgICAgIGd0ZTogbmV3IERhdGUoJzIwMjQtMDEtMDEnKSxcbiAgICAgICAgICAgICAgbHRlOiBuZXcgRGF0ZSgnMjAyNC0xMi0zMScpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiAnZGVzYycgfSxcbiAgICAgICAgICBpbmNsdWRlOiB7IHVzZXI6IHsgc2VsZWN0OiB7IHVzZXJuYW1lOiB0cnVlLCBlbWFpbDogdHJ1ZSB9IH0gfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0xvZ3MpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHJlc3VsdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tQcmlzbWEuYXVkaXRMb2cuZmluZE1hbnkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1ZGl0U2VydmljZS5nZXRBdWRpdExvZ3Moe30pO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY2xlYW51cE9sZExvZ3MnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGNsZWFudXAgb2xkIGF1ZGl0IGxvZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbGV0ZVJlc3VsdCA9IHsgY291bnQ6IDUwIH07XG4gICAgICAgIG1vY2tQcmlzbWEuYXVkaXRMb2cuZGVsZXRlTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZShkZWxldGVSZXN1bHQpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1ZGl0U2VydmljZS5jbGVhbnVwT2xkTG9ncyg5MCk7IC8vIDkwIGRheXMgb2xkXG5cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDdXRvZmZEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgZXhwZWN0ZWRDdXRvZmZEYXRlLnNldERhdGUoZXhwZWN0ZWRDdXRvZmZEYXRlLmdldERhdGUoKSAtIDkwKTtcblxuICAgICAgICBleHBlY3QobW9ja1ByaXNtYS5hdWRpdExvZy5kZWxldGVNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgIGNyZWF0ZWRBdDoge1xuICAgICAgICAgICAgICBsdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoNTApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZWZyZXNoVG9rZW5TZXJ2aWNlJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tSZWZyZXNoVG9rZW4gPSB7XG4gICAgICBpZDogMSxcbiAgICAgIHRva2VuOiAncmVmcmVzaC10b2tlbi0xMjMnLFxuICAgICAgdXNlcklkOiAxLFxuICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLCAvLyA3IGRheXNcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9O1xuXG4gICAgZGVzY3JpYmUoJ2NyZWF0ZVJlZnJlc2hUb2tlbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY3JlYXRlIHJlZnJlc2ggdG9rZW4gc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1JlZnJlc2hUb2tlbik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS5jcmVhdGVSZWZyZXNoVG9rZW4oMSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgICAgIHRva2VuOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICBleHBpcmVzQXQ6IGV4cGVjdC5hbnkoRGF0ZSksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1JlZnJlc2hUb2tlbik7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgY3JlYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjcmVhdGVFcnJvciA9IG5ldyBFcnJvcignVG9rZW4gY3JlYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmNyZWF0ZS5tb2NrUmVqZWN0ZWRWYWx1ZShjcmVhdGVFcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHJlZnJlc2hUb2tlblNlcnZpY2UuY3JlYXRlUmVmcmVzaFRva2VuKDEpKS5yZWplY3RzLnRvVGhyb3coJ1Rva2VuIGNyZWF0aW9uIGZhaWxlZCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndmFsaWRhdGVSZWZyZXNoVG9rZW4nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHZhbGlkIHJlZnJlc2ggdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tVc2VyID0geyBpZDogMSwgdXNlcm5hbWU6ICd0ZXN0dXNlcicsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfTtcbiAgICAgICAgbW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgLi4ubW9ja1JlZnJlc2hUb2tlbixcbiAgICAgICAgICB1c2VyOiBtb2NrVXNlcixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS52YWxpZGF0ZVJlZnJlc2hUb2tlbigncmVmcmVzaC10b2tlbi0xMjMnKTtcblxuICAgICAgICBleHBlY3QobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uZmluZFVuaXF1ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHdoZXJlOiB7IHRva2VuOiAncmVmcmVzaC10b2tlbi0xMjMnIH0sXG4gICAgICAgICAgaW5jbHVkZTogeyB1c2VyOiB0cnVlIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgLi4ubW9ja1JlZnJlc2hUb2tlbiwgdXNlcjogbW9ja1VzZXIgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgaW52YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLnZhbGlkYXRlUmVmcmVzaFRva2VuKCdpbnZhbGlkLXRva2VuJyk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBleHBpcmVkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBleHBpcmVkVG9rZW4gPSB7XG4gICAgICAgICAgLi4ubW9ja1JlZnJlc2hUb2tlbixcbiAgICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSAxMDAwKSwgLy8gRXhwaXJlZFxuICAgICAgICB9O1xuICAgICAgICBtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKGV4cGlyZWRUb2tlbik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS52YWxpZGF0ZVJlZnJlc2hUb2tlbignZXhwaXJlZC10b2tlbicpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdyZXZva2VSZWZyZXNoVG9rZW4nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHJldm9rZSByZWZyZXNoIHRva2VuIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uZGVsZXRlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tSZWZyZXNoVG9rZW4pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hUb2tlblNlcnZpY2UucmV2b2tlUmVmcmVzaFRva2VuKCdyZWZyZXNoLXRva2VuLTEyMycpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5kZWxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB3aGVyZTogeyB0b2tlbjogJ3JlZnJlc2gtdG9rZW4tMTIzJyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUmVmcmVzaFRva2VuKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBub24tZXhpc3RlbnQgdG9rZW4gZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgbm90Rm91bmRFcnJvciA9IG5ldyBFcnJvcignVG9rZW4gbm90IGZvdW5kJyk7XG4gICAgICAgIG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmRlbGV0ZS5tb2NrUmVqZWN0ZWRWYWx1ZShub3RGb3VuZEVycm9yKTtcblxuICAgICAgICBhd2FpdCBleHBlY3QocmVmcmVzaFRva2VuU2VydmljZS5yZXZva2VSZWZyZXNoVG9rZW4oJ25vbi1leGlzdGVudCcpKS5yZWplY3RzLnRvVGhyb3coJ1Rva2VuIG5vdCBmb3VuZCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgncmV2b2tlQWxsVXNlclRva2VucycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmV2b2tlIGFsbCB0b2tlbnMgZm9yIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbGV0ZVJlc3VsdCA9IHsgY291bnQ6IDMgfTtcbiAgICAgICAgbW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uZGVsZXRlTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZShkZWxldGVSZXN1bHQpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hUb2tlblNlcnZpY2UucmV2b2tlQWxsVXNlclRva2VucygxKTtcblxuICAgICAgICBleHBlY3QobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uZGVsZXRlTWFueSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHdoZXJlOiB7IHVzZXJJZDogMSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCgzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NsZWFudXBFeHBpcmVkVG9rZW5zJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjbGVhbnVwIGV4cGlyZWQgdG9rZW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBkZWxldGVSZXN1bHQgPSB7IGNvdW50OiAxMCB9O1xuICAgICAgICBtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5kZWxldGVNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKGRlbGV0ZVJlc3VsdCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS5jbGVhbnVwRXhwaXJlZFRva2VucygpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5kZWxldGVNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgIGV4cGlyZXNBdDoge1xuICAgICAgICAgICAgICBsdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoMTApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZXJ2aWNlIEludGVncmF0aW9uIFRlc3RzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcnZpY2UgZGVwZW5kZW5jaWVzIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRlc3QgaW50ZXJhY3Rpb24gYmV0d2VlbiBzZXJ2aWNlc1xuICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSB7IG5hbWU6ICdUZXN0IFByb2R1Y3QnLCBwcmljZTogOTkuOTkgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRQcm9kdWN0ID0geyAuLi5tb2NrUHJvZHVjdERhdGEsIC4uLnByb2R1Y3REYXRhLCBpZDogNSB9O1xuICAgICAgXG4gICAgICBtb2NrUHJvZHVjdC5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoY3JlYXRlZFByb2R1Y3QpO1xuICAgICAgbW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpZDogMSxcbiAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgICAgZW50aXR5SWQ6IDUsXG4gICAgICAgIGRldGFpbHM6IHByb2R1Y3REYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIHByb2R1Y3RcbiAgICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5jcmVhdGVQcm9kdWN0KHByb2R1Y3REYXRhKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIGF1ZGl0IGFjdGlvblxuICAgICAgY29uc3QgYXVkaXRMb2cgPSBhd2FpdCBhdWRpdFNlcnZpY2UubG9nQWN0aW9uKHtcbiAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgICAgZW50aXR5SWQ6IHByb2R1Y3QuaWQsXG4gICAgICAgIGRldGFpbHM6IHByb2R1Y3REYXRhLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChwcm9kdWN0KS50b0VxdWFsKGNyZWF0ZWRQcm9kdWN0KTtcbiAgICAgIGV4cGVjdChhdWRpdExvZykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChhdWRpdExvZy5lbnRpdHlJZCkudG9CZShwcm9kdWN0LmlkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcnZpY2UgZXJyb3IgcHJvcGFnYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYkVycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGxvc3QnKTtcbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRBbGwubW9ja1JlamVjdGVkVmFsdWUoZGJFcnJvcik7XG4gICAgICBtb2NrUHJpc21hLmF1ZGl0TG9nLmNyZWF0ZS5tb2NrUmVqZWN0ZWRWYWx1ZShkYkVycm9yKTtcblxuICAgICAgLy8gQm90aCBzZXJ2aWNlcyBzaG91bGQgaGFuZGxlIGVycm9ycyBpbmRlcGVuZGVudGx5XG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuZ2V0QWxsUHJvZHVjdHMoKSkucmVqZWN0cy50b1Rocm93KCdEYXRhYmFzZSBjb25uZWN0aW9uIGxvc3QnKTtcbiAgICAgIFxuICAgICAgY29uc3QgYXVkaXRSZXN1bHQgPSBhd2FpdCBhdWRpdFNlcnZpY2UubG9nQWN0aW9uKHtcbiAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICBhY3Rpb246ICdSRUFEJyxcbiAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGF1ZGl0UmVzdWx0KS50b0JlVW5kZWZpbmVkKCk7IC8vIEF1ZGl0IHNlcnZpY2UgaGFuZGxlcyBlcnJvcnMgZ3JhY2VmdWxseVxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tQcm9kdWN0IiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJtb2NrUHJpc21hIiwiZmluZEFsbCIsImZuIiwiZmluZE9uZSIsImZpbmRCeVBrIiwiY3JlYXRlIiwidXBkYXRlIiwiZGVzdHJveSIsImNvdW50IiwicmVmcmVzaFRva2VuIiwiZmluZFVuaXF1ZSIsImRlbGV0ZSIsImRlbGV0ZU1hbnkiLCJhdWRpdExvZyIsImZpbmRNYW55IiwidXNlciIsImNvbnNvbGVTcHkiLCJsb2ciLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJlcnJvciIsIndhcm4iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja0NsZWFyIiwiYWZ0ZXJBbGwiLCJtb2NrUmVzdG9yZSIsIm1vY2tQcm9kdWN0RGF0YSIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwicHJpY2UiLCJjb3N0UHJpY2UiLCJza3UiLCJpc0FjdGl2ZSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ1cGRhdGVkQXQiLCJpdCIsIm1vY2tQcm9kdWN0cyIsIm1vY2tSZXNvbHZlZFZhbHVlIiwicmVzdWx0IiwicHJvZHVjdFNlcnZpY2UiLCJnZXRBbGxQcm9kdWN0cyIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwid2hlcmUiLCJ0b0VxdWFsIiwidG9IYXZlTGVuZ3RoIiwiZGJFcnJvciIsIkVycm9yIiwibW9ja1JlamVjdGVkVmFsdWUiLCJyZWplY3RzIiwidG9UaHJvdyIsImdldFByb2R1Y3RCeUlkIiwidG9CZU51bGwiLCJuZXdQcm9kdWN0RGF0YSIsImNyZWF0ZWRQcm9kdWN0IiwiY3JlYXRlUHJvZHVjdCIsInZhbGlkYXRpb25FcnJvciIsImR1cGxpY2F0ZUVycm9yIiwiZHVwbGljYXRlRGF0YSIsInVwZGF0ZURhdGEiLCJtb2NrUHJvZHVjdEluc3RhbmNlIiwidXBkYXRlUHJvZHVjdCIsImFueSIsImRlbGV0ZVByb2R1Y3QiLCJtb2NrQXVkaXREYXRhIiwidXNlcklkIiwiYWN0aW9uIiwiZW50aXR5IiwiZW50aXR5SWQiLCJkZXRhaWxzIiwiYXVkaXRTZXJ2aWNlIiwibG9nQWN0aW9uIiwiZGF0YSIsImF1ZGl0RXJyb3IiLCJ0b0JlVW5kZWZpbmVkIiwibW9ja0xvZ3MiLCJnZXRBdWRpdExvZ3MiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiZ3RlIiwibHRlIiwib3JkZXJCeSIsImluY2x1ZGUiLCJzZWxlY3QiLCJ1c2VybmFtZSIsImVtYWlsIiwiZGVsZXRlUmVzdWx0IiwiY2xlYW51cE9sZExvZ3MiLCJleHBlY3RlZEN1dG9mZkRhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImx0IiwibW9ja1JlZnJlc2hUb2tlbiIsInRva2VuIiwiZXhwaXJlc0F0Iiwibm93IiwicmVmcmVzaFRva2VuU2VydmljZSIsImNyZWF0ZVJlZnJlc2hUb2tlbiIsIlN0cmluZyIsImNyZWF0ZUVycm9yIiwibW9ja1VzZXIiLCJ2YWxpZGF0ZVJlZnJlc2hUb2tlbiIsImV4cGlyZWRUb2tlbiIsInJldm9rZVJlZnJlc2hUb2tlbiIsIm5vdEZvdW5kRXJyb3IiLCJyZXZva2VBbGxVc2VyVG9rZW5zIiwiY2xlYW51cEV4cGlyZWRUb2tlbnMiLCJwcm9kdWN0RGF0YSIsInByb2R1Y3QiLCJ0b0JlRGVmaW5lZCIsInRvQmUiLCJhdWRpdFJlc3VsdCJdLCJtYXBwaW5ncyI6IkFBQUEseUJBQXlCOztBQTRCekIsa0JBQWtCO0FBQ2xCQSxLQUFLQyxJQUFJLENBQUMsd0JBQXdCLElBQU1DO0FBQ3hDRixLQUFLQyxJQUFJLENBQUMsZ0JBQWdCLElBQU8sQ0FBQTtRQUMvQkUsWUFBWTtRQUNaQyxTQUFTQztJQUNYLENBQUE7Ozs7Z0NBRStCOzhCQUNGO3FDQUNPO0FBcENwQyxNQUFNSCxjQUFjO0lBQ2xCSSxTQUFTTixLQUFLTyxFQUFFO0lBQ2hCQyxTQUFTUixLQUFLTyxFQUFFO0lBQ2hCRSxVQUFVVCxLQUFLTyxFQUFFO0lBQ2pCRyxRQUFRVixLQUFLTyxFQUFFO0lBQ2ZJLFFBQVFYLEtBQUtPLEVBQUU7SUFDZkssU0FBU1osS0FBS08sRUFBRTtJQUNoQk0sT0FBT2IsS0FBS08sRUFBRTtBQUNoQjtBQUVBLHFCQUFxQjtBQUNyQixNQUFNRixhQUFhO0lBQ2pCUyxjQUFjO1FBQ1pKLFFBQVFWLEtBQUtPLEVBQUU7UUFDZlEsWUFBWWYsS0FBS08sRUFBRTtRQUNuQlMsUUFBUWhCLEtBQUtPLEVBQUU7UUFDZlUsWUFBWWpCLEtBQUtPLEVBQUU7SUFDckI7SUFDQVcsVUFBVTtRQUNSUixRQUFRVixLQUFLTyxFQUFFO1FBQ2ZZLFVBQVVuQixLQUFLTyxFQUFFO0lBQ25CO0lBQ0FhLE1BQU07UUFDSkwsWUFBWWYsS0FBS08sRUFBRTtJQUNyQjtBQUNGO0FBZUEsdUJBQXVCO0FBQ3ZCLE1BQU1jLGFBQWE7SUFDakJDLEtBQUt0QixLQUFLdUIsS0FBSyxDQUFDQyxTQUFTLE9BQU9DLGtCQUFrQixDQUFDLEtBQU87SUFDMURDLE9BQU8xQixLQUFLdUIsS0FBSyxDQUFDQyxTQUFTLFNBQVNDLGtCQUFrQixDQUFDLEtBQU87SUFDOURFLE1BQU0zQixLQUFLdUIsS0FBSyxDQUFDQyxTQUFTLFFBQVFDLGtCQUFrQixDQUFDLEtBQU87QUFDOUQ7QUFFQUcsU0FBUyx1QkFBdUI7SUFDOUJDLFdBQVc7UUFDVDdCLEtBQUs4QixhQUFhO1FBQ2xCVCxXQUFXQyxHQUFHLENBQUNTLFNBQVM7UUFDeEJWLFdBQVdLLEtBQUssQ0FBQ0ssU0FBUztRQUMxQlYsV0FBV00sSUFBSSxDQUFDSSxTQUFTO0lBQzNCO0lBRUFDLFNBQVM7UUFDUFgsV0FBV0MsR0FBRyxDQUFDVyxXQUFXO1FBQzFCWixXQUFXSyxLQUFLLENBQUNPLFdBQVc7UUFDNUJaLFdBQVdNLElBQUksQ0FBQ00sV0FBVztJQUM3QjtJQUVBTCxTQUFTLGtCQUFrQjtRQUN6QixNQUFNTSxtQkFBa0I7WUFDdEJDLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxhQUFhO1lBQ2JDLE9BQU87WUFDUEMsV0FBVztZQUNYQyxLQUFLO1lBQ0xDLFVBQVU7WUFDVkMsV0FBVyxJQUFJQztZQUNmQyxXQUFXLElBQUlEO1FBQ2pCO1FBRUFmLFNBQVMsa0JBQWtCO1lBQ3pCaUIsR0FBRyxpREFBaUQ7Z0JBQ2xELE1BQU1DLGVBQWU7b0JBQUNaO29CQUFpQjt3QkFBRSxHQUFHQSxnQkFBZTt3QkFBRUMsSUFBSTt3QkFBR0MsTUFBTTtvQkFBWTtpQkFBRTtnQkFDeEZsQyxZQUFZSSxPQUFPLENBQUN5QyxpQkFBaUIsQ0FBQ0Q7Z0JBRXRDLE1BQU1FLFNBQVMsTUFBTUMsOEJBQWMsQ0FBQ0MsY0FBYztnQkFFbERDLE9BQU9qRCxZQUFZSSxPQUFPLEVBQUU4QyxvQkFBb0IsQ0FBQztvQkFDL0NDLE9BQU87d0JBQUVaLFVBQVU7b0JBQUs7Z0JBQzFCO2dCQUNBVSxPQUFPSCxRQUFRTSxPQUFPLENBQUNSO2dCQUN2QkssT0FBT0gsUUFBUU8sWUFBWSxDQUFDO1lBQzlCO1lBRUFWLEdBQUcsNENBQTRDO2dCQUM3QyxNQUFNVyxVQUFVLElBQUlDLE1BQU07Z0JBQzFCdkQsWUFBWUksT0FBTyxDQUFDb0QsaUJBQWlCLENBQUNGO2dCQUV0QyxNQUFNTCxPQUFPRiw4QkFBYyxDQUFDQyxjQUFjLElBQUlTLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO2dCQUM5RFQsT0FBTzlCLFdBQVdLLEtBQUssRUFBRTBCLG9CQUFvQixDQUFDLDRCQUE0Qkk7WUFDNUU7WUFFQVgsR0FBRyxvREFBb0Q7Z0JBQ3JEM0MsWUFBWUksT0FBTyxDQUFDeUMsaUJBQWlCLENBQUMsRUFBRTtnQkFFeEMsTUFBTUMsU0FBUyxNQUFNQyw4QkFBYyxDQUFDQyxjQUFjO2dCQUVsREMsT0FBT0gsUUFBUU0sT0FBTyxDQUFDLEVBQUU7Z0JBQ3pCSCxPQUFPSCxRQUFRTyxZQUFZLENBQUM7WUFDOUI7UUFDRjtRQUVBM0IsU0FBUyxrQkFBa0I7WUFDekJpQixHQUFHLDJDQUEyQztnQkFDNUMzQyxZQUFZTSxPQUFPLENBQUN1QyxpQkFBaUIsQ0FBQ2I7Z0JBRXRDLE1BQU1jLFNBQVMsTUFBTUMsOEJBQWMsQ0FBQ1ksY0FBYyxDQUFDO2dCQUVuRFYsT0FBT2pELFlBQVlNLE9BQU8sRUFBRTRDLG9CQUFvQixDQUFDO29CQUMvQ0MsT0FBTzt3QkFBRWxCLElBQUk7d0JBQUdNLFVBQVU7b0JBQUs7Z0JBQ2pDO2dCQUNBVSxPQUFPSCxRQUFRTSxPQUFPLENBQUNwQjtZQUN6QjtZQUVBVyxHQUFHLCtDQUErQztnQkFDaEQzQyxZQUFZTSxPQUFPLENBQUN1QyxpQkFBaUIsQ0FBQztnQkFFdEMsTUFBTUMsU0FBUyxNQUFNQyw4QkFBYyxDQUFDWSxjQUFjLENBQUM7Z0JBRW5EVixPQUFPSCxRQUFRYyxRQUFRO1lBQ3pCO1lBRUFqQixHQUFHLGlDQUFpQztnQkFDbEMsTUFBTVcsVUFBVSxJQUFJQyxNQUFNO2dCQUMxQnZELFlBQVlNLE9BQU8sQ0FBQ2tELGlCQUFpQixDQUFDRjtnQkFFdEMsTUFBTUwsT0FBT0YsOEJBQWMsQ0FBQ1ksY0FBYyxDQUFDLElBQUlGLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO2dCQUMvRFQsT0FBTzlCLFdBQVdLLEtBQUssRUFBRTBCLG9CQUFvQixDQUFDLHFDQUFxQ0k7WUFDckY7UUFDRjtRQUVBNUIsU0FBUyxpQkFBaUI7WUFDeEJpQixHQUFHLDRDQUE0QztnQkFDN0MsTUFBTWtCLGlCQUFpQjtvQkFDckIzQixNQUFNO29CQUNOQyxhQUFhO29CQUNiQyxPQUFPO29CQUNQQyxXQUFXO29CQUNYQyxLQUFLO2dCQUNQO2dCQUNBLE1BQU13QixpQkFBaUI7b0JBQUUsR0FBRzlCLGdCQUFlO29CQUFFLEdBQUc2QixjQUFjO29CQUFFNUIsSUFBSTtnQkFBRTtnQkFDdEVqQyxZQUFZUSxNQUFNLENBQUNxQyxpQkFBaUIsQ0FBQ2lCO2dCQUVyQyxNQUFNaEIsU0FBUyxNQUFNQyw4QkFBYyxDQUFDZ0IsYUFBYSxDQUFDRjtnQkFFbERaLE9BQU9qRCxZQUFZUSxNQUFNLEVBQUUwQyxvQkFBb0IsQ0FBQ1c7Z0JBQ2hEWixPQUFPSCxRQUFRTSxPQUFPLENBQUNVO1lBQ3pCO1lBRUFuQixHQUFHLG1DQUFtQztnQkFDcEMsTUFBTXFCLGtCQUFrQixJQUFJVCxNQUFNO2dCQUNsQ3ZELFlBQVlRLE1BQU0sQ0FBQ2dELGlCQUFpQixDQUFDUTtnQkFFckMsTUFBTWYsT0FBT0YsOEJBQWMsQ0FBQ2dCLGFBQWEsQ0FBQyxDQUFDLElBQUlOLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO2dCQUMvRFQsT0FBTzlCLFdBQVdLLEtBQUssRUFBRTBCLG9CQUFvQixDQUFDLDJCQUEyQmM7WUFDM0U7WUFFQXJCLEdBQUcsc0NBQXNDO2dCQUN2QyxNQUFNc0IsaUJBQWlCLElBQUlWLE1BQU07Z0JBQ2pDdkQsWUFBWVEsTUFBTSxDQUFDZ0QsaUJBQWlCLENBQUNTO2dCQUVyQyxNQUFNQyxnQkFBZ0I7b0JBQUVoQyxNQUFNO29CQUFRSSxLQUFLO2dCQUFlO2dCQUMxRCxNQUFNVyxPQUFPRiw4QkFBYyxDQUFDZ0IsYUFBYSxDQUFDRyxnQkFBZ0JULE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO1lBQzVFO1FBQ0Y7UUFFQWhDLFNBQVMsaUJBQWlCO1lBQ3hCaUIsR0FBRyxzQ0FBc0M7Z0JBQ3ZDLE1BQU13QixhQUFhO29CQUFFakMsTUFBTTtvQkFBbUJFLE9BQU87Z0JBQU87Z0JBQzVELE1BQU1nQyxzQkFBc0I7b0JBQzFCLEdBQUdwQyxnQkFBZTtvQkFDbEJ2QixRQUFRWCxLQUFLTyxFQUFFLEdBQUd3QyxpQkFBaUIsQ0FBQzt3QkFBRSxHQUFHYixnQkFBZTt3QkFBRSxHQUFHbUMsVUFBVTtvQkFBQztnQkFDMUU7Z0JBQ0FuRSxZQUFZTyxRQUFRLENBQUNzQyxpQkFBaUIsQ0FBQ3VCO2dCQUV2QyxNQUFNdEIsU0FBUyxNQUFNQyw4QkFBYyxDQUFDc0IsYUFBYSxDQUFDLEdBQUdGO2dCQUVyRGxCLE9BQU9qRCxZQUFZTyxRQUFRLEVBQUUyQyxvQkFBb0IsQ0FBQztnQkFDbERELE9BQU9tQixvQkFBb0IzRCxNQUFNLEVBQUV5QyxvQkFBb0IsQ0FBQ2lCO2dCQUN4RGxCLE9BQU9ILFFBQVFNLE9BQU8sQ0FBQztvQkFBRSxHQUFHcEIsZ0JBQWU7b0JBQUUsR0FBR21DLFVBQVU7Z0JBQUM7WUFDN0Q7WUFFQXhCLEdBQUcsK0NBQStDO2dCQUNoRDNDLFlBQVlPLFFBQVEsQ0FBQ3NDLGlCQUFpQixDQUFDO2dCQUV2QyxNQUFNSSxPQUFPRiw4QkFBYyxDQUFDc0IsYUFBYSxDQUFDLEtBQUs7b0JBQUVuQyxNQUFNO2dCQUFVLElBQUl1QixPQUFPLENBQUNDLE9BQU8sQ0FDbEY7Z0JBRUZULE9BQU85QixXQUFXSyxLQUFLLEVBQUUwQixvQkFBb0IsQ0FDM0MsdUNBQ0FELE9BQU9xQixHQUFHLENBQUNmO1lBRWY7WUFFQVosR0FBRyx3Q0FBd0M7Z0JBQ3pDLE1BQU15QixzQkFBc0I7b0JBQzFCM0QsUUFBUVgsS0FBS08sRUFBRSxHQUFHbUQsaUJBQWlCLENBQUMsSUFBSUQsTUFBTTtnQkFDaEQ7Z0JBQ0F2RCxZQUFZTyxRQUFRLENBQUNzQyxpQkFBaUIsQ0FBQ3VCO2dCQUV2QyxNQUFNbkIsT0FBT0YsOEJBQWMsQ0FBQ3NCLGFBQWEsQ0FBQyxHQUFHO29CQUFFbkMsTUFBTTtnQkFBVSxJQUFJdUIsT0FBTyxDQUFDQyxPQUFPLENBQUM7WUFDckY7UUFDRjtRQUVBaEMsU0FBUyxpQkFBaUI7WUFDeEJpQixHQUFHLDJDQUEyQztnQkFDNUMsTUFBTXlCLHNCQUFzQjtvQkFDMUIsR0FBR3BDLGdCQUFlO29CQUNsQnZCLFFBQVFYLEtBQUtPLEVBQUUsR0FBR3dDLGlCQUFpQixDQUFDO3dCQUFFLEdBQUdiLGdCQUFlO3dCQUFFTyxVQUFVO29CQUFNO2dCQUM1RTtnQkFDQXZDLFlBQVlPLFFBQVEsQ0FBQ3NDLGlCQUFpQixDQUFDdUI7Z0JBRXZDLE1BQU10QixTQUFTLE1BQU1DLDhCQUFjLENBQUN3QixhQUFhLENBQUM7Z0JBRWxEdEIsT0FBT2pELFlBQVlPLFFBQVEsRUFBRTJDLG9CQUFvQixDQUFDO2dCQUNsREQsT0FBT21CLG9CQUFvQjNELE1BQU0sRUFBRXlDLG9CQUFvQixDQUFDO29CQUFFWCxVQUFVO2dCQUFNO2dCQUMxRVUsT0FBT0gsUUFBUU0sT0FBTyxDQUFDO29CQUFFLEdBQUdwQixnQkFBZTtvQkFBRU8sVUFBVTtnQkFBTTtZQUMvRDtZQUVBSSxHQUFHLCtDQUErQztnQkFDaEQzQyxZQUFZTyxRQUFRLENBQUNzQyxpQkFBaUIsQ0FBQztnQkFFdkMsTUFBTUksT0FBT0YsOEJBQWMsQ0FBQ3dCLGFBQWEsQ0FBQyxNQUFNZCxPQUFPLENBQUNDLE9BQU8sQ0FDN0Q7Z0JBRUZULE9BQU85QixXQUFXSyxLQUFLLEVBQUUwQixvQkFBb0IsQ0FDM0MsdUNBQ0FELE9BQU9xQixHQUFHLENBQUNmO1lBRWY7UUFDRjtJQUNGO0lBRUE3QixTQUFTLGdCQUFnQjtRQUN2QixNQUFNOEMsZ0JBQWdCO1lBQ3BCdkMsSUFBSTtZQUNKd0MsUUFBUTtZQUNSQyxRQUFRO1lBQ1JDLFFBQVE7WUFDUkMsVUFBVTtZQUNWQyxTQUFTO2dCQUFFM0MsTUFBTTtZQUFlO1lBQ2hDTSxXQUFXLElBQUlDO1FBQ2pCO1FBRUFmLFNBQVMsYUFBYTtZQUNwQmlCLEdBQUcsd0NBQXdDO2dCQUN6Q3hDLFdBQVdhLFFBQVEsQ0FBQ1IsTUFBTSxDQUFDcUMsaUJBQWlCLENBQUMyQjtnQkFFN0MsTUFBTTFCLFNBQVMsTUFBTWdDLDBCQUFZLENBQUNDLFNBQVMsQ0FBQztvQkFDMUNOLFFBQVE7b0JBQ1JDLFFBQVE7b0JBQ1JDLFFBQVE7b0JBQ1JDLFVBQVU7b0JBQ1ZDLFNBQVM7d0JBQUUzQyxNQUFNO29CQUFlO2dCQUNsQztnQkFFQWUsT0FBTzlDLFdBQVdhLFFBQVEsQ0FBQ1IsTUFBTSxFQUFFMEMsb0JBQW9CLENBQUM7b0JBQ3REOEIsTUFBTTt3QkFDSlAsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsVUFBVTt3QkFDVkMsU0FBUzs0QkFBRTNDLE1BQU07d0JBQWU7b0JBQ2xDO2dCQUNGO2dCQUNBZSxPQUFPSCxRQUFRTSxPQUFPLENBQUNvQjtZQUN6QjtZQUVBN0IsR0FBRyxpREFBaUQ7Z0JBQ2xELE1BQU1zQyxhQUFhLElBQUkxQixNQUFNO2dCQUM3QnBELFdBQVdhLFFBQVEsQ0FBQ1IsTUFBTSxDQUFDZ0QsaUJBQWlCLENBQUN5QjtnQkFFN0Msc0NBQXNDO2dCQUN0QyxNQUFNbkMsU0FBUyxNQUFNZ0MsMEJBQVksQ0FBQ0MsU0FBUyxDQUFDO29CQUMxQ04sUUFBUTtvQkFDUkMsUUFBUTtvQkFDUkMsUUFBUTtnQkFDVjtnQkFFQTFCLE9BQU9ILFFBQVFvQyxhQUFhO2dCQUM1QmpDLE9BQU85QixXQUFXSyxLQUFLLEVBQUUwQixvQkFBb0IsQ0FBQywrQkFBK0IrQjtZQUMvRTtRQUNGO1FBRUF2RCxTQUFTLGdCQUFnQjtZQUN2QmlCLEdBQUcsd0NBQXdDO2dCQUN6QyxNQUFNd0MsV0FBVztvQkFBQ1g7b0JBQWU7d0JBQUUsR0FBR0EsYUFBYTt3QkFBRXZDLElBQUk7d0JBQUd5QyxRQUFRO29CQUFTO2lCQUFFO2dCQUMvRXZFLFdBQVdhLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDNEIsaUJBQWlCLENBQUNzQztnQkFFL0MsTUFBTXJDLFNBQVMsTUFBTWdDLDBCQUFZLENBQUNNLFlBQVksQ0FBQztvQkFDN0NYLFFBQVE7b0JBQ1JFLFFBQVE7b0JBQ1JVLFdBQVcsSUFBSTVDLEtBQUs7b0JBQ3BCNkMsU0FBUyxJQUFJN0MsS0FBSztnQkFDcEI7Z0JBRUFRLE9BQU85QyxXQUFXYSxRQUFRLENBQUNDLFFBQVEsRUFBRWlDLG9CQUFvQixDQUFDO29CQUN4REMsT0FBTzt3QkFDTHNCLFFBQVE7d0JBQ1JFLFFBQVE7d0JBQ1JuQyxXQUFXOzRCQUNUK0MsS0FBSyxJQUFJOUMsS0FBSzs0QkFDZCtDLEtBQUssSUFBSS9DLEtBQUs7d0JBQ2hCO29CQUNGO29CQUNBZ0QsU0FBUzt3QkFBRWpELFdBQVc7b0JBQU87b0JBQzdCa0QsU0FBUzt3QkFBRXhFLE1BQU07NEJBQUV5RSxRQUFRO2dDQUFFQyxVQUFVO2dDQUFNQyxPQUFPOzRCQUFLO3dCQUFFO29CQUFFO2dCQUMvRDtnQkFDQTVDLE9BQU9ILFFBQVFNLE9BQU8sQ0FBQytCO1lBQ3pCO1lBRUF4QyxHQUFHLCtCQUErQjtnQkFDaEN4QyxXQUFXYSxRQUFRLENBQUNDLFFBQVEsQ0FBQzRCLGlCQUFpQixDQUFDLEVBQUU7Z0JBRWpELE1BQU1DLFNBQVMsTUFBTWdDLDBCQUFZLENBQUNNLFlBQVksQ0FBQyxDQUFDO2dCQUVoRG5DLE9BQU9ILFFBQVFNLE9BQU8sQ0FBQyxFQUFFO1lBQzNCO1FBQ0Y7UUFFQTFCLFNBQVMsa0JBQWtCO1lBQ3pCaUIsR0FBRyxpQ0FBaUM7Z0JBQ2xDLE1BQU1tRCxlQUFlO29CQUFFbkYsT0FBTztnQkFBRztnQkFDakNSLFdBQVdhLFFBQVEsQ0FBQ0QsVUFBVSxDQUFDOEIsaUJBQWlCLENBQUNpRDtnQkFFakQsTUFBTWhELFNBQVMsTUFBTWdDLDBCQUFZLENBQUNpQixjQUFjLENBQUMsS0FBSyxjQUFjO2dCQUVwRSxNQUFNQyxxQkFBcUIsSUFBSXZEO2dCQUMvQnVELG1CQUFtQkMsT0FBTyxDQUFDRCxtQkFBbUJFLE9BQU8sS0FBSztnQkFFMURqRCxPQUFPOUMsV0FBV2EsUUFBUSxDQUFDRCxVQUFVLEVBQUVtQyxvQkFBb0IsQ0FBQztvQkFDMURDLE9BQU87d0JBQ0xYLFdBQVc7NEJBQ1QyRCxJQUFJbEQsT0FBT3FCLEdBQUcsQ0FBQzdCO3dCQUNqQjtvQkFDRjtnQkFDRjtnQkFDQVEsT0FBT0gsUUFBUU0sT0FBTyxDQUFDO1lBQ3pCO1FBQ0Y7SUFDRjtJQUVBMUIsU0FBUyx1QkFBdUI7UUFDOUIsTUFBTTBFLG1CQUFtQjtZQUN2Qm5FLElBQUk7WUFDSm9FLE9BQU87WUFDUDVCLFFBQVE7WUFDUjZCLFdBQVcsSUFBSTdELEtBQUtBLEtBQUs4RCxHQUFHLEtBQUssSUFBSSxLQUFLLEtBQUssS0FBSztZQUNwRC9ELFdBQVcsSUFBSUM7UUFDakI7UUFFQWYsU0FBUyxzQkFBc0I7WUFDN0JpQixHQUFHLDRDQUE0QztnQkFDN0N4QyxXQUFXUyxZQUFZLENBQUNKLE1BQU0sQ0FBQ3FDLGlCQUFpQixDQUFDdUQ7Z0JBRWpELE1BQU10RCxTQUFTLE1BQU0wRCx3Q0FBbUIsQ0FBQ0Msa0JBQWtCLENBQUM7Z0JBRTVEeEQsT0FBTzlDLFdBQVdTLFlBQVksQ0FBQ0osTUFBTSxFQUFFMEMsb0JBQW9CLENBQUM7b0JBQzFEOEIsTUFBTTt3QkFDSlAsUUFBUTt3QkFDUjRCLE9BQU9wRCxPQUFPcUIsR0FBRyxDQUFDb0M7d0JBQ2xCSixXQUFXckQsT0FBT3FCLEdBQUcsQ0FBQzdCO29CQUN4QjtnQkFDRjtnQkFDQVEsT0FBT0gsUUFBUU0sT0FBTyxDQUFDZ0Q7WUFDekI7WUFFQXpELEdBQUcsaUNBQWlDO2dCQUNsQyxNQUFNZ0UsY0FBYyxJQUFJcEQsTUFBTTtnQkFDOUJwRCxXQUFXUyxZQUFZLENBQUNKLE1BQU0sQ0FBQ2dELGlCQUFpQixDQUFDbUQ7Z0JBRWpELE1BQU0xRCxPQUFPdUQsd0NBQW1CLENBQUNDLGtCQUFrQixDQUFDLElBQUloRCxPQUFPLENBQUNDLE9BQU8sQ0FBQztZQUMxRTtRQUNGO1FBRUFoQyxTQUFTLHdCQUF3QjtZQUMvQmlCLEdBQUcsdUNBQXVDO2dCQUN4QyxNQUFNaUUsV0FBVztvQkFBRTNFLElBQUk7b0JBQUcyRCxVQUFVO29CQUFZQyxPQUFPO2dCQUFtQjtnQkFDMUUxRixXQUFXUyxZQUFZLENBQUNDLFVBQVUsQ0FBQ2dDLGlCQUFpQixDQUFDO29CQUNuRCxHQUFHdUQsZ0JBQWdCO29CQUNuQmxGLE1BQU0wRjtnQkFDUjtnQkFFQSxNQUFNOUQsU0FBUyxNQUFNMEQsd0NBQW1CLENBQUNLLG9CQUFvQixDQUFDO2dCQUU5RDVELE9BQU85QyxXQUFXUyxZQUFZLENBQUNDLFVBQVUsRUFBRXFDLG9CQUFvQixDQUFDO29CQUM5REMsT0FBTzt3QkFBRWtELE9BQU87b0JBQW9CO29CQUNwQ1gsU0FBUzt3QkFBRXhFLE1BQU07b0JBQUs7Z0JBQ3hCO2dCQUNBK0IsT0FBT0gsUUFBUU0sT0FBTyxDQUFDO29CQUFFLEdBQUdnRCxnQkFBZ0I7b0JBQUVsRixNQUFNMEY7Z0JBQVM7WUFDL0Q7WUFFQWpFLEdBQUcsd0NBQXdDO2dCQUN6Q3hDLFdBQVdTLFlBQVksQ0FBQ0MsVUFBVSxDQUFDZ0MsaUJBQWlCLENBQUM7Z0JBRXJELE1BQU1DLFNBQVMsTUFBTTBELHdDQUFtQixDQUFDSyxvQkFBb0IsQ0FBQztnQkFFOUQ1RCxPQUFPSCxRQUFRYyxRQUFRO1lBQ3pCO1lBRUFqQixHQUFHLHdDQUF3QztnQkFDekMsTUFBTW1FLGVBQWU7b0JBQ25CLEdBQUdWLGdCQUFnQjtvQkFDbkJFLFdBQVcsSUFBSTdELEtBQUtBLEtBQUs4RCxHQUFHLEtBQUs7Z0JBQ25DO2dCQUNBcEcsV0FBV1MsWUFBWSxDQUFDQyxVQUFVLENBQUNnQyxpQkFBaUIsQ0FBQ2lFO2dCQUVyRCxNQUFNaEUsU0FBUyxNQUFNMEQsd0NBQW1CLENBQUNLLG9CQUFvQixDQUFDO2dCQUU5RDVELE9BQU9ILFFBQVFjLFFBQVE7WUFDekI7UUFDRjtRQUVBbEMsU0FBUyxzQkFBc0I7WUFDN0JpQixHQUFHLDRDQUE0QztnQkFDN0N4QyxXQUFXUyxZQUFZLENBQUNFLE1BQU0sQ0FBQytCLGlCQUFpQixDQUFDdUQ7Z0JBRWpELE1BQU10RCxTQUFTLE1BQU0wRCx3Q0FBbUIsQ0FBQ08sa0JBQWtCLENBQUM7Z0JBRTVEOUQsT0FBTzlDLFdBQVdTLFlBQVksQ0FBQ0UsTUFBTSxFQUFFb0Msb0JBQW9CLENBQUM7b0JBQzFEQyxPQUFPO3dCQUFFa0QsT0FBTztvQkFBb0I7Z0JBQ3RDO2dCQUNBcEQsT0FBT0gsUUFBUU0sT0FBTyxDQUFDZ0Q7WUFDekI7WUFFQXpELEdBQUcsK0NBQStDO2dCQUNoRCxNQUFNcUUsZ0JBQWdCLElBQUl6RCxNQUFNO2dCQUNoQ3BELFdBQVdTLFlBQVksQ0FBQ0UsTUFBTSxDQUFDMEMsaUJBQWlCLENBQUN3RDtnQkFFakQsTUFBTS9ELE9BQU91RCx3Q0FBbUIsQ0FBQ08sa0JBQWtCLENBQUMsaUJBQWlCdEQsT0FBTyxDQUFDQyxPQUFPLENBQUM7WUFDdkY7UUFDRjtRQUVBaEMsU0FBUyx1QkFBdUI7WUFDOUJpQixHQUFHLHFDQUFxQztnQkFDdEMsTUFBTW1ELGVBQWU7b0JBQUVuRixPQUFPO2dCQUFFO2dCQUNoQ1IsV0FBV1MsWUFBWSxDQUFDRyxVQUFVLENBQUM4QixpQkFBaUIsQ0FBQ2lEO2dCQUVyRCxNQUFNaEQsU0FBUyxNQUFNMEQsd0NBQW1CLENBQUNTLG1CQUFtQixDQUFDO2dCQUU3RGhFLE9BQU85QyxXQUFXUyxZQUFZLENBQUNHLFVBQVUsRUFBRW1DLG9CQUFvQixDQUFDO29CQUM5REMsT0FBTzt3QkFBRXNCLFFBQVE7b0JBQUU7Z0JBQ3JCO2dCQUNBeEIsT0FBT0gsUUFBUU0sT0FBTyxDQUFDO1lBQ3pCO1FBQ0Y7UUFFQTFCLFNBQVMsd0JBQXdCO1lBQy9CaUIsR0FBRyxpQ0FBaUM7Z0JBQ2xDLE1BQU1tRCxlQUFlO29CQUFFbkYsT0FBTztnQkFBRztnQkFDakNSLFdBQVdTLFlBQVksQ0FBQ0csVUFBVSxDQUFDOEIsaUJBQWlCLENBQUNpRDtnQkFFckQsTUFBTWhELFNBQVMsTUFBTTBELHdDQUFtQixDQUFDVSxvQkFBb0I7Z0JBRTdEakUsT0FBTzlDLFdBQVdTLFlBQVksQ0FBQ0csVUFBVSxFQUFFbUMsb0JBQW9CLENBQUM7b0JBQzlEQyxPQUFPO3dCQUNMbUQsV0FBVzs0QkFDVEgsSUFBSWxELE9BQU9xQixHQUFHLENBQUM3Qjt3QkFDakI7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0FRLE9BQU9ILFFBQVFNLE9BQU8sQ0FBQztZQUN6QjtRQUNGO0lBQ0Y7SUFFQTFCLFNBQVMsNkJBQTZCO1FBQ3BDaUIsR0FBRyxnREFBZ0Q7WUFDakQsb0NBQW9DO1lBQ3BDLE1BQU13RSxjQUFjO2dCQUFFakYsTUFBTTtnQkFBZ0JFLE9BQU87WUFBTTtZQUN6RCxNQUFNMEIsaUJBQWlCO2dCQUFFLEdBQUc5QixlQUFlO2dCQUFFLEdBQUdtRixXQUFXO2dCQUFFbEYsSUFBSTtZQUFFO1lBRW5FakMsWUFBWVEsTUFBTSxDQUFDcUMsaUJBQWlCLENBQUNpQjtZQUNyQzNELFdBQVdhLFFBQVEsQ0FBQ1IsTUFBTSxDQUFDcUMsaUJBQWlCLENBQUM7Z0JBQzNDWixJQUFJO2dCQUNKd0MsUUFBUTtnQkFDUkMsUUFBUTtnQkFDUkMsUUFBUTtnQkFDUkMsVUFBVTtnQkFDVkMsU0FBU3NDO2dCQUNUM0UsV0FBVyxJQUFJQztZQUNqQjtZQUVBLGlCQUFpQjtZQUNqQixNQUFNMkUsVUFBVSxNQUFNckUsOEJBQWMsQ0FBQ2dCLGFBQWEsQ0FBQ29EO1lBRW5ELG1CQUFtQjtZQUNuQixNQUFNbkcsV0FBVyxNQUFNOEQsMEJBQVksQ0FBQ0MsU0FBUyxDQUFDO2dCQUM1Q04sUUFBUTtnQkFDUkMsUUFBUTtnQkFDUkMsUUFBUTtnQkFDUkMsVUFBVXdDLFFBQVFuRixFQUFFO2dCQUNwQjRDLFNBQVNzQztZQUNYO1lBRUFsRSxPQUFPbUUsU0FBU2hFLE9BQU8sQ0FBQ1U7WUFDeEJiLE9BQU9qQyxVQUFVcUcsV0FBVztZQUM1QnBFLE9BQU9qQyxTQUFTNEQsUUFBUSxFQUFFMEMsSUFBSSxDQUFDRixRQUFRbkYsRUFBRTtRQUMzQztRQUVBVSxHQUFHLDJDQUEyQztZQUM1QyxNQUFNVyxVQUFVLElBQUlDLE1BQU07WUFDMUJ2RCxZQUFZSSxPQUFPLENBQUNvRCxpQkFBaUIsQ0FBQ0Y7WUFDdENuRCxXQUFXYSxRQUFRLENBQUNSLE1BQU0sQ0FBQ2dELGlCQUFpQixDQUFDRjtZQUU3QyxtREFBbUQ7WUFDbkQsTUFBTUwsT0FBT0YsOEJBQWMsQ0FBQ0MsY0FBYyxJQUFJUyxPQUFPLENBQUNDLE9BQU8sQ0FBQztZQUU5RCxNQUFNNkQsY0FBYyxNQUFNekMsMEJBQVksQ0FBQ0MsU0FBUyxDQUFDO2dCQUMvQ04sUUFBUTtnQkFDUkMsUUFBUTtnQkFDUkMsUUFBUTtZQUNWO1lBRUExQixPQUFPc0UsYUFBYXJDLGFBQWEsSUFBSSwwQ0FBMEM7UUFDakY7SUFDRjtBQUNGIn0=