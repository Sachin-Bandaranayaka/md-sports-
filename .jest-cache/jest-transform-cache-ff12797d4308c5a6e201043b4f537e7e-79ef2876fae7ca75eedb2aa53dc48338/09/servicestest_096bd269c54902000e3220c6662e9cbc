50dc1867f9c3395606e9a8f726c396bf
// Mock the Product model
// Mock Product is defined in the jest.mock call below
// Mock the models
"use strict";
jest.mock("@/lib/models", ()=>({
        Product: {
            findAll: jest.fn(),
            findOne: jest.fn(),
            findByPk: jest.fn(),
            create: jest.fn(),
            update: jest.fn(),
            destroy: jest.fn(),
            count: jest.fn()
        }
    }));
// Mock prisma
jest.mock("@/lib/prisma", ()=>({
        prisma: {
            refreshToken: {
                deleteMany: jest.fn(),
                updateMany: jest.fn(),
                findFirst: jest.fn(),
                findUnique: jest.fn(),
                create: jest.fn(),
                update: jest.fn(),
                delete: jest.fn()
            },
            auditLog: {
                findMany: jest.fn(),
                create: jest.fn()
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _productService = require("../../src/services/productService");
const _auditService = require("../../src/services/auditService");
const _refreshTokenService = /*#__PURE__*/ _interop_require_wildcard(require("../../src/services/refreshTokenService"));
const _prisma = require("../../src/lib/prisma");
const _models = require("../../src/lib/models");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Get the mocked Product
const mockedProduct = _models.Product;
// Get the mocked prisma instance
const mockPrisma = _prisma.prisma;
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Service Layer Tests", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("ProductService", ()=>{
        const mockProductData = {
            id: 1,
            name: "Test Product",
            description: "Test Description",
            price: 99.99,
            costPrice: 50.00,
            sku: "TEST-001",
            isActive: true,
            createdAt: new Date(),
            updatedAt: new Date()
        };
        describe("getAllProducts", ()=>{
            it("should fetch all active products successfully", async ()=>{
                const mockProducts = [
                    mockProductData,
                    {
                        ...mockProductData,
                        id: 2,
                        name: "Product 2"
                    }
                ];
                mockProduct.findAll.mockResolvedValue(mockProducts);
                const result = await _productService.productService.getAllProducts();
                expect(mockProduct.findAll).toHaveBeenCalledWith({
                    where: {
                        isActive: true
                    }
                });
                expect(result).toEqual(mockProducts);
                expect(result).toHaveLength(2);
            });
            it("should handle database errors gracefully", async ()=>{
                const dbError = new Error("Database connection failed");
                mockProduct.findAll.mockRejectedValue(dbError);
                await expect(_productService.productService.getAllProducts()).rejects.toThrow("Database connection failed");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error fetching products:", dbError);
            });
            it("should return empty array when no products found", async ()=>{
                mockProduct.findAll.mockResolvedValue([]);
                const result = await _productService.productService.getAllProducts();
                expect(result).toEqual([]);
                expect(result).toHaveLength(0);
            });
        });
        describe("getProductById", ()=>{
            it("should fetch product by id successfully", async ()=>{
                mockProduct.findOne.mockResolvedValue(mockProductData);
                const result = await _productService.productService.getProductById(1);
                expect(mockProduct.findOne).toHaveBeenCalledWith({
                    where: {
                        id: 1,
                        isActive: true
                    }
                });
                expect(result).toEqual(mockProductData);
            });
            it("should return null for non-existent product", async ()=>{
                mockProduct.findOne.mockResolvedValue(null);
                const result = await _productService.productService.getProductById(999);
                expect(result).toBeNull();
            });
            it("should handle database errors", async ()=>{
                const dbError = new Error("Product not found");
                mockProduct.findOne.mockRejectedValue(dbError);
                await expect(_productService.productService.getProductById(1)).rejects.toThrow("Product not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error fetching product with ID 1:", dbError);
            });
        });
        describe("createProduct", ()=>{
            it("should create a new product successfully", async ()=>{
                const newProductData = {
                    name: "New Product",
                    description: "New Description",
                    price: 149.99,
                    costPrice: 75.00,
                    sku: "NEW-001"
                };
                const createdProduct = {
                    ...mockProductData,
                    ...newProductData,
                    id: 3
                };
                mockProduct.create.mockResolvedValue(createdProduct);
                const result = await _productService.productService.createProduct(newProductData);
                expect(mockProduct.create).toHaveBeenCalledWith(newProductData);
                expect(result).toEqual(createdProduct);
            });
            it("should handle validation errors", async ()=>{
                const validationError = new Error("Validation failed: name is required");
                mockProduct.create.mockRejectedValue(validationError);
                await expect(_productService.productService.createProduct({})).rejects.toThrow("Validation failed: name is required");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error creating product:", validationError);
            });
            it("should handle duplicate SKU errors", async ()=>{
                const duplicateError = new Error("SKU already exists");
                mockProduct.create.mockRejectedValue(duplicateError);
                const duplicateData = {
                    name: "Test",
                    sku: "EXISTING-SKU"
                };
                await expect(_productService.productService.createProduct(duplicateData)).rejects.toThrow("SKU already exists");
            });
        });
        describe("updateProduct", ()=>{
            it("should update product successfully", async ()=>{
                const updateData = {
                    name: "Updated Product",
                    price: 199.99
                };
                const mockProductInstance = {
                    ...mockProductData,
                    update: jest.fn().mockResolvedValue({
                        ...mockProductData,
                        ...updateData
                    })
                };
                mockProduct.findByPk.mockResolvedValue(mockProductInstance);
                const result = await _productService.productService.updateProduct(1, updateData);
                expect(mockProduct.findByPk).toHaveBeenCalledWith(1);
                expect(mockProductInstance.update).toHaveBeenCalledWith(updateData);
                expect(result).toEqual({
                    ...mockProductData,
                    ...updateData
                });
            });
            it("should throw error for non-existent product", async ()=>{
                mockProduct.findByPk.mockResolvedValue(null);
                await expect(_productService.productService.updateProduct(999, {
                    name: "Updated"
                })).rejects.toThrow("Product with ID 999 not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error updating product with ID 999:", expect.any(Error));
            });
            it("should handle database update errors", async ()=>{
                const mockProductInstance = {
                    update: jest.fn().mockRejectedValue(new Error("Update failed"))
                };
                mockProduct.findByPk.mockResolvedValue(mockProductInstance);
                await expect(_productService.productService.updateProduct(1, {
                    name: "Updated"
                })).rejects.toThrow("Update failed");
            });
        });
        describe("deleteProduct", ()=>{
            it("should soft delete product successfully", async ()=>{
                const mockProductInstance = {
                    ...mockProductData,
                    update: jest.fn().mockResolvedValue({
                        ...mockProductData,
                        isActive: false
                    })
                };
                mockProduct.findByPk.mockResolvedValue(mockProductInstance);
                const result = await _productService.productService.deleteProduct(1);
                expect(mockProduct.findByPk).toHaveBeenCalledWith(1);
                expect(mockProductInstance.update).toHaveBeenCalledWith({
                    isActive: false
                });
                expect(result).toEqual({
                    ...mockProductData,
                    isActive: false
                });
            });
            it("should throw error for non-existent product", async ()=>{
                mockProduct.findByPk.mockResolvedValue(null);
                await expect(_productService.productService.deleteProduct(999)).rejects.toThrow("Product with ID 999 not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error deleting product with ID 999:", expect.any(Error));
            });
        });
    });
    describe("AuditService", ()=>{
        const mockAuditData = {
            id: 1,
            userId: 1,
            action: "CREATE",
            entity: "Product",
            entityId: 1,
            details: {
                name: "Test Product"
            },
            createdAt: new Date()
        };
        describe("logAction", ()=>{
            it("should log audit action successfully", async ()=>{
                mockPrisma.auditLog.create.mockResolvedValue(mockAuditData);
                await _auditService.auditService.logAction({
                    userId: 1,
                    action: "CREATE",
                    entity: "Product",
                    entityId: 1,
                    details: {
                        name: "Test Product"
                    }
                });
                expect(mockPrisma.auditLog.create).toHaveBeenCalledWith({
                    data: {
                        userId: 1,
                        action: "CREATE",
                        entity: "Product",
                        entityId: 1,
                        details: {
                            name: "Test Product",
                            originalData: undefined,
                            isDeleted: false,
                            deletedAt: undefined,
                            deletedBy: undefined,
                            canRecover: false,
                            recoveredAt: undefined,
                            recoveredBy: undefined
                        }
                    }
                });
            });
            it("should handle audit logging errors gracefully", async ()=>{
                const auditError = new Error("Audit log failed");
                mockPrisma.auditLog.create.mockRejectedValue(auditError);
                // Should not throw error, just log it
                await _auditService.auditService.logAction({
                    userId: 1,
                    action: "CREATE",
                    entity: "Product"
                });
                expect(consoleSpy.error).toHaveBeenCalledWith("Failed to log audit entry:", auditError);
            });
        });
    // Note: getAuditLogs and cleanupOldLogs methods don't exist in the actual auditService
    // These tests have been removed to match the actual implementation
    });
    describe.skip("RefreshTokenService", ()=>{
        const mockRefreshToken = {
            id: 1,
            token: "refresh-token-123",
            userId: 1,
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
            createdAt: new Date(),
            isRevoked: false
        };
        describe("generateRefreshToken", ()=>{
            it("should generate refresh token successfully", async ()=>{
                mockPrisma.refreshToken.create.mockResolvedValue(mockRefreshToken);
                const result = await _refreshTokenService.generateRefreshToken(1);
                expect(mockPrisma.refreshToken.create).toHaveBeenCalledWith({
                    data: {
                        userId: 1,
                        token: expect.any(String),
                        expiresAt: expect.any(Date)
                    }
                });
                expect(result).toEqual(expect.any(String));
            });
            it("should handle creation errors", async ()=>{
                const createError = new Error("Token creation failed");
                mockPrisma.refreshToken.create.mockRejectedValue(createError);
                await expect(_refreshTokenService.generateRefreshToken(1)).rejects.toThrow("Token creation failed");
            });
        });
        describe("verifyRefreshToken", ()=>{
            it("should verify valid refresh token", async ()=>{
                mockPrisma.refreshToken.findUnique.mockResolvedValue(mockRefreshToken);
                const result = await _refreshTokenService.verifyRefreshToken("refresh-token-123");
                expect(mockPrisma.refreshToken.findUnique).toHaveBeenCalledWith({
                    where: {
                        token: "refresh-token-123"
                    }
                });
                expect(result).toEqual(1);
            });
            it("should return null for invalid token", async ()=>{
                mockPrisma.refreshToken.findUnique.mockResolvedValue(null);
                const result = await _refreshTokenService.verifyRefreshToken("invalid-token");
                expect(result).toBeNull();
            });
            it("should return null for expired token", async ()=>{
                const expiredToken = {
                    ...mockRefreshToken,
                    expiresAt: new Date(Date.now() - 1000)
                };
                mockPrisma.refreshToken.findUnique.mockResolvedValue(expiredToken);
                mockPrisma.refreshToken.update.mockResolvedValue(expiredToken);
                const result = await _refreshTokenService.verifyRefreshToken("expired-token");
                expect(result).toBeNull();
            });
        });
        describe.skip("revokeRefreshToken", ()=>{
            it("should revoke refresh token successfully", async ()=>{
                mockPrisma.refreshToken.updateMany.mockResolvedValue({
                    count: 1
                });
                const result = await _refreshTokenService.revokeRefreshToken("refresh-token-123");
                expect(mockPrisma.refreshToken.updateMany).toHaveBeenCalledWith({
                    where: {
                        token: "refresh-token-123"
                    },
                    data: {
                        isRevoked: true
                    }
                });
                expect(result).toBe(true);
            });
            it("should handle errors gracefully", async ()=>{
                const revokeError = new Error("Database error");
                mockPrisma.refreshToken.updateMany.mockRejectedValue(revokeError);
                const result = await _refreshTokenService.revokeRefreshToken("non-existent");
                expect(result).toBe(false);
            });
        });
        describe.skip("revokeAllUserRefreshTokens", ()=>{
            it("should revoke all tokens for user", async ()=>{
                mockPrisma.refreshToken.updateMany.mockResolvedValue({
                    count: 3
                });
                const result = await _refreshTokenService.revokeAllUserRefreshTokens(1);
                expect(mockPrisma.refreshToken.updateMany).toHaveBeenCalledWith({
                    where: {
                        userId: 1
                    },
                    data: {
                        isRevoked: true
                    }
                });
                expect(result).toBe(true);
            });
        });
        describe.skip("cleanupRefreshTokens", ()=>{
            it("should cleanup expired tokens", async ()=>{
                mockPrisma.refreshToken.deleteMany.mockResolvedValue({
                    count: 10
                });
                await _refreshTokenService.cleanupRefreshTokens();
                // The function uses executeWithRetry wrapper, so we check if deleteMany was called
                expect(mockPrisma.refreshToken.deleteMany).toHaveBeenCalled();
            });
        });
    });
    describe("Service Integration Tests", ()=>{
        it("should handle service dependencies correctly", async ()=>{
            // Test interaction between services
            const productData = {
                name: "Test Product",
                price: 99.99
            };
            const createdProduct = {
                id: 5,
                name: "Test Product",
                price: 99.99,
                description: "Test description",
                category: "Test Category",
                stock: 10,
                createdAt: new Date(),
                updatedAt: new Date()
            };
            mockedProduct.create.mockResolvedValue(createdProduct);
            mockPrisma.auditLog.create.mockResolvedValue({
                id: 1,
                userId: 1,
                action: "CREATE",
                entity: "Product",
                entityId: 5,
                details: productData,
                createdAt: new Date()
            });
            // Create product
            const product = await _productService.productService.createProduct(productData);
            // Log audit action
            await _auditService.auditService.logAction({
                userId: 1,
                action: "CREATE",
                entity: "Product",
                entityId: product.id,
                details: productData
            });
            expect(product).toEqual(createdProduct);
            expect(mockPrisma.auditLog.create).toHaveBeenCalled();
        });
        it("should handle service error propagation", async ()=>{
            const dbError = new Error("Database connection lost");
            mockedProduct.findAll.mockRejectedValue(dbError);
            mockPrisma.auditLog.create.mockRejectedValue(dbError);
            // Both services should handle errors independently
            await expect(_productService.productService.getAllProducts()).rejects.toThrow("Database connection lost");
            await _auditService.auditService.logAction({
                userId: 1,
                action: "READ",
                entity: "Product"
            });
            // Audit service handles errors gracefully, so no exception should be thrown
            expect(mockPrisma.auditLog.create).toHaveBeenCalled();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9zZXJ2aWNlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1vY2sgdGhlIFByb2R1Y3QgbW9kZWxcbi8vIE1vY2sgUHJvZHVjdCBpcyBkZWZpbmVkIGluIHRoZSBqZXN0Lm1vY2sgY2FsbCBiZWxvd1xuXG4vLyBNb2NrIHRoZSBtb2RlbHNcbmplc3QubW9jaygnQC9saWIvbW9kZWxzJywgKCkgPT4gKHtcbiAgUHJvZHVjdDoge1xuICAgIGZpbmRBbGw6IGplc3QuZm4oKSxcbiAgICBmaW5kT25lOiBqZXN0LmZuKCksXG4gICAgZmluZEJ5UGs6IGplc3QuZm4oKSxcbiAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICBkZXN0cm95OiBqZXN0LmZuKCksXG4gICAgY291bnQ6IGplc3QuZm4oKSxcbiAgfVxufSkpO1xuXG4vLyBNb2NrIHByaXNtYVxuamVzdC5tb2NrKCdAL2xpYi9wcmlzbWEnLCAoKSA9PiAoe1xuICBwcmlzbWE6IHtcbiAgICByZWZyZXNoVG9rZW46IHtcbiAgICAgIGRlbGV0ZU1hbnk6IGplc3QuZm4oKSxcbiAgICAgIHVwZGF0ZU1hbnk6IGplc3QuZm4oKSxcbiAgICAgIGZpbmRGaXJzdDogamVzdC5mbigpLFxuICAgICAgZmluZFVuaXF1ZTogamVzdC5mbigpLFxuICAgICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gICAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICAgIGRlbGV0ZTogamVzdC5mbigpLFxuICAgIH0sXG4gICAgYXVkaXRMb2c6IHtcbiAgICAgIGZpbmRNYW55OiBqZXN0LmZuKCksXG4gICAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgICB9LFxuICB9LFxufSkpO1xuXG5pbXBvcnQgeyBwcm9kdWN0U2VydmljZSB9IGZyb20gJ0Avc2VydmljZXMvcHJvZHVjdFNlcnZpY2UnO1xuaW1wb3J0IHsgYXVkaXRTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9hdWRpdFNlcnZpY2UnO1xuaW1wb3J0ICogYXMgcmVmcmVzaFRva2VuU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL3JlZnJlc2hUb2tlblNlcnZpY2UnO1xuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSAnQC9saWIvcHJpc21hJztcbmltcG9ydCB7IFByb2R1Y3QgfSBmcm9tICdAL2xpYi9tb2RlbHMnO1xuXG4vLyBHZXQgdGhlIG1vY2tlZCBQcm9kdWN0XG5jb25zdCBtb2NrZWRQcm9kdWN0ID0gUHJvZHVjdCBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgUHJvZHVjdD47XG5cbi8vIEdldCB0aGUgbW9ja2VkIHByaXNtYSBpbnN0YW5jZVxuY29uc3QgbW9ja1ByaXNtYSA9IHByaXNtYSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgcHJpc21hPjtcblxuXG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBjb25zb2xlU3B5ID0ge1xuICBsb2c6IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIGVycm9yOiBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIHdhcm46IGplc3Quc3B5T24oY29uc29sZSwgJ3dhcm4nKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pLFxufTtcblxuZGVzY3JpYmUoJ1NlcnZpY2UgTGF5ZXIgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkuZXJyb3IubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgY29uc29sZVNweS5sb2cubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9kdWN0U2VydmljZScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUHJvZHVjdERhdGEgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6ICdUZXN0IFByb2R1Y3QnLFxuICAgICAgZGVzY3JpcHRpb246ICdUZXN0IERlc2NyaXB0aW9uJyxcbiAgICAgIHByaWNlOiA5OS45OSxcbiAgICAgIGNvc3RQcmljZTogNTAuMDAsXG4gICAgICBza3U6ICdURVNULTAwMScsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9O1xuXG4gICAgZGVzY3JpYmUoJ2dldEFsbFByb2R1Y3RzJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBmZXRjaCBhbGwgYWN0aXZlIHByb2R1Y3RzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1Byb2R1Y3RzID0gW21vY2tQcm9kdWN0RGF0YSwgeyAuLi5tb2NrUHJvZHVjdERhdGEsIGlkOiAyLCBuYW1lOiAnUHJvZHVjdCAyJyB9XTtcbiAgICAgICAgbW9ja1Byb2R1Y3QuZmluZEFsbC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvZHVjdHMpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRBbGwpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB3aGVyZTogeyBpc0FjdGl2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUHJvZHVjdHMpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVMZW5ndGgoMik7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRiRXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRBbGwubW9ja1JlamVjdGVkVmFsdWUoZGJFcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCkpLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBmZXRjaGluZyBwcm9kdWN0czonLCBkYkVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIG5vIHByb2R1Y3RzIGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kQWxsLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5nZXRBbGxQcm9kdWN0cygpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdnZXRQcm9kdWN0QnlJZCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZmV0Y2ggcHJvZHVjdCBieSBpZCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2R1Y3REYXRhKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5nZXRQcm9kdWN0QnlJZCgxKTtcblxuICAgICAgICBleHBlY3QobW9ja1Byb2R1Y3QuZmluZE9uZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHdoZXJlOiB7IGlkOiAxLCBpc0FjdGl2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUHJvZHVjdERhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG5vbi1leGlzdGVudCBwcm9kdWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmdldFByb2R1Y3RCeUlkKDk5OSk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRiRXJyb3IgPSBuZXcgRXJyb3IoJ1Byb2R1Y3Qgbm90IGZvdW5kJyk7XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRPbmUubW9ja1JlamVjdGVkVmFsdWUoZGJFcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmdldFByb2R1Y3RCeUlkKDEpKS5yZWplY3RzLnRvVGhyb3coJ1Byb2R1Y3Qgbm90IGZvdW5kJyk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdCB3aXRoIElEIDE6JywgZGJFcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdjcmVhdGVQcm9kdWN0JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBuZXcgcHJvZHVjdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1Byb2R1Y3REYXRhID0ge1xuICAgICAgICAgIG5hbWU6ICdOZXcgUHJvZHVjdCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdOZXcgRGVzY3JpcHRpb24nLFxuICAgICAgICAgIHByaWNlOiAxNDkuOTksXG4gICAgICAgICAgY29zdFByaWNlOiA3NS4wMCxcbiAgICAgICAgICBza3U6ICdORVctMDAxJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3JlYXRlZFByb2R1Y3QgPSB7IC4uLm1vY2tQcm9kdWN0RGF0YSwgLi4ubmV3UHJvZHVjdERhdGEsIGlkOiAzIH07XG4gICAgICAgIG1vY2tQcm9kdWN0LmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShjcmVhdGVkUHJvZHVjdCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuY3JlYXRlUHJvZHVjdChuZXdQcm9kdWN0RGF0YSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgobmV3UHJvZHVjdERhdGEpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGNyZWF0ZWRQcm9kdWN0KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSB2YWxpZGF0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gbmV3IEVycm9yKCdWYWxpZGF0aW9uIGZhaWxlZDogbmFtZSBpcyByZXF1aXJlZCcpO1xuICAgICAgICBtb2NrUHJvZHVjdC5jcmVhdGUubW9ja1JlamVjdGVkVmFsdWUodmFsaWRhdGlvbkVycm9yKTtcblxuICAgICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuY3JlYXRlUHJvZHVjdCh7fSkpLnJlamVjdHMudG9UaHJvdygnVmFsaWRhdGlvbiBmYWlsZWQ6IG5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBjcmVhdGluZyBwcm9kdWN0OicsIHZhbGlkYXRpb25FcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZHVwbGljYXRlIFNLVSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZUVycm9yID0gbmV3IEVycm9yKCdTS1UgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgICAgbW9ja1Byb2R1Y3QuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKGR1cGxpY2F0ZUVycm9yKTtcblxuICAgICAgICBjb25zdCBkdXBsaWNhdGVEYXRhID0geyBuYW1lOiAnVGVzdCcsIHNrdTogJ0VYSVNUSU5HLVNLVScgfTtcbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3QoZHVwbGljYXRlRGF0YSkpLnJlamVjdHMudG9UaHJvdygnU0tVIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd1cGRhdGVQcm9kdWN0JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgcHJvZHVjdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7IG5hbWU6ICdVcGRhdGVkIFByb2R1Y3QnLCBwcmljZTogMTk5Ljk5IH07XG4gICAgICAgIGNvbnN0IG1vY2tQcm9kdWN0SW5zdGFuY2UgPSB7XG4gICAgICAgICAgLi4ubW9ja1Byb2R1Y3REYXRhLFxuICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgLi4ubW9ja1Byb2R1Y3REYXRhLCAuLi51cGRhdGVEYXRhIH0pLFxuICAgICAgICB9O1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvZHVjdEluc3RhbmNlKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDEsIHVwZGF0ZURhdGEpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kQnlQaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMSk7XG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdEluc3RhbmNlLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodXBkYXRlRGF0YSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyAuLi5tb2NrUHJvZHVjdERhdGEsIC4uLnVwZGF0ZURhdGEgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3Igbm9uLWV4aXN0ZW50IHByb2R1Y3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDk5OSwgeyBuYW1lOiAnVXBkYXRlZCcgfSkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgICAnUHJvZHVjdCB3aXRoIElEIDk5OSBub3QgZm91bmQnXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnRXJyb3IgdXBkYXRpbmcgcHJvZHVjdCB3aXRoIElEIDk5OTonLFxuICAgICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgdXBkYXRlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1Byb2R1Y3RJbnN0YW5jZSA9IHtcbiAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1VwZGF0ZSBmYWlsZWQnKSksXG4gICAgICAgIH07XG4gICAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9kdWN0SW5zdGFuY2UpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDEsIHsgbmFtZTogJ1VwZGF0ZWQnIH0pKS5yZWplY3RzLnRvVGhyb3coJ1VwZGF0ZSBmYWlsZWQnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2RlbGV0ZVByb2R1Y3QnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHNvZnQgZGVsZXRlIHByb2R1Y3Qgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrUHJvZHVjdEluc3RhbmNlID0ge1xuICAgICAgICAgIC4uLm1vY2tQcm9kdWN0RGF0YSxcbiAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IC4uLm1vY2tQcm9kdWN0RGF0YSwgaXNBY3RpdmU6IGZhbHNlIH0pLFxuICAgICAgICB9O1xuICAgICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvZHVjdEluc3RhbmNlKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5kZWxldGVQcm9kdWN0KDEpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kQnlQaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMSk7XG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdEluc3RhbmNlLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBpc0FjdGl2ZTogZmFsc2UgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyAuLi5tb2NrUHJvZHVjdERhdGEsIGlzQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBub24tZXhpc3RlbnQgcHJvZHVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja1Byb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmRlbGV0ZVByb2R1Y3QoOTk5KSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAgICdQcm9kdWN0IHdpdGggSUQgOTk5IG5vdCBmb3VuZCdcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICdFcnJvciBkZWxldGluZyBwcm9kdWN0IHdpdGggSUQgOTk5OicsXG4gICAgICAgICAgZXhwZWN0LmFueShFcnJvcilcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXVkaXRTZXJ2aWNlJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tBdWRpdERhdGEgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIHVzZXJJZDogMSxcbiAgICAgIGFjdGlvbjogJ0NSRUFURScsXG4gICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgIGVudGl0eUlkOiAxLFxuICAgICAgZGV0YWlsczogeyBuYW1lOiAnVGVzdCBQcm9kdWN0JyB9LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIH07XG5cbiAgICBkZXNjcmliZSgnbG9nQWN0aW9uJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBsb2cgYXVkaXQgYWN0aW9uIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgKG1vY2tQcmlzbWEuYXVkaXRMb2cuY3JlYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUobW9ja0F1ZGl0RGF0YSk7XG5cbiAgICAgICAgYXdhaXQgYXVkaXRTZXJ2aWNlLmxvZ0FjdGlvbih7XG4gICAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICAgIGFjdGlvbjogJ0NSRUFURScsXG4gICAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICAgICAgZW50aXR5SWQ6IDEsXG4gICAgICAgICAgZGV0YWlsczogeyBuYW1lOiAnVGVzdCBQcm9kdWN0JyB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICAgICAgICBlbnRpdHlJZDogMSxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgUHJvZHVjdCcsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBpc0RlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBkZWxldGVkQXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZGVsZXRlZEJ5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGNhblJlY292ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICByZWNvdmVyZWRBdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICByZWNvdmVyZWRCeTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBhdWRpdCBsb2dnaW5nIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBhdWRpdEVycm9yID0gbmV3IEVycm9yKCdBdWRpdCBsb2cgZmFpbGVkJyk7XG4gICAgICAgIChtb2NrUHJpc21hLmF1ZGl0TG9nLmNyZWF0ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKGF1ZGl0RXJyb3IpO1xuXG4gICAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgZXJyb3IsIGp1c3QgbG9nIGl0XG4gICAgICAgIGF3YWl0IGF1ZGl0U2VydmljZS5sb2dBY3Rpb24oe1xuICAgICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICAgIGVudGl0eTogJ1Byb2R1Y3QnLFxuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0ZhaWxlZCB0byBsb2cgYXVkaXQgZW50cnk6JywgYXVkaXRFcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGU6IGdldEF1ZGl0TG9ncyBhbmQgY2xlYW51cE9sZExvZ3MgbWV0aG9kcyBkb24ndCBleGlzdCBpbiB0aGUgYWN0dWFsIGF1ZGl0U2VydmljZVxuICAgIC8vIFRoZXNlIHRlc3RzIGhhdmUgYmVlbiByZW1vdmVkIHRvIG1hdGNoIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb25cbiAgfSk7XG5cbiAgZGVzY3JpYmUuc2tpcCgnUmVmcmVzaFRva2VuU2VydmljZScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUmVmcmVzaFRva2VuID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICB0b2tlbjogJ3JlZnJlc2gtdG9rZW4tMTIzJyxcbiAgICAgIHVzZXJJZDogMSxcbiAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKSwgLy8gNyBkYXlzXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICBpc1Jldm9rZWQ6IGZhbHNlLFxuICAgIH07XG5cbiAgICBkZXNjcmliZSgnZ2VuZXJhdGVSZWZyZXNoVG9rZW4nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIHJlZnJlc2ggdG9rZW4gc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uY3JlYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUobW9ja1JlZnJlc2hUb2tlbik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS5nZW5lcmF0ZVJlZnJlc2hUb2tlbigxKTtcblxuICAgICAgICBleHBlY3QobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICAgICAgdG9rZW46IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICAgIGV4cGlyZXNBdDogZXhwZWN0LmFueShEYXRlKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChleHBlY3QuYW55KFN0cmluZykpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGNyZWF0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY3JlYXRlRXJyb3IgPSBuZXcgRXJyb3IoJ1Rva2VuIGNyZWF0aW9uIGZhaWxlZCcpO1xuICAgICAgICAobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uY3JlYXRlIGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUoY3JlYXRlRXJyb3IpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChyZWZyZXNoVG9rZW5TZXJ2aWNlLmdlbmVyYXRlUmVmcmVzaFRva2VuKDEpKS5yZWplY3RzLnRvVGhyb3coJ1Rva2VuIGNyZWF0aW9uIGZhaWxlZCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndmVyaWZ5UmVmcmVzaFRva2VuJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB2ZXJpZnkgdmFsaWQgcmVmcmVzaCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmZpbmRVbmlxdWUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUmVmcmVzaFRva2VuKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLnZlcmlmeVJlZnJlc2hUb2tlbigncmVmcmVzaC10b2tlbi0xMjMnKTtcblxuICAgICAgICBleHBlY3QobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uZmluZFVuaXF1ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHdoZXJlOiB7IHRva2VuOiAncmVmcmVzaC10b2tlbi0xMjMnIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKDEpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGludmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5maW5kVW5pcXVlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS52ZXJpZnlSZWZyZXNoVG9rZW4oJ2ludmFsaWQtdG9rZW4nKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGV4cGlyZWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4cGlyZWRUb2tlbiA9IHtcbiAgICAgICAgICAuLi5tb2NrUmVmcmVzaFRva2VuLFxuICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDEwMDApLCAvLyBFeHBpcmVkXG4gICAgICAgIH07XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5maW5kVW5pcXVlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoZXhwaXJlZFRva2VuKTtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLnVwZGF0ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKGV4cGlyZWRUb2tlbik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS52ZXJpZnlSZWZyZXNoVG9rZW4oJ2V4cGlyZWQtdG9rZW4nKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZS5za2lwKCdyZXZva2VSZWZyZXNoVG9rZW4nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHJldm9rZSByZWZyZXNoIHRva2VuIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLnVwZGF0ZU1hbnkgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGNvdW50OiAxIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hUb2tlblNlcnZpY2UucmV2b2tlUmVmcmVzaFRva2VuKCdyZWZyZXNoLXRva2VuLTEyMycpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi51cGRhdGVNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHsgdG9rZW46ICdyZWZyZXNoLXRva2VuLTEyMycgfSxcbiAgICAgICAgICBkYXRhOiB7IGlzUmV2b2tlZDogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmV2b2tlRXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGVycm9yJyk7XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi51cGRhdGVNYW55IGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUocmV2b2tlRXJyb3IpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hUb2tlblNlcnZpY2UucmV2b2tlUmVmcmVzaFRva2VuKCdub24tZXhpc3RlbnQnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlLnNraXAoJ3Jldm9rZUFsbFVzZXJSZWZyZXNoVG9rZW5zJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCByZXZva2UgYWxsIHRva2VucyBmb3IgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLnVwZGF0ZU1hbnkgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGNvdW50OiAzIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hUb2tlblNlcnZpY2UucmV2b2tlQWxsVXNlclJlZnJlc2hUb2tlbnMoMSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLnVwZGF0ZU1hbnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB3aGVyZTogeyB1c2VySWQ6IDEgfSxcbiAgICAgICAgICBkYXRhOiB7IGlzUmV2b2tlZDogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUuc2tpcCgnY2xlYW51cFJlZnJlc2hUb2tlbnMnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGNsZWFudXAgZXhwaXJlZCB0b2tlbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5kZWxldGVNYW55IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoeyBjb3VudDogMTAgfSk7XG5cbiAgICAgICAgYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS5jbGVhbnVwUmVmcmVzaFRva2VucygpO1xuXG4gICAgICAgIC8vIFRoZSBmdW5jdGlvbiB1c2VzIGV4ZWN1dGVXaXRoUmV0cnkgd3JhcHBlciwgc28gd2UgY2hlY2sgaWYgZGVsZXRlTWFueSB3YXMgY2FsbGVkXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5kZWxldGVNYW55KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlcnZpY2UgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VydmljZSBkZXBlbmRlbmNpZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBpbnRlcmFjdGlvbiBiZXR3ZWVuIHNlcnZpY2VzXG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHsgbmFtZTogJ1Rlc3QgUHJvZHVjdCcsIHByaWNlOiA5OS45OSB9O1xuICAgICAgY29uc3QgY3JlYXRlZFByb2R1Y3QgPSB7IFxuICAgICAgICBpZDogNSwgXG4gICAgICAgIG5hbWU6ICdUZXN0IFByb2R1Y3QnLCBcbiAgICAgICAgcHJpY2U6IDk5Ljk5LCBcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IGRlc2NyaXB0aW9uJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdUZXN0IENhdGVnb3J5JyxcbiAgICAgICAgc3RvY2s6IDEwLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgKG1vY2tlZFByb2R1Y3QuY3JlYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoY3JlYXRlZFByb2R1Y3QpO1xuICAgICAgKG1vY2tQcmlzbWEuYXVkaXRMb2cuY3JlYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpZDogMSxcbiAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgICAgZW50aXR5SWQ6IDUsXG4gICAgICAgIGRldGFpbHM6IHByb2R1Y3REYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIHByb2R1Y3RcbiAgICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5jcmVhdGVQcm9kdWN0KHByb2R1Y3REYXRhKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIGF1ZGl0IGFjdGlvblxuICAgICAgYXdhaXQgYXVkaXRTZXJ2aWNlLmxvZ0FjdGlvbih7XG4gICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgYWN0aW9uOiAnQ1JFQVRFJyxcbiAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICAgIGVudGl0eUlkOiBwcm9kdWN0LmlkLFxuICAgICAgICBkZXRhaWxzOiBwcm9kdWN0RGF0YSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocHJvZHVjdCkudG9FcXVhbChjcmVhdGVkUHJvZHVjdCk7XG4gICAgICBleHBlY3QobW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcnZpY2UgZXJyb3IgcHJvcGFnYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYkVycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGxvc3QnKTtcbiAgICAgIChtb2NrZWRQcm9kdWN0LmZpbmRBbGwgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShkYkVycm9yKTtcbiAgICAgIChtb2NrUHJpc21hLmF1ZGl0TG9nLmNyZWF0ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKGRiRXJyb3IpO1xuXG4gICAgICAvLyBCb3RoIHNlcnZpY2VzIHNob3VsZCBoYW5kbGUgZXJyb3JzIGluZGVwZW5kZW50bHlcbiAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS5nZXRBbGxQcm9kdWN0cygpKS5yZWplY3RzLnRvVGhyb3coJ0RhdGFiYXNlIGNvbm5lY3Rpb24gbG9zdCcpO1xuICAgICAgXG4gICAgICBhd2FpdCBhdWRpdFNlcnZpY2UubG9nQWN0aW9uKHtcbiAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICBhY3Rpb246ICdSRUFEJyxcbiAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQXVkaXQgc2VydmljZSBoYW5kbGVzIGVycm9ycyBncmFjZWZ1bGx5LCBzbyBubyBleGNlcHRpb24gc2hvdWxkIGJlIHRocm93blxuICAgICAgZXhwZWN0KG1vY2tQcmlzbWEuYXVkaXRMb2cuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiUHJvZHVjdCIsImZpbmRBbGwiLCJmbiIsImZpbmRPbmUiLCJmaW5kQnlQayIsImNyZWF0ZSIsInVwZGF0ZSIsImRlc3Ryb3kiLCJjb3VudCIsInByaXNtYSIsInJlZnJlc2hUb2tlbiIsImRlbGV0ZU1hbnkiLCJ1cGRhdGVNYW55IiwiZmluZEZpcnN0IiwiZmluZFVuaXF1ZSIsImRlbGV0ZSIsImF1ZGl0TG9nIiwiZmluZE1hbnkiLCJtb2NrZWRQcm9kdWN0IiwibW9ja1ByaXNtYSIsImNvbnNvbGVTcHkiLCJsb2ciLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJlcnJvciIsIndhcm4iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja0NsZWFyIiwiYWZ0ZXJBbGwiLCJtb2NrUmVzdG9yZSIsIm1vY2tQcm9kdWN0RGF0YSIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwicHJpY2UiLCJjb3N0UHJpY2UiLCJza3UiLCJpc0FjdGl2ZSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ1cGRhdGVkQXQiLCJpdCIsIm1vY2tQcm9kdWN0cyIsIm1vY2tQcm9kdWN0IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJyZXN1bHQiLCJwcm9kdWN0U2VydmljZSIsImdldEFsbFByb2R1Y3RzIiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ3aGVyZSIsInRvRXF1YWwiLCJ0b0hhdmVMZW5ndGgiLCJkYkVycm9yIiwiRXJyb3IiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsInJlamVjdHMiLCJ0b1Rocm93IiwiZ2V0UHJvZHVjdEJ5SWQiLCJ0b0JlTnVsbCIsIm5ld1Byb2R1Y3REYXRhIiwiY3JlYXRlZFByb2R1Y3QiLCJjcmVhdGVQcm9kdWN0IiwidmFsaWRhdGlvbkVycm9yIiwiZHVwbGljYXRlRXJyb3IiLCJkdXBsaWNhdGVEYXRhIiwidXBkYXRlRGF0YSIsIm1vY2tQcm9kdWN0SW5zdGFuY2UiLCJ1cGRhdGVQcm9kdWN0IiwiYW55IiwiZGVsZXRlUHJvZHVjdCIsIm1vY2tBdWRpdERhdGEiLCJ1c2VySWQiLCJhY3Rpb24iLCJlbnRpdHkiLCJlbnRpdHlJZCIsImRldGFpbHMiLCJhdWRpdFNlcnZpY2UiLCJsb2dBY3Rpb24iLCJkYXRhIiwib3JpZ2luYWxEYXRhIiwidW5kZWZpbmVkIiwiaXNEZWxldGVkIiwiZGVsZXRlZEF0IiwiZGVsZXRlZEJ5IiwiY2FuUmVjb3ZlciIsInJlY292ZXJlZEF0IiwicmVjb3ZlcmVkQnkiLCJhdWRpdEVycm9yIiwic2tpcCIsIm1vY2tSZWZyZXNoVG9rZW4iLCJ0b2tlbiIsImV4cGlyZXNBdCIsIm5vdyIsImlzUmV2b2tlZCIsInJlZnJlc2hUb2tlblNlcnZpY2UiLCJnZW5lcmF0ZVJlZnJlc2hUb2tlbiIsIlN0cmluZyIsImNyZWF0ZUVycm9yIiwidmVyaWZ5UmVmcmVzaFRva2VuIiwiZXhwaXJlZFRva2VuIiwicmV2b2tlUmVmcmVzaFRva2VuIiwidG9CZSIsInJldm9rZUVycm9yIiwicmV2b2tlQWxsVXNlclJlZnJlc2hUb2tlbnMiLCJjbGVhbnVwUmVmcmVzaFRva2VucyIsInRvSGF2ZUJlZW5DYWxsZWQiLCJwcm9kdWN0RGF0YSIsImNhdGVnb3J5Iiwic3RvY2siLCJwcm9kdWN0Il0sIm1hcHBpbmdzIjoiQUFBQSx5QkFBeUI7QUFDekIsc0RBQXNEO0FBRXRELGtCQUFrQjs7QUFDbEJBLEtBQUtDLElBQUksQ0FBQyxnQkFBZ0IsSUFBTyxDQUFBO1FBQy9CQyxTQUFTO1lBQ1BDLFNBQVNILEtBQUtJLEVBQUU7WUFDaEJDLFNBQVNMLEtBQUtJLEVBQUU7WUFDaEJFLFVBQVVOLEtBQUtJLEVBQUU7WUFDakJHLFFBQVFQLEtBQUtJLEVBQUU7WUFDZkksUUFBUVIsS0FBS0ksRUFBRTtZQUNmSyxTQUFTVCxLQUFLSSxFQUFFO1lBQ2hCTSxPQUFPVixLQUFLSSxFQUFFO1FBQ2hCO0lBQ0YsQ0FBQTtBQUVBLGNBQWM7QUFDZEosS0FBS0MsSUFBSSxDQUFDLGdCQUFnQixJQUFPLENBQUE7UUFDL0JVLFFBQVE7WUFDTkMsY0FBYztnQkFDWkMsWUFBWWIsS0FBS0ksRUFBRTtnQkFDbkJVLFlBQVlkLEtBQUtJLEVBQUU7Z0JBQ25CVyxXQUFXZixLQUFLSSxFQUFFO2dCQUNsQlksWUFBWWhCLEtBQUtJLEVBQUU7Z0JBQ25CRyxRQUFRUCxLQUFLSSxFQUFFO2dCQUNmSSxRQUFR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