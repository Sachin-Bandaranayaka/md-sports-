95873272249ebef59b83c6595707ab01
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
// Mock implementations for missing utility functions
const formatDate = (dateString)=>{
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric"
    });
};
const validateEmail = (email)=>{
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
};
const validatePassword = (password)=>{
    return password.length >= 8;
};
const validatePhoneNumber = (phone)=>{
    const phoneRegex = /^[\+]?[1-9][\d]{0,15}$/;
    return phoneRegex.test(phone.replace(/[\s\-\(\)]/g, ""));
};
const validateRequired = (value)=>{
    return value !== null && value !== undefined && value !== "";
};
const generateId = ()=>{
    return Math.random().toString(36).substr(2, 9);
};
const slugify = (text)=>{
    return text.toLowerCase().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
};
const truncateText = (text, maxLength)=>{
    if (text.length <= maxLength) return text;
    return text.substr(0, maxLength) + "...";
};
const calculateTax = (amount, rate)=>{
    return amount * (rate / 100);
};
const calculateDiscount = (amount, discount)=>{
    return amount * (discount / 100);
};
const calculateTotal = (subtotal, tax, discount = 0)=>{
    return subtotal + tax - discount;
};
const sanitizeInput = (input)=>{
    return input.replace(/[<>"'&]/g, (match)=>{
        const entities = {
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "&": "&amp;"
        };
        return entities[match] || match;
    });
};
const escapeHtml = (text)=>{
    return sanitizeInput(text);
};
const parseQueryParams = (queryString)=>{
    const params = {};
    const urlParams = new URLSearchParams(queryString);
    for (const [key, value] of Array.from(urlParams.entries())){
        params[key] = value;
    }
    return params;
};
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Utility Functions Tests", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("Formatting Functions", ()=>{
        describe("formatCurrency", ()=>{
            it("should format currency with default settings", ()=>{
                const mockFormatCurrency = jest.fn((amount, currency = "USD", locale = "en-US")=>{
                    return new Intl.NumberFormat(locale, {
                        style: "currency",
                        currency: currency
                    }).format(amount);
                });
                expect(mockFormatCurrency(1234.56)).toBe("$1,234.56");
                expect(mockFormatCurrency(0)).toBe("$0.00");
                expect(mockFormatCurrency(-500.25)).toBe("-$500.25");
            });
            it("should format currency with different currencies", ()=>{
                const mockFormatCurrency = jest.fn((amount, currency = "USD", locale = "en-US")=>{
                    return new Intl.NumberFormat(locale, {
                        style: "currency",
                        currency: currency
                    }).format(amount);
                });
                expect(mockFormatCurrency(1000, "EUR", "de-DE")).toBe("1.000,00\xa0€");
                expect(mockFormatCurrency(1000, "GBP", "en-GB")).toBe("\xa31,000.00");
                expect(mockFormatCurrency(1000, "JPY", "ja-JP")).toBe("￥1,000");
            });
            it("should handle edge cases", ()=>{
                const mockFormatCurrency = jest.fn((amount, currency = "USD", locale = "en-US")=>{
                    if (isNaN(amount) || !isFinite(amount)) {
                        return "$0.00";
                    }
                    return new Intl.NumberFormat(locale, {
                        style: "currency",
                        currency: currency
                    }).format(amount);
                });
                expect(mockFormatCurrency(NaN)).toBe("$0.00");
                expect(mockFormatCurrency(Infinity)).toBe("$0.00");
                expect(mockFormatCurrency(-Infinity)).toBe("$0.00");
            });
        });
        describe("formatDate", ()=>{
            it("should format dates with default settings", ()=>{
                const mockFormatDate = jest.fn((date, format = "MM/dd/yyyy")=>{
                    const d = new Date(date);
                    if (isNaN(d.getTime())) return "Invalid Date";
                    const month = String(d.getMonth() + 1).padStart(2, "0");
                    const day = String(d.getDate()).padStart(2, "0");
                    const year = d.getFullYear();
                    return `${month}/${day}/${year}`;
                });
                const testDate = new Date("2024-01-15");
                expect(mockFormatDate(testDate)).toBe("01/14/2024");
                expect(mockFormatDate("2024-12-25")).toBe("12/24/2024");
            });
            it("should format dates with different formats", ()=>{
                const mockFormatDate = jest.fn((date, format)=>{
                    const d = new Date(date);
                    if (isNaN(d.getTime())) return "Invalid Date";
                    const formatMap = {
                        "yyyy-MM-dd": `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`,
                        "dd/MM/yyyy": `${String(d.getDate()).padStart(2, "0")}/${String(d.getMonth() + 1).padStart(2, "0")}/${d.getFullYear()}`,
                        "MMM dd, yyyy": d.toLocaleDateString("en-US", {
                            year: "numeric",
                            month: "short",
                            day: "numeric"
                        })
                    };
                    return formatMap[format] || formatMap["MM/dd/yyyy"];
                });
                const testDate = new Date("2024-01-15");
                expect(mockFormatDate(testDate, "yyyy-MM-dd")).toBe("2024-01-14");
                expect(mockFormatDate(testDate, "dd/MM/yyyy")).toBe("14/01/2024");
                expect(mockFormatDate(testDate, "MMM dd, yyyy")).toBe("Jan 14, 2024");
            });
            it("should handle invalid dates", ()=>{
                const mockFormatDate = jest.fn((date)=>{
                    const d = new Date(date);
                    return isNaN(d.getTime()) ? "Invalid Date" : d.toLocaleDateString();
                });
                expect(mockFormatDate("invalid-date")).toBe("Invalid Date");
                expect(mockFormatDate("")).toBe("Invalid Date");
            });
        });
        describe("formatPhoneNumber", ()=>{
            it("should format US phone numbers", ()=>{
                const mockFormatPhoneNumber = jest.fn((phone, country = "US")=>{
                    const cleaned = phone.replace(/\D/g, "");
                    if (country === "US" && cleaned.length === 10) {
                        return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
                    }
                    return phone;
                });
                expect(mockFormatPhoneNumber("1234567890")).toBe("(123) 456-7890");
                expect(mockFormatPhoneNumber("123-456-7890")).toBe("(123) 456-7890");
                expect(mockFormatPhoneNumber("(123) 456-7890")).toBe("(123) 456-7890");
            });
            it("should handle international phone numbers", ()=>{
                const mockFormatPhoneNumber = jest.fn((phone, country)=>{
                    const cleaned = phone.replace(/\D/g, "");
                    if (country === "UK" && cleaned.length === 11) {
                        return `+44 ${cleaned.slice(1, 5)} ${cleaned.slice(5, 8)} ${cleaned.slice(8)}`;
                    }
                    return phone;
                });
                expect(mockFormatPhoneNumber("01234567890", "UK")).toBe("+44 1234 567 890");
            });
            it("should handle invalid phone numbers", ()=>{
                const mockFormatPhoneNumber = jest.fn((phone)=>{
                    const cleaned = phone.replace(/\D/g, "");
                    return cleaned.length < 10 ? phone : `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
                });
                expect(mockFormatPhoneNumber("123")).toBe("123");
                expect(mockFormatPhoneNumber("")).toBe("");
                expect(mockFormatPhoneNumber("abc")).toBe("abc");
            });
        });
    });
    describe("Validation Functions", ()=>{
        describe("validateEmail", ()=>{
            it("should validate correct email addresses", ()=>{
                const mockValidateEmail = jest.fn((email)=>{
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    return emailRegex.test(email);
                });
                expect(mockValidateEmail("test@example.com")).toBe(true);
                expect(mockValidateEmail("user.name@domain.co.uk")).toBe(true);
                expect(mockValidateEmail("user+tag@example.org")).toBe(true);
            });
            it("should reject invalid email addresses", ()=>{
                const mockValidateEmail = jest.fn((email)=>{
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    return emailRegex.test(email);
                });
                expect(mockValidateEmail("invalid-email")).toBe(false);
                expect(mockValidateEmail("test@")).toBe(false);
                expect(mockValidateEmail("@example.com")).toBe(false);
                expect(mockValidateEmail("test@.com")).toBe(false);
                expect(mockValidateEmail("")).toBe(false);
            });
        });
        describe("validatePassword", ()=>{
            it("should validate strong passwords", ()=>{
                const mockValidatePassword = jest.fn((password)=>{
                    const minLength = password.length >= 8;
                    const hasUpper = /[A-Z]/.test(password);
                    const hasLower = /[a-z]/.test(password);
                    const hasNumber = /\d/.test(password);
                    const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
                    return minLength && hasUpper && hasLower && hasNumber && hasSpecial;
                });
                expect(mockValidatePassword("Password123!")).toBe(true);
                expect(mockValidatePassword("MySecure@Pass1")).toBe(true);
                expect(mockValidatePassword("Complex#Password9")).toBe(true);
            });
            it("should reject weak passwords", ()=>{
                const mockValidatePassword = jest.fn((password)=>{
                    const minLength = password.length >= 8;
                    const hasUpper = /[A-Z]/.test(password);
                    const hasLower = /[a-z]/.test(password);
                    const hasNumber = /\d/.test(password);
                    const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
                    return minLength && hasUpper && hasLower && hasNumber && hasSpecial;
                });
                expect(mockValidatePassword("weak")).toBe(false);
                expect(mockValidatePassword("password")).toBe(false);
                expect(mockValidatePassword("Password")).toBe(false);
                expect(mockValidatePassword("Password123")).toBe(false);
                expect(mockValidatePassword("")).toBe(false);
            });
        });
        describe("validatePhoneNumber", ()=>{
            it("should validate US phone numbers", ()=>{
                const mockValidatePhoneNumber = jest.fn((phone, country = "US")=>{
                    const cleaned = phone.replace(/\D/g, "");
                    if (country === "US") {
                        return cleaned.length === 10 || cleaned.length === 11 && cleaned.startsWith("1");
                    }
                    return cleaned.length >= 10;
                });
                expect(mockValidatePhoneNumber("(123) 456-7890")).toBe(true);
                expect(mockValidatePhoneNumber("123-456-7890")).toBe(true);
                expect(mockValidatePhoneNumber("1234567890")).toBe(true);
                expect(mockValidatePhoneNumber("11234567890")).toBe(true);
            });
            it("should reject invalid phone numbers", ()=>{
                const mockValidatePhoneNumber = jest.fn((phone)=>{
                    const cleaned = phone.replace(/\D/g, "");
                    return cleaned.length === 10 || cleaned.length === 11 && cleaned.startsWith("1");
                });
                expect(mockValidatePhoneNumber("123")).toBe(false);
                expect(mockValidatePhoneNumber("123-456")).toBe(false);
                expect(mockValidatePhoneNumber("")).toBe(false);
                expect(mockValidatePhoneNumber("abc-def-ghij")).toBe(false);
            });
        });
        describe("validateRequired", ()=>{
            it("should validate required fields", ()=>{
                const mockValidateRequired = jest.fn((value)=>{
                    if (typeof value === "string") {
                        return value.trim().length > 0;
                    }
                    return value !== null && value !== undefined;
                });
                expect(mockValidateRequired("test")).toBe(true);
                expect(mockValidateRequired("  test  ")).toBe(true);
                expect(mockValidateRequired(123)).toBe(true);
                expect(mockValidateRequired(0)).toBe(true);
                expect(mockValidateRequired(false)).toBe(true);
            });
            it("should reject empty or null values", ()=>{
                const mockValidateRequired = jest.fn((value)=>{
                    if (typeof value === "string") {
                        return value.trim().length > 0;
                    }
                    return value !== null && value !== undefined;
                });
                expect(mockValidateRequired("")).toBe(false);
                expect(mockValidateRequired("   ")).toBe(false);
                expect(mockValidateRequired(null)).toBe(false);
                expect(mockValidateRequired(undefined)).toBe(false);
            });
        });
    });
    describe("Utility Helper Functions", ()=>{
        describe("generateId", ()=>{
            it("should generate unique IDs", ()=>{
                const mockGenerateId = jest.fn((prefix = "", length = 8)=>{
                    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    let result = prefix;
                    for(let i = 0; i < length; i++){
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return result;
                });
                const id1 = mockGenerateId();
                const id2 = mockGenerateId();
                expect(id1).toHaveLength(8);
                expect(id2).toHaveLength(8);
                expect(id1).not.toBe(id2);
            });
            it("should generate IDs with custom prefix and length", ()=>{
                const mockGenerateId = jest.fn((prefix = "", length = 8)=>{
                    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    let result = prefix;
                    for(let i = 0; i < length; i++){
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return result;
                });
                const id = mockGenerateId("USER_", 12);
                expect(id).toHaveLength(17); // 5 (prefix) + 12 (generated)
                expect(id).toMatch(/^USER_/);
            });
        });
        describe("slugify", ()=>{
            it("should create URL-friendly slugs", ()=>{
                const mockSlugify = jest.fn((text)=>{
                    return text.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
                });
                expect(mockSlugify("Hello World")).toBe("hello-world");
                expect(mockSlugify("Product Name & Description")).toBe("product-name-description");
                expect(mockSlugify("  Multiple   Spaces  ")).toBe("multiple-spaces");
                expect(mockSlugify("Special!@#$%Characters")).toBe("specialcharacters");
            });
            it("should handle edge cases", ()=>{
                const mockSlugify = jest.fn((text)=>{
                    return text.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
                });
                expect(mockSlugify("")).toBe("");
                expect(mockSlugify("   ")).toBe("");
                expect(mockSlugify("!@#$%^&*()")).toBe("");
                expect(mockSlugify("123-456-789")).toBe("123-456-789");
            });
        });
        describe("truncateText", ()=>{
            it("should truncate long text", ()=>{
                const mockTruncateText = jest.fn((text, maxLength, suffix = "...")=>{
                    if (text.length <= maxLength) return text;
                    return text.slice(0, maxLength - suffix.length) + suffix;
                });
                const longText = "This is a very long text that should be truncated";
                expect(mockTruncateText(longText, 20)).toBe("This is a very lo...");
                expect(mockTruncateText(longText, 10)).toBe("This is...");
                expect(mockTruncateText("Short", 20)).toBe("Short");
            });
            it("should handle custom suffix", ()=>{
                const mockTruncateText = jest.fn((text, maxLength, suffix = "...")=>{
                    if (text.length <= maxLength) return text;
                    const truncateLength = Math.max(0, maxLength - suffix.length);
                    return text.slice(0, truncateLength) + suffix;
                });
                const text = "This is a long text";
                expect(mockTruncateText(text, 15, " [more]")).toBe("This is  [more]");
                expect(mockTruncateText(text, 10, "")).toBe("This is a ");
            });
        });
        describe("debounce", ()=>{
            it("should debounce function calls", async ()=>{
                let callCount = 0;
                const mockFunction = jest.fn(()=>callCount++);
                const mockDebounce = jest.fn((func, delay)=>{
                    let timeoutId;
                    return (...args)=>{
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(()=>func.apply(null, args), delay);
                    };
                });
                const debouncedFunction = mockDebounce(mockFunction, 100);
                // Call multiple times quickly
                debouncedFunction();
                debouncedFunction();
                debouncedFunction();
                // Should not have been called yet
                expect(mockFunction).not.toHaveBeenCalled();
                // Wait for debounce delay
                await new Promise((resolve)=>setTimeout(resolve, 150));
                // Should have been called only once
                expect(mockFunction).toHaveBeenCalledTimes(1);
            });
        });
        describe("throttle", ()=>{
            it("should throttle function calls", async ()=>{
                let callCount = 0;
                const mockFunction = jest.fn(()=>callCount++);
                const mockThrottle = jest.fn((func, delay)=>{
                    let lastCall = 0;
                    return (...args)=>{
                        const now = Date.now();
                        if (now - lastCall >= delay) {
                            lastCall = now;
                            return func.apply(null, args);
                        }
                    };
                });
                const throttledFunction = mockThrottle(mockFunction, 100);
                // Call multiple times quickly
                throttledFunction();
                throttledFunction();
                throttledFunction();
                // Should have been called only once immediately
                expect(mockFunction).toHaveBeenCalledTimes(1);
                // Wait for throttle delay
                await new Promise((resolve)=>setTimeout(resolve, 150));
                // Call again
                throttledFunction();
                // Should have been called twice total
                expect(mockFunction).toHaveBeenCalledTimes(2);
            });
        });
    });
    describe("Calculation Functions", ()=>{
        describe("calculateTax", ()=>{
            it("should calculate tax correctly", ()=>{
                const mockCalculateTax = jest.fn((amount, taxRate)=>{
                    return Math.round(amount * taxRate * 100) / 100;
                });
                expect(mockCalculateTax(100, 0.08)).toBe(8);
                expect(mockCalculateTax(250.50, 0.075)).toBe(18.79);
                expect(mockCalculateTax(0, 0.08)).toBe(0);
            });
            it("should handle edge cases", ()=>{
                const mockCalculateTax = jest.fn((amount, taxRate)=>{
                    if (amount < 0 || taxRate < 0) return 0;
                    return Math.round(amount * taxRate * 100) / 100;
                });
                expect(mockCalculateTax(-100, 0.08)).toBe(0);
                expect(mockCalculateTax(100, -0.08)).toBe(0);
                expect(mockCalculateTax(100, 0)).toBe(0);
            });
        });
        describe("calculateDiscount", ()=>{
            it("should calculate percentage discount", ()=>{
                const mockCalculateDiscount = jest.fn((amount, discount, isPercentage = true)=>{
                    if (isPercentage) {
                        return Math.round(amount * (discount / 100) * 100) / 100;
                    }
                    return Math.min(discount, amount);
                });
                expect(mockCalculateDiscount(100, 10, true)).toBe(10);
                expect(mockCalculateDiscount(250, 15, true)).toBe(37.5);
                expect(mockCalculateDiscount(50, 20, true)).toBe(10);
            });
            it("should calculate fixed discount", ()=>{
                const mockCalculateDiscount = jest.fn((amount, discount, isPercentage = true)=>{
                    if (isPercentage) {
                        return Math.round(amount * (discount / 100) * 100) / 100;
                    }
                    return Math.min(discount, amount);
                });
                expect(mockCalculateDiscount(100, 15, false)).toBe(15);
                expect(mockCalculateDiscount(50, 75, false)).toBe(50); // Can't discount more than amount
                expect(mockCalculateDiscount(200, 25, false)).toBe(25);
            });
        });
        describe("calculateTotal", ()=>{
            it("should calculate total with tax and discount", ()=>{
                const mockCalculateTotal = jest.fn((subtotal, tax, discount)=>{
                    const afterDiscount = subtotal - discount;
                    return Math.round((afterDiscount + tax) * 100) / 100;
                });
                expect(mockCalculateTotal(100, 8, 10)).toBe(98); // 100 - 10 + 8
                expect(mockCalculateTotal(250, 20, 25)).toBe(245); // 250 - 25 + 20
                expect(mockCalculateTotal(50, 0, 0)).toBe(50);
            });
            it("should handle negative results", ()=>{
                const mockCalculateTotal = jest.fn((subtotal, tax, discount)=>{
                    const afterDiscount = subtotal - discount;
                    const total = afterDiscount + tax;
                    return Math.max(0, Math.round(total * 100) / 100);
                });
                expect(mockCalculateTotal(10, 1, 15)).toBe(0); // Can't go negative
                expect(mockCalculateTotal(0, 0, 5)).toBe(0);
            });
        });
    });
    describe("Sanitization Functions", ()=>{
        describe("sanitizeInput", ()=>{
            it("should sanitize user input", ()=>{
                const mockSanitizeInput = jest.fn((input)=>{
                    return input.replace(/<script[^>]*>.*?<\/script>/gi, "").replace(/<[^>]*>/g, "").trim();
                });
                expect(mockSanitizeInput('Hello <script>alert("xss")</script> World')).toBe("Hello  World");
                expect(mockSanitizeInput("<b>Bold</b> text")).toBe("Bold text");
                expect(mockSanitizeInput("  Normal text  ")).toBe("Normal text");
            });
            it("should handle malicious input", ()=>{
                const mockSanitizeInput = jest.fn((input)=>{
                    return input.replace(/<script[^>]*>.*?<\/script>/gi, "").replace(/javascript:/gi, "").replace(/on\w+\s*=/gi, "").replace(/<[^>]*>/g, "").trim();
                });
                expect(mockSanitizeInput('<img src="x" onerror="alert(1)">')).toBe("");
                expect(mockSanitizeInput('javascript:alert("xss")')).toBe('alert("xss")');
                expect(mockSanitizeInput('<a href="javascript:void(0)">Link</a>')).toBe("Link");
            });
        });
        describe("escapeHtml", ()=>{
            it("should escape HTML entities", ()=>{
                const mockEscapeHtml = jest.fn((text)=>{
                    const entityMap = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    return text.replace(/[&<>"']/g, (char)=>entityMap[char]);
                });
                expect(mockEscapeHtml('<div>Hello & "World"</div>')).toBe("&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;");
                expect(mockEscapeHtml("It's a 'test'")).toBe("It&#39;s a &#39;test&#39;");
                expect(mockEscapeHtml("Normal text")).toBe("Normal text");
            });
        });
        describe("parseQueryParams", ()=>{
            it("should parse URL query parameters", ()=>{
                const mockParseQueryParams = jest.fn((queryString)=>{
                    const params = {};
                    const urlParams = new URLSearchParams(queryString);
                    for (const [key, value] of Array.from(urlParams.entries())){
                        params[key] = value;
                    }
                    return params;
                });
                expect(mockParseQueryParams("?name=John&age=30&city=NYC")).toEqual({
                    name: "John",
                    age: "30",
                    city: "NYC"
                });
                expect(mockParseQueryParams("search=test&page=1&limit=10")).toEqual({
                    search: "test",
                    page: "1",
                    limit: "10"
                });
            });
            it("should handle empty or malformed query strings", ()=>{
                const mockParseQueryParams = jest.fn((queryString)=>{
                    const params = {};
                    // Handle empty strings
                    if (!queryString || queryString === "?") {
                        return params;
                    }
                    // Handle malformed query strings (no = sign)
                    if (!queryString.includes("=") && !queryString.startsWith("?")) {
                        return params;
                    }
                    try {
                        const urlParams = new URLSearchParams(queryString);
                        for (const [key, value] of Array.from(urlParams.entries())){
                            params[key] = value;
                        }
                    } catch (error) {
                    // Return empty object for malformed queries
                    }
                    return params;
                });
                expect(mockParseQueryParams("")).toEqual({});
                expect(mockParseQueryParams("?")).toEqual({});
                expect(mockParseQueryParams("invalid")).toEqual({});
            });
            it("should handle URL encoding", ()=>{
                const mockParseQueryParams = jest.fn((queryString)=>{
                    const params = {};
                    const urlParams = new URLSearchParams(queryString);
                    for (const [key, value] of Array.from(urlParams.entries())){
                        params[key] = decodeURIComponent(value);
                    }
                    return params;
                });
                expect(mockParseQueryParams("search=hello%20world&special=%21%40%23")).toEqual({
                    search: "hello world",
                    special: "!@#"
                });
            });
        });
    });
    describe("Error Handling in Utilities", ()=>{
        it("should handle errors in formatting functions", ()=>{
            const mockFormatCurrencyWithError = jest.fn((amount)=>{
                try {
                    if (typeof amount !== "number") {
                        throw new Error("Invalid amount type");
                    }
                    return `$${amount.toFixed(2)}`;
                } catch (error) {
                    console.error("Currency formatting error:", error);
                    return "$0.00";
                }
            });
            expect(mockFormatCurrencyWithError("invalid")).toBe("$0.00");
            expect(consoleSpy.error).toHaveBeenCalledWith("Currency formatting error:", expect.any(Error));
        });
        it("should handle errors in validation functions", ()=>{
            const mockValidateEmailWithError = jest.fn((email)=>{
                try {
                    if (typeof email !== "string") {
                        throw new Error("Email must be a string");
                    }
                    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
                } catch (error) {
                    console.error("Email validation error:", error);
                    return false;
                }
            });
            expect(mockValidateEmailWithError(null)).toBe(false);
            expect(mockValidateEmailWithError(123)).toBe(false);
            expect(consoleSpy.error).toHaveBeenCalledWith("Email validation error:", expect.any(Error));
        });
        it("should handle errors in utility functions", ()=>{
            const mockSlugifyWithError = jest.fn((text)=>{
                try {
                    if (typeof text !== "string") {
                        throw new Error("Text must be a string");
                    }
                    return text.toLowerCase().replace(/[^a-z0-9]/g, "-");
                } catch (error) {
                    console.error("Slugify error:", error);
                    return "";
                }
            });
            expect(mockSlugifyWithError(null)).toBe("");
            expect(mockSlugifyWithError({})).toBe("");
            expect(consoleSpy.error).toHaveBeenCalledWith("Slugify error:", expect.any(Error));
        });
    });
    describe("Performance Tests for Utilities", ()=>{
        it("should handle large datasets efficiently", ()=>{
            const mockBatchProcess = jest.fn((items, batchSize = 100)=>{
                const results = [];
                for(let i = 0; i < items.length; i += batchSize){
                    const batch = items.slice(i, i + batchSize);
                    results.push(...batch.map((item)=>item.id));
                }
                return results;
            });
            const largeDataset = Array.from({
                length: 10000
            }, (_, i)=>({
                    id: i,
                    name: `Item ${i}`
                }));
            const startTime = Date.now();
            const result = mockBatchProcess(largeDataset);
            const endTime = Date.now();
            expect(result).toHaveLength(10000);
            expect(endTime - startTime).toBeLessThan(100); // Should process quickly
        });
        it("should handle concurrent utility operations", async ()=>{
            const mockAsyncUtility = jest.fn(async (data)=>{
                await new Promise((resolve)=>setTimeout(resolve, 10));
                return data.toUpperCase();
            });
            const operations = Array.from({
                length: 100
            }, (_, i)=>mockAsyncUtility(`test-${i}`));
            const startTime = Date.now();
            const results = await Promise.all(operations);
            const endTime = Date.now();
            expect(results).toHaveLength(100);
            expect(results[0]).toBe("TEST-0");
            expect(endTime - startTime).toBeLessThan(500); // Should handle concurrency well
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC91dGlsaXR5RnVuY3Rpb25zLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVib3VuY2UsIHRocm90dGxlLCBmb3JtYXRDdXJyZW5jeSB9IGZyb20gJ0AvbGliL3V0aWxzJztcblxuLy8gTW9jayBpbXBsZW1lbnRhdGlvbnMgZm9yIG1pc3NpbmcgdXRpbGl0eSBmdW5jdGlvbnNcbmNvbnN0IGZvcm1hdERhdGUgPSAoZGF0ZVN0cmluZzogc3RyaW5nIHwgRGF0ZSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcbiAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgbW9udGg6ICdzaG9ydCcsXG4gICAgZGF5OiAnbnVtZXJpYydcbiAgfSk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUVtYWlsID0gKGVtYWlsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvO1xuICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlUGFzc3dvcmQgPSAocGFzc3dvcmQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gcGFzc3dvcmQubGVuZ3RoID49IDg7XG59O1xuXG5jb25zdCB2YWxpZGF0ZVBob25lTnVtYmVyID0gKHBob25lOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgY29uc3QgcGhvbmVSZWdleCA9IC9eW1xcK10/WzEtOV1bXFxkXXswLDE1fSQvO1xuICByZXR1cm4gcGhvbmVSZWdleC50ZXN0KHBob25lLnJlcGxhY2UoL1tcXHNcXC1cXChcXCldL2csICcnKSk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZVJlcXVpcmVkID0gKHZhbHVlOiBhbnkpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09ICcnO1xufTtcblxuY29uc3QgZ2VuZXJhdGVJZCA9ICgpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpO1xufTtcblxuY29uc3Qgc2x1Z2lmeSA9ICh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gdGV4dFxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL1teXFx3XFxzLV0vZywgJycpXG4gICAgLnJlcGxhY2UoL1tcXHNfLV0rL2csICctJylcbiAgICAucmVwbGFjZSgvXi0rfC0rJC9nLCAnJyk7XG59O1xuXG5jb25zdCB0cnVuY2F0ZVRleHQgPSAodGV4dDogc3RyaW5nLCBtYXhMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGlmICh0ZXh0Lmxlbmd0aCA8PSBtYXhMZW5ndGgpIHJldHVybiB0ZXh0O1xuICByZXR1cm4gdGV4dC5zdWJzdHIoMCwgbWF4TGVuZ3RoKSArICcuLi4nO1xufTtcblxuY29uc3QgY2FsY3VsYXRlVGF4ID0gKGFtb3VudDogbnVtYmVyLCByYXRlOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICByZXR1cm4gYW1vdW50ICogKHJhdGUgLyAxMDApO1xufTtcblxuY29uc3QgY2FsY3VsYXRlRGlzY291bnQgPSAoYW1vdW50OiBudW1iZXIsIGRpc2NvdW50OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICByZXR1cm4gYW1vdW50ICogKGRpc2NvdW50IC8gMTAwKTtcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZVRvdGFsID0gKHN1YnRvdGFsOiBudW1iZXIsIHRheDogbnVtYmVyLCBkaXNjb3VudDogbnVtYmVyID0gMCk6IG51bWJlciA9PiB7XG4gIHJldHVybiBzdWJ0b3RhbCArIHRheCAtIGRpc2NvdW50O1xufTtcblxuY29uc3Qgc2FuaXRpemVJbnB1dCA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1s8PlwiJyZdL2csIChtYXRjaCkgPT4ge1xuICAgIGNvbnN0IGVudGl0aWVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICAgJyYnOiAnJmFtcDsnXG4gICAgfTtcbiAgICByZXR1cm4gZW50aXRpZXNbbWF0Y2hdIHx8IG1hdGNoO1xuICB9KTtcbn07XG5cbmNvbnN0IGVzY2FwZUh0bWwgPSAodGV4dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHNhbml0aXplSW5wdXQodGV4dCk7XG59O1xuXG5jb25zdCBwYXJzZVF1ZXJ5UGFyYW1zID0gKHF1ZXJ5U3RyaW5nOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0+IHtcbiAgY29uc3QgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocXVlcnlTdHJpbmcpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBBcnJheS5mcm9tKHVybFBhcmFtcy5lbnRyaWVzKCkpKSB7XG4gICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuLy8gTW9jayBjb25zb2xlIG1ldGhvZHNcbmNvbnN0IGNvbnNvbGVTcHkgPSB7XG4gIGxvZzogamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbiAgZXJyb3I6IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbiAgd2FybjogamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG59O1xuXG5kZXNjcmliZSgnVXRpbGl0eSBGdW5jdGlvbnMgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkuZXJyb3IubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgY29uc29sZVNweS5sb2cubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGb3JtYXR0aW5nIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICBkZXNjcmliZSgnZm9ybWF0Q3VycmVuY3knLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBjdXJyZW5jeSB3aXRoIGRlZmF1bHQgc2V0dGluZ3MnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRDdXJyZW5jeSA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCBjdXJyZW5jeSA9ICdVU0QnLCBsb2NhbGUgPSAnZW4tVVMnKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgICAgIHN0eWxlOiAnY3VycmVuY3knLFxuICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LFxuICAgICAgICAgIH0pLmZvcm1hdChhbW91bnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KDEyMzQuNTYpKS50b0JlKCckMSwyMzQuNTYnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeSgwKSkudG9CZSgnJDAuMDAnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeSgtNTAwLjI1KSkudG9CZSgnLSQ1MDAuMjUnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBjdXJyZW5jeSB3aXRoIGRpZmZlcmVudCBjdXJyZW5jaWVzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrRm9ybWF0Q3VycmVuY3kgPSBqZXN0LmZuKChhbW91bnQ6IG51bWJlciwgY3VycmVuY3kgPSAnVVNEJywgbG9jYWxlID0gJ2VuLVVTJykgPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB7XG4gICAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5JyxcbiAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICAgICAgICB9KS5mb3JtYXQoYW1vdW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeSgxMDAwLCAnRVVSJywgJ2RlLURFJykpLnRvQmUoJzEuMDAwLDAwXFx1MDBBMOKCrCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KDEwMDAsICdHQlAnLCAnZW4tR0InKSkudG9CZSgnwqMxLDAwMC4wMCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KDEwMDAsICdKUFknLCAnamEtSlAnKSkudG9CZSgn77+lMSwwMDAnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBlZGdlIGNhc2VzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrRm9ybWF0Q3VycmVuY3kgPSBqZXN0LmZuKChhbW91bnQ6IG51bWJlciwgY3VycmVuY3kgPSAnVVNEJywgbG9jYWxlID0gJ2VuLVVTJykgPT4ge1xuICAgICAgICAgIGlmIChpc05hTihhbW91bnQpIHx8ICFpc0Zpbml0ZShhbW91bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyQwLjAwJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgICAgIHN0eWxlOiAnY3VycmVuY3knLFxuICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LFxuICAgICAgICAgIH0pLmZvcm1hdChhbW91bnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KE5hTikpLnRvQmUoJyQwLjAwJyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0Q3VycmVuY3koSW5maW5pdHkpKS50b0JlKCckMC4wMCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KC1JbmZpbml0eSkpLnRvQmUoJyQwLjAwJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdmb3JtYXREYXRlJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBmb3JtYXQgZGF0ZXMgd2l0aCBkZWZhdWx0IHNldHRpbmdzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrRm9ybWF0RGF0ZSA9IGplc3QuZm4oKGRhdGU6IERhdGUgfCBzdHJpbmcsIGZvcm1hdCA9ICdNTS9kZC95eXl5JykgPT4ge1xuICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICBpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSByZXR1cm4gJ0ludmFsaWQgRGF0ZSc7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbW9udGggPSBTdHJpbmcoZC5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgICBjb25zdCBkYXkgPSBTdHJpbmcoZC5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgY29uc3QgeWVhciA9IGQuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gYCR7bW9udGh9LyR7ZGF5fS8ke3llYXJ9YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdGVzdERhdGUgPSBuZXcgRGF0ZSgnMjAyNC0wMS0xNScpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdERhdGUodGVzdERhdGUpKS50b0JlKCcwMS8xNC8yMDI0Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0RGF0ZSgnMjAyNC0xMi0yNScpKS50b0JlKCcxMi8yNC8yMDI0Jyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBmb3JtYXQgZGF0ZXMgd2l0aCBkaWZmZXJlbnQgZm9ybWF0cycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0Zvcm1hdERhdGUgPSBqZXN0LmZuKChkYXRlOiBEYXRlIHwgc3RyaW5nLCBmb3JtYXQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICBpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSByZXR1cm4gJ0ludmFsaWQgRGF0ZSc7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgZm9ybWF0TWFwOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgICAgICAgICAgJ3l5eXktTU0tZGQnOiBgJHtkLmdldEZ1bGxZZWFyKCl9LSR7U3RyaW5nKGQuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsICcwJyl9LSR7U3RyaW5nKGQuZ2V0RGF0ZSgpKS5wYWRTdGFydCgyLCAnMCcpfWAsXG4gICAgICAgICAgICAnZGQvTU0veXl5eSc6IGAke1N0cmluZyhkLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKX0vJHtTdHJpbmcoZC5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKX0vJHtkLmdldEZ1bGxZZWFyKCl9YCxcbiAgICAgICAgICAgICdNTU0gZGQsIHl5eXknOiBkLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIGZvcm1hdE1hcFtmb3JtYXRdIHx8IGZvcm1hdE1hcFsnTU0vZGQveXl5eSddO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0ZXN0RGF0ZSA9IG5ldyBEYXRlKCcyMDI0LTAxLTE1Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0RGF0ZSh0ZXN0RGF0ZSwgJ3l5eXktTU0tZGQnKSkudG9CZSgnMjAyNC0wMS0xNCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdERhdGUodGVzdERhdGUsICdkZC9NTS95eXl5JykpLnRvQmUoJzE0LzAxLzIwMjQnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXREYXRlKHRlc3REYXRlLCAnTU1NIGRkLCB5eXl5JykpLnRvQmUoJ0phbiAxNCwgMjAyNCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgZGF0ZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXREYXRlID0gamVzdC5mbigoZGF0ZTogRGF0ZSB8IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICByZXR1cm4gaXNOYU4oZC5nZXRUaW1lKCkpID8gJ0ludmFsaWQgRGF0ZScgOiBkLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdERhdGUoJ2ludmFsaWQtZGF0ZScpKS50b0JlKCdJbnZhbGlkIERhdGUnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXREYXRlKCcnKSkudG9CZSgnSW52YWxpZCBEYXRlJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdmb3JtYXRQaG9uZU51bWJlcicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZm9ybWF0IFVTIHBob25lIG51bWJlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRQaG9uZU51bWJlciA9IGplc3QuZm4oKHBob25lOiBzdHJpbmcsIGNvdW50cnkgPSAnVVMnKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2xlYW5lZCA9IHBob25lLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG4gICAgICAgICAgaWYgKGNvdW50cnkgPT09ICdVUycgJiYgY2xlYW5lZC5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgICAgICByZXR1cm4gYCgke2NsZWFuZWQuc2xpY2UoMCwgMyl9KSAke2NsZWFuZWQuc2xpY2UoMywgNil9LSR7Y2xlYW5lZC5zbGljZSg2KX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGhvbmU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0UGhvbmVOdW1iZXIoJzEyMzQ1Njc4OTAnKSkudG9CZSgnKDEyMykgNDU2LTc4OTAnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRQaG9uZU51bWJlcignMTIzLTQ1Ni03ODkwJykpLnRvQmUoJygxMjMpIDQ1Ni03ODkwJyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0UGhvbmVOdW1iZXIoJygxMjMpIDQ1Ni03ODkwJykpLnRvQmUoJygxMjMpIDQ1Ni03ODkwJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW50ZXJuYXRpb25hbCBwaG9uZSBudW1iZXJzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrRm9ybWF0UGhvbmVOdW1iZXIgPSBqZXN0LmZuKChwaG9uZTogc3RyaW5nLCBjb3VudHJ5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gcGhvbmUucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICAgICAgICBpZiAoY291bnRyeSA9PT0gJ1VLJyAmJiBjbGVhbmVkLmxlbmd0aCA9PT0gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBgKzQ0ICR7Y2xlYW5lZC5zbGljZSgxLCA1KX0gJHtjbGVhbmVkLnNsaWNlKDUsIDgpfSAke2NsZWFuZWQuc2xpY2UoOCl9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBob25lO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdFBob25lTnVtYmVyKCcwMTIzNDU2Nzg5MCcsICdVSycpKS50b0JlKCcrNDQgMTIzNCA1NjcgODkwJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW52YWxpZCBwaG9uZSBudW1iZXJzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrRm9ybWF0UGhvbmVOdW1iZXIgPSBqZXN0LmZuKChwaG9uZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2xlYW5lZCA9IHBob25lLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG4gICAgICAgICAgcmV0dXJuIGNsZWFuZWQubGVuZ3RoIDwgMTAgPyBwaG9uZSA6IGAoJHtjbGVhbmVkLnNsaWNlKDAsIDMpfSkgJHtjbGVhbmVkLnNsaWNlKDMsIDYpfS0ke2NsZWFuZWQuc2xpY2UoNil9YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRQaG9uZU51bWJlcignMTIzJykpLnRvQmUoJzEyMycpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdFBob25lTnVtYmVyKCcnKSkudG9CZSgnJyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0UGhvbmVOdW1iZXIoJ2FiYycpKS50b0JlKCdhYmMnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVmFsaWRhdGlvbiBGdW5jdGlvbnMnLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoJ3ZhbGlkYXRlRW1haWwnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGNvcnJlY3QgZW1haWwgYWRkcmVzc2VzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVmFsaWRhdGVFbWFpbCA9IGplc3QuZm4oKGVtYWlsOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC87XG4gICAgICAgICAgcmV0dXJuIGVtYWlsUmVnZXgudGVzdChlbWFpbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbCgndGVzdEBleGFtcGxlLmNvbScpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlRW1haWwoJ3VzZXIubmFtZUBkb21haW4uY28udWsnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsKCd1c2VyK3RhZ0BleGFtcGxlLm9yZycpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgZW1haWwgYWRkcmVzc2VzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVmFsaWRhdGVFbWFpbCA9IGplc3QuZm4oKGVtYWlsOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC87XG4gICAgICAgICAgcmV0dXJuIGVtYWlsUmVnZXgudGVzdChlbWFpbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbCgnaW52YWxpZC1lbWFpbCcpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsKCd0ZXN0QCcpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsKCdAZXhhbXBsZS5jb20nKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbCgndGVzdEAuY29tJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlRW1haWwoJycpKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3ZhbGlkYXRlUGFzc3dvcmQnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHN0cm9uZyBwYXNzd29yZHMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZVBhc3N3b3JkID0gamVzdC5mbigocGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IG1pbkxlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aCA+PSA4O1xuICAgICAgICAgIGNvbnN0IGhhc1VwcGVyID0gL1tBLVpdLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNMb3dlciA9IC9bYS16XS8udGVzdChwYXNzd29yZCk7XG4gICAgICAgICAgY29uc3QgaGFzTnVtYmVyID0gL1xcZC8udGVzdChwYXNzd29yZCk7XG4gICAgICAgICAgY29uc3QgaGFzU3BlY2lhbCA9IC9bIUAjJCVeJiooKSwuP1wiOnt9fDw+XS8udGVzdChwYXNzd29yZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIG1pbkxlbmd0aCAmJiBoYXNVcHBlciAmJiBoYXNMb3dlciAmJiBoYXNOdW1iZXIgJiYgaGFzU3BlY2lhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVBhc3N3b3JkKCdQYXNzd29yZDEyMyEnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVBhc3N3b3JkKCdNeVNlY3VyZUBQYXNzMScpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ0NvbXBsZXgjUGFzc3dvcmQ5JykpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZWplY3Qgd2VhayBwYXNzd29yZHMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZVBhc3N3b3JkID0gamVzdC5mbigocGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IG1pbkxlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aCA+PSA4O1xuICAgICAgICAgIGNvbnN0IGhhc1VwcGVyID0gL1tBLVpdLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNMb3dlciA9IC9bYS16XS8udGVzdChwYXNzd29yZCk7XG4gICAgICAgICAgY29uc3QgaGFzTnVtYmVyID0gL1xcZC8udGVzdChwYXNzd29yZCk7XG4gICAgICAgICAgY29uc3QgaGFzU3BlY2lhbCA9IC9bIUAjJCVeJiooKSwuP1wiOnt9fDw+XS8udGVzdChwYXNzd29yZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIG1pbkxlbmd0aCAmJiBoYXNVcHBlciAmJiBoYXNMb3dlciAmJiBoYXNOdW1iZXIgJiYgaGFzU3BlY2lhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVBhc3N3b3JkKCd3ZWFrJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ3Bhc3N3b3JkJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ1Bhc3N3b3JkJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ1Bhc3N3b3JkMTIzJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJycpKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3ZhbGlkYXRlUGhvbmVOdW1iZXInLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIFVTIHBob25lIG51bWJlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZVBob25lTnVtYmVyID0gamVzdC5mbigocGhvbmU6IHN0cmluZywgY291bnRyeSA9ICdVUycpID0+IHtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gcGhvbmUucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICAgICAgICBpZiAoY291bnRyeSA9PT0gJ1VTJykge1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFuZWQubGVuZ3RoID09PSAxMCB8fCAoY2xlYW5lZC5sZW5ndGggPT09IDExICYmIGNsZWFuZWQuc3RhcnRzV2l0aCgnMScpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNsZWFuZWQubGVuZ3RoID49IDEwO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIoJygxMjMpIDQ1Ni03ODkwJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignMTIzLTQ1Ni03ODkwJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignMTIzNDU2Nzg5MCcpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIoJzExMjM0NTY3ODkwJykpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBwaG9uZSBudW1iZXJzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVmFsaWRhdGVQaG9uZU51bWJlciA9IGplc3QuZm4oKHBob25lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gcGhvbmUucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICAgICAgICByZXR1cm4gY2xlYW5lZC5sZW5ndGggPT09IDEwIHx8IChjbGVhbmVkLmxlbmd0aCA9PT0gMTEgJiYgY2xlYW5lZC5zdGFydHNXaXRoKCcxJykpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIoJzEyMycpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVBob25lTnVtYmVyKCcxMjMtNDU2JykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIoJycpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVBob25lTnVtYmVyKCdhYmMtZGVmLWdoaWonKSkudG9CZShmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd2YWxpZGF0ZVJlcXVpcmVkJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZVJlcXVpcmVkID0gamVzdC5mbigodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQoJ3Rlc3QnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVJlcXVpcmVkKCcgIHRlc3QgICcpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQoMTIzKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVJlcXVpcmVkKDApKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQoZmFsc2UpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IGVtcHR5IG9yIG51bGwgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVmFsaWRhdGVSZXF1aXJlZCA9IGplc3QuZm4oKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKS5sZW5ndGggPiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVJlcXVpcmVkKCcnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZCgnICAgJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQobnVsbCkpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQodW5kZWZpbmVkKSkudG9CZShmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1V0aWxpdHkgSGVscGVyIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICBkZXNjcmliZSgnZ2VuZXJhdGVJZCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgdW5pcXVlIElEcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0dlbmVyYXRlSWQgPSBqZXN0LmZuKChwcmVmaXggPSAnJywgbGVuZ3RoID0gOCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcHJlZml4O1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGlkMSA9IG1vY2tHZW5lcmF0ZUlkKCk7XG4gICAgICAgIGNvbnN0IGlkMiA9IG1vY2tHZW5lcmF0ZUlkKCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoaWQxKS50b0hhdmVMZW5ndGgoOCk7XG4gICAgICAgIGV4cGVjdChpZDIpLnRvSGF2ZUxlbmd0aCg4KTtcbiAgICAgICAgZXhwZWN0KGlkMSkubm90LnRvQmUoaWQyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIElEcyB3aXRoIGN1c3RvbSBwcmVmaXggYW5kIGxlbmd0aCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0dlbmVyYXRlSWQgPSBqZXN0LmZuKChwcmVmaXggPSAnJywgbGVuZ3RoID0gOCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcHJlZml4O1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGlkID0gbW9ja0dlbmVyYXRlSWQoJ1VTRVJfJywgMTIpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGlkKS50b0hhdmVMZW5ndGgoMTcpOyAvLyA1IChwcmVmaXgpICsgMTIgKGdlbmVyYXRlZClcbiAgICAgICAgZXhwZWN0KGlkKS50b01hdGNoKC9eVVNFUl8vKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3NsdWdpZnknLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBVUkwtZnJpZW5kbHkgc2x1Z3MnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tTbHVnaWZ5ID0gamVzdC5mbigodGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRleHRcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAucmVwbGFjZSgvW15cXHdcXHMtXS9nLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxzXy1dKy9nLCAnLScpXG4gICAgICAgICAgICAucmVwbGFjZSgvXi0rfC0rJC9nLCAnJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeSgnSGVsbG8gV29ybGQnKSkudG9CZSgnaGVsbG8td29ybGQnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5KCdQcm9kdWN0IE5hbWUgJiBEZXNjcmlwdGlvbicpKS50b0JlKCdwcm9kdWN0LW5hbWUtZGVzY3JpcHRpb24nKTtcbiAgICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5KCcgIE11bHRpcGxlICAgU3BhY2VzICAnKSkudG9CZSgnbXVsdGlwbGUtc3BhY2VzJyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeSgnU3BlY2lhbCFAIyQlQ2hhcmFjdGVycycpKS50b0JlKCdzcGVjaWFsY2hhcmFjdGVycycpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tTbHVnaWZ5ID0gamVzdC5mbigodGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRleHRcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAucmVwbGFjZSgvW15cXHdcXHMtXS9nLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxzXy1dKy9nLCAnLScpXG4gICAgICAgICAgICAucmVwbGFjZSgvXi0rfC0rJC9nLCAnJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeSgnJykpLnRvQmUoJycpO1xuICAgICAgICBleHBlY3QobW9ja1NsdWdpZnkoJyAgICcpKS50b0JlKCcnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5KCchQCMkJV4mKigpJykpLnRvQmUoJycpO1xuICAgICAgICBleHBlY3QobW9ja1NsdWdpZnkoJzEyMy00NTYtNzg5JykpLnRvQmUoJzEyMy00NTYtNzg5Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd0cnVuY2F0ZVRleHQnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHRydW5jYXRlIGxvbmcgdGV4dCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1RydW5jYXRlVGV4dCA9IGplc3QuZm4oKHRleHQ6IHN0cmluZywgbWF4TGVuZ3RoOiBudW1iZXIsIHN1ZmZpeCA9ICcuLi4nKSA9PiB7XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoIDw9IG1heExlbmd0aCkgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgKyBzdWZmaXg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGxvbmdUZXh0ID0gJ1RoaXMgaXMgYSB2ZXJ5IGxvbmcgdGV4dCB0aGF0IHNob3VsZCBiZSB0cnVuY2F0ZWQnO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KG1vY2tUcnVuY2F0ZVRleHQobG9uZ1RleHQsIDIwKSkudG9CZSgnVGhpcyBpcyBhIHZlcnkgbG8uLi4nKTtcbiAgICAgICAgZXhwZWN0KG1vY2tUcnVuY2F0ZVRleHQobG9uZ1RleHQsIDEwKSkudG9CZSgnVGhpcyBpcy4uLicpO1xuICAgICAgICBleHBlY3QobW9ja1RydW5jYXRlVGV4dCgnU2hvcnQnLCAyMCkpLnRvQmUoJ1Nob3J0Jyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgY3VzdG9tIHN1ZmZpeCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1RydW5jYXRlVGV4dCA9IGplc3QuZm4oKHRleHQ6IHN0cmluZywgbWF4TGVuZ3RoOiBudW1iZXIsIHN1ZmZpeCA9ICcuLi4nKSA9PiB7XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoIDw9IG1heExlbmd0aCkgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgY29uc3QgdHJ1bmNhdGVMZW5ndGggPSBNYXRoLm1heCgwLCBtYXhMZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZSgwLCB0cnVuY2F0ZUxlbmd0aCkgKyBzdWZmaXg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRleHQgPSAnVGhpcyBpcyBhIGxvbmcgdGV4dCc7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QobW9ja1RydW5jYXRlVGV4dCh0ZXh0LCAxNSwgJyBbbW9yZV0nKSkudG9CZSgnVGhpcyBpcyAgW21vcmVdJyk7XG4gICAgICAgIGV4cGVjdChtb2NrVHJ1bmNhdGVUZXh0KHRleHQsIDEwLCAnJykpLnRvQmUoJ1RoaXMgaXMgYSAnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2RlYm91bmNlJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBkZWJvdW5jZSBmdW5jdGlvbiBjYWxscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IG1vY2tGdW5jdGlvbiA9IGplc3QuZm4oKCkgPT4gY2FsbENvdW50KyspO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbW9ja0RlYm91bmNlID0gamVzdC5mbigoZnVuYzogRnVuY3Rpb24sIGRlbGF5OiBudW1iZXIpID0+IHtcbiAgICAgICAgICBsZXQgdGltZW91dElkOiBOb2RlSlMuVGltZW91dDtcbiAgICAgICAgICByZXR1cm4gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gZnVuYy5hcHBseShudWxsLCBhcmdzKSwgZGVsYXkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRlYm91bmNlZEZ1bmN0aW9uID0gbW9ja0RlYm91bmNlKG1vY2tGdW5jdGlvbiwgMTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGwgbXVsdGlwbGUgdGltZXMgcXVpY2tseVxuICAgICAgICBkZWJvdW5jZWRGdW5jdGlvbigpO1xuICAgICAgICBkZWJvdW5jZWRGdW5jdGlvbigpO1xuICAgICAgICBkZWJvdW5jZWRGdW5jdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXZlIGJlZW4gY2FsbGVkIHlldFxuICAgICAgICBleHBlY3QobW9ja0Z1bmN0aW9uKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBmb3IgZGVib3VuY2UgZGVsYXlcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDE1MCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgYmVlbiBjYWxsZWQgb25seSBvbmNlXG4gICAgICAgIGV4cGVjdChtb2NrRnVuY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3Rocm90dGxlJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB0aHJvdHRsZSBmdW5jdGlvbiBjYWxscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IG1vY2tGdW5jdGlvbiA9IGplc3QuZm4oKCkgPT4gY2FsbENvdW50KyspO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbW9ja1Rocm90dGxlID0gamVzdC5mbigoZnVuYzogRnVuY3Rpb24sIGRlbGF5OiBudW1iZXIpID0+IHtcbiAgICAgICAgICBsZXQgbGFzdENhbGwgPSAwO1xuICAgICAgICAgIHJldHVybiAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZiAobm93IC0gbGFzdENhbGwgPj0gZGVsYXkpIHtcbiAgICAgICAgICAgICAgbGFzdENhbGwgPSBub3c7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRocm90dGxlZEZ1bmN0aW9uID0gbW9ja1Rocm90dGxlKG1vY2tGdW5jdGlvbiwgMTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGwgbXVsdGlwbGUgdGltZXMgcXVpY2tseVxuICAgICAgICB0aHJvdHRsZWRGdW5jdGlvbigpO1xuICAgICAgICB0aHJvdHRsZWRGdW5jdGlvbigpO1xuICAgICAgICB0aHJvdHRsZWRGdW5jdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgYmVlbiBjYWxsZWQgb25seSBvbmNlIGltbWVkaWF0ZWx5XG4gICAgICAgIGV4cGVjdChtb2NrRnVuY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIHRocm90dGxlIGRlbGF5XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGwgYWdhaW5cbiAgICAgICAgdGhyb3R0bGVkRnVuY3Rpb24oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBoYXZlIGJlZW4gY2FsbGVkIHR3aWNlIHRvdGFsXG4gICAgICAgIGV4cGVjdChtb2NrRnVuY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FsY3VsYXRpb24gRnVuY3Rpb25zJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCdjYWxjdWxhdGVUYXgnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSB0YXggY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrQ2FsY3VsYXRlVGF4ID0gamVzdC5mbigoYW1vdW50OiBudW1iZXIsIHRheFJhdGU6IG51bWJlcikgPT4ge1xuICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbW91bnQgKiB0YXhSYXRlKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVGF4KDEwMCwgMC4wOCkpLnRvQmUoOCk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVGF4KDI1MC41MCwgMC4wNzUpKS50b0JlKDE4Ljc5KTtcbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUYXgoMCwgMC4wOCkpLnRvQmUoMCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZWRnZSBjYXNlcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0NhbGN1bGF0ZVRheCA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCB0YXhSYXRlOiBudW1iZXIpID0+IHtcbiAgICAgICAgICBpZiAoYW1vdW50IDwgMCB8fCB0YXhSYXRlIDwgMCkgcmV0dXJuIDA7XG4gICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGFtb3VudCAqIHRheFJhdGUpICogMTAwKSAvIDEwMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUYXgoLTEwMCwgMC4wOCkpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVGF4KDEwMCwgLTAuMDgpKS50b0JlKDApO1xuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRheCgxMDAsIDApKS50b0JlKDApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY2FsY3VsYXRlRGlzY291bnQnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSBwZXJjZW50YWdlIGRpc2NvdW50JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrQ2FsY3VsYXRlRGlzY291bnQgPSBqZXN0LmZuKChhbW91bnQ6IG51bWJlciwgZGlzY291bnQ6IG51bWJlciwgaXNQZXJjZW50YWdlID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgIGlmIChpc1BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbW91bnQgKiAoZGlzY291bnQgLyAxMDApKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbihkaXNjb3VudCwgYW1vdW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVEaXNjb3VudCgxMDAsIDEwLCB0cnVlKSkudG9CZSgxMCk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlRGlzY291bnQoMjUwLCAxNSwgdHJ1ZSkpLnRvQmUoMzcuNSk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlRGlzY291bnQoNTAsIDIwLCB0cnVlKSkudG9CZSgxMCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgZml4ZWQgZGlzY291bnQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tDYWxjdWxhdGVEaXNjb3VudCA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCBkaXNjb3VudDogbnVtYmVyLCBpc1BlcmNlbnRhZ2UgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgaWYgKGlzUGVyY2VudGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGFtb3VudCAqIChkaXNjb3VudCAvIDEwMCkpICogMTAwKSAvIDEwMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKGRpc2NvdW50LCBhbW91bnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZURpc2NvdW50KDEwMCwgMTUsIGZhbHNlKSkudG9CZSgxNSk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlRGlzY291bnQoNTAsIDc1LCBmYWxzZSkpLnRvQmUoNTApOyAvLyBDYW4ndCBkaXNjb3VudCBtb3JlIHRoYW4gYW1vdW50XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlRGlzY291bnQoMjAwLCAyNSwgZmFsc2UpKS50b0JlKDI1KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NhbGN1bGF0ZVRvdGFsJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgdG90YWwgd2l0aCB0YXggYW5kIGRpc2NvdW50JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrQ2FsY3VsYXRlVG90YWwgPSBqZXN0LmZuKChzdWJ0b3RhbDogbnVtYmVyLCB0YXg6IG51bWJlciwgZGlzY291bnQ6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGFmdGVyRGlzY291bnQgPSBzdWJ0b3RhbCAtIGRpc2NvdW50O1xuICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhZnRlckRpc2NvdW50ICsgdGF4KSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVG90YWwoMTAwLCA4LCAxMCkpLnRvQmUoOTgpOyAvLyAxMDAgLSAxMCArIDhcbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUb3RhbCgyNTAsIDIwLCAyNSkpLnRvQmUoMjQ1KTsgLy8gMjUwIC0gMjUgKyAyMFxuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRvdGFsKDUwLCAwLCAwKSkudG9CZSg1MCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmVnYXRpdmUgcmVzdWx0cycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0NhbGN1bGF0ZVRvdGFsID0gamVzdC5mbigoc3VidG90YWw6IG51bWJlciwgdGF4OiBudW1iZXIsIGRpc2NvdW50OiBudW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBhZnRlckRpc2NvdW50ID0gc3VidG90YWwgLSBkaXNjb3VudDtcbiAgICAgICAgICBjb25zdCB0b3RhbCA9IGFmdGVyRGlzY291bnQgKyB0YXg7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgucm91bmQodG90YWwgKiAxMDApIC8gMTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUb3RhbCgxMCwgMSwgMTUpKS50b0JlKDApOyAvLyBDYW4ndCBnbyBuZWdhdGl2ZVxuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRvdGFsKDAsIDAsIDUpKS50b0JlKDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTYW5pdGl6YXRpb24gRnVuY3Rpb25zJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCdzYW5pdGl6ZUlucHV0JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSB1c2VyIGlucHV0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrU2FuaXRpemVJbnB1dCA9IGplc3QuZm4oKGlucHV0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICByZXR1cm4gaW5wdXRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88c2NyaXB0W14+XSo+Lio/PFxcL3NjcmlwdD4vZ2ksICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzxbXj5dKj4vZywgJycpXG4gICAgICAgICAgICAudHJpbSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1Nhbml0aXplSW5wdXQoJ0hlbGxvIDxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD4gV29ybGQnKSkudG9CZSgnSGVsbG8gIFdvcmxkJyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2FuaXRpemVJbnB1dCgnPGI+Qm9sZDwvYj4gdGV4dCcpKS50b0JlKCdCb2xkIHRleHQnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tTYW5pdGl6ZUlucHV0KCcgIE5vcm1hbCB0ZXh0ICAnKSkudG9CZSgnTm9ybWFsIHRleHQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBtYWxpY2lvdXMgaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tTYW5pdGl6ZUlucHV0ID0gamVzdC5mbigoaW5wdXQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHJldHVybiBpbnB1dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzxzY3JpcHRbXj5dKj4uKj88XFwvc2NyaXB0Pi9naSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvamF2YXNjcmlwdDovZ2ksICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL29uXFx3K1xccyo9L2dpLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88W14+XSo+L2csICcnKVxuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tTYW5pdGl6ZUlucHV0KCc8aW1nIHNyYz1cInhcIiBvbmVycm9yPVwiYWxlcnQoMSlcIj4nKSkudG9CZSgnJyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2FuaXRpemVJbnB1dCgnamF2YXNjcmlwdDphbGVydChcInhzc1wiKScpKS50b0JlKCdhbGVydChcInhzc1wiKScpO1xuICAgICAgICBleHBlY3QobW9ja1Nhbml0aXplSW5wdXQoJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIj5MaW5rPC9hPicpKS50b0JlKCdMaW5rJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdlc2NhcGVIdG1sJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBlc2NhcGUgSFRNTCBlbnRpdGllcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0VzY2FwZUh0bWwgPSBqZXN0LmZuKCh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBlbnRpdHlNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICAgICAnJic6ICcmYW1wOycsXG4gICAgICAgICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICAgICAgICc+JzogJyZndDsnLFxuICAgICAgICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICAgICAgICBcIidcIjogJyYjMzk7JyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1smPD5cIiddL2csIChjaGFyKSA9PiBlbnRpdHlNYXBbY2hhcl0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0VzY2FwZUh0bWwoJzxkaXY+SGVsbG8gJiBcIldvcmxkXCI8L2Rpdj4nKSkudG9CZSgnJmx0O2RpdiZndDtIZWxsbyAmYW1wOyAmcXVvdDtXb3JsZCZxdW90OyZsdDsvZGl2Jmd0OycpO1xuICAgICAgICBleHBlY3QobW9ja0VzY2FwZUh0bWwoXCJJdCdzIGEgJ3Rlc3QnXCIpKS50b0JlKCdJdCYjMzk7cyBhICYjMzk7dGVzdCYjMzk7Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrRXNjYXBlSHRtbCgnTm9ybWFsIHRleHQnKSkudG9CZSgnTm9ybWFsIHRleHQnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3BhcnNlUXVlcnlQYXJhbXMnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHBhcnNlIFVSTCBxdWVyeSBwYXJhbWV0ZXJzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrUGFyc2VRdWVyeVBhcmFtcyA9IGplc3QuZm4oKHF1ZXJ5U3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5U3RyaW5nKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBBcnJheS5mcm9tKHVybFBhcmFtcy5lbnRyaWVzKCkpKSB7XG4gICAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1BhcnNlUXVlcnlQYXJhbXMoJz9uYW1lPUpvaG4mYWdlPTMwJmNpdHk9TllDJykpLnRvRXF1YWwoe1xuICAgICAgICAgIG5hbWU6ICdKb2huJyxcbiAgICAgICAgICBhZ2U6ICczMCcsXG4gICAgICAgICAgY2l0eTogJ05ZQycsXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KG1vY2tQYXJzZVF1ZXJ5UGFyYW1zKCdzZWFyY2g9dGVzdCZwYWdlPTEmbGltaXQ9MTAnKSkudG9FcXVhbCh7XG4gICAgICAgICAgc2VhcmNoOiAndGVzdCcsXG4gICAgICAgICAgcGFnZTogJzEnLFxuICAgICAgICAgIGxpbWl0OiAnMTAnLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBvciBtYWxmb3JtZWQgcXVlcnkgc3RyaW5ncycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1BhcnNlUXVlcnlQYXJhbXMgPSBqZXN0LmZuKChxdWVyeVN0cmluZzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGFuZGxlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgICBpZiAoIXF1ZXJ5U3RyaW5nIHx8IHF1ZXJ5U3RyaW5nID09PSAnPycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhhbmRsZSBtYWxmb3JtZWQgcXVlcnkgc3RyaW5ncyAobm8gPSBzaWduKVxuICAgICAgICAgIGlmICghcXVlcnlTdHJpbmcuaW5jbHVkZXMoJz0nKSAmJiAhcXVlcnlTdHJpbmcuc3RhcnRzV2l0aCgnPycpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeVN0cmluZyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBBcnJheS5mcm9tKHVybFBhcmFtcy5lbnRyaWVzKCkpKSB7XG4gICAgICAgICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBlbXB0eSBvYmplY3QgZm9yIG1hbGZvcm1lZCBxdWVyaWVzXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUGFyc2VRdWVyeVBhcmFtcygnJykpLnRvRXF1YWwoe30pO1xuICAgICAgICBleHBlY3QobW9ja1BhcnNlUXVlcnlQYXJhbXMoJz8nKSkudG9FcXVhbCh7fSk7XG4gICAgICAgIGV4cGVjdChtb2NrUGFyc2VRdWVyeVBhcmFtcygnaW52YWxpZCcpKS50b0VxdWFsKHt9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBVUkwgZW5jb2RpbmcnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tQYXJzZVF1ZXJ5UGFyYW1zID0gamVzdC5mbigocXVlcnlTdHJpbmc6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocXVlcnlTdHJpbmcpO1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIEFycmF5LmZyb20odXJsUGFyYW1zLmVudHJpZXMoKSkpIHtcbiAgICAgICAgICAgIHBhcmFtc1trZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQYXJzZVF1ZXJ5UGFyYW1zKCdzZWFyY2g9aGVsbG8lMjB3b3JsZCZzcGVjaWFsPSUyMSU0MCUyMycpKS50b0VxdWFsKHtcbiAgICAgICAgICBzZWFyY2g6ICdoZWxsbyB3b3JsZCcsXG4gICAgICAgICAgc3BlY2lhbDogJyFAIycsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZyBpbiBVdGlsaXRpZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGluIGZvcm1hdHRpbmcgZnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Zvcm1hdEN1cnJlbmN5V2l0aEVycm9yID0gamVzdC5mbigoYW1vdW50OiBhbnkpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFtb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhbW91bnQgdHlwZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYCQke2Ftb3VudC50b0ZpeGVkKDIpfWA7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignQ3VycmVuY3kgZm9ybWF0dGluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuICckMC4wMCc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5V2l0aEVycm9yKCdpbnZhbGlkJykpLnRvQmUoJyQwLjAwJyk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdDdXJyZW5jeSBmb3JtYXR0aW5nIGVycm9yOicsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGluIHZhbGlkYXRpb24gZnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlRW1haWxXaXRoRXJyb3IgPSBqZXN0LmZuKChlbWFpbDogYW55KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW1haWwgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC8udGVzdChlbWFpbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRW1haWwgdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsV2l0aEVycm9yKG51bGwpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbFdpdGhFcnJvcigxMjMpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0VtYWlsIHZhbGlkYXRpb24gZXJyb3I6JyxcbiAgICAgICAgZXhwZWN0LmFueShFcnJvcilcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgaW4gdXRpbGl0eSBmdW5jdGlvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2x1Z2lmeVdpdGhFcnJvciA9IGplc3QuZm4oKHRleHQ6IGFueSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0ZXh0LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICctJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignU2x1Z2lmeSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5V2l0aEVycm9yKG51bGwpKS50b0JlKCcnKTtcbiAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeVdpdGhFcnJvcih7fSkpLnRvQmUoJycpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnU2x1Z2lmeSBlcnJvcjonLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFRlc3RzIGZvciBVdGlsaXRpZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgZGF0YXNldHMgZWZmaWNpZW50bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQmF0Y2hQcm9jZXNzID0gamVzdC5mbigoaXRlbXM6IGFueVtdLCBiYXRjaFNpemUgPSAxMDApID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICAgICAgICBjb25zdCBiYXRjaCA9IGl0ZW1zLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xuICAgICAgICAgIHJlc3VsdHMucHVzaCguLi5iYXRjaC5tYXAoaXRlbSA9PiBpdGVtLmlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbGFyZ2VEYXRhc2V0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwMDAgfSwgKF8sIGkpID0+ICh7IGlkOiBpLCBuYW1lOiBgSXRlbSAke2l9YCB9KSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBtb2NrQmF0Y2hQcm9jZXNzKGxhcmdlRGF0YXNldCk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDEwMDAwKTtcbiAgICAgIGV4cGVjdChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTsgLy8gU2hvdWxkIHByb2Nlc3MgcXVpY2tseVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCB1dGlsaXR5IG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQXN5bmNVdGlsaXR5ID0gamVzdC5mbihhc3luYyAoZGF0YTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMCkpO1xuICAgICAgICByZXR1cm4gZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGkpID0+IFxuICAgICAgICBtb2NrQXN5bmNVdGlsaXR5KGB0ZXN0LSR7aX1gKVxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChvcGVyYXRpb25zKTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKDEwMCk7XG4gICAgICBleHBlY3QocmVzdWx0c1swXSkudG9CZSgnVEVTVC0wJyk7XG4gICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDUwMCk7IC8vIFNob3VsZCBoYW5kbGUgY29uY3VycmVuY3kgd2VsbFxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJmb3JtYXREYXRlIiwiZGF0ZVN0cmluZyIsImRhdGUiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwieWVhciIsIm1vbnRoIiwiZGF5IiwidmFsaWRhdGVFbWFpbCIsImVtYWlsIiwiZW1haWxSZWdleCIsInRlc3QiLCJ2YWxpZGF0ZVBhc3N3b3JkIiwicGFzc3dvcmQiLCJsZW5ndGgiLCJ2YWxpZGF0ZVBob25lTnVtYmVyIiwicGhvbmUiLCJwaG9uZVJlZ2V4IiwicmVwbGFjZSIsInZhbGlkYXRlUmVxdWlyZWQiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImdlbmVyYXRlSWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJzbHVnaWZ5IiwidGV4dCIsInRvTG93ZXJDYXNlIiwidHJ1bmNhdGVUZXh0IiwibWF4TGVuZ3RoIiwiY2FsY3VsYXRlVGF4IiwiYW1vdW50IiwicmF0ZSIsImNhbGN1bGF0ZURpc2NvdW50IiwiZGlzY291bnQiLCJjYWxjdWxhdGVUb3RhbCIsInN1YnRvdGFsIiwidGF4Iiwic2FuaXRpemVJbnB1dCIsImlucHV0IiwibWF0Y2giLCJlbnRpdGllcyIsImVzY2FwZUh0bWwiLCJwYXJzZVF1ZXJ5UGFyYW1zIiwicXVlcnlTdHJpbmciLCJwYXJhbXMiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJrZXkiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwiY29uc29sZVNweSIsImxvZyIsImplc3QiLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJlcnJvciIsIndhcm4iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja0NsZWFyIiwiYWZ0ZXJBbGwiLCJtb2NrUmVzdG9yZSIsIml0IiwibW9ja0Zvcm1hdEN1cnJlbmN5IiwiZm4iLCJjdXJyZW5jeSIsImxvY2FsZSIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJzdHlsZSIsImZvcm1hdCIsImV4cGVjdCIsInRvQmUiLCJpc05hTiIsImlzRmluaXRlIiwiTmFOIiwiSW5maW5pdHkiLCJtb2NrRm9ybWF0RGF0ZSIsImQiLCJnZXRUaW1lIiwiU3RyaW5nIiwiZ2V0TW9udGgiLCJwYWRTdGFydCIsImdldERhdGUiLCJnZXRGdWxsWWVhciIsInRlc3REYXRlIiwiZm9ybWF0TWFwIiwibW9ja0Zvcm1hdFBob25lTnVtYmVyIiwiY291bnRyeSIsImNsZWFuZWQiLCJzbGljZSIsIm1vY2tWYWxpZGF0ZUVtYWlsIiwibW9ja1ZhbGlkYXRlUGFzc3dvcmQiLCJtaW5MZW5ndGgiLCJoYXNVcHBlciIsImhhc0xvd2VyIiwiaGFzTnVtYmVyIiwiaGFzU3BlY2lhbCIsIm1vY2tWYWxpZGF0ZVBob25lTnVtYmVyIiwic3RhcnRzV2l0aCIsIm1vY2tWYWxpZGF0ZVJlcXVpcmVkIiwidHJpbSIsIm1vY2tHZW5lcmF0ZUlkIiwicHJlZml4IiwiY2hhcnMiLCJyZXN1bHQiLCJpIiwiY2hhckF0IiwiZmxvb3IiLCJpZDEiLCJpZDIiLCJ0b0hhdmVMZW5ndGgiLCJub3QiLCJpZCIsInRvTWF0Y2giLCJtb2NrU2x1Z2lmeSIsIm1vY2tUcnVuY2F0ZVRleHQiLCJzdWZmaXgiLCJsb25nVGV4dCIsInRydW5jYXRlTGVuZ3RoIiwibWF4IiwiY2FsbENvdW50IiwibW9ja0Z1bmN0aW9uIiwibW9ja0RlYm91bmNlIiwiZnVuYyIsImRlbGF5IiwidGltZW91dElkIiwiYXJncyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJhcHBseSIsImRlYm91bmNlZEZ1bmN0aW9uIiwidG9IYXZlQmVlbkNhbGxlZCIsIlByb21pc2UiLCJyZXNvbHZlIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwibW9ja1Rocm90dGxlIiwibGFzdENhbGwiLCJub3ciLCJ0aHJvdHRsZWRGdW5jdGlvbiIsIm1vY2tDYWxjdWxhdGVUYXgiLCJ0YXhSYXRlIiwicm91bmQiLCJtb2NrQ2FsY3VsYXRlRGlzY291bnQiLCJpc1BlcmNlbnRhZ2UiLCJtaW4iLCJtb2NrQ2FsY3VsYXRlVG90YWwiLCJhZnRlckRpc2NvdW50IiwidG90YWwiLCJtb2NrU2FuaXRpemVJbnB1dCIsIm1vY2tFc2NhcGVIdG1sIiwiZW50aXR5TWFwIiwiY2hhciIsIm1vY2tQYXJzZVF1ZXJ5UGFyYW1zIiwidG9FcXVhbCIsIm5hbWUiLCJhZ2UiLCJjaXR5Iiwic2VhcmNoIiwicGFnZSIsImxpbWl0IiwiaW5jbHVkZXMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzcGVjaWFsIiwibW9ja0Zvcm1hdEN1cnJlbmN5V2l0aEVycm9yIiwiRXJyb3IiLCJ0b0ZpeGVkIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJhbnkiLCJtb2NrVmFsaWRhdGVFbWFpbFdpdGhFcnJvciIsIm1vY2tTbHVnaWZ5V2l0aEVycm9yIiwibW9ja0JhdGNoUHJvY2VzcyIsIml0ZW1zIiwiYmF0Y2hTaXplIiwicmVzdWx0cyIsImJhdGNoIiwicHVzaCIsIm1hcCIsIml0ZW0iLCJsYXJnZURhdGFzZXQiLCJfIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInRvQmVMZXNzVGhhbiIsIm1vY2tBc3luY1V0aWxpdHkiLCJkYXRhIiwidG9VcHBlckNhc2UiLCJvcGVyYXRpb25zIiwiYWxsIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUEscURBQXFEO0FBQ3JELE1BQU1BLGFBQWEsQ0FBQ0M7SUFDbEIsTUFBTUMsT0FBTyxJQUFJQyxLQUFLRjtJQUN0QixPQUFPQyxLQUFLRSxrQkFBa0IsQ0FBQyxTQUFTO1FBQ3RDQyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsS0FBSztJQUNQO0FBQ0Y7QUFFQSxNQUFNQyxnQkFBZ0IsQ0FBQ0M7SUFDckIsTUFBTUMsYUFBYTtJQUNuQixPQUFPQSxXQUFXQyxJQUFJLENBQUNGO0FBQ3pCO0FBRUEsTUFBTUcsbUJBQW1CLENBQUNDO0lBQ3hCLE9BQU9BLFNBQVNDLE1BQU0sSUFBSTtBQUM1QjtBQUVBLE1BQU1DLHNCQUFzQixDQUFDQztJQUMzQixNQUFNQyxhQUFhO0lBQ25CLE9BQU9BLFdBQVdOLElBQUksQ0FBQ0ssTUFBTUUsT0FBTyxDQUFDLGVBQWU7QUFDdEQ7QUFFQSxNQUFNQyxtQkFBbUIsQ0FBQ0M7SUFDeEIsT0FBT0EsVUFBVSxRQUFRQSxVQUFVQyxhQUFhRCxVQUFVO0FBQzVEO0FBRUEsTUFBTUUsYUFBYTtJQUNqQixPQUFPQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxNQUFNLENBQUMsR0FBRztBQUM5QztBQUVBLE1BQU1DLFVBQVUsQ0FBQ0M7SUFDZixPQUFPQSxLQUNKQyxXQUFXLEdBQ1hYLE9BQU8sQ0FB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