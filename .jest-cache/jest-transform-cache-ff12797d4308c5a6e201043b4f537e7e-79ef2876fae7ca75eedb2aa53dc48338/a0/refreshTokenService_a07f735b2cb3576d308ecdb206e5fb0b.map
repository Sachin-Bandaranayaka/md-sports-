{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/services/refreshTokenService.ts"],"sourcesContent":["import prisma, { safeQuery } from '@/lib/prisma';\n\n// Configuration\nconst REFRESH_TOKEN_EXPIRES_IN_DAYS = 30;\n\n// Generate a secure random token using Web Crypto API\nconst generateSecureToken = (length = 40): string => {\n    // Use Web Crypto API which is supported in Edge Runtime\n    if (typeof crypto !== 'undefined') {\n        const bytes = new Uint8Array(length);\n        crypto.getRandomValues(bytes);\n        return Array.from(bytes)\n            .map(byte => byte.toString(16).padStart(2, '0'))\n            .join('');\n    }\n\n    // Fallback (less secure but works everywhere)\n    return Array.from(\n        { length },\n        () => Math.floor(Math.random() * 16).toString(16)\n    ).join('');\n};\n\n/**\n * Generate a new refresh token for a user\n */\nexport const generateRefreshToken = async (userId: string): Promise<string> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            throw new Error('Database client not initialized correctly');\n        }\n\n        // Log for debugging\n        console.log('Generating refresh token for user ID:', userId);\n\n        // IMPORTANT: Revoke all existing non-expired refresh tokens for this user\n        // This ensures only one active session per user at a time\n        console.log('Revoking all existing refresh tokens for user before creating new one');\n        await safeQuery(\n            () => prisma.refreshToken.updateMany({\n                where: {\n                    userId,\n                    isRevoked: false,\n                    expiresAt: { gt: new Date() }\n                },\n                data: { isRevoked: true },\n            }),\n            null,\n            'Failed to revoke existing refresh tokens'\n        );\n\n        // Generate a random token\n        const token = generateSecureToken(40);\n\n        // Calculate expiration date (30 days from now)\n        const expiresAt = new Date();\n        expiresAt.setDate(expiresAt.getDate() + REFRESH_TOKEN_EXPIRES_IN_DAYS);\n\n        // Log the token details before creating\n        console.log('Preparing to create refresh token with:', {\n            userId,\n            token: token.substring(0, 10) + '...',\n            expiresAt,\n        });\n\n        // Store the token in the database with retry logic\n        const createdToken = await safeQuery(\n            () => prisma.refreshToken.create({\n                data: {\n                    userId,\n                    token,\n                    expiresAt,\n                    updatedAt: new Date(),\n                },\n            }),\n            null,\n            'Failed to create refresh token'\n        );\n\n        if (!createdToken) {\n            throw new Error('Failed to create refresh token in database');\n        }\n\n        console.log('Successfully created refresh token with ID:', createdToken.id);\n\n        return token;\n    } catch (error) {\n        // More detailed error logging\n        console.error('Error generating refresh token:', error);\n        if (error instanceof Error) {\n            console.error('Error message:', error.message);\n            console.error('Error stack:', error.stack);\n        }\n        throw new Error('Failed to generate refresh token');\n    }\n};\n\n/**\n * Verify a refresh token and return the associated user ID if valid\n */\nexport const verifyRefreshToken = async (token: string): Promise<string | null> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return null;\n        }\n\n        // Find the token in the database with retry logic\n        const refreshToken = await safeQuery(\n            () => prisma.refreshToken.findUnique({\n                where: { token },\n            }),\n            null,\n            'Failed to find refresh token'\n        );\n\n        // Check if token exists and is not revoked\n        if (!refreshToken || refreshToken.isRevoked) {\n            console.log('Token not found or revoked:', token.substring(0, 10) + '...');\n            return null;\n        }\n\n        // Check if token is expired\n        if (new Date() > refreshToken.expiresAt) {\n            console.log('Token expired:', token.substring(0, 10) + '...');\n\n            // Revoke expired token with retry logic\n            await safeQuery(\n                () => prisma.refreshToken.update({\n                    where: { id: refreshToken.id },\n                    data: { isRevoked: true },\n                }),\n                null,\n                'Failed to revoke expired refresh token'\n            );\n\n            return null;\n        }\n\n        return refreshToken.userId;\n    } catch (error) {\n        console.error('Error verifying refresh token:', error);\n        return null;\n    }\n};\n\n/**\n * Revoke a specific refresh token\n */\nexport const revokeRefreshToken = async (token: string): Promise<boolean> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return false;\n        }\n\n        await safeQuery(\n            () => prisma.refreshToken.updateMany({\n                where: { token },\n                data: { isRevoked: true },\n            }),\n            null,\n            'Failed to revoke refresh token'\n        );\n\n        return true;\n    } catch (error) {\n        console.error('Error revoking refresh token:', error);\n        return false;\n    }\n};\n\n/**\n * Revoke all refresh tokens for a specific user\n */\nexport const revokeAllUserRefreshTokens = async (userId: string): Promise<boolean> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return false;\n        }\n\n        await safeQuery(\n            () => prisma.refreshToken.updateMany({\n                where: { userId },\n                data: { isRevoked: true },\n            }),\n            null,\n            'Failed to revoke all user refresh tokens'\n        );\n\n        return true;\n    } catch (error) {\n        console.error('Error revoking user refresh tokens:', error);\n        return false;\n    }\n};\n\n/**\n * Clean up expired and revoked tokens\n * Note: This should be run periodically via a cron job\n */\nexport const cleanupRefreshTokens = async (): Promise<void> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return;\n        }\n\n        const now = new Date();\n\n        await safeQuery(\n            () => prisma.refreshToken.deleteMany({\n                where: {\n                    OR: [\n                        { expiresAt: { lt: now } },\n                        { isRevoked: true },\n                    ],\n                },\n            }),\n            null,\n            'Failed to cleanup expired refresh tokens'\n        );\n    } catch (error) {\n        console.error('Error cleaning up refresh tokens:', error);\n    }\n};"],"names":["cleanupRefreshTokens","generateRefreshToken","revokeAllUserRefreshTokens","revokeRefreshToken","verifyRefreshToken","REFRESH_TOKEN_EXPIRES_IN_DAYS","generateSecureToken","length","crypto","bytes","Uint8Array","getRandomValues","Array","from","map","byte","toString","padStart","join","Math","floor","random","userId","prisma","refreshToken","console","error","Error","log","safeQuery","updateMany","where","isRevoked","expiresAt","gt","Date","data","token","setDate","getDate","substring","createdToken","create","updatedAt","id","message","stack","findUnique","update","now","deleteMany","OR","lt"],"mappings":"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"}