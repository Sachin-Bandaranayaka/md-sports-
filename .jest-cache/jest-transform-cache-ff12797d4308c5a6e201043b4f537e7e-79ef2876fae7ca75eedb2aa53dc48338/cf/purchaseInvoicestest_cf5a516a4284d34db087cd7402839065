10a0717fa4efeb8b70e197635a7360d8
/**
 * @jest-environment node
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _client = require("@prisma/client");
const _route = require("../../src/app/api/purchases/route");
const _route1 = require("../../src/app/api/purchases/[id]/route");
// Helper function to create mock NextRequest
const createMockNextRequest = (url, options = {})=>{
    const { method = "GET", body, headers = {} } = options;
    return {
        method,
        url,
        headers: new Headers(headers),
        json: async ()=>body ? typeof body === "string" ? JSON.parse(body) : body : {},
        text: async ()=>body ? typeof body === "string" ? body : JSON.stringify(body) : ""
    };
};
const prisma = new _client.PrismaClient();
describe("Purchase Invoice API Integration Tests", ()=>{
    let createdShopId;
    let createdSupplierId;
    let createdProductId;
    beforeAll(async ()=>{
    // Seed initial data if necessary, e.g., a default supplier or shop
    // For now, we'll create them in beforeEach or specific tests
    });
    beforeEach(async ()=>{
        // Clean up database tables to ensure test isolation
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        // Create a shop for testing
        const shop = await prisma.shop.create({
            data: {
                name: "Test Shop Local",
                location: "Test Location"
            }
        });
        createdShopId = shop.id;
        // Create a supplier for testing
        const supplier = await prisma.supplier.create({
            data: {
                name: "Test Supplier Local"
            }
        });
        createdSupplierId = supplier.id;
        // Create a product for testing updates/deletes (not for create new product test)
        const product = await prisma.product.create({
            data: {
                name: "Existing Product",
                price: 100,
                sku: "EXISTING001",
                shopId: createdShopId
            }
        });
        createdProductId = product.id;
    });
    afterAll(async ()=>{
        // Clean up database after all tests
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        await prisma.$disconnect();
    });
    describe("POST /api/purchases (Create Purchase Invoice)", ()=>{
        it("should create a purchase invoice for a new product, update inventory, and set WAC", async ()=>{
            // 1. Define data for a new product
            const newProductName = "Brand New Racket";
            const newProductSku = "NEWB001";
            const purchasePrice = 150;
            const purchaseQuantity = 10;
            // Create product first (as API expects productId)
            // In a real scenario, the UI might create product then purchase, or purchase API handles product creation
            // For this test, assume product is created just before, or API implies its creation from purchase (not current API)
            // Let's assume for now product must exist, if API doesn't create it from purchase items.
            // The current API's POST /api/purchases expects item.productId, implying product exists.
            const newTestProduct = await prisma.product.create({
                data: {
                    name: newProductName,
                    sku: newProductSku,
                    price: 250,
                    shopId: createdShopId // Optional default shop association
                }
            });
            const newTestProductId = newTestProduct.id;
            // 2. Prepare the request body for POST /api/purchases
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // 3. Construct a NextRequest instance
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: purchaseInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate the API call
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201); // Or 200 depending on your API's success response for POST
            expect(responseBody.data).toHaveProperty("id");
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice).not.toBeNull();
            expect(dbInvoice?.supplierId).toBe(createdSupplierId);
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(newTestProductId);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice);
            // Verify InventoryItem in DB
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newTestProductId,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem).not.toBeNull();
            expect(dbInventoryItem?.quantity).toBe(purchaseQuantity);
            // The POST route seems to calculate shopSpecificCost too.
            // WAC = (Current Total Value + New Purchase Value) / (Current Quantity + New Quantity)
            // For new item, existing shopSpecificCost is 0, currentQuantity is 0.
            // So newShopSpecificCost should be newCost (purchasePrice)
            expect(dbInventoryItem?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC in DB
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: newTestProductId
                }
            });
            expect(dbProduct).not.toBeNull();
            // For a new product, WAC should be equal to the purchase price of this first batch
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should create a purchase for an existing product, update inventory, and recalculate WACs", async ()=>{
            // 0. Initial state: Product exists, potentially with some inventory and WAC
            const initialPurchasePrice = 120;
            const initialPurchaseQuantity = 5;
            const existingProductId = createdProductId; // From beforeEach
            // Create an initial purchase to set up existing inventory and WAC
            const initialPayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const initialReq = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: initialPayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route.POST)(initialReq);
            const productBeforeNewPurchase = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            const inventoryBeforeNewPurchase = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            expect(productBeforeNewPurchase?.weightedAverageCost).toBe(initialPurchasePrice);
            expect(inventoryBeforeNewPurchase?.quantity).toBe(initialPurchaseQuantity);
            expect(inventoryBeforeNewPurchase?.shopSpecificCost).toBe(initialPurchasePrice);
            // 1. Define data for the new purchase of the existing product
            const newPurchasePrice = 100;
            const newPurchaseQuantity = 8;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: newPurchaseQuantity,
                        price: newPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newPurchaseQuantity
                    }
                ],
                totalAmount: newPurchaseQuantity * newPurchasePrice,
                status: "paid"
            };
            // 3. Simulate API call
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: purchaseInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify InventoryItem
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            const expectedTotalQuantity = initialPurchaseQuantity + newPurchaseQuantity;
            expect(dbInventoryItem?.quantity).toBe(expectedTotalQuantity);
            // Verify shopSpecificCost recalculation
            // SSC = ((oldQty * oldSSC) + (newQty * newPrice)) / (oldQty + newQty)
            const expectedShopSpecificCost = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            expect(dbInventoryItem?.shopSpecificCost).toBeCloseTo(expectedShopSpecificCost);
            // Verify Product WAC recalculation
            // WAC = ((oldTotalQty * oldWAC) + (newPurchaseQty * newPurchasePrice)) / (newTotalQty + newPurchaseQty)
            // In this case, product WAC was initialPurchasePrice for initialPurchaseQuantity.
            const expectedProductWAC = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            expect(dbProduct?.weightedAverageCost).toBeCloseTo(expectedProductWAC);
        }, 15000); // Increased timeout
        it("should create a purchase with multiple items and update inventory/WAC for each", async ()=>{
            // 1. Create two distinct products for this test
            const product1Data = {
                name: "MultiItem Product A",
                sku: "MULTI001",
                price: 50,
                shopId: createdShopId
            };
            const product2Data = {
                name: "MultiItem Product B",
                sku: "MULTI002",
                price: 75,
                shopId: createdShopId
            };
            const product1 = await prisma.product.create({
                data: product1Data
            });
            const product2 = await prisma.product.create({
                data: product2Data
            });
            const purchasePrice1 = 40;
            const purchaseQuantity1 = 5;
            const purchasePrice2 = 60;
            const purchaseQuantity2 = 3;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product1.id.toString(),
                        quantity: purchaseQuantity1,
                        price: purchasePrice1
                    },
                    {
                        productId: product2.id.toString(),
                        quantity: purchaseQuantity2,
                        price: purchasePrice2
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity1
                    },
                    {
                        [createdShopId]: purchaseQuantity2
                    } // Distribution for item 2
                ],
                totalAmount: purchaseQuantity1 * purchasePrice1 + purchaseQuantity2 * purchasePrice2,
                status: "pending"
            };
            // 3. Simulate API call
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: purchaseInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice and its items
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                } // Order to ensure consistent assertion
            });
            expect(dbInvoice?.items.length).toBe(2);
            // Assuming product1.id < product2.id due to creation order for consistent checks
            const sortedProducts = [
                product1,
                product2
            ].sort((a, b)=>a.id - b.id);
            expect(dbInvoice?.items[0].productId).toBe(sortedProducts[0].id);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity1);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice1);
            expect(dbInvoice?.items[1].productId).toBe(sortedProducts[1].id);
            expect(dbInvoice?.items[1].quantity).toBe(purchaseQuantity2);
            expect(dbInvoice?.items[1].price).toBe(purchasePrice2);
            // Verify InventoryItem and Product WAC for Product 1
            const dbInventoryItem1 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product1.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem1?.quantity).toBe(purchaseQuantity1);
            expect(dbInventoryItem1?.shopSpecificCost).toBe(purchasePrice1);
            const dbProduct1 = await prisma.product.findUnique({
                where: {
                    id: product1.id
                }
            });
            expect(dbProduct1?.weightedAverageCost).toBe(purchasePrice1);
            // Verify InventoryItem and Product WAC for Product 2
            const dbInventoryItem2 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product2.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem2?.quantity).toBe(purchaseQuantity2);
            expect(dbInventoryItem2?.shopSpecificCost).toBe(purchasePrice2);
            const dbProduct2 = await prisma.product.findUnique({
                where: {
                    id: product2.id
                }
            });
            expect(dbProduct2?.weightedAverageCost).toBe(purchasePrice2);
        }, 15000); // Increased timeout
        it("should distribute a single purchase item to multiple shops", async ()=>{
            // 1. Create two new shops for this test
            const shopA = await prisma.shop.create({
                data: {
                    name: "Test Shop A",
                    location: "Loc A"
                }
            });
            const shopB = await prisma.shop.create({
                data: {
                    name: "Test Shop B",
                    location: "Loc B"
                }
            });
            // 2. Create a new product
            const product = await prisma.product.create({
                data: {
                    name: "Split Product",
                    sku: "SPLIT001",
                    price: 200
                }
            });
            const purchasePrice = 180;
            const totalQuantity = 10;
            const quantityForShopA = 6;
            const quantityForShopB = 4;
            expect(quantityForShopA + quantityForShopB).toBe(totalQuantity); // Sanity check
            // 3. Prepare request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product.id.toString(),
                        quantity: totalQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [shopA.id]: quantityForShopA,
                        [shopB.id]: quantityForShopB
                    }
                ],
                totalAmount: totalQuantity * purchasePrice,
                status: "paid"
            };
            // 4. Simulate API call
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: purchaseInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 5. Assertions
            expect(response.status).toBe(201);
            // Verify InventoryItem for Shop A
            const invItemA = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopA.id
                }
            });
            expect(invItemA).not.toBeNull();
            expect(invItemA?.quantity).toBe(quantityForShopA);
            expect(invItemA?.shopSpecificCost).toBe(purchasePrice);
            // Verify InventoryItem for Shop B
            const invItemB = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopB.id
                }
            });
            expect(invItemB).not.toBeNull();
            expect(invItemB?.quantity).toBe(quantityForShopB);
            expect(invItemB?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC (should be the purchase price as it's all new stock)
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: product.id
                }
            });
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a productId does not exist", async ()=>{
            const nonExistentProductId = 999999; // Assuming this ID won't exist
            const purchasePrice = 100;
            const purchaseQuantity = 5;
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: nonExistentProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: purchaseInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            // Expect a client error (e.g., 400 or 404) or potentially 500 if not handled gracefully
            // For robust error handling, API should return specific error code.
            // Prisma will throw an error if a related record (product) is not found for foreign key.
            // This will likely result in a 500 if not caught and handled by the API route.
            // Let's aim for the API to catch this and return a more specific client error.
            // For now, we'll check if it's NOT a success (201).
            // A more precise check would be for 400/404/422 depending on planned error handling.
            expect(response.status).toBe(500); // Or 400/404 if you implement specific error handling
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        // Optionally, check for a specific error message or code if your API provides one.
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a supplierId does not exist", async ()=>{
            const newTestProduct = await prisma.product.create({
                data: {
                    name: "Product For Invalid Supplier Test",
                    sku: "INV SUP001",
                    price: 100
                }
            });
            const purchasePrice = 80;
            const purchaseQuantity = 5;
            const nonExistentSupplierId = 999999; // Assuming this ID won't exist
            const purchaseInvoicePayload = {
                supplierId: nonExistentSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: purchaseInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            expect(response.status).toBe(500); // Expecting 500 as Prisma throws P2003
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        });
    });
    describe("PUT /api/purchases/:id (Update Purchase Invoice)", ()=>{
        let existingInvoiceId;
        let productForUpdateTestsId;
        const initialPurchasePrice = 50;
        const initialPurchaseQuantity = 10;
        beforeEach(async ()=>{
            // Create a product specifically for these update/delete tests if not already created
            // The global createdProductId can be used if it fits, or make a new one.
            // Let's use the global one for simplicity, assuming beforeEach cleans it up.
            productForUpdateTestsId = createdProductId;
            // Create an initial purchase invoice to be updated or deleted in tests
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: initialInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            existingInvoiceId = body.data.id;
            // Sanity check: verify initial state
            const initialProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(initialProduct?.weightedAverageCost).toBe(initialPurchasePrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(initialPurchasePrice);
        });
        it("should update item quantity (increase), recalculate stock and WACs", async ()=>{
            const quantityIncrease = 5;
            const newQuantity = initialPurchaseQuantity + quantityIncrease;
            // Price remains the same for this item in this update scenario
            const updatedPriceForItem = initialPurchasePrice;
            const updatePayload = {
                // We need to send the complete structure expected by the PUT route
                // This includes all items, even if only one is changing.
                // The PUT route logic might compare with existing items to see what changed.
                items: [
                    {
                        // If the item had an ID (PurchaseInvoiceItem id), it might be needed.
                        // Let's assume for now the PUT matches items based on productId if not item ID.
                        // Based on current PUT route, it expects productId.
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    // The distributions in PUT might need to reflect the *new total* for the item
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = createMockNextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: updatePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate API call - updatePurchaseInvoice(req, { params: { id: existingInvoiceId } })
            // This is how you call it if you are testing the handler directly in Jest with context
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // WAC calculation: ((oldQty * oldSSC) + (addedQty * priceOfAddedQty)) / (newTotalQty)
            // In this specific update, the PUT route reverses the old item and adds the new one as if it's a new purchase line for WAC calcs.
            // So, the old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // However, the current PUT logic first reverses *all* old items based on their *original* recorded cost.
            // Then it adds *all* new items based on their *new* cost.
            // So for the product WAC: (TotalValueBefore - OldItemValue + NewItemValue) / (TotalStockBefore - OldItemQty + NewItemQty)
            // And for shop specific WAC: (ShopValueBefore - OldItemValueInShop + NewItemValueInShop) / (ShopStockBefore - OldItemQtyInShop + NewItemQtyInShop)
            // Let's check the logic from src/app/api/purchases/[id]/route.ts
            // 1. It fetches the old invoice.
            // 2. It reverses inventory adjustments for ALL old items (decrease stock, WAC updated).
            // 3. It processes ALL new/updated items as if they are new purchases (increase stock, WAC updated).
            // So, after reversal of initialPurchaseQuantity at initialPurchasePrice:
            // Product WAC and ShopSpecificCost would be effectively 0 if this were the only product/stock.
            // Then, adding newQuantity at updatedPriceForItem:
            // The new WACs should become updatedPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB reflects the change
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item quantity (decrease), recalculate stock and WACs", async ()=>{
            const quantityDecrease = 3;
            const newQuantity = initialPurchaseQuantity - quantityDecrease;
            expect(newQuantity).toBeGreaterThanOrEqual(0); // Ensure we don't go negative for this test logic
            const updatedPriceForItem = initialPurchasePrice; // Price remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = createMockNextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: updatePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // Due to the reversal and re-addition logic of the PUT route:
            // The old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // So, new WACs should become updatedPriceForItem (which is initialPurchasePrice).
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item price, recalculate stock and WACs", async ()=>{
            const newPriceForItem = initialPurchasePrice + 25; // New price, e.g., 50 + 25 = 75
            const quantityUnchanged = initialPurchaseQuantity; // Quantity remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: quantityUnchanged,
                        price: newPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityUnchanged
                    }
                ]
            };
            const req = createMockNextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: updatePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock (should be unchanged) and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(quantityUnchanged);
            // WAC logic in PUT: reverses old, adds new. So shopSpecificCost should reflect newPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(newPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(newPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(quantityUnchanged);
            expect(dbInvoice?.items[0].price).toBe(newPriceForItem);
            expect(dbInvoice?.total).toBe(quantityUnchanged * newPriceForItem);
        }, 15000); // Increased timeout
        it("should add a new item to an existing invoice, update stock and WACs", async ()=>{
            // 1. Define a new product for the new item
            const newItemProduct = await prisma.product.create({
                data: {
                    name: "Newly Added Product for PUT",
                    sku: "PUTNEW001",
                    price: 200
                }
            });
            const newItemProductId = newItemProduct.id;
            const newItemQuantity = 7;
            const newItemPrice = 120;
            // Original item details (from beforeEach setup)
            const originalItemProductId = productForUpdateTestsId;
            const originalItemQuantity = initialPurchaseQuantity;
            const originalItemPrice = initialPurchasePrice;
            // 2. Prepare the update payload with both original and new item
            const updatePayload = {
                items: [
                    {
                        productId: originalItemProductId.toString(),
                        quantity: originalItemQuantity,
                        price: originalItemPrice
                    },
                    {
                        productId: newItemProductId.toString(),
                        quantity: newItemQuantity,
                        price: newItemPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: originalItemQuantity
                    },
                    {
                        [createdShopId]: newItemQuantity
                    } // Distribution for new item
                ]
            };
            // 3. Simulate API call
            const req = createMockNextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: updatePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                }
            });
            expect(dbInvoice?.items.length).toBe(2);
            const expectedTotal = originalItemQuantity * originalItemPrice + newItemQuantity * newItemPrice;
            expect(dbInvoice?.total).toBe(expectedTotal);
            // Find the items in the response (order might vary, so find by productId)
            const dbOriginalItem = dbInvoice?.items.find((item)=>item.productId === originalItemProductId);
            const dbNewItem = dbInvoice?.items.find((item)=>item.productId === newItemProductId);
            expect(dbOriginalItem).toBeDefined();
            expect(dbOriginalItem?.quantity).toBe(originalItemQuantity);
            expect(dbOriginalItem?.price).toBe(originalItemPrice);
            expect(dbNewItem).toBeDefined();
            expect(dbNewItem?.quantity).toBe(newItemQuantity);
            expect(dbNewItem?.price).toBe(newItemPrice);
            // Verify InventoryItem and Product WAC for the original item
            // (Due to PUT logic of reverse & re-add, WACs should reflect its current price)
            const originalInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: originalItemProductId,
                    shopId: createdShopId
                }
            });
            expect(originalInventory?.quantity).toBe(originalItemQuantity);
            expect(originalInventory?.shopSpecificCost).toBeCloseTo(originalItemPrice);
            const originalProduct = await prisma.product.findUnique({
                where: {
                    id: originalItemProductId
                }
            });
            expect(originalProduct?.weightedAverageCost).toBeCloseTo(originalItemPrice);
            // Verify InventoryItem and Product WAC for the NEW item
            const newInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newItemProductId,
                    shopId: createdShopId
                }
            });
            expect(newInventory?.quantity).toBe(newItemQuantity);
            expect(newInventory?.shopSpecificCost).toBeCloseTo(newItemPrice);
            const newProductDb = await prisma.product.findUnique({
                where: {
                    id: newItemProductId
                }
            });
            expect(newProductDb?.weightedAverageCost).toBeCloseTo(newItemPrice);
        }, 15000); // Increased timeout
        it("should remove an item from an existing invoice, update stock and WACs", async ()=>{
            // 1. Setup: Ensure an invoice with at least two items exists.
            // We'll use the existing `productForUpdateTestsId` and create one more product and item.
            const productToRemove = await prisma.product.create({
                data: {
                    name: "Product To Be Removed",
                    sku: "PUTRMV001",
                    price: 300
                }
            });
            const productToRemoveId = productToRemove.id;
            const productToRemoveQuantity = 4;
            const productToRemovePrice = 40;
            // Update the existing invoice (created in global beforeEach for PUT) to include this second item first.
            const addSecondItemPayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    },
                    {
                        productId: productToRemoveId.toString(),
                        quantity: productToRemoveQuantity,
                        price: productToRemovePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    },
                    {
                        [createdShopId]: productToRemoveQuantity
                    }
                ]
            };
            const addReq = createMockNextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: addSecondItemPayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route1.PUT)(addReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            // Sanity check: Invoice should have 2 items
            let invoiceWithTwoItems = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(invoiceWithTwoItems?.items.length).toBe(2);
            // 2. Prepare the update payload that only contains the item we want to keep.
            const updatePayloadToRemoveItem = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    } // Distribution for the kept item
                ]
            };
            // 3. Simulate API call to remove the item
            const removeReq = createMockNextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayloadToRemoveItem),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(removeReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB - should now have only 1 item
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(productForUpdateTestsId);
            expect(dbInvoice?.items[0].quantity).toBe(initialPurchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(initialPurchasePrice);
            expect(dbInvoice?.total).toBe(initialPurchaseQuantity * initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the KEPT item
            const keptInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(keptInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(keptInventory?.shopSpecificCost).toBeCloseTo(initialPurchasePrice);
            const keptProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(keptProduct?.weightedAverageCost).toBeCloseTo(initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the REMOVED item
            // Stock should be zero or the item might be gone from inventory if it was the only purchase
            // WAC on product should be 0 if no other purchases exist.
            const removedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productToRemoveId,
                    shopId: createdShopId
                }
            });
            // The PUT logic reverses stock. If this was the only stock, it becomes 0.
            expect(removedInventory?.quantity).toBe(0);
            // ShopSpecificCost might become 0 or NaN if quantity is 0. The API sets it to 0 for safety.
            expect(removedInventory?.shopSpecificCost).toBeCloseTo(0);
            const removedProductDb = await prisma.product.findUnique({
                where: {
                    id: productToRemoveId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfRemovedItem = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productToRemoveId
                }
            });
            if (otherPurchasesOfRemovedItem === 0) {
                expect(removedProductDb?.weightedAverageCost).toBeCloseTo(0);
            } // Else, it would be based on other purchases, which this test doesn't set up.
        }, 15000); // Increased timeout
    });
    describe("DELETE /api/purchases/:id (Delete Purchase Invoice)", ()=>{
        let invoiceToDeleteId;
        let productForDeleteTestId;
        const deleteTestInitialPrice = 60;
        const deleteTestInitialQuantity = 12;
        beforeEach(async ()=>{
            // Ensure product exists for the test
            const product = await prisma.product.create({
                data: {
                    name: "Product For Delete Test",
                    sku: "DELPROD001",
                    price: 100
                }
            });
            productForDeleteTestId = product.id;
            // Create an initial purchase invoice to be deleted
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productForDeleteTestId.toString(),
                        quantity: deleteTestInitialQuantity,
                        price: deleteTestInitialPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: deleteTestInitialQuantity
                    } // Explicit distribution
                ],
                totalAmount: deleteTestInitialQuantity * deleteTestInitialPrice,
                status: "paid"
            };
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: initialInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            invoiceToDeleteId = body.data.id;
            // Sanity check: verify initial state after creation
            const initialProductDB = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            expect(initialProductDB?.weightedAverageCost).toBe(deleteTestInitialPrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(deleteTestInitialQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(deleteTestInitialPrice);
        });
        it("should delete a purchase invoice and correctly reverse stock and WACs for a single-item invoice with explicit distribution", async ()=>{
            // 1. Call the DELETE endpoint
            const deleteReq = createMockNextRequest(`http://localhost/api/purchases/${invoiceToDeleteId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceToDeleteId
                }
            });
            // 2. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 3. Verify PurchaseInvoice is deleted from DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceToDeleteId
                }
            });
            expect(dbInvoice).toBeNull();
            // 4. Verify PurchaseInvoiceItems are deleted
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceToDeleteId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock is reversed
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            // Assuming this was the only purchase, stock should be 0
            expect(updatedInventory?.quantity).toBe(0);
            // ShopSpecificCost should also be 0 if stock is 0
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated (should be 0 if this was the only purchase)
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfProduct = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productForDeleteTestId
                }
            });
            if (otherPurchasesOfProduct === 0) {
                expect(updatedProduct?.weightedAverageCost).toBeCloseTo(0);
            }
        });
        it("should delete a purchase and reverse stock/WAC when product is in a single inferred shop", async ()=>{
            // 1. Setup: Create dedicated entities for this test to ensure isolation.
            const testShop = await prisma.shop.create({
                data: {
                    name: "Inferred Delete Test Shop",
                    location: "Loc X"
                }
            });
            const testSupplier = await prisma.supplier.create({
                data: {
                    name: "Inferred Delete Test Supplier"
                }
            });
            const testProduct = await prisma.product.create({
                data: {
                    name: "Product for Inferred Delete",
                    sku: "INFDEL001",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            // Create an inventory item for this product in the test shop.
            // This makes it the "single inferred shop".
            await prisma.inventoryItem.create({
                data: {
                    productId: testProduct.id,
                    shopId: testShop.id,
                    quantity: 0,
                    shopSpecificCost: 0
                }
            });
            const purchaseQuantity = 12;
            const purchasePrice = 60;
            const inferredShopInvoicePayload = {
                supplierId: testSupplier.id.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: testProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                // NO distributions property here for inference to kick in on POST
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // Create the purchase invoice (this is where the failure was happening)
            const createReq = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(inferredShopInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201); // Assert successful creation
            const createBody = await createResponse.json();
            const invoiceIdForInferredDelete = createBody.data.id;
            // Sanity check: Verify stock and WAC after creation
            const inventoryAfterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(inventoryAfterCreate?.quantity).toBe(purchaseQuantity);
            expect(inventoryAfterCreate?.shopSpecificCost).toBeCloseTo(purchasePrice);
            const productAfterCreate = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(productAfterCreate?.weightedAverageCost).toBeCloseTo(purchasePrice);
            // 2. Call the DELETE endpoint
            const deleteReq = createMockNextRequest(`http://localhost/api/purchases/${invoiceIdForInferredDelete}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceIdForInferredDelete
                }
            });
            // 3. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 4. Verify PurchaseInvoice and Items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock and shopSpecificCost are reversed in the inferred shop
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(updatedInventory?.quantity).toBe(0);
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated to 0
            const updatedProductDB = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(updatedProductDB?.weightedAverageCost).toBeCloseTo(0);
            // Cleanup dedicated entities for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: testProduct.id
                }
            });
            await prisma.product.delete({
                where: {
                    id: testProduct.id
                }
            });
            await prisma.supplier.delete({
                where: {
                    id: testSupplier.id
                }
            });
            await prisma.shop.delete({
                where: {
                    id: testShop.id
                }
            });
        }, 15000); // Added a longer timeout as a precaution
        it("should delete an invoice with multiple items, reversing stock/WAC for each", async ()=>{
            // 1. Setup: Create multiple products and an invoice with items from these products.
            // For simplicity, distribute each to the main createdShopId from global beforeEach.
            const productA = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod A",
                    sku: "MDEL00A",
                    price: 100,
                    weightedAverageCost: 0
                }
            });
            const productB = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod B",
                    sku: "MDEL00B",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            const quantityA = 5;
            const priceA = 50;
            const quantityB = 3;
            const priceB = 120;
            const multiItemInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productA.id.toString(),
                        quantity: quantityA,
                        price: priceA
                    },
                    {
                        productId: productB.id.toString(),
                        quantity: quantityB,
                        price: priceB
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityA
                    },
                    {
                        [createdShopId]: quantityB
                    } // Item B to main shop
                ],
                totalAmount: quantityA * priceA + quantityB * priceB,
                status: "paid"
            };
            const createReq = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: multiItemInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201);
            const createBody = await createResponse.json();
            const multiItemInvoiceId = createBody.data.id;
            // Sanity check inventory and WAC after creation
            const invA_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterCreate?.quantity).toBe(quantityA);
            expect(invA_afterCreate?.shopSpecificCost).toBe(priceA);
            const prodA_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterCreate?.weightedAverageCost).toBe(priceA);
            const invB_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterCreate?.quantity).toBe(quantityB);
            expect(invB_afterCreate?.shopSpecificCost).toBe(priceB);
            const prodB_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterCreate?.weightedAverageCost).toBe(priceB);
            // 2. Call DELETE endpoint
            const deleteReq = createMockNextRequest(`http://localhost/api/purchases/${multiItemInvoiceId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: multiItemInvoiceId
                }
            });
            expect(deleteResponse.status).toBe(200);
            // 3. Verify invoice and items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: multiItemInvoiceId
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: multiItemInvoiceId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 4. Verify stock and WAC for Product A are reversed
            const invA_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterDelete?.quantity).toBe(0);
            expect(invA_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodA_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // 5. Verify stock and WAC for Product B are reversed
            const invB_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterDelete?.quantity).toBe(0);
            expect(invB_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodB_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // Clean up products and their inventory items created for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
            await prisma.product.deleteMany({
                where: {
                    id: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
        }, 15000); // Timeout for safety
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvaW50ZWdyYXRpb24vcHVyY2hhc2VJbnZvaWNlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGplc3QtZW52aXJvbm1lbnQgbm9kZVxuICovXG5pbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tICdAcHJpc21hL2NsaWVudCc7XG5pbXBvcnQgeyBQT1NUIGFzIGNyZWF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvcm91dGUnOyAvLyBBZGp1c3QgaWYgZGlyZWN0IGltcG9ydCBpc24ndCBmZWFzaWJsZVxuaW1wb3J0IHsgUFVUIGFzIHVwZGF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuaW1wb3J0IHsgREVMRVRFIGFzIGRlbGV0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuLy8gTW9jayBOZXh0UmVxdWVzdCBpbnRlcmZhY2VcbmludGVyZmFjZSBOZXh0UmVxdWVzdCB7XG4gIG1ldGhvZDogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgaGVhZGVyczogSGVhZGVycztcbiAganNvbigpOiBQcm9taXNlPGFueT47XG4gIHRleHQoKTogUHJvbWlzZTxzdHJpbmc+O1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2sgTmV4dFJlcXVlc3RcbmNvbnN0IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCA9ICh1cmw6IHN0cmluZywgb3B0aW9uczoge1xuICBtZXRob2Q/OiBzdHJpbmc7XG4gIGJvZHk/OiBhbnk7XG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSA9IHt9KTogTmV4dFJlcXVlc3QgPT4ge1xuICBjb25zdCB7IG1ldGhvZCA9ICdHRVQnLCBib2R5LCBoZWFkZXJzID0ge30gfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIHVybCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICBqc29uOiBhc3luYyAoKSA9PiBib2R5ID8gKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoYm9keSkgOiBib2R5KSA6IHt9LFxuICAgIHRleHQ6IGFzeW5jICgpID0+IGJvZHkgPyAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnID8gYm9keSA6IEpTT04uc3RyaW5naWZ5KGJvZHkpKSA6ICcnLFxuICB9IGFzIE5leHRSZXF1ZXN0O1xufTtcblxuaW1wb3J0IHsgY3JlYXRlTW9ja3MgfSBmcm9tICdub2RlLW1vY2tzLWh0dHAnOyAvLyBPciBhbnkgb3RoZXIgd2F5IHRvIG1vY2sgTmV4dFJlcXVlc3QvUmVzcG9uc2VcblxuY29uc3QgcHJpc21hID0gbmV3IFByaXNtYUNsaWVudCgpO1xuXG5kZXNjcmliZSgnUHVyY2hhc2UgSW52b2ljZSBBUEkgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gICAgbGV0IGNyZWF0ZWRTaG9wSWQ6IHN0cmluZztcbiAgICBsZXQgY3JlYXRlZFN1cHBsaWVySWQ6IG51bWJlcjtcbiAgICBsZXQgY3JlYXRlZFByb2R1Y3RJZDogbnVtYmVyO1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gU2VlZCBpbml0aWFsIGRhdGEgaWYgbmVjZXNzYXJ5LCBlLmcuLCBhIGRlZmF1bHQgc3VwcGxpZXIgb3Igc2hvcFxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBjcmVhdGUgdGhlbSBpbiBiZWZvcmVFYWNoIG9yIHNwZWNpZmljIHRlc3RzXG4gICAgfSk7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgZGF0YWJhc2UgdGFibGVzIHRvIGVuc3VyZSB0ZXN0IGlzb2xhdGlvblxuICAgICAgICBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5wcm9kdWN0LmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5zaG9wLmRlbGV0ZU1hbnkoe30pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHNob3AgZm9yIHRlc3RpbmdcbiAgICAgICAgY29uc3Qgc2hvcCA9IGF3YWl0IHByaXNtYS5zaG9wLmNyZWF0ZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgU2hvcCBMb2NhbCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdUZXN0IExvY2F0aW9uJyxcbiAgICAgICAgICAgICAgICAvLyBBZGQgb3RoZXIgcmVxdWlyZWQgZmllbGRzIGlmIGFueVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNyZWF0ZWRTaG9wSWQgPSBzaG9wLmlkO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHN1cHBsaWVyIGZvciB0ZXN0aW5nXG4gICAgICAgIGNvbnN0IHN1cHBsaWVyID0gYXdhaXQgcHJpc21hLnN1cHBsaWVyLmNyZWF0ZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgU3VwcGxpZXIgTG9jYWwnLFxuICAgICAgICAgICAgICAgIC8vIEFkZCBvdGhlciByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjcmVhdGVkU3VwcGxpZXJJZCA9IHN1cHBsaWVyLmlkO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHByb2R1Y3QgZm9yIHRlc3RpbmcgdXBkYXRlcy9kZWxldGVzIChub3QgZm9yIGNyZWF0ZSBuZXcgcHJvZHVjdCB0ZXN0KVxuICAgICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXhpc3RpbmcgUHJvZHVjdCcsXG4gICAgICAgICAgICAgICAgcHJpY2U6IDEwMCwgLy8gcmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgc2t1OiAnRVhJU1RJTkcwMDEnLFxuICAgICAgICAgICAgICAgIHNob3BJZDogY3JlYXRlZFNob3BJZCwgLy8gT3B0aW9uYWw6IGFzc29jaWF0ZSB3aXRoIGEgc2hvcCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gd2VpZ2h0ZWRBdmVyYWdlQ29zdCB3aWxsIGJlIHNldCBieSBwdXJjaGFzZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNyZWF0ZWRQcm9kdWN0SWQgPSBwcm9kdWN0LmlkO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBDbGVhbiB1cCBkYXRhYmFzZSBhZnRlciBhbGwgdGVzdHNcbiAgICAgICAgYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEucHJvZHVjdC5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnN1cHBsaWVyLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuc2hvcC5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLiRkaXNjb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnUE9TVCAvYXBpL3B1cmNoYXNlcyAoQ3JlYXRlIFB1cmNoYXNlIEludm9pY2UpJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhIHB1cmNoYXNlIGludm9pY2UgZm9yIGEgbmV3IHByb2R1Y3QsIHVwZGF0ZSBpbnZlbnRvcnksIGFuZCBzZXQgV0FDJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gRGVmaW5lIGRhdGEgZm9yIGEgbmV3IHByb2R1Y3RcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb2R1Y3ROYW1lID0gJ0JyYW5kIE5ldyBSYWNrZXQnO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvZHVjdFNrdSA9ICdORVdCMDAxJztcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUHJpY2UgPSAxNTA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gMTA7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcm9kdWN0IGZpcnN0IChhcyBBUEkgZXhwZWN0cyBwcm9kdWN0SWQpXG4gICAgICAgICAgICAvLyBJbiBhIHJlYWwgc2NlbmFyaW8sIHRoZSBVSSBtaWdodCBjcmVhdGUgcHJvZHVjdCB0aGVuIHB1cmNoYXNlLCBvciBwdXJjaGFzZSBBUEkgaGFuZGxlcyBwcm9kdWN0IGNyZWF0aW9uXG4gICAgICAgICAgICAvLyBGb3IgdGhpcyB0ZXN0LCBhc3N1bWUgcHJvZHVjdCBpcyBjcmVhdGVkIGp1c3QgYmVmb3JlLCBvciBBUEkgaW1wbGllcyBpdHMgY3JlYXRpb24gZnJvbSBwdXJjaGFzZSAobm90IGN1cnJlbnQgQVBJKVxuICAgICAgICAgICAgLy8gTGV0J3MgYXNzdW1lIGZvciBub3cgcHJvZHVjdCBtdXN0IGV4aXN0LCBpZiBBUEkgZG9lc24ndCBjcmVhdGUgaXQgZnJvbSBwdXJjaGFzZSBpdGVtcy5cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IEFQSSdzIFBPU1QgL2FwaS9wdXJjaGFzZXMgZXhwZWN0cyBpdGVtLnByb2R1Y3RJZCwgaW1wbHlpbmcgcHJvZHVjdCBleGlzdHMuXG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1Rlc3RQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5ld1Byb2R1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBza3U6IG5ld1Byb2R1Y3RTa3UsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAyNTAsIC8vIFJldGFpbCBwcmljZVxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgLy8gT3B0aW9uYWwgZGVmYXVsdCBzaG9wIGFzc29jaWF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXN0UHJvZHVjdElkID0gbmV3VGVzdFByb2R1Y3QuaWQ7XG5cbiAgICAgICAgICAgIC8vIDIuIFByZXBhcmUgdGhlIHJlcXVlc3QgYm9keSBmb3IgUE9TVCAvYXBpL3B1cmNoYXNlc1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IG5ld1Rlc3RQcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbIC8vIEV4cGxpY2l0IGRpc3RyaWJ1dGlvbiBpcyBjcnVjaWFsIGJhc2VkIG9uIGN1cnJlbnQgUE9TVCBBUElcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2NyZWF0ZWRTaG9wSWRdOiBwdXJjaGFzZVF1YW50aXR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBwdXJjaGFzZVF1YW50aXR5ICogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIENvbnN0cnVjdCBhIE5leHRSZXF1ZXN0IGluc3RhbmNlXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBwdXJjaGFzZUludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHRoZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpOyAvLyBPciAyMDAgZGVwZW5kaW5nIG9uIHlvdXIgQVBJJ3Mgc3VjY2VzcyByZXNwb25zZSBmb3IgUE9TVFxuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogY3JlYXRlZEludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5zdXBwbGllcklkKS50b0JlKGNyZWF0ZWRTdXBwbGllcklkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShuZXdUZXN0UHJvZHVjdElkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGluIERCXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0gPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcElkOiBjcmVhdGVkU2hvcElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0pLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8ucXVhbnRpdHkpLnRvQmUocHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICAvLyBUaGUgUE9TVCByb3V0ZSBzZWVtcyB0byBjYWxjdWxhdGUgc2hvcFNwZWNpZmljQ29zdCB0b28uXG4gICAgICAgICAgICAvLyBXQUMgPSAoQ3VycmVudCBUb3RhbCBWYWx1ZSArIE5ldyBQdXJjaGFzZSBWYWx1ZSkgLyAoQ3VycmVudCBRdWFudGl0eSArIE5ldyBRdWFudGl0eSlcbiAgICAgICAgICAgIC8vIEZvciBuZXcgaXRlbSwgZXhpc3Rpbmcgc2hvcFNwZWNpZmljQ29zdCBpcyAwLCBjdXJyZW50UXVhbnRpdHkgaXMgMC5cbiAgICAgICAgICAgIC8vIFNvIG5ld1Nob3BTcGVjaWZpY0Nvc3Qgc2hvdWxkIGJlIG5ld0Nvc3QgKHB1cmNoYXNlUHJpY2UpXG4gICAgICAgICAgICBleHBlY3QoZGJJbnZlbnRvcnlJdGVtPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UpO1xuXG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQcm9kdWN0IFdBQyBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IG5ld1Rlc3RQcm9kdWN0SWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICAvLyBGb3IgYSBuZXcgcHJvZHVjdCwgV0FDIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgcHVyY2hhc2UgcHJpY2Ugb2YgdGhpcyBmaXJzdCBiYXRjaFxuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgcHVyY2hhc2UgZm9yIGFuIGV4aXN0aW5nIHByb2R1Y3QsIHVwZGF0ZSBpbnZlbnRvcnksIGFuZCByZWNhbGN1bGF0ZSBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMC4gSW5pdGlhbCBzdGF0ZTogUHJvZHVjdCBleGlzdHMsIHBvdGVudGlhbGx5IHdpdGggc29tZSBpbnZlbnRvcnkgYW5kIFdBQ1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFB1cmNoYXNlUHJpY2UgPSAxMjA7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDU7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3RJZCA9IGNyZWF0ZWRQcm9kdWN0SWQ7IC8vIEZyb20gYmVmb3JlRWFjaFxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gaW5pdGlhbCBwdXJjaGFzZSB0byBzZXQgdXAgZXhpc3RpbmcgaW52ZW50b3J5IGFuZCBXQUNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDg2NDAwMDAwKS50b0lTT1N0cmluZygpLCAvLyBZZXN0ZXJkYXlcbiAgICAgICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBleGlzdGluZ1Byb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiBpbml0aWFsUHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH1dLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAqIGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBpbml0aWFsUGF5bG9hZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UoaW5pdGlhbFJlcSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RCZWZvcmVOZXdQdXJjaGFzZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogZXhpc3RpbmdQcm9kdWN0SWQgfSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGludmVudG9yeUJlZm9yZU5ld1B1cmNoYXNlID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHsgd2hlcmU6IHsgcHJvZHVjdElkOiBleGlzdGluZ1Byb2R1Y3RJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH0gfSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChwcm9kdWN0QmVmb3JlTmV3UHVyY2hhc2U/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuICAgICAgICAgICAgZXhwZWN0KGludmVudG9yeUJlZm9yZU5ld1B1cmNoYXNlPy5xdWFudGl0eSkudG9CZShpbml0aWFsUHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoaW52ZW50b3J5QmVmb3JlTmV3UHVyY2hhc2U/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyAxLiBEZWZpbmUgZGF0YSBmb3IgdGhlIG5ldyBwdXJjaGFzZSBvZiB0aGUgZXhpc3RpbmcgcHJvZHVjdFxuICAgICAgICAgICAgY29uc3QgbmV3UHVyY2hhc2VQcmljZSA9IDEwMDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1B1cmNoYXNlUXVhbnRpdHkgPSA4O1xuXG4gICAgICAgICAgICAvLyAyLiBQcmVwYXJlIHRoZSByZXF1ZXN0IGJvZHlcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBleGlzdGluZ1Byb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IG5ld1B1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogbmV3UHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2NyZWF0ZWRTaG9wSWRdOiBuZXdQdXJjaGFzZVF1YW50aXR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBuZXdQdXJjaGFzZVF1YW50aXR5ICogbmV3UHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIFNpbXVsYXRlIEFQSSBjYWxsXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBwdXJjaGFzZUludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIDQuIEFzc2VydGlvbnNcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW1cbiAgICAgICAgICAgIGNvbnN0IGRiSW52ZW50b3J5SXRlbSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBleGlzdGluZ1Byb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcElkOiBjcmVhdGVkU2hvcElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVG90YWxRdWFudGl0eSA9IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICsgbmV3UHVyY2hhc2VRdWFudGl0eTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0/LnF1YW50aXR5KS50b0JlKGV4cGVjdGVkVG90YWxRdWFudGl0eSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBzaG9wU3BlY2lmaWNDb3N0IHJlY2FsY3VsYXRpb25cbiAgICAgICAgICAgIC8vIFNTQyA9ICgob2xkUXR5ICogb2xkU1NDKSArIChuZXdRdHkgKiBuZXdQcmljZSkpIC8gKG9sZFF0eSArIG5ld1F0eSlcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkU2hvcFNwZWNpZmljQ29zdCA9XG4gICAgICAgICAgICAgICAgKChpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAqIGluaXRpYWxQdXJjaGFzZVByaWNlKSArIChuZXdQdXJjaGFzZVF1YW50aXR5ICogbmV3UHVyY2hhc2VQcmljZSkpIC9cbiAgICAgICAgICAgICAgICAoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKyBuZXdQdXJjaGFzZVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKGV4cGVjdGVkU2hvcFNwZWNpZmljQ29zdCk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQcm9kdWN0IFdBQyByZWNhbGN1bGF0aW9uXG4gICAgICAgICAgICAvLyBXQUMgPSAoKG9sZFRvdGFsUXR5ICogb2xkV0FDKSArIChuZXdQdXJjaGFzZVF0eSAqIG5ld1B1cmNoYXNlUHJpY2UpKSAvIChuZXdUb3RhbFF0eSArIG5ld1B1cmNoYXNlUXR5KVxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBwcm9kdWN0IFdBQyB3YXMgaW5pdGlhbFB1cmNoYXNlUHJpY2UgZm9yIGluaXRpYWxQdXJjaGFzZVF1YW50aXR5LlxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRQcm9kdWN0V0FDID1cbiAgICAgICAgICAgICAgICAoKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UpICsgKG5ld1B1cmNoYXNlUXVhbnRpdHkgKiBuZXdQdXJjaGFzZVByaWNlKSkgL1xuICAgICAgICAgICAgICAgIChpbml0aWFsUHVyY2hhc2VRdWFudGl0eSArIG5ld1B1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgY29uc3QgZGJQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBleGlzdGluZ1Byb2R1Y3RJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oZXhwZWN0ZWRQcm9kdWN0V0FDKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgcHVyY2hhc2Ugd2l0aCBtdWx0aXBsZSBpdGVtcyBhbmQgdXBkYXRlIGludmVudG9yeS9XQUMgZm9yIGVhY2gnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBDcmVhdGUgdHdvIGRpc3RpbmN0IHByb2R1Y3RzIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QxRGF0YSA9IHsgbmFtZTogJ011bHRpSXRlbSBQcm9kdWN0IEEnLCBza3U6ICdNVUxUSTAwMScsIHByaWNlOiA1MCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH07XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0MkRhdGEgPSB7IG5hbWU6ICdNdWx0aUl0ZW0gUHJvZHVjdCBCJywgc2t1OiAnTVVMVEkwMDInLCBwcmljZTogNzUsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9O1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdDEgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoeyBkYXRhOiBwcm9kdWN0MURhdGEgfSk7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0MiA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7IGRhdGE6IHByb2R1Y3QyRGF0YSB9KTtcblxuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZTEgPSA0MDtcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUXVhbnRpdHkxID0gNTtcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUHJpY2UyID0gNjA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5MiA9IDM7XG5cbiAgICAgICAgICAgIC8vIDIuIFByZXBhcmUgdGhlIHJlcXVlc3QgYm9keVxuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3QxLmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcHVyY2hhc2VRdWFudGl0eTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZTEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdDIuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5MixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwdXJjaGFzZVByaWNlMixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFsgLy8gRXhwbGljaXQgZGlzdHJpYnV0aW9uIGZvciBlYWNoIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHkxIH0sIC8vIERpc3RyaWJ1dGlvbiBmb3IgaXRlbSAxXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBwdXJjaGFzZVF1YW50aXR5MiB9ICAvLyBEaXN0cmlidXRpb24gZm9yIGl0ZW0gMlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IChwdXJjaGFzZVF1YW50aXR5MSAqIHB1cmNoYXNlUHJpY2UxKSArIChwdXJjaGFzZVF1YW50aXR5MiAqIHB1cmNoYXNlUHJpY2UyKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIFNpbXVsYXRlIEFQSSBjYWxsXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBwdXJjaGFzZUludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIDQuIEFzc2VydGlvbnNcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBhbmQgaXRzIGl0ZW1zXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBjcmVhdGVkSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogeyBvcmRlckJ5OiB7IHByb2R1Y3RJZDogJ2FzYycgfSB9IH0gLy8gT3JkZXIgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYXNzZXJ0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcbiAgICAgICAgICAgIC8vIEFzc3VtaW5nIHByb2R1Y3QxLmlkIDwgcHJvZHVjdDIuaWQgZHVlIHRvIGNyZWF0aW9uIG9yZGVyIGZvciBjb25zaXN0ZW50IGNoZWNrc1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkUHJvZHVjdHMgPSBbcHJvZHVjdDEsIHByb2R1Y3QyXS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1swXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5MSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzFdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1sxXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5Mik7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMik7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAxXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0xID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QxLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTE/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0xPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UxKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDEgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QxLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0MT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAyXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0yID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QyLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTI/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkyKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0yPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UyKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QyLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Mj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMik7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIGRpc3RyaWJ1dGUgYSBzaW5nbGUgcHVyY2hhc2UgaXRlbSB0byBtdWx0aXBsZSBzaG9wcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSB0d28gbmV3IHNob3BzIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgIGNvbnN0IHNob3BBID0gYXdhaXQgcHJpc21hLnNob3AuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnVGVzdCBTaG9wIEEnLCBsb2NhdGlvbjogJ0xvYyBBJyB9IH0pO1xuICAgICAgICAgICAgY29uc3Qgc2hvcEIgPSBhd2FpdCBwcmlzbWEuc2hvcC5jcmVhdGUoeyBkYXRhOiB7IG5hbWU6ICdUZXN0IFNob3AgQicsIGxvY2F0aW9uOiAnTG9jIEInIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIDIuIENyZWF0ZSBhIG5ldyBwcm9kdWN0XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnU3BsaXQgUHJvZHVjdCcsIHNrdTogJ1NQTElUMDAxJywgcHJpY2U6IDIwMCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZSA9IDE4MDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsUXVhbnRpdHkgPSAxMDtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5Rm9yU2hvcEEgPSA2O1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlGb3JTaG9wQiA9IDQ7XG5cbiAgICAgICAgICAgIGV4cGVjdChxdWFudGl0eUZvclNob3BBICsgcXVhbnRpdHlGb3JTaG9wQikudG9CZSh0b3RhbFF1YW50aXR5KTsgLy8gU2FuaXR5IGNoZWNrXG5cbiAgICAgICAgICAgIC8vIDMuIFByZXBhcmUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHRvdGFsUXVhbnRpdHksIC8vIFRvdGFsIHF1YW50aXR5IGZvciB0aGUgaXRlbSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyAvLyBEaXN0cmlidXRpb24gZm9yIHRoZSBzaW5nbGUgaXRlbSwgc3BsaXQgaW50byB0d28gc2hvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzaG9wQS5pZF06IHF1YW50aXR5Rm9yU2hvcEEsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2hvcEIuaWRdOiBxdWFudGl0eUZvclNob3BCLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogdG90YWxRdWFudGl0eSAqIHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyA0LiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogcHVyY2hhc2VJbnZvaWNlUGF5bG9hZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZVB1cmNoYXNlSW52b2ljZShyZXEpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAvLyA1LiBBc3NlcnRpb25zXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGZvciBTaG9wIEFcbiAgICAgICAgICAgIGNvbnN0IGludkl0ZW1BID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QuaWQsIHNob3BJZDogc2hvcEEuaWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUEpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1BPy5xdWFudGl0eSkudG9CZShxdWFudGl0eUZvclNob3BBKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gZm9yIFNob3AgQlxuICAgICAgICAgICAgY29uc3QgaW52SXRlbUIgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdC5pZCwgc2hvcElkOiBzaG9wQi5pZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQikubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUI/LnF1YW50aXR5KS50b0JlKHF1YW50aXR5Rm9yU2hvcEIpO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1CPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgUHJvZHVjdCBXQUMgKHNob3VsZCBiZSB0aGUgcHVyY2hhc2UgcHJpY2UgYXMgaXQncyBhbGwgbmV3IHN0b2NrKVxuICAgICAgICAgICAgY29uc3QgZGJQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0LmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UpO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBmYWlsIHRvIGNyZWF0ZSBhIHB1cmNoYXNlIGlmIGEgcHJvZHVjdElkIGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9uRXhpc3RlbnRQcm9kdWN0SWQgPSA5OTk5OTk7IC8vIEFzc3VtaW5nIHRoaXMgSUQgd29uJ3QgZXhpc3RcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUHJpY2UgPSAxMDA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gNTtcblxuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IG5vbkV4aXN0ZW50UHJvZHVjdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcHVyY2hhc2VRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcHVyY2hhc2VRdWFudGl0eSB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogcHVyY2hhc2VRdWFudGl0eSAqIHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBwdXJjaGFzZUludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG5cbiAgICAgICAgICAgIC8vIEV4cGVjdCBhIGNsaWVudCBlcnJvciAoZS5nLiwgNDAwIG9yIDQwNCkgb3IgcG90ZW50aWFsbHkgNTAwIGlmIG5vdCBoYW5kbGVkIGdyYWNlZnVsbHlcbiAgICAgICAgICAgIC8vIEZvciByb2J1c3QgZXJyb3IgaGFuZGxpbmcsIEFQSSBzaG91bGQgcmV0dXJuIHNwZWNpZmljIGVycm9yIGNvZGUuXG4gICAgICAgICAgICAvLyBQcmlzbWEgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBhIHJlbGF0ZWQgcmVjb3JkIChwcm9kdWN0KSBpcyBub3QgZm91bmQgZm9yIGZvcmVpZ24ga2V5LlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGxpa2VseSByZXN1bHQgaW4gYSA1MDAgaWYgbm90IGNhdWdodCBhbmQgaGFuZGxlZCBieSB0aGUgQVBJIHJvdXRlLlxuICAgICAgICAgICAgLy8gTGV0J3MgYWltIGZvciB0aGUgQVBJIHRvIGNhdGNoIHRoaXMgYW5kIHJldHVybiBhIG1vcmUgc3BlY2lmaWMgY2xpZW50IGVycm9yLlxuICAgICAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgY2hlY2sgaWYgaXQncyBOT1QgYSBzdWNjZXNzICgyMDEpLlxuICAgICAgICAgICAgLy8gQSBtb3JlIHByZWNpc2UgY2hlY2sgd291bGQgYmUgZm9yIDQwMC80MDQvNDIyIGRlcGVuZGluZyBvbiBwbGFubmVkIGVycm9yIGhhbmRsaW5nLlxuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApOyAvLyBPciA0MDAvNDA0IGlmIHlvdSBpbXBsZW1lbnQgc3BlY2lmaWMgZXJyb3IgaGFuZGxpbmdcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsbHksIGNoZWNrIGZvciBhIHNwZWNpZmljIGVycm9yIG1lc3NhZ2Ugb3IgY29kZSBpZiB5b3VyIEFQSSBwcm92aWRlcyBvbmUuXG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIGZhaWwgdG8gY3JlYXRlIGEgcHVyY2hhc2UgaWYgYSBzdXBwbGllcklkIGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3VGVzdFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1Byb2R1Y3QgRm9yIEludmFsaWQgU3VwcGxpZXIgVGVzdCcsXG4gICAgICAgICAgICAgICAgICAgIHNrdTogJ0lOViBTVVAwMDEnLFxuICAgICAgICAgICAgICAgICAgICBwcmljZTogMTAwLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZSA9IDgwO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eSA9IDU7XG4gICAgICAgICAgICBjb25zdCBub25FeGlzdGVudFN1cHBsaWVySWQgPSA5OTk5OTk7IC8vIEFzc3VtaW5nIHRoaXMgSUQgd29uJ3QgZXhpc3RcblxuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBub25FeGlzdGVudFN1cHBsaWVySWQudG9TdHJpbmcoKSwgLy8gSW52YWxpZCBzdXBwbGllclxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IG5ld1Rlc3RQcm9kdWN0LmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcHVyY2hhc2VRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcHVyY2hhc2VRdWFudGl0eSB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogcHVyY2hhc2VRdWFudGl0eSAqIHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBwdXJjaGFzZUludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTsgLy8gRXhwZWN0aW5nIDUwMCBhcyBQcmlzbWEgdGhyb3dzIFAyMDAzXG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1BVVCAvYXBpL3B1cmNoYXNlcy86aWQgKFVwZGF0ZSBQdXJjaGFzZSBJbnZvaWNlKScsICgpID0+IHtcbiAgICAgICAgbGV0IGV4aXN0aW5nSW52b2ljZUlkOiBzdHJpbmc7XG4gICAgICAgIGxldCBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZDogbnVtYmVyO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VQcmljZSA9IDUwO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDEwO1xuXG4gICAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZHVjdCBzcGVjaWZpY2FsbHkgZm9yIHRoZXNlIHVwZGF0ZS9kZWxldGUgdGVzdHMgaWYgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gVGhlIGdsb2JhbCBjcmVhdGVkUHJvZHVjdElkIGNhbiBiZSB1c2VkIGlmIGl0IGZpdHMsIG9yIG1ha2UgYSBuZXcgb25lLlxuICAgICAgICAgICAgLy8gTGV0J3MgdXNlIHRoZSBnbG9iYWwgb25lIGZvciBzaW1wbGljaXR5LCBhc3N1bWluZyBiZWZvcmVFYWNoIGNsZWFucyBpdCB1cC5cbiAgICAgICAgICAgIHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkID0gY3JlYXRlZFByb2R1Y3RJZDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGluaXRpYWwgcHVyY2hhc2UgaW52b2ljZSB0byBiZSB1cGRhdGVkIG9yIGRlbGV0ZWQgaW4gdGVzdHNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSA4NjQwMDAwMCkudG9JU09TdHJpbmcoKSwgLy8gWWVzdGVyZGF5XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVxID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogaW5pdGlhbEludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZVB1cmNoYXNlSW52b2ljZShyZXEpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4aXN0aW5nSW52b2ljZUlkID0gYm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IHZlcmlmeSBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShpbml0aWFsUHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGluaXRpYWxJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSBpdGVtIHF1YW50aXR5IChpbmNyZWFzZSksIHJlY2FsY3VsYXRlIHN0b2NrIGFuZCBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlJbmNyZWFzZSA9IDU7XG4gICAgICAgICAgICBjb25zdCBuZXdRdWFudGl0eSA9IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICsgcXVhbnRpdHlJbmNyZWFzZTtcbiAgICAgICAgICAgIC8vIFByaWNlIHJlbWFpbnMgdGhlIHNhbWUgZm9yIHRoaXMgaXRlbSBpbiB0aGlzIHVwZGF0ZSBzY2VuYXJpb1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByaWNlRm9ySXRlbSA9IGluaXRpYWxQdXJjaGFzZVByaWNlO1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc2VuZCB0aGUgY29tcGxldGUgc3RydWN0dXJlIGV4cGVjdGVkIGJ5IHRoZSBQVVQgcm91dGVcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIGFsbCBpdGVtcywgZXZlbiBpZiBvbmx5IG9uZSBpcyBjaGFuZ2luZy5cbiAgICAgICAgICAgICAgICAvLyBUaGUgUFVUIHJvdXRlIGxvZ2ljIG1pZ2h0IGNvbXBhcmUgd2l0aCBleGlzdGluZyBpdGVtcyB0byBzZWUgd2hhdCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtIGhhZCBhbiBJRCAoUHVyY2hhc2VJbnZvaWNlSXRlbSBpZCksIGl0IG1pZ2h0IGJlIG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGFzc3VtZSBmb3Igbm93IHRoZSBQVVQgbWF0Y2hlcyBpdGVtcyBiYXNlZCBvbiBwcm9kdWN0SWQgaWYgbm90IGl0ZW0gSUQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlZCBvbiBjdXJyZW50IFBVVCByb3V0ZSwgaXQgZXhwZWN0cyBwcm9kdWN0SWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3UXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogdXBkYXRlZFByaWNlRm9ySXRlbSwgLy8gU2VuZCB0aGUgb3JpZ2luYWwgcHJpY2UgaWYgaXQgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGlzdHJpYnV0aW9ucyBpbiBQVVQgbWlnaHQgbmVlZCB0byByZWZsZWN0IHRoZSAqbmV3IHRvdGFsKiBmb3IgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IG5ld1F1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIE90aGVyIGZpZWxkcyBsaWtlIHN1cHBsaWVySWQsIGRhdGUsIHRvdGFsQW1vdW50IG1pZ2h0IGJlIHVwZGF0YWJsZSB0b28uXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoaXMgdGVzdCwgZm9jdXMgb24gaXRlbSBxdWFudGl0eSBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgLy8gVGhlIFBVVCByb3V0ZSByZWNhbGN1bGF0ZXMgdG90YWxBbW91bnQgYmFzZWQgb24gaXRlbXMgaWYgbm90IHByb3ZpZGVkIG9yIGlmIGl0ZW1zIGNoYW5nZS5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgdG90YWxBbW91bnQgd2lsbCBiZSByZWNhbGN1bGF0ZWQgYnkgdGhlIEFQSS5cbiAgICAgICAgICAgICAgICAvLyBzdXBwbGllcklkIGFuZCBkYXRlIGNvdWxkIGJlIHBhcnQgb2YgdGhlIHBheWxvYWQgaWYgdGhleSBhcmUgdXBkYXRhYmxlLlxuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIGtlZXBpbmcgaXQgbWluaW1hbCB0byB0ZXN0IGl0ZW0gdXBkYXRlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBQVVQgaGFuZGxlciByZS1jYWxjdWxhdGVzIHRvdGFsIGFtb3VudCwgc28gbm90IHNlbmRpbmcgaXQuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IHVwZGF0ZVBheWxvYWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBOZWVkIHRvIHBhc3Mgcm91dGUgcGFyYW1zIGZvciBbaWRdIHRvIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBub3Qgc3RhbmRhcmQgTmV4dFJlcXVlc3QgYnV0IGhvdyB0ZXN0IHNldHVwIG1pZ2h0IG5lZWQgaXQgb3IgaG93IGhhbmRsZXIgZXhwZWN0cyBpdC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgYWN0dWFsIGhhbmRsZXIgYHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXF1ZXN0OiBOZXh0UmVxdWVzdCwgeyBwYXJhbXMgfTogeyBwYXJhbXM6IHsgaWQ6IHN0cmluZyB9IH0pYFxuICAgICAgICAgICAgICAgIC8vIG5lZWRzIGBwYXJhbXNgLiBub2RlLW1vY2tzLWh0dHAgYGNyZWF0ZU1vY2tzYCBoYW5kbGVzIHRoaXMgd2VsbC5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZGlyZWN0IE5leHRSZXF1ZXN0LCB3ZSBwYXNzIGl0IGluIGNvbnRleHQgdG8gdGhlIGhhbmRsZXIgY2FsbC5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTaW11bGF0ZSBBUEkgY2FsbCAtIHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGhvdyB5b3UgY2FsbCBpdCBpZiB5b3UgYXJlIHRlc3RpbmcgdGhlIGhhbmRsZXIgZGlyZWN0bHkgaW4gSmVzdCB3aXRoIGNvbnRleHRcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdXBkYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSwgeyBwYXJhbXM6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZGF0YSkudG9IYXZlUHJvcGVydHkoJ2lkJywgZXhpc3RpbmdJbnZvaWNlSWQpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBzdG9jayBhbmQgc2hvcFNwZWNpZmljQ29zdFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKG5ld1F1YW50aXR5KTtcblxuICAgICAgICAgICAgLy8gV0FDIGNhbGN1bGF0aW9uOiAoKG9sZFF0eSAqIG9sZFNTQykgKyAoYWRkZWRRdHkgKiBwcmljZU9mQWRkZWRRdHkpKSAvIChuZXdUb3RhbFF0eSlcbiAgICAgICAgICAgIC8vIEluIHRoaXMgc3BlY2lmaWMgdXBkYXRlLCB0aGUgUFVUIHJvdXRlIHJldmVyc2VzIHRoZSBvbGQgaXRlbSBhbmQgYWRkcyB0aGUgbmV3IG9uZSBhcyBpZiBpdCdzIGEgbmV3IHB1cmNoYXNlIGxpbmUgZm9yIFdBQyBjYWxjcy5cbiAgICAgICAgICAgIC8vIFNvLCB0aGUgb2xkIGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IGF0IGluaXRpYWxQdXJjaGFzZVByaWNlIGlzIHJldmVyc2VkLlxuICAgICAgICAgICAgLy8gVGhlbiwgbmV3UXVhbnRpdHkgYXQgdXBkYXRlZFByaWNlRm9ySXRlbSBpcyBhZGRlZC5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBjdXJyZW50IFBVVCBsb2dpYyBmaXJzdCByZXZlcnNlcyAqYWxsKiBvbGQgaXRlbXMgYmFzZWQgb24gdGhlaXIgKm9yaWdpbmFsKiByZWNvcmRlZCBjb3N0LlxuICAgICAgICAgICAgLy8gVGhlbiBpdCBhZGRzICphbGwqIG5ldyBpdGVtcyBiYXNlZCBvbiB0aGVpciAqbmV3KiBjb3N0LlxuICAgICAgICAgICAgLy8gU28gZm9yIHRoZSBwcm9kdWN0IFdBQzogKFRvdGFsVmFsdWVCZWZvcmUgLSBPbGRJdGVtVmFsdWUgKyBOZXdJdGVtVmFsdWUpIC8gKFRvdGFsU3RvY2tCZWZvcmUgLSBPbGRJdGVtUXR5ICsgTmV3SXRlbVF0eSlcbiAgICAgICAgICAgIC8vIEFuZCBmb3Igc2hvcCBzcGVjaWZpYyBXQUM6IChTaG9wVmFsdWVCZWZvcmUgLSBPbGRJdGVtVmFsdWVJblNob3AgKyBOZXdJdGVtVmFsdWVJblNob3ApIC8gKFNob3BTdG9ja0JlZm9yZSAtIE9sZEl0ZW1RdHlJblNob3AgKyBOZXdJdGVtUXR5SW5TaG9wKVxuXG4gICAgICAgICAgICAvLyBMZXQncyBjaGVjayB0aGUgbG9naWMgZnJvbSBzcmMvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZS50c1xuICAgICAgICAgICAgLy8gMS4gSXQgZmV0Y2hlcyB0aGUgb2xkIGludm9pY2UuXG4gICAgICAgICAgICAvLyAyLiBJdCByZXZlcnNlcyBpbnZlbnRvcnkgYWRqdXN0bWVudHMgZm9yIEFMTCBvbGQgaXRlbXMgKGRlY3JlYXNlIHN0b2NrLCBXQUMgdXBkYXRlZCkuXG4gICAgICAgICAgICAvLyAzLiBJdCBwcm9jZXNzZXMgQUxMIG5ldy91cGRhdGVkIGl0ZW1zIGFzIGlmIHRoZXkgYXJlIG5ldyBwdXJjaGFzZXMgKGluY3JlYXNlIHN0b2NrLCBXQUMgdXBkYXRlZCkuXG5cbiAgICAgICAgICAgIC8vIFNvLCBhZnRlciByZXZlcnNhbCBvZiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSBhdCBpbml0aWFsUHVyY2hhc2VQcmljZTpcbiAgICAgICAgICAgIC8vIFByb2R1Y3QgV0FDIGFuZCBTaG9wU3BlY2lmaWNDb3N0IHdvdWxkIGJlIGVmZmVjdGl2ZWx5IDAgaWYgdGhpcyB3ZXJlIHRoZSBvbmx5IHByb2R1Y3Qvc3RvY2suXG4gICAgICAgICAgICAvLyBUaGVuLCBhZGRpbmcgbmV3UXVhbnRpdHkgYXQgdXBkYXRlZFByaWNlRm9ySXRlbTpcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgV0FDcyBzaG91bGQgYmVjb21lIHVwZGF0ZWRQcmljZUZvckl0ZW0uXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8odXBkYXRlZFByaWNlRm9ySXRlbSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQcm9kdWN0IFdBQ1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZFByb2R1Y3Q/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgUHVyY2hhc2VJbnZvaWNlSXRlbSBpbiBEQiByZWZsZWN0cyB0aGUgY2hhbmdlXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXMubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucXVhbnRpdHkpLnRvQmUobmV3UXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUodXBkYXRlZFByaWNlRm9ySXRlbSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy50b3RhbCkudG9CZShuZXdRdWFudGl0eSAqIHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgaXRlbSBxdWFudGl0eSAoZGVjcmVhc2UpLCByZWNhbGN1bGF0ZSBzdG9jayBhbmQgV0FDcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5RGVjcmVhc2UgPSAzO1xuICAgICAgICAgICAgY29uc3QgbmV3UXVhbnRpdHkgPSBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAtIHF1YW50aXR5RGVjcmVhc2U7XG4gICAgICAgICAgICBleHBlY3QobmV3UXVhbnRpdHkpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7IC8vIEVuc3VyZSB3ZSBkb24ndCBnbyBuZWdhdGl2ZSBmb3IgdGhpcyB0ZXN0IGxvZ2ljXG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcmljZUZvckl0ZW0gPSBpbml0aWFsUHVyY2hhc2VQcmljZTsgLy8gUHJpY2UgcmVtYWlucyB0aGUgc2FtZVxuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBuZXdRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiB1cGRhdGVkUHJpY2VGb3JJdGVtLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBuZXdRdWFudGl0eSB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7ZXhpc3RpbmdJbnZvaWNlSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgYm9keTogdXBkYXRlUGF5bG9hZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgYW5kIHNob3BTcGVjaWZpY0Nvc3RcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZShuZXdRdWFudGl0eSk7XG5cbiAgICAgICAgICAgIC8vIER1ZSB0byB0aGUgcmV2ZXJzYWwgYW5kIHJlLWFkZGl0aW9uIGxvZ2ljIG9mIHRoZSBQVVQgcm91dGU6XG4gICAgICAgICAgICAvLyBUaGUgb2xkIGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IGF0IGluaXRpYWxQdXJjaGFzZVByaWNlIGlzIHJldmVyc2VkLlxuICAgICAgICAgICAgLy8gVGhlbiwgbmV3UXVhbnRpdHkgYXQgdXBkYXRlZFByaWNlRm9ySXRlbSBpcyBhZGRlZC5cbiAgICAgICAgICAgIC8vIFNvLCBuZXcgV0FDcyBzaG91bGQgYmVjb21lIHVwZGF0ZWRQcmljZUZvckl0ZW0gKHdoaWNoIGlzIGluaXRpYWxQdXJjaGFzZVByaWNlKS5cbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8odXBkYXRlZFByaWNlRm9ySXRlbSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQdXJjaGFzZUludm9pY2VJdGVtIGluIERCXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXMubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucXVhbnRpdHkpLnRvQmUobmV3UXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUodXBkYXRlZFByaWNlRm9ySXRlbSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy50b3RhbCkudG9CZShuZXdRdWFudGl0eSAqIHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgaXRlbSBwcmljZSwgcmVjYWxjdWxhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdQcmljZUZvckl0ZW0gPSBpbml0aWFsUHVyY2hhc2VQcmljZSArIDI1OyAvLyBOZXcgcHJpY2UsIGUuZy4sIDUwICsgMjUgPSA3NVxuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlVbmNoYW5nZWQgPSBpbml0aWFsUHVyY2hhc2VRdWFudGl0eTsgLy8gUXVhbnRpdHkgcmVtYWlucyB0aGUgc2FtZVxuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBxdWFudGl0eVVuY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBuZXdQcmljZUZvckl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHF1YW50aXR5VW5jaGFuZ2VkIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIHRvdGFsQW1vdW50IHdpbGwgYmUgcmVjYWxjdWxhdGVkIGJ5IHRoZSBBUElcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7ZXhpc3RpbmdJbnZvaWNlSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgYm9keTogdXBkYXRlUGF5bG9hZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgKHNob3VsZCBiZSB1bmNoYW5nZWQpIGFuZCBzaG9wU3BlY2lmaWNDb3N0XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlVbmNoYW5nZWQpO1xuICAgICAgICAgICAgLy8gV0FDIGxvZ2ljIGluIFBVVDogcmV2ZXJzZXMgb2xkLCBhZGRzIG5ldy4gU28gc2hvcFNwZWNpZmljQ29zdCBzaG91bGQgcmVmbGVjdCBuZXdQcmljZUZvckl0ZW0uXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8obmV3UHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8obmV3UHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREJcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShxdWFudGl0eVVuY2hhbmdlZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShuZXdQcmljZUZvckl0ZW0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUocXVhbnRpdHlVbmNoYW5nZWQgKiBuZXdQcmljZUZvckl0ZW0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBhZGQgYSBuZXcgaXRlbSB0byBhbiBleGlzdGluZyBpbnZvaWNlLCB1cGRhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBEZWZpbmUgYSBuZXcgcHJvZHVjdCBmb3IgdGhlIG5ldyBpdGVtXG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTmV3bHkgQWRkZWQgUHJvZHVjdCBmb3IgUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnUFVUTkVXMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDIwMCwgLy8gUmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUHJvZHVjdElkID0gbmV3SXRlbVByb2R1Y3QuaWQ7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUXVhbnRpdHkgPSA3O1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbVByaWNlID0gMTIwO1xuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBpdGVtIGRldGFpbHMgKGZyb20gYmVmb3JlRWFjaCBzZXR1cClcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbVByb2R1Y3RJZCA9IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxJdGVtUXVhbnRpdHkgPSBpbml0aWFsUHVyY2hhc2VRdWFudGl0eTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbVByaWNlID0gaW5pdGlhbFB1cmNoYXNlUHJpY2U7XG5cbiAgICAgICAgICAgIC8vIDIuIFByZXBhcmUgdGhlIHVwZGF0ZSBwYXlsb2FkIHdpdGggYm90aCBvcmlnaW5hbCBhbmQgbmV3IGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBvcmlnaW5hbEl0ZW1RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBvcmlnaW5hbEl0ZW1QcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBuZXdJdGVtUHJvZHVjdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3SXRlbVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld0l0ZW1QcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogb3JpZ2luYWxJdGVtUXVhbnRpdHkgfSwgLy8gRGlzdHJpYnV0aW9uIGZvciBvcmlnaW5hbCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBuZXdJdGVtUXVhbnRpdHkgfSAgICAgIC8vIERpc3RyaWJ1dGlvbiBmb3IgbmV3IGl0ZW1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIHRvdGFsQW1vdW50IHdpbGwgYmUgcmVjYWxjdWxhdGVkIGJ5IHRoZSBBUElcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIFNpbXVsYXRlIEFQSSBjYWxsXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IHVwZGF0ZVBheWxvYWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdXBkYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSwgeyBwYXJhbXM6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIDQuIEFzc2VydGlvbnNcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZGF0YSkudG9IYXZlUHJvcGVydHkoJ2lkJywgZXhpc3RpbmdJbnZvaWNlSWQpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgUHVyY2hhc2VJbnZvaWNlIGluIERCXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHsgb3JkZXJCeTogeyBwcm9kdWN0SWQ6ICdhc2MnIH0gfSB9LCAvLyBPcmRlciBmb3IgY29uc2lzdGVudCBjaGVja3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXMubGVuZ3RoKS50b0JlKDIpO1xuXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFRvdGFsID0gKG9yaWdpbmFsSXRlbVF1YW50aXR5ICogb3JpZ2luYWxJdGVtUHJpY2UpICsgKG5ld0l0ZW1RdWFudGl0eSAqIG5ld0l0ZW1QcmljZSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy50b3RhbCkudG9CZShleHBlY3RlZFRvdGFsKTtcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgaXRlbXMgaW4gdGhlIHJlc3BvbnNlIChvcmRlciBtaWdodCB2YXJ5LCBzbyBmaW5kIGJ5IHByb2R1Y3RJZClcbiAgICAgICAgICAgIGNvbnN0IGRiT3JpZ2luYWxJdGVtID0gZGJJbnZvaWNlPy5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5wcm9kdWN0SWQgPT09IG9yaWdpbmFsSXRlbVByb2R1Y3RJZCk7XG4gICAgICAgICAgICBjb25zdCBkYk5ld0l0ZW0gPSBkYkludm9pY2U/Lml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLnByb2R1Y3RJZCA9PT0gbmV3SXRlbVByb2R1Y3RJZCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYk9yaWdpbmFsSXRlbSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChkYk9yaWdpbmFsSXRlbT8ucXVhbnRpdHkpLnRvQmUob3JpZ2luYWxJdGVtUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiT3JpZ2luYWxJdGVtPy5wcmljZSkudG9CZShvcmlnaW5hbEl0ZW1QcmljZSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYk5ld0l0ZW0pLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZGJOZXdJdGVtPy5xdWFudGl0eSkudG9CZShuZXdJdGVtUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiTmV3SXRlbT8ucHJpY2UpLnRvQmUobmV3SXRlbVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gYW5kIFByb2R1Y3QgV0FDIGZvciB0aGUgb3JpZ2luYWwgaXRlbVxuICAgICAgICAgICAgLy8gKER1ZSB0byBQVVQgbG9naWMgb2YgcmV2ZXJzZSAmIHJlLWFkZCwgV0FDcyBzaG91bGQgcmVmbGVjdCBpdHMgY3VycmVudCBwcmljZSlcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IG9yaWdpbmFsSXRlbVByb2R1Y3RJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZShvcmlnaW5hbEl0ZW1RdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3Qob3JpZ2luYWxJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKG9yaWdpbmFsSXRlbVByaWNlKTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogb3JpZ2luYWxJdGVtUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3Qob3JpZ2luYWxQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhvcmlnaW5hbEl0ZW1QcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgdGhlIE5FVyBpdGVtXG4gICAgICAgICAgICBjb25zdCBuZXdJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogbmV3SXRlbVByb2R1Y3RJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KG5ld0ludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUobmV3SXRlbVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChuZXdJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKG5ld0l0ZW1QcmljZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9kdWN0RGIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IG5ld0l0ZW1Qcm9kdWN0SWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChuZXdQcm9kdWN0RGI/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKG5ld0l0ZW1QcmljZSk7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIHJlbW92ZSBhbiBpdGVtIGZyb20gYW4gZXhpc3RpbmcgaW52b2ljZSwgdXBkYXRlIHN0b2NrIGFuZCBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gU2V0dXA6IEVuc3VyZSBhbiBpbnZvaWNlIHdpdGggYXQgbGVhc3QgdHdvIGl0ZW1zIGV4aXN0cy5cbiAgICAgICAgICAgIC8vIFdlJ2xsIHVzZSB0aGUgZXhpc3RpbmcgYHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkYCBhbmQgY3JlYXRlIG9uZSBtb3JlIHByb2R1Y3QgYW5kIGl0ZW0uXG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9SZW1vdmUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1Byb2R1Y3QgVG8gQmUgUmVtb3ZlZCcsXG4gICAgICAgICAgICAgICAgICAgIHNrdTogJ1BVVFJNVjAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAzMDAsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9SZW1vdmVJZCA9IHByb2R1Y3RUb1JlbW92ZS5pZDtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RUb1JlbW92ZVF1YW50aXR5ID0gNDtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RUb1JlbW92ZVByaWNlID0gNDA7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW52b2ljZSAoY3JlYXRlZCBpbiBnbG9iYWwgYmVmb3JlRWFjaCBmb3IgUFVUKSB0byBpbmNsdWRlIHRoaXMgc2Vjb25kIGl0ZW0gZmlyc3QuXG4gICAgICAgICAgICBjb25zdCBhZGRTZWNvbmRJdGVtUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogaW5pdGlhbFB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdFRvUmVtb3ZlSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwcm9kdWN0VG9SZW1vdmVQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHByb2R1Y3RUb1JlbW92ZVF1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFkZFJlcSA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7ZXhpc3RpbmdJbnZvaWNlSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgYm9keTogYWRkU2Vjb25kSXRlbVBheWxvYWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShhZGRSZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IEludm9pY2Ugc2hvdWxkIGhhdmUgMiBpdGVtc1xuICAgICAgICAgICAgbGV0IGludm9pY2VXaXRoVHdvSXRlbXMgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSwgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludm9pY2VXaXRoVHdvSXRlbXM/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgdXBkYXRlIHBheWxvYWQgdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBpdGVtIHdlIHdhbnQgdG8ga2VlcC5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWRUb1JlbW92ZUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLCAvLyBLZWVwIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogaW5pdGlhbFB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH0gLy8gRGlzdHJpYnV0aW9uIGZvciB0aGUga2VwdCBpdGVtXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIFNpbXVsYXRlIEFQSSBjYWxsIHRvIHJlbW92ZSB0aGUgaXRlbVxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlUmVxID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtleGlzdGluZ0ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVQYXlsb2FkVG9SZW1vdmVJdGVtKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVtb3ZlUmVxLCB7IHBhcmFtczogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnLCBleGlzdGluZ0ludm9pY2VJZCk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQdXJjaGFzZUludm9pY2UgaW4gREIgLSBzaG91bGQgbm93IGhhdmUgb25seSAxIGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcm9kdWN0SWQpLnRvQmUocHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKiBpbml0aWFsUHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgdGhlIEtFUFQgaXRlbVxuICAgICAgICAgICAgY29uc3Qga2VwdEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGtlcHRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChrZXB0SW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhpbml0aWFsUHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBjb25zdCBrZXB0UHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChrZXB0UHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBhbmQgUHJvZHVjdCBXQUMgZm9yIHRoZSBSRU1PVkVEIGl0ZW1cbiAgICAgICAgICAgIC8vIFN0b2NrIHNob3VsZCBiZSB6ZXJvIG9yIHRoZSBpdGVtIG1pZ2h0IGJlIGdvbmUgZnJvbSBpbnZlbnRvcnkgaWYgaXQgd2FzIHRoZSBvbmx5IHB1cmNoYXNlXG4gICAgICAgICAgICAvLyBXQUMgb24gcHJvZHVjdCBzaG91bGQgYmUgMCBpZiBubyBvdGhlciBwdXJjaGFzZXMgZXhpc3QuXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RUb1JlbW92ZUlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUaGUgUFVUIGxvZ2ljIHJldmVyc2VzIHN0b2NrLiBJZiB0aGlzIHdhcyB0aGUgb25seSBzdG9jaywgaXQgYmVjb21lcyAwLlxuICAgICAgICAgICAgZXhwZWN0KHJlbW92ZWRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKDApO1xuICAgICAgICAgICAgLy8gU2hvcFNwZWNpZmljQ29zdCBtaWdodCBiZWNvbWUgMCBvciBOYU4gaWYgcXVhbnRpdHkgaXMgMC4gVGhlIEFQSSBzZXRzIGl0IHRvIDAgZm9yIHNhZmV0eS5cbiAgICAgICAgICAgIGV4cGVjdChyZW1vdmVkSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbygwKTtcblxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFByb2R1Y3REYiA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdFRvUmVtb3ZlSWQgfSB9KTtcbiAgICAgICAgICAgIC8vIElmIG5vIG90aGVyIHB1cmNoYXNlIGl0ZW1zIGZvciB0aGlzIHByb2R1Y3QsIFdBQyBzaG91bGQgYmVjb21lIDAuXG4gICAgICAgICAgICBjb25zdCBvdGhlclB1cmNoYXNlc09mUmVtb3ZlZEl0ZW0gPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5jb3VudCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0VG9SZW1vdmVJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvdGhlclB1cmNoYXNlc09mUmVtb3ZlZEl0ZW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBleHBlY3QocmVtb3ZlZFByb2R1Y3REYj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oMCk7XG4gICAgICAgICAgICB9IC8vIEVsc2UsIGl0IHdvdWxkIGJlIGJhc2VkIG9uIG90aGVyIHB1cmNoYXNlcywgd2hpY2ggdGhpcyB0ZXN0IGRvZXNuJ3Qgc2V0IHVwLlxuXG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdERUxFVEUgL2FwaS9wdXJjaGFzZXMvOmlkIChEZWxldGUgUHVyY2hhc2UgSW52b2ljZSknLCAoKSA9PiB7XG4gICAgICAgIGxldCBpbnZvaWNlVG9EZWxldGVJZDogc3RyaW5nO1xuICAgICAgICBsZXQgcHJvZHVjdEZvckRlbGV0ZVRlc3RJZDogbnVtYmVyO1xuICAgICAgICBjb25zdCBkZWxldGVUZXN0SW5pdGlhbFByaWNlID0gNjA7XG4gICAgICAgIGNvbnN0IGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHkgPSAxMjtcblxuICAgICAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBwcm9kdWN0IGV4aXN0cyBmb3IgdGhlIHRlc3RcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1Byb2R1Y3QgRm9yIERlbGV0ZSBUZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnREVMUFJPRDAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAxMDAsIC8vIHJldGFpbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCA9IHByb2R1Y3QuaWQ7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBpbml0aWFsIHB1cmNoYXNlIGludm9pY2UgdG8gYmUgZGVsZXRlZFxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbEludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogZGVsZXRlVGVzdEluaXRpYWxQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHkgfSAvLyBFeHBsaWNpdCBkaXN0cmlidXRpb25cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBkZWxldGVUZXN0SW5pdGlhbFF1YW50aXR5ICogZGVsZXRlVGVzdEluaXRpYWxQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBpbml0aWFsSW52b2ljZVBheWxvYWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaW52b2ljZVRvRGVsZXRlSWQgPSBib2R5LmRhdGEuaWQ7XG5cbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjazogdmVyaWZ5IGluaXRpYWwgc3RhdGUgYWZ0ZXIgY3JlYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxQcm9kdWN0REIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RGb3JEZWxldGVUZXN0SWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsUHJvZHVjdERCPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKGRlbGV0ZVRlc3RJbml0aWFsUHJpY2UpO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShkZWxldGVUZXN0SW5pdGlhbFByaWNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBkZWxldGUgYSBwdXJjaGFzZSBpbnZvaWNlIGFuZCBjb3JyZWN0bHkgcmV2ZXJzZSBzdG9jayBhbmQgV0FDcyBmb3IgYSBzaW5nbGUtaXRlbSBpbnZvaWNlIHdpdGggZXhwbGljaXQgZGlzdHJpYnV0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gQ2FsbCB0aGUgREVMRVRFIGVuZHBvaW50XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2ludm9pY2VUb0RlbGV0ZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXNwb25zZSA9IGF3YWl0IGRlbGV0ZVB1cmNoYXNlSW52b2ljZShkZWxldGVSZXEsIHsgcGFyYW1zOiB7IGlkOiBpbnZvaWNlVG9EZWxldGVJZCB9IH0pO1xuXG4gICAgICAgICAgICAvLyAyLiBBc3NlcnRpb25zIGZvciBERUxFVEUgcmVzcG9uc2VcbiAgICAgICAgICAgIGV4cGVjdChkZWxldGVSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3BvbnNlQm9keSA9IGF3YWl0IGRlbGV0ZVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4cGVjdChkZWxldGVSZXNwb25zZUJvZHkubWVzc2FnZSkudG9CZSgnUHVyY2hhc2UgaW52b2ljZSBkZWxldGVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgICAgICAgICAvLyAzLiBWZXJpZnkgUHVyY2hhc2VJbnZvaWNlIGlzIGRlbGV0ZWQgZnJvbSBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogaW52b2ljZVRvRGVsZXRlSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkudG9CZU51bGwoKTtcblxuICAgICAgICAgICAgLy8gNC4gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW1zIGFyZSBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2VJdGVtcyA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmZpbmRNYW55KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwdXJjaGFzZUludm9pY2VJZDogaW52b2ljZVRvRGVsZXRlSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZUl0ZW1zLmxlbmd0aCkudG9CZSgwKTtcblxuICAgICAgICAgICAgLy8gNS4gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgaXMgcmV2ZXJzZWRcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXNzdW1pbmcgdGhpcyB3YXMgdGhlIG9ubHkgcHVyY2hhc2UsIHN0b2NrIHNob3VsZCBiZSAwXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICAvLyBTaG9wU3BlY2lmaWNDb3N0IHNob3VsZCBhbHNvIGJlIDAgaWYgc3RvY2sgaXMgMFxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG5cbiAgICAgICAgICAgIC8vIDYuIFZlcmlmeSBQcm9kdWN0IFdBQyBpcyByZWNhbGN1bGF0ZWQgKHNob3VsZCBiZSAwIGlmIHRoaXMgd2FzIHRoZSBvbmx5IHB1cmNoYXNlKVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiBubyBvdGhlciBwdXJjaGFzZSBpdGVtcyBmb3IgdGhpcyBwcm9kdWN0LCBXQUMgc2hvdWxkIGJlY29tZSAwLlxuICAgICAgICAgICAgY29uc3Qgb3RoZXJQdXJjaGFzZXNPZlByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5jb3VudCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkLFxuICAgICAgICAgICAgICAgICAgICAvLyBwdXJjaGFzZUludm9pY2VJZDogeyBub3Q6IGludm9pY2VUb0RlbGV0ZUlkIH0gLy8gTm90IG5lZWRlZCBhcyBvcmlnaW5hbCBpbnZvaWNlIGl0ZW1zIGFyZSBnb25lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3RoZXJQdXJjaGFzZXNPZlByb2R1Y3QgPT09IDApIHsgLy8gVGhpcyBzaG91bGQgYmUgdHJ1ZSBmb3IgdGhpcyB0ZXN0XG4gICAgICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbygwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBkZWxldGUgYSBwdXJjaGFzZSBhbmQgcmV2ZXJzZSBzdG9jay9XQUMgd2hlbiBwcm9kdWN0IGlzIGluIGEgc2luZ2xlIGluZmVycmVkIHNob3AnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBTZXR1cDogQ3JlYXRlIGRlZGljYXRlZCBlbnRpdGllcyBmb3IgdGhpcyB0ZXN0IHRvIGVuc3VyZSBpc29sYXRpb24uXG4gICAgICAgICAgICBjb25zdCB0ZXN0U2hvcCA9IGF3YWl0IHByaXNtYS5zaG9wLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBuYW1lOiAnSW5mZXJyZWQgRGVsZXRlIFRlc3QgU2hvcCcsIGxvY2F0aW9uOiAnTG9jIFgnIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGVzdFN1cHBsaWVyID0gYXdhaXQgcHJpc21hLnN1cHBsaWVyLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBuYW1lOiAnSW5mZXJyZWQgRGVsZXRlIFRlc3QgU3VwcGxpZXInIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGVzdFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1Byb2R1Y3QgZm9yIEluZmVycmVkIERlbGV0ZScsXG4gICAgICAgICAgICAgICAgICAgIHNrdTogJ0lORkRFTDAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAyMDAsIC8vIHJldGFpbCBwcmljZVxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRlZEF2ZXJhZ2VDb3N0OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBpbnZlbnRvcnkgaXRlbSBmb3IgdGhpcyBwcm9kdWN0IGluIHRoZSB0ZXN0IHNob3AuXG4gICAgICAgICAgICAvLyBUaGlzIG1ha2VzIGl0IHRoZSBcInNpbmdsZSBpbmZlcnJlZCBzaG9wXCIuXG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiB0ZXN0UHJvZHVjdC5pZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcElkOiB0ZXN0U2hvcC5pZCxcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IDAsIC8vIFdpbGwgYmUgdXBkYXRlZCBieSB0aGUgcHVyY2hhc2VcbiAgICAgICAgICAgICAgICAgICAgc2hvcFNwZWNpZmljQ29zdDogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gMTI7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gNjA7XG5cbiAgICAgICAgICAgIGNvbnN0IGluZmVycmVkU2hvcEludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IHRlc3RTdXBwbGllci5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHRlc3RQcm9kdWN0LmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcHVyY2hhc2VRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgLy8gTk8gZGlzdHJpYnV0aW9ucyBwcm9wZXJ0eSBoZXJlIGZvciBpbmZlcmVuY2UgdG8ga2ljayBpbiBvbiBQT1NUXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IHB1cmNoYXNlUXVhbnRpdHkgKiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBwdXJjaGFzZSBpbnZvaWNlICh0aGlzIGlzIHdoZXJlIHRoZSBmYWlsdXJlIHdhcyBoYXBwZW5pbmcpXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVSZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbmZlcnJlZFNob3BJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKGNyZWF0ZVJlcSk7XG4gICAgICAgICAgICBleHBlY3QoY3JlYXRlUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7IC8vIEFzc2VydCBzdWNjZXNzZnVsIGNyZWF0aW9uXG5cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJvZHkgPSBhd2FpdCBjcmVhdGVSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCBpbnZvaWNlSWRGb3JJbmZlcnJlZERlbGV0ZSA9IGNyZWF0ZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrOiBWZXJpZnkgc3RvY2sgYW5kIFdBQyBhZnRlciBjcmVhdGlvblxuICAgICAgICAgICAgY29uc3QgaW52ZW50b3J5QWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogdGVzdFByb2R1Y3QuaWQsIHNob3BJZDogdGVzdFNob3AuaWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52ZW50b3J5QWZ0ZXJDcmVhdGU/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGludmVudG9yeUFmdGVyQ3JlYXRlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RBZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogdGVzdFByb2R1Y3QuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChwcm9kdWN0QWZ0ZXJDcmVhdGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKHB1cmNoYXNlUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyAyLiBDYWxsIHRoZSBERUxFVEUgZW5kcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcSA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7aW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGV9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3BvbnNlID0gYXdhaXQgZGVsZXRlUHVyY2hhc2VJbnZvaWNlKGRlbGV0ZVJlcSwgeyBwYXJhbXM6IHsgaWQ6IGludm9pY2VJZEZvckluZmVycmVkRGVsZXRlIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIDMuIEFzc2VydGlvbnMgZm9yIERFTEVURSByZXNwb25zZVxuICAgICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzcG9uc2VCb2R5ID0gYXdhaXQgZGVsZXRlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3BvbnNlQm9keS5tZXNzYWdlKS50b0JlKCdQdXJjaGFzZSBpbnZvaWNlIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICAgICAgICAgIC8vIDQuIFZlcmlmeSBQdXJjaGFzZUludm9pY2UgYW5kIEl0ZW1zIGFyZSBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogaW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGUgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2UpLnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2VJdGVtcyA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmZpbmRNYW55KHsgd2hlcmU6IHsgcHVyY2hhc2VJbnZvaWNlSWQ6IGludm9pY2VJZEZvckluZmVycmVkRGVsZXRlIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlSXRlbXMubGVuZ3RoKS50b0JlKDApO1xuXG4gICAgICAgICAgICAvLyA1LiBWZXJpZnkgSW52ZW50b3J5SXRlbSBzdG9jayBhbmQgc2hvcFNwZWNpZmljQ29zdCBhcmUgcmV2ZXJzZWQgaW4gdGhlIGluZmVycmVkIHNob3BcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogdGVzdFByb2R1Y3QuaWQsIHNob3BJZDogdGVzdFNob3AuaWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oMCk7XG5cbiAgICAgICAgICAgIC8vIDYuIFZlcmlmeSBQcm9kdWN0IFdBQyBpcyByZWNhbGN1bGF0ZWQgdG8gMFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2R1Y3REQiA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogdGVzdFByb2R1Y3QuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdERCPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbygwKTtcblxuICAgICAgICAgICAgLy8gQ2xlYW51cCBkZWRpY2F0ZWQgZW50aXRpZXMgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZGVsZXRlTWFueSh7IHdoZXJlOiB7IHByb2R1Y3RJZDogdGVzdFByb2R1Y3QuaWQgfSB9KTtcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5wcm9kdWN0LmRlbGV0ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0UHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnN1cHBsaWVyLmRlbGV0ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0U3VwcGxpZXIuaWQgfSB9KTtcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5zaG9wLmRlbGV0ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0U2hvcC5pZCB9IH0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEFkZGVkIGEgbG9uZ2VyIHRpbWVvdXQgYXMgYSBwcmVjYXV0aW9uXG5cbiAgICAgICAgaXQoJ3Nob3VsZCBkZWxldGUgYW4gaW52b2ljZSB3aXRoIG11bHRpcGxlIGl0ZW1zLCByZXZlcnNpbmcgc3RvY2svV0FDIGZvciBlYWNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gU2V0dXA6IENyZWF0ZSBtdWx0aXBsZSBwcm9kdWN0cyBhbmQgYW4gaW52b2ljZSB3aXRoIGl0ZW1zIGZyb20gdGhlc2UgcHJvZHVjdHMuXG4gICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgZGlzdHJpYnV0ZSBlYWNoIHRvIHRoZSBtYWluIGNyZWF0ZWRTaG9wSWQgZnJvbSBnbG9iYWwgYmVmb3JlRWFjaC5cblxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdEEgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHsgbmFtZTogJ011bHRpLURlbCBQcm9kIEEnLCBza3U6ICdNREVMMDBBJywgcHJpY2U6IDEwMCwgd2VpZ2h0ZWRBdmVyYWdlQ29zdDogMCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RCID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IG5hbWU6ICdNdWx0aS1EZWwgUHJvZCBCJywgc2t1OiAnTURFTDAwQicsIHByaWNlOiAyMDAsIHdlaWdodGVkQXZlcmFnZUNvc3Q6IDAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5QSA9IDU7XG4gICAgICAgICAgICBjb25zdCBwcmljZUEgPSA1MDtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5QiA9IDM7XG4gICAgICAgICAgICBjb25zdCBwcmljZUIgPSAxMjA7XG5cbiAgICAgICAgICAgIGNvbnN0IG11bHRpSXRlbUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvZHVjdElkOiBwcm9kdWN0QS5pZC50b1N0cmluZygpLCBxdWFudGl0eTogcXVhbnRpdHlBLCBwcmljZTogcHJpY2VBIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvZHVjdElkOiBwcm9kdWN0Qi5pZC50b1N0cmluZygpLCBxdWFudGl0eTogcXVhbnRpdHlCLCBwcmljZTogcHJpY2VCIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBxdWFudGl0eUEgfSwgLy8gSXRlbSBBIHRvIG1haW4gc2hvcFxuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcXVhbnRpdHlCIH0gIC8vIEl0ZW0gQiB0byBtYWluIHNob3BcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiAocXVhbnRpdHlBICogcHJpY2VBKSArIChxdWFudGl0eUIgKiBwcmljZUIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVxID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogbXVsdGlJdGVtSW52b2ljZVBheWxvYWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKGNyZWF0ZVJlcSk7XG4gICAgICAgICAgICBleHBlY3QoY3JlYXRlUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVCb2R5ID0gYXdhaXQgY3JlYXRlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlJdGVtSW52b2ljZUlkID0gY3JlYXRlQm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2sgaW52ZW50b3J5IGFuZCBXQUMgYWZ0ZXIgY3JlYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGludkFfYWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3QoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RBLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZBX2FmdGVyQ3JlYXRlPy5xdWFudGl0eSkudG9CZShxdWFudGl0eUEpO1xuICAgICAgICAgICAgZXhwZWN0KGludkFfYWZ0ZXJDcmVhdGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUocHJpY2VBKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2RBX2FmdGVyQ3JlYXRlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0QS5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHByb2RBX2FmdGVyQ3JlYXRlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKHByaWNlQSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGludkJfYWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3QoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RCLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZCX2FmdGVyQ3JlYXRlPy5xdWFudGl0eSkudG9CZShxdWFudGl0eUIpO1xuICAgICAgICAgICAgZXhwZWN0KGludkJfYWZ0ZXJDcmVhdGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUocHJpY2VCKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2RCX2FmdGVyQ3JlYXRlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Qi5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHByb2RCX2FmdGVyQ3JlYXRlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKHByaWNlQik7XG5cbiAgICAgICAgICAgIC8vIDIuIENhbGwgREVMRVRFIGVuZHBvaW50XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke211bHRpSXRlbUludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzcG9uc2UgPSBhd2FpdCBkZWxldGVQdXJjaGFzZUludm9pY2UoZGVsZXRlUmVxLCB7IHBhcmFtczogeyBpZDogbXVsdGlJdGVtSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG5cbiAgICAgICAgICAgIC8vIDMuIFZlcmlmeSBpbnZvaWNlIGFuZCBpdGVtcyBhcmUgZGVsZXRlZFxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IG11bHRpSXRlbUludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZUl0ZW1zID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZmluZE1hbnkoeyB3aGVyZTogeyBwdXJjaGFzZUludm9pY2VJZDogbXVsdGlJdGVtSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlSXRlbXMubGVuZ3RoKS50b0JlKDApO1xuXG4gICAgICAgICAgICAvLyA0LiBWZXJpZnkgc3RvY2sgYW5kIFdBQyBmb3IgUHJvZHVjdCBBIGFyZSByZXZlcnNlZFxuICAgICAgICAgICAgY29uc3QgaW52QV9hZnRlckRlbGV0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEEuaWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkFfYWZ0ZXJEZWxldGU/LnF1YW50aXR5KS50b0JlKDApO1xuICAgICAgICAgICAgZXhwZWN0KGludkFfYWZ0ZXJEZWxldGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuICAgICAgICAgICAgY29uc3QgcHJvZEFfYWZ0ZXJEZWxldGUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RBLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QocHJvZEFfYWZ0ZXJEZWxldGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICAvLyA1LiBWZXJpZnkgc3RvY2sgYW5kIFdBQyBmb3IgUHJvZHVjdCBCIGFyZSByZXZlcnNlZFxuICAgICAgICAgICAgY29uc3QgaW52Ql9hZnRlckRlbGV0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEIuaWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkJfYWZ0ZXJEZWxldGU/LnF1YW50aXR5KS50b0JlKDApO1xuICAgICAgICAgICAgZXhwZWN0KGludkJfYWZ0ZXJEZWxldGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuICAgICAgICAgICAgY29uc3QgcHJvZEJfYWZ0ZXJEZWxldGUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RCLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QocHJvZEJfYWZ0ZXJEZWxldGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBwcm9kdWN0cyBhbmQgdGhlaXIgaW52ZW50b3J5IGl0ZW1zIGNyZWF0ZWQgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZGVsZXRlTWFueSh7IHdoZXJlOiB7IHByb2R1Y3RJZDogeyBpbjogW3Byb2R1Y3RBLmlkLCBwcm9kdWN0Qi5pZF0gfSB9IH0pO1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnByb2R1Y3QuZGVsZXRlTWFueSh7IHdoZXJlOiB7IGlkOiB7IGluOiBbcHJvZHVjdEEuaWQsIHByb2R1Y3RCLmlkXSB9IH0gfSk7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gVGltZW91dCBmb3Igc2FmZXR5XG4gICAgfSk7XG5cbn0pOyJdLCJuYW1lcyI6WyJjcmVhdGVNb2NrTmV4dFJlcXVlc3QiLCJ1cmwiLCJvcHRpb25zIiwibWV0aG9kIiwiYm9keSIsImhlYWRlcnMiLCJIZWFkZXJzIiwianNvbiIsIkpTT04iLCJwYXJzZSIsInRleHQiLCJzdHJpbmdpZnkiLCJwcmlzbWEiLCJQcmlzbWFDbGllbnQiLCJkZXNjcmliZSIsImNyZWF0ZWRTaG9wSWQiLCJjcmVhdGVkU3VwcGxpZXJJZCIsImNyZWF0ZWRQcm9kdWN0SWQiLCJiZWZvcmVBbGwiLCJiZWZvcmVFYWNoIiwicHVyY2hhc2VJbnZvaWNlSXRlbSIsImRlbGV0ZU1hbnkiLCJwdXJjaGFzZUludm9pY2UiLCJpbnZlbnRvcnlJdGVtIiwicHJvZHVjdCIsInN1cHBsaWVyIiwic2hvcCIsImNyZWF0ZSIsImRhdGEiLCJuYW1lIiwibG9jYXRpb24iLCJpZCIsInByaWNlIiwic2t1Iiwic2hvcElkIiwiYWZ0ZXJBbGwiLCIkZGlzY29ubmVjdCIsIml0IiwibmV3UHJvZHVjdE5hbWUiLCJuZXdQcm9kdWN0U2t1IiwicHVyY2hhc2VQcmljZSIsInB1cmNoYXNlUXVhbnRpdHkiLCJuZXdUZXN0UHJvZHVjdCIsIm5ld1Rlc3RQcm9kdWN0SWQiLCJwdXJjaGFzZUludm9pY2VQYXlsb2FkIiwic3VwcGxpZXJJZCIsInRvU3RyaW5nIiwiZGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIml0ZW1zIiwicHJvZHVjdElkIiwicXVhbnRpdHkiLCJkaXN0cmlidXRpb25zIiwidG90YWxBbW91bnQiLCJzdGF0dXMiLCJyZXEiLCJyZXNwb25zZSIsImNyZWF0ZVB1cmNoYXNlSW52b2ljZSIsInJlc3BvbnNlQm9keSIsImV4cGVjdCIsInRvQmUiLCJ0b0hhdmVQcm9wZXJ0eSIsImNyZWF0ZWRJbnZvaWNlSWQiLCJkYkludm9pY2UiLCJmaW5kVW5pcXVlIiwid2hlcmUiLCJpbmNsdWRlIiwibm90IiwidG9CZU51bGwiLCJsZW5ndGgiLCJkYkludmVudG9yeUl0ZW0iLCJmaW5kRmlyc3QiLCJzaG9wU3BlY2lmaWNDb3N0IiwiZGJQcm9kdWN0Iiwid2VpZ2h0ZWRBdmVyYWdlQ29zdCIsImluaXRpYWxQdXJjaGFzZVByaWNlIiwiaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkiLCJleGlzdGluZ1Byb2R1Y3RJZCIsImluaXRpYWxQYXlsb2FkIiwibm93IiwiaW5pdGlhbFJlcSIsInByb2R1Y3RCZWZvcmVOZXdQdXJjaGFzZSIsImludmVudG9yeUJlZm9yZU5ld1B1cmNoYXNlIiwibmV3UHVyY2hhc2VQcmljZSIsIm5ld1B1cmNoYXNlUXVhbnRpdHkiLCJleHBlY3RlZFRvdGFsUXVhbnRpdHkiLCJleHBlY3RlZFNob3BTcGVjaWZpY0Nvc3QiLCJ0b0JlQ2xvc2VUbyIsImV4cGVjdGVkUHJvZHVjdFdBQyIsInByb2R1Y3QxRGF0YSIsInByb2R1Y3QyRGF0YSIsInByb2R1Y3QxIiwicHJvZHVjdDIiLCJwdXJjaGFzZVByaWNlMSIsInB1cmNoYXNlUXVhbnRpdHkxIiwicHVyY2hhc2VQcmljZTIiLCJwdXJjaGFzZVF1YW50aXR5MiIsIm9yZGVyQnkiLCJzb3J0ZWRQcm9kdWN0cyIsInNvcnQiLCJhIiwiYiIsImRiSW52ZW50b3J5SXRlbTEiLCJkYlByb2R1Y3QxIiwiZGJJbnZlbnRvcnlJdGVtMiIsImRiUHJvZHVjdDIiLCJzaG9wQSIsInNob3BCIiwidG90YWxRdWFudGl0eSIsInF1YW50aXR5Rm9yU2hvcEEiLCJxdWFudGl0eUZvclNob3BCIiwiaW52SXRlbUEiLCJpbnZJdGVtQiIsIm5vbkV4aXN0ZW50UHJvZHVjdElkIiwiZXJyb3IiLCJ0b0JlRGVmaW5lZCIsIm5vbkV4aXN0ZW50U3VwcGxpZXJJZCIsImV4aXN0aW5nSW52b2ljZUlkIiwicHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQiLCJpbml0aWFsSW52b2ljZVBheWxvYWQiLCJpbml0aWFsUHJvZHVjdCIsImluaXRpYWxJbnZlbnRvcnkiLCJxdWFudGl0eUluY3JlYXNlIiwibmV3UXVhbnRpdHkiLCJ1cGRhdGVkUHJpY2VGb3JJdGVtIiwidXBkYXRlUGF5bG9hZCIsInVwZGF0ZVB1cmNoYXNlSW52b2ljZSIsInBhcmFtcyIsInVwZGF0ZWRJbnZlbnRvcnkiLCJ1cGRhdGVkUHJvZHVjdCIsInRvdGFsIiwicXVhbnRpdHlEZWNyZWFzZSIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiLCJuZXdQcmljZUZvckl0ZW0iLCJxdWFudGl0eVVuY2hhbmdlZCIsIm5ld0l0ZW1Qcm9kdWN0IiwibmV3SXRlbVByb2R1Y3RJZCIsIm5ld0l0ZW1RdWFudGl0eSIsIm5ld0l0ZW1QcmljZSIsIm9yaWdpbmFsSXRlbVByb2R1Y3RJZCIsIm9yaWdpbmFsSXRlbVF1YW50aXR5Iiwib3JpZ2luYWxJdGVtUHJpY2UiLCJleHBlY3RlZFRvdGFsIiwiZGJPcmlnaW5hbEl0ZW0iLCJmaW5kIiwiaXRlbSIsImRiTmV3SXRlbSIsIm9yaWdpbmFsSW52ZW50b3J5Iiwib3JpZ2luYWxQcm9kdWN0IiwibmV3SW52ZW50b3J5IiwibmV3UHJvZHVjdERiIiwicHJvZHVjdFRvUmVtb3ZlIiwicHJvZHVjdFRvUmVtb3ZlSWQiLCJwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSIsInByb2R1Y3RUb1JlbW92ZVByaWNlIiwiYWRkU2Vjb25kSXRlbVBheWxvYWQiLCJhZGRSZXEiLCJpbnZvaWNlV2l0aFR3b0l0ZW1zIiwidXBkYXRlUGF5bG9hZFRvUmVtb3ZlSXRlbSIsInJlbW92ZVJlcSIsImtlcHRJbnZlbnRvcnkiLCJrZXB0UHJvZHVjdCIsInJlbW92ZWRJbnZlbnRvcnkiLCJyZW1vdmVkUHJvZHVjdERiIiwib3RoZXJQdXJjaGFzZXNPZlJlbW92ZWRJdGVtIiwiY291bnQiLCJpbnZvaWNlVG9EZWxldGVJZCIsInByb2R1Y3RGb3JEZWxldGVUZXN0SWQiLCJkZWxldGVUZXN0SW5pdGlhbFByaWNlIiwiZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSIsImluaXRpYWxQcm9kdWN0REIiLCJkZWxldGVSZXEiLCJkZWxldGVSZXNwb25zZSIsImRlbGV0ZVB1cmNoYXNlSW52b2ljZSIsImRlbGV0ZVJlc3BvbnNlQm9keSIsIm1lc3NhZ2UiLCJkYkludm9pY2VJdGVtcyIsImZpbmRNYW55IiwicHVyY2hhc2VJbnZvaWNlSWQiLCJvdGhlclB1cmNoYXNlc09mUHJvZHVjdCIsInRlc3RTaG9wIiwidGVzdFN1cHBsaWVyIiwidGVzdFByb2R1Y3QiLCJpbmZlcnJlZFNob3BJbnZvaWNlUGF5bG9hZCIsImNyZWF0ZVJlcSIsImNyZWF0ZVJlc3BvbnNlIiwiY3JlYXRlQm9keSIsImludm9pY2VJZEZvckluZmVycmVkRGVsZXRlIiwiaW52ZW50b3J5QWZ0ZXJDcmVhdGUiLCJwcm9kdWN0QWZ0ZXJDcmVhdGUiLCJ1cGRhdGVkUHJvZHVjdERCIiwiZGVsZXRlIiwicHJvZHVjdEEiLCJwcm9kdWN0QiIsInF1YW50aXR5QSIsInByaWNlQSIsInF1YW50aXR5QiIsInByaWNlQiIsIm11bHRpSXRlbUludm9pY2VQYXlsb2FkIiwibXVsdGlJdGVtSW52b2ljZUlkIiwiaW52QV9hZnRlckNyZWF0ZSIsInByb2RBX2FmdGVyQ3JlYXRlIiwiaW52Ql9hZnRlckNyZWF0ZSIsInByb2RCX2FmdGVyQ3JlYXRlIiwiaW52QV9hZnRlckRlbGV0ZSIsInByb2RBX2FmdGVyRGVsZXRlIiwiaW52Ql9hZnRlckRlbGV0ZSIsInByb2RCX2FmdGVyRGVsZXRlIiwiaW4iXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDOzs7O3dCQUM0Qjt1QkFDaUI7d0JBQ0Q7QUFXN0MsNkNBQTZDO0FBQzdDLE1BQU1BLHdCQUF3QixDQUFDQyxLQUFhQyxVQUl4QyxDQUFDLENBQUM7SUFDSixNQUFNLEVBQUVDLFNBQVMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsR0FBR0g7SUFDL0MsT0FBTztRQUNMQztRQUNBRjtRQUNBSSxTQUFTLElBQUlDLFFBQVFEO1FBQ3JCRSxNQUFNLFVBQVlILE9BQVEsT0FBT0EsU0FBUyxXQUFXSSxLQUFLQyxLQUFLLENBQUNMLFFBQVFBLE9BQVEsQ0FBQztRQUNqRk0sTUFBTSxVQUFZTixPQUFRLE9BQU9BLFNBQVMsV0FBV0EsT0FBT0ksS0FBS0csU0FBUyxDQUFDUCxRQUFTO0lBQ3RGO0FBQ0Y7QUFJQSxNQUFNUSxTQUFTLElBQUlDLG9CQUFZO0FBRS9CQyxTQUFTLDBDQUEwQztJQUMvQyxJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSkMsVUFBVTtJQUNOLG1FQUFtRTtJQUNuRSw2REFBNkQ7SUFDakU7SUFFQUMsV0FBVztRQUNQLG9EQUFvRDtRQUNwRCxNQUFNUCxPQUFPUSxtQkFBbUIsQ0FBQ0MsVUFBVSxDQUFDLENBQUM7UUFDN0MsTUFBTVQsT0FBT1UsZUFBZSxDQUFDRCxVQUFVLENBQUMsQ0FBQztRQUN6QyxNQUFNVCxPQUFPVyxhQUFhLENBQUNGLFVBQVUsQ0FBQyxDQUFDO1FBQ3ZDLE1BQU1ULE9BQU9ZLE9BQU8sQ0FBQ0gsVUFBVSxDQUFDLENBQUM7UUFDakMsTUFBTVQsT0FBT2EsUUFBUSxDQUFDSixVQUFVLENBQUMsQ0FBQztRQUNsQyxNQUFNVCxPQUFPYyxJQUFJLENBQUNMLFVBQVUsQ0FBQyxDQUFDO1FBRTlCLDRCQUE0QjtRQUM1QixNQUFNSyxPQUFPLE1BQU1kLE9BQU9jLElBQUksQ0FBQ0MsTUFBTSxDQUFDO1lBQ2xDQyxNQUFNO2dCQUNGQyxNQUFNO2dCQUNOQyxVQUFVO1lBRWQ7UUFDSjtRQUNBZixnQkFBZ0JXLEtBQUtLLEVBQUU7UUFFdkIsZ0NBQWdDO1FBQ2hDLE1BQU1OLFdBQVcsTUFBTWIsT0FBT2EsUUFBUSxDQUFDRSxNQUFNLENBQUM7WUFDMUNDLE1BQU07Z0JBQ0ZDLE1BQU07WUFFVjtRQUNKO1FBQ0FiLG9CQUFvQlMsU0FBU00sRUFBRTtRQUUvQixpRkFBaUY7UUFDakYsTUFBTVAsVUFBVSxNQUFNWixPQUFPWSxPQUFPLENBQUNHLE1BQU0sQ0FBQztZQUN4Q0MsTUFBTTtnQkFDRkMsTUFBTTtnQkFDTkcsT0FBTztnQkFDUEMsS0FBSztnQkFDTEMsUUFBUW5CO1lBRVo7UUFDSjtRQUNBRSxtQkFBbUJPLFFBQVFPLEVBQUU7SUFDakM7SUFFQUksU0FBUztRQUNMLG9DQUFvQztRQUNwQyxNQUFNdkIsT0FBT1EsbUJBQW1CLENBQUNDLFVBQVUsQ0FBQyxDQUFDO1FBQzdDLE1BQU1ULE9BQU9VLGVBQWUsQ0FBQ0QsVUFBVSxDQUFDLENBQUM7UUFDekMsTUFBTVQsT0FBT1csYUFBYSxDQUFDRixVQUFVLENBQUMsQ0FBQztRQUN2QyxNQUFNVCxPQUFPWSxPQUFPLENBQUNILFVBQVUsQ0FBQyxDQUFDO1FBQ2pDLE1BQU1ULE9BQU9hLFFBQVEsQ0FBQ0osVUFBVSxDQUFDLENBQUM7UUFDbEMsTUFBTVQsT0FBT2MsSUFBSSxDQUFDTCxVQUFVLENBQUMsQ0FBQztRQUM5QixNQUFNVCxPQUFPd0IsV0FBVztJQUM1QjtJQUVBdEIsU0FBUyxpREFBaUQ7UUFDdER1QixHQUFHLHFGQUFxRjtZQUNwRixtQ0FBbUM7WUFDbkMsTUFBTUMsaUJBQWlCO1lBQ3ZCLE1BQU1DLGdCQUFnQjtZQUN0QixNQUFNQyxnQkFBZ0I7WUFDdEIsTUFBTUMsbUJBQW1CO1lBRXpCLGtEQUFrRDtZQUNsRCwwR0FBMEc7WUFDMUcsb0hBQW9IO1lBQ3BILHlGQUF5RjtZQUN6Rix5RkFBeUY7WUFFekYsTUFBTUMsaUJBQWlCLE1BQU05QixPQUFPWSxPQUFPLENBQUNHLE1BQU0sQ0FBQztnQkFDL0NDLE1BQU07b0JBQ0ZDLE1BQU1TO29CQUNOTCxLQUFLTTtvQkFDTFAsT0FBTztvQkFDUEUsUUFBUW5CLGNBQWMsb0NBQW9DO2dCQUM5RDtZQUNKO1lBQ0EsTUFBTTRCLG1CQUFtQkQsZUFBZVgsRUFBRTtZQUUxQyxzREFBc0Q7WUFDdEQsTUFBTWEseUJBQXlCO2dCQUMzQkMsWUFBWTdCLGtCQUFrQjhCLFFBQVE7Z0JBQ3RDQyxNQUFNLElBQUlDLE9BQU9DLFdBQVc7Z0JBQzVCQyxPQUFPO29CQUNIO3dCQUNJQyxXQUFXUixpQkFBaUJHLFFBQVE7d0JBQ3BDTSxVQUFVWDt3QkFDVlQsT0FBT1E7b0JBQ1g7aUJBQ0g7Z0JBQ0RhLGVBQWU7b0JBQ1g7d0JBQ0ksQ0FBQ3RDLGNBQWMsRUFBRTBCO29CQUNyQjtpQkFDSDtnQkFDRGEsYUFBYWIsbUJBQW1CRDtnQkFDaENlLFFBQVE7WUFDWjtZQUVBLHNDQUFzQztZQUN0QyxNQUFNQyxNQUFNeEQsc0JBQXNCLGtDQUFrQztnQkFDaEVHLFFBQVE7Z0JBQ1JDLE1BQU13QztnQkFDTnZDLFNBQVM7b0JBQ0wsZ0JBQWdCO2dCQUNwQjtZQUNKO1lBRUEsd0JBQXdCO1lBQ3hCLE1BQU1vRCxXQUFXLE1BQU1DLElBQUFBLFdBQXFCLEVBQUNGO1lBQzdDLE1BQU1HLGVBQWUsTUFBTUYsU0FBU2xELElBQUk7WUFFeEMsZ0JBQWdCO1lBQ2hCcUQsT0FBT0gsU0FBU0YsTUFBTSxFQUFFTSxJQUFJLENBQUMsTUFBTSwyREFBMkQ7WUFDOUZELE9BQU9ELGFBQWEvQixJQUFJLEVBQUVrQyxjQUFjLENBQUM7WUFDekMsTUFBTUMsbUJBQW1CSixhQUFhL0IsSUFBSSxDQUFDRyxFQUFFO1lBRTdDLCtCQUErQjtZQUMvQixNQUFNaUMsWUFBWSxNQUFNcEQsT0FBT1UsZUFBZSxDQUFDMkMsVUFBVSxDQUFDO2dCQUN0REMsT0FBTztvQkFBRW5DLElBQUlnQztnQkFBaUI7Z0JBQzlCSSxTQUFTO29CQUFFakIsT0FBTztnQkFBSztZQUMzQjtZQUNBVSxPQUFPSSxXQUFXSSxHQUFHLENBQUNDLFFBQVE7WUFDOUJULE9BQU9JLFdBQVduQixZQUFZZ0IsSUFBSSxDQUFDN0M7WUFDbkM0QyxPQUFPSSxXQUFXZCxNQUFNb0IsUUFBUVQsSUFBSSxDQUFDO1lBQ3JDRCxPQUFPSSxXQUFXZCxLQUFLLENBQUMsRUFBRSxDQUFDQyxXQUFXVSxJQUFJLENBQUNsQjtZQUMzQ2lCLE9BQU9JLFdBQVdkLEtBQUssQ0FBQyxFQUFFLENBQUNFLFVBQVVTLElBQUksQ0FBQ3BCO1lBQzFDbUIsT0FBT0ksV0FBV2QsS0FBSyxDQUFDLEVBQUUsQ0FBQ2xCLE9BQU82QixJQUFJLENBQUNyQjtZQUV2Qyw2QkFBNkI7WUFDN0IsTUFBTStCLGtCQUFrQixNQUFNM0QsT0FBT1csYUFBYSxDQUFDaUQsU0FBUyxDQUFDO2dCQUN6RE4sT0FBTztvQkFDSGYsV0FBV1I7b0JBQ1hULFFBQVFuQjtnQkFDWjtZQUNKO1lBQ0E2QyxPQUFPVyxpQkFBaUJILEdBQUcsQ0FBQ0MsUUFBUTtZQUNwQ1QsT0FBT1csaUJBQWlCbkIsVUFBVVMsSUFBSSxDQUFDcEI7WUFDdkMsMERBQTBEO1lBQzFELHVGQUF1RjtZQUN2RixzRUFBc0U7WUFDdEUsMkRBQTJEO1lBQzNEbUIsT0FBT1csaUJBQWlCRSxrQkFBa0JaLElBQUksQ0FBQ3JCO1lBRy9DLDJCQUEyQjtZQUMzQixNQUFNa0MsWUFBWSxNQUFNOUQsT0FBT1ksT0FBTyxDQUFDeUMsVUFBVSxDQUFDO2dCQUM5Q0MsT0FBTztvQkFBRW5DLElBQUlZO2dCQUFpQjtZQUNsQztZQUNBaUIsT0FBT2MsV0FBV04sR0FBRyxDQUFDQyxRQUFRO1lBQzlCLG1GQUFtRjtZQUNuRlQsT0FBT2MsV0FBV0MscUJBQXFCZCxJQUFJLENBQUNyQjtRQUNoRCxHQUFHLFFBQVEsb0JBQW9CO1FBRS9CSCxHQUFHLDRGQUE0RjtZQUMzRiw0RUFBNEU7WUFDNUUsTUFBTXVDLHVCQUF1QjtZQUM3QixNQUFNQywwQkFBMEI7WUFDaEMsTUFBTUMsb0JBQW9CN0Qsa0JBQWtCLGtCQUFrQjtZQUU5RCxrRUFBa0U7WUFDbEUsTUFBTThELGlCQUFpQjtnQkFDbkJsQyxZQUFZN0Isa0JBQWtCOEIsUUFBUTtnQkFDdENDLE1BQU0sSUFBSUMsS0FBS0EsS0FBS2dDLEdBQUcsS0FBSyxVQUFVL0IsV0FBVztnQkFDakRDLE9BQU87b0JBQUM7d0JBQ0pDLFdBQVcyQixrQkFBa0JoQyxRQUFRO3dCQUNyQ00sVUFBVXlCO3dCQUNWN0MsT0FBTzRDO29CQUNYO2lCQUFFO2dCQUNGdkIsZUFBZTtvQkFBQzt3QkFBRSxDQUFDdEMsY0FBYyxFQUFFOEQ7b0JBQXdCO2lCQUFFO2dCQUM3RHZCLGFBQWF1QiwwQkFBMEJEO2dCQUN2Q3JCLFFBQVE7WUFDWjtZQUNBLE1BQU0wQixhQUFhakYsc0JBQXNCLGtDQUFrQztnQkFDdkVHLFFBQVE7Z0JBQ1JDLE1BQU0yRTtnQkFDTjFFLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtZQUNsRDtZQUNBLE1BQU1xRCxJQUFBQSxXQUFxQixFQUFDdUI7WUFFNUIsTUFBTUMsMkJBQTJCLE1BQU10RSxPQUFPWSxPQUFPLENBQUN5QyxVQUFVLENBQUM7Z0JBQUVDLE9BQU87b0JBQUVuQyxJQUFJK0M7Z0JBQWtCO1lBQUU7WUFDcEcsTUFBTUssNkJBQTZCLE1BQU12RSxPQUFPVyxhQUFhLENBQUNpRCxTQUFTLENBQUM7Z0JBQUVOLE9BQU87b0JBQUVmLFdBQVcyQjtvQkFBbUI1QyxRQUFRbkI7Z0JBQWM7WUFBRTtZQUV6STZDLE9BQU9zQiwwQkFBMEJQLHFCQUFxQmQsSUFBSSxDQUFDZTtZQUMzRGhCLE9BQU91Qiw0QkFBNEIvQixVQUFVUyxJQUFJLENBQUNnQjtZQUNsRGpCLE9BQU91Qiw0QkFBNEJWLGtCQUFrQlosSUFBSSxDQUFDZTtZQUUxRCw4REFBOEQ7WUFDOUQsTUFBTVEsbUJBQW1CO1lBQ3pCLE1BQU1DLHNCQUFzQjtZQUU1Qiw4QkFBOEI7WUFDOUIsTUFBTXpDLHlCQUF5QjtnQkFDM0JDLFlBQVk3QixrQkFBa0I4QixRQUFRO2dCQUN0Q0MsTUFBTSxJQUFJQyxPQUFPQyxXQUFXO2dCQUM1QkMsT0FBTztvQkFDSDt3QkFDSUMsV0FBVzJCLGtCQUFrQmhDLFFBQVE7d0JBQ3JDTSxVQUFVaUM7d0JBQ1ZyRCxPQUFPb0Q7b0JBQ1g7aUJBQ0g7Z0JBQ0QvQixlQUFlO29CQUNYO3dCQUNJLENBQUN0QyxjQUFjLEVBQUVzRTtvQkFDckI7aUJBQ0g7Z0JBQ0QvQixhQUFhK0Isc0JBQXNCRDtnQkFDbkM3QixRQUFRO1lBQ1o7WUFFQSx1QkFBdUI7WUFDdkIsTUFBTUMsTUFBTXhELHNCQUFzQixrQ0FBa0M7Z0JBQ2hFRyxRQUFRO2dCQUNSQyxNQUFNd0M7Z0JBQ052QyxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7WUFDbEQ7WUFDQSxNQUFNb0QsV0FBVyxNQUFNQyxJQUFBQSxXQUFxQixFQUFDRjtZQUM3QyxNQUFNRyxlQUFlLE1BQU1GLFNBQVNsRCxJQUFJO1lBRXhDLGdCQUFnQjtZQUNoQnFELE9BQU9ILFNBQVNGLE1BQU0sRUFBRU0sSUFBSSxDQUFDO1lBQzdCLE1BQU1FLG1CQUFtQkosYUFBYS9CLElBQUksQ0FBQ0csRUFBRTtZQUU3Qyx1QkFBdUI7WUFDdkIsTUFBTXdDLGtCQUFrQixNQUFNM0QsT0FBT1csYUFBYSxDQUFDaUQsU0FBUyxDQUFDO2dCQUN6RE4sT0FBTztvQkFDSGYsV0FBVzJCO29CQUNYNUMsUUFBUW5CO2dCQUNaO1lBQ0o7WUFDQSxNQUFNdUUsd0JBQXdCVCwwQkFBMEJRO1lBQ3hEekIsT0FBT1csaUJBQWlCbkIsVUFBVVMsSUFBSSxDQUFDeUI7WUFFdkMsd0NBQXdDO1lBQ3hDLHNFQUFzRTtZQUN0RSxNQUFNQywyQkFDRixBQUFDLENBQUEsQUFBQ1YsMEJBQTBCRCx1QkFBeUJTLHNCQUFzQkQsZ0JBQWdCLElBQzFGUCxDQUFBQSwwQkFBMEJRLG1CQUFrQjtZQUNqRHpCLE9BQU9XLGlCQUFpQkUsa0JBQWtCZSxXQUFXLENBQUNEO1lBRXRELG1DQUFtQztZQUNuQyx3R0FBd0c7WUFDeEcsa0ZBQWtGO1lBQ2xGLE1BQU1FLHFCQUNGLEFBQUMsQ0FBQSxBQUFDWiwwQkFBMEJELHVCQUF5QlMsc0JBQXNCRCxnQkFBZ0IsSUFDMUZQLENBQUFBLDBCQUEwQlEsbUJBQWtCO1lBQ2pELE1BQU1YLFlBQVksTUFBTTlELE9BQU9ZLE9BQU8sQ0FBQ3lDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUkrQztnQkFBa0I7WUFBRTtZQUNyRmxCLE9BQU9jLFdBQVdDLHFCQUFxQmEsV0FBVyxDQUFDQztRQUN2RCxHQUFHLFFBQVEsb0JBQW9CO1FBRS9CcEQsR0FBRyxrRkFBa0Y7WUFDakYsZ0RBQWdEO1lBQ2hELE1BQU1xRCxlQUFlO2dCQUFFN0QsTUFBTTtnQkFBdUJJLEtBQUs7Z0JBQVlELE9BQU87Z0JBQUlFLFFBQVFuQjtZQUFjO1lBQ3RHLE1BQU00RSxlQUFlO2dCQUFFOUQsTUFBTTtnQkFBdUJJLEtBQUs7Z0JBQVlELE9BQU87Z0JBQUlFLFFBQVFuQjtZQUFjO1lBQ3RHLE1BQU02RSxXQUFXLE1BQU1oRixPQUFPWSxPQUFPLENBQUNHLE1BQU0sQ0FBQztnQkFBRUMsTUFBTThEO1lBQWE7WUFDbEUsTUFBTUcsV0FBVyxNQUFNakYsT0FBT1ksT0FBTyxDQUFDRyxNQUFNLENBQUM7Z0JBQUVDLE1BQU0rRDtZQUFhO1lBRWxFLE1BQU1HLGlCQUFpQjtZQUN2QixNQUFNQyxvQkFBb0I7WUFDMUIsTUFBTUMsaUJBQWlCO1lBQ3ZCLE1BQU1DLG9CQUFvQjtZQUUxQiw4QkFBOEI7WUFDOUIsTUFBTXJELHlCQUF5QjtnQkFDM0JDLFlBQVk3QixrQkFBa0I4QixRQUFRO2dCQUN0Q0MsTUFBTSxJQUFJQyxPQUFPQyxXQUFXO2dCQUM1QkMsT0FBTztvQkFDSDt3QkFDSUMsV0FBV3lDLFNBQVM3RCxFQUFFLENBQUNlLFFBQVE7d0JBQy9CTSxVQUFVMkM7d0JBQ1YvRCxPQUFPOEQ7b0JBQ1g7b0JBQ0E7d0JBQ0kzQyxXQUFXMEMsU0FBUzlELEVBQUUsQ0FBQ2UsUUFBUTt3QkFDL0JNLFVBQVU2Qzt3QkFDVmpFLE9BQU9nRTtvQkFDWDtpQkFDSDtnQkFDRDNDLGVBQWU7b0JBQ1g7d0JBQUUsQ0FBQ3RDLGNBQWMsRUFBRWdGO29CQUFrQjtvQkFDckM7d0JBQUUsQ0FBQ2hGLGNBQWMsRUFBRWtGO29CQUFrQixFQUFHLDBCQUEwQjtpQkFDckU7Z0JBQ0QzQyxhQUFhLEFBQUN5QyxvQkFBb0JELGlCQUFtQkcsb0JBQW9CRDtnQkFDekV6QyxRQUFRO1lBQ1o7WUFFQSx1QkFBdUI7WUFDdkIsTUFBTUMsTUFBTXhELHNCQUFzQixrQ0FBa0M7Z0JBQ2hFRyxRQUFRO2dCQUNSQyxNQUFNd0M7Z0JBQ052QyxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7WUFDbEQ7WUFDQSxNQUFNb0QsV0FBVyxNQUFNQyxJQUFBQSxXQUFxQixFQUFDRjtZQUM3QyxNQUFNRyxlQUFlLE1BQU1GLFNBQVNsRCxJQUFJO1lBRXhDLGdCQUFnQjtZQUNoQnFELE9BQU9ILFNBQVNGLE1BQU0sRUFBRU0sSUFBSSxDQUFDO1lBQzdCLE1BQU1FLG1CQUFtQkosYUFBYS9CLElBQUksQ0FBQ0csRUFBRTtZQUU3Qyx1Q0FBdUM7WUFDdkMsTUFBTWlDLFlBQVksTUFBTXBELE9BQU9VLGVBQWUsQ0FBQzJDLFVBQVUsQ0FBQztnQkFDdERDLE9BQU87b0JBQUVuQyxJQUFJZ0M7Z0JBQWlCO2dCQUM5QkksU0FBUztvQkFBRWpCLE9BQU87d0JBQUVnRCxTQUFTOzRCQUFFL0MsV0FBVzt3QkFBTTtvQkFBRTtnQkFBRSxFQUFFLHVDQUF1QztZQUNqRztZQUNBUyxPQUFPSSxXQUFXZCxNQUFNb0IsUUFBUVQsSUFBSSxDQUFDO1lBQ3JDLGlGQUFpRjtZQUNqRixNQUFNc0MsaUJBQWlCO2dCQUFDUDtnQkFBVUM7YUFBUyxDQUFDTyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRXRFLEVBQUUsR0FBR3VFLEVBQUV2RSxFQUFFO1lBRXRFNkIsT0FBT0ksV0FBV2QsS0FBSyxDQUFDLEVBQUUsQ0FBQ0MsV0FBV1UsSUFBSSxDQUFDc0MsY0FBYyxDQUFDLEVBQUUsQ0FBQ3BFLEVBQUU7WUFDL0Q2QixPQUFPSSxXQUFXZCxLQUFLLENBQUMsRUFBRSxDQUFDRSxVQUFVUyxJQUFJLENBQUNrQztZQUMxQ25DLE9BQU9JLFdBQVdkLEtBQUssQ0FBQyxFQUFFLENBQUNsQixPQUFPNkIsSUFBSSxDQUFDaUM7WUFFdkNsQyxPQUFPSSxXQUFXZCxLQUFLLENBQUMsRUFBRSxDQUFDQyxXQUFXVSxJQUFJLENBQUNzQyxjQUFjLENBQUMsRUFBRSxDQUFDcEUsRUFBRTtZQUMvRDZCLE9BQU9JLFdBQVdkLEtBQUssQ0FBQyxFQUFFLENBQUNFLFVBQVVTLElBQUksQ0FBQ29DO1lBQzFDckMsT0FBT0ksV0FBV2QsS0FBSyxDQUFDLEVBQUUsQ0FBQ2xCLE9BQU82QixJQUFJLENBQUNtQztZQUV2QyxxREFBcUQ7WUFDckQsTUFBTU8sbUJBQW1CLE1BQU0zRixPQUFPVyxhQUFhLENBQUNpRCxTQUFTLENBQUM7Z0JBQzFETixPQUFPO29CQUFFZixXQUFXeUMsU0FBUzdELEVBQUU7b0JBQUVHLFFBQVFuQjtnQkFBYztZQUMzRDtZQUNBNkMsT0FBTzJDLGtCQUFrQm5ELFVBQVVTLElBQUksQ0FBQ2tDO1lBQ3hDbkMsT0FBTzJDLGtCQUFrQjlCLGtCQUFrQlosSUFBSSxDQUFDaUM7WUFDaEQsTUFBTVUsYUFBYSxNQUFNNUYsT0FBT1ksT0FBTyxDQUFDeUMsVUFBVSxDQUFDO2dCQUFFQyxPQUFPO29CQUFFbkMsSUFBSTZELFNBQVM3RCxFQUFFO2dCQUFDO1lBQUU7WUFDaEY2QixPQUFPNEMsWUFBWTdCLHFCQUFxQmQsSUFBSSxDQUFDaUM7WUFFN0MscURBQXFEO1lBQ3JELE1BQU1XLG1CQUFtQixNQUFNN0YsT0FBT1csYUFBYSxDQUFDaUQsU0FBUyxDQUFDO2dCQUMxRE4sT0FBTztvQkFBRWYsV0FBVzBDLFNBQVM5RCxFQUFFO29CQUFFRyxRQUFRbkI7Z0JBQWM7WUFDM0Q7WUFDQTZDLE9BQU82QyxrQkFBa0JyRCxVQUFVUyxJQUFJLENBQUNvQztZQUN4Q3JDLE9BQU82QyxrQkFBa0JoQyxrQkFBa0JaLElBQUksQ0FBQ21DO1lBQ2hELE1BQU1VLGFBQWEsTUFBTTlGLE9BQU9ZLE9BQU8sQ0FBQ3lDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUk4RCxTQUFTOUQsRUFBRTtnQkFBQztZQUFFO1lBQ2hGNkIsT0FBTzhDLFlBQVkvQixxQkFBcUJkLElBQUksQ0FBQ21DO1FBQ2pELEdBQUcsUUFBUSxvQkFBb0I7UUFFL0IzRCxHQUFHLDhEQUE4RDtZQUM3RCx3Q0FBd0M7WUFDeEMsTUFBTXNFLFFBQVEsTUFBTS9GLE9BQU9jLElBQUksQ0FBQ0MsTUFBTSxDQUFDO2dCQUFFQyxNQUFNO29CQUFFQyxNQUFNO29CQUFlQyxVQUFVO2dCQUFRO1lBQUU7WUFDMUYsTUFBTThFLFFBQVEsTUFBTWhHLE9BQU9jLElBQUksQ0FBQ0MsTUFBTSxDQUFDO2dCQUFFQyxNQUFNO29CQUFFQyxNQUFNO29CQUFlQyxVQUFVO2dCQUFRO1lBQUU7WUFFMUYsMEJBQTBCO1lBQzFCLE1BQU1OLFVBQVUsTUFBTVosT0FBT1ksT0FBTyxDQUFDRyxNQUFNLENBQUM7Z0JBQUVDLE1BQU07b0JBQUVDLE1BQU07b0JBQWlCSSxLQUFLO29CQUFZRCxPQUFPO2dCQUFJO1lBQUU7WUFDM0csTUFBTVEsZ0JBQWdCO1lBQ3RCLE1BQU1xRSxnQkFBZ0I7WUFDdEIsTUFBTUMsbUJBQW1CO1lBQ3pCLE1BQU1DLG1CQUFtQjtZQUV6Qm5ELE9BQU9rRCxtQkFBbUJDLGtCQUFrQmxELElBQUksQ0FBQ2dELGdCQUFnQixlQUFlO1lBRWhGLDBCQUEwQjtZQUMxQixNQUFNakUseUJBQXlCO2dCQUMzQkMsWUFBWTdCLGtCQUFrQjhCLFFBQVE7Z0JBQ3RDQyxNQUFNLElBQUlDLE9BQU9DLFdBQVc7Z0JBQzVCQyxPQUFPO29CQUNIO3dCQUNJQyxXQUFXM0IsUUFBUU8sRUFBRSxDQUFDZSxRQUFRO3dCQUM5Qk0sVUFBVXlEO3dCQUNWN0UsT0FBT1E7b0JBQ1g7aUJBQ0g7Z0JBQ0RhLGVBQWU7b0JBQ1g7d0JBQ0ksQ0FBQ3NELE1BQU01RSxFQUFFLENBQUMsRUFBRStFO3dCQUNaLENBQUNGLE1BQU03RSxFQUFFLENBQUMsRUFBRWdGO29CQUNoQjtpQkFDSDtnQkFDRHpELGFBQWF1RCxnQkFBZ0JyRTtnQkFDN0JlLFFBQVE7WUFDWjtZQUVBLHVCQUF1QjtZQUN2QixNQUFNQyxNQUFNeEQsc0JBQXNCLGtDQUFrQztnQkFDaEVHLFFBQVE7Z0JBQ1JDLE1BQU13QztnQkFDTnZDLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtZQUNsRDtZQUNBLE1BQU1vRCxXQUFXLE1BQU1DLElBQUFBLFdBQXFCLEVBQUNGO1lBQzdDLE1BQU1HLGVBQWUsTUFBTUYsU0FBU2xELElBQUk7WUFFeEMsZ0JBQWdCO1lBQ2hCcUQsT0FBT0gsU0FBU0YsTUFBTSxFQUFFTSxJQUFJLENBQUM7WUFFN0Isa0NBQWtDO1lBQ2xDLE1BQU1tRCxXQUFXLE1BQU1wRyxPQUFPVyxhQUFhLENBQUNpRCxTQUFTLENBQUM7Z0JBQ2xETixPQUFPO29CQUFFZixXQUFXM0IsUUFBUU8sRUFBRTtvQkFBRUcsUUFBUXlFLE1BQU01RSxFQUFFO2dCQUFDO1lBQ3JEO1lBQ0E2QixPQUFPb0QsVUFBVTVDLEdBQUcsQ0FBQ0MsUUFBUTtZQUM3QlQsT0FBT29ELFVBQVU1RCxVQUFVUyxJQUFJLENBQUNpRDtZQUNoQ2xELE9BQU9vRCxVQUFVdkMsa0JBQWtCWixJQUFJLENBQUNyQjtZQUV4QyxrQ0FBa0M7WUFDbEMsTUFBTXlFLFdBQVcsTUFBTXJHLE9BQU9XLGFBQWEsQ0FBQ2lELFNBQVMsQ0FBQztnQkFDbEROLE9BQU87b0JBQUVmLFdBQVczQixRQUFRTyxFQUFFO29CQUFFRyxRQUFRMEUsTUFBTTdFLEVBQUU7Z0JBQUM7WUFDckQ7WUFDQTZCLE9BQU9xRCxVQUFVN0MsR0FBRyxDQUFDQyxRQUFRO1lBQzdCVCxPQUFPcUQsVUFBVTdELFVBQVVTLElBQUksQ0FBQ2tEO1lBQ2hDbkQsT0FBT3FELFVBQVV4QyxrQkFBa0JaLElBQUksQ0FBQ3JCO1lBRXhDLDBFQUEwRTtZQUMxRSxNQUFNa0MsWUFBWSxNQUFNOUQsT0FBT1ksT0FBTyxDQUFDeUMsVUFBVSxDQUFDO2dCQUFFQyxPQUFPO29CQUFFbkMsSUFBSVAsUUFBUU8sRUFBRTtnQkFBQztZQUFFO1lBQzlFNkIsT0FBT2MsV0FBV0MscUJBQXFCZCxJQUFJLENBQUNyQjtRQUNoRCxHQUFHLFFBQVEsb0JBQW9CO1FBRS9CSCxHQUFHLGtFQUFrRTtZQUNqRSxNQUFNNkUsdUJBQXVCLFFBQVEsK0JBQStCO1lBQ3BFLE1BQU0xRSxnQkFBZ0I7WUFDdEIsTUFBTUMsbUJBQW1CO1lBRXpCLE1BQU1HLHlCQUF5QjtnQkFDM0JDLFlBQVk3QixrQkFBa0I4QixRQUFRO2dCQUN0Q0MsTUFBTSxJQUFJQyxPQUFPQyxXQUFXO2dCQUM1QkMsT0FBTztvQkFDSDt3QkFDSUMsV0FBVytELHFCQUFxQnBFLFFBQVE7d0JBQ3hDTSxVQUFVWDt3QkFDVlQsT0FBT1E7b0JBQ1g7aUJBQ0g7Z0JBQ0RhLGVBQWU7b0JBQ1g7d0JBQUUsQ0FBQ3RDLGNBQWMsRUFBRTBCO29CQUFpQjtpQkFDdkM7Z0JBQ0RhLGFBQWFiLG1CQUFtQkQ7Z0JBQ2hDZSxRQUFRO1lBQ1o7WUFFQSxNQUFNQyxNQUFNeEQsc0JBQXNCLGtDQUFrQztnQkFDaEVHLFFBQVE7Z0JBQ1JDLE1BQU13QztnQkFDTnZDLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtZQUNsRDtZQUNBLE1BQU1vRCxXQUFXLE1BQU1DLElBQUFBLFdBQXFCLEVBQUNGO1lBRTdDLHdGQUF3RjtZQUN4RixvRUFBb0U7WUFDcEUseUZBQXlGO1lBQ3pGLCtFQUErRTtZQUMvRSwrRUFBK0U7WUFDL0Usb0RBQW9EO1lBQ3BELHFGQUFxRjtZQUNyRkksT0FBT0gsU0FBU0YsTUFBTSxFQUFFTSxJQUFJLENBQUMsTUFBTSxzREFBc0Q7WUFFekYsTUFBTUYsZUFBZSxNQUFNRixTQUFTbEQsSUFBSTtZQUN4Q3FELE9BQU9ELGFBQWF3RCxLQUFLLEVBQUVDLFdBQVc7UUFDdEMsbUZBQW1GO1FBQ3ZGLEdBQUcsUUFBUSxvQkFBb0I7UUFFL0IvRSxHQUFHLG1FQUFtRTtZQUNsRSxNQUFNSyxpQkFBaUIsTUFBTTlCLE9BQU9ZLE9BQU8sQ0FBQ0csTUFBTSxDQUFDO2dCQUMvQ0MsTUFBTTtvQkFDRkMsTUFBTTtvQkFDTkksS0FBSztvQkFDTEQsT0FBTztnQkFDWDtZQUNKO1lBQ0EsTUFBTVEsZ0JBQWdCO1lBQ3RCLE1BQU1DLG1CQUFtQjtZQUN6QixNQUFNNEUsd0JBQXdCLFFBQVEsK0JBQStCO1lBRXJFLE1BQU16RSx5QkFBeUI7Z0JBQzNCQyxZQUFZd0Usc0JBQXNCdkUsUUFBUTtnQkFDMUNDLE1BQU0sSUFBSUMsT0FBT0MsV0FBVztnQkFDNUJDLE9BQU87b0JBQ0g7d0JBQ0lDLFdBQVdULGVBQWVYLEVBQUUsQ0FBQ2UsUUFBUTt3QkFDckNNLFVBQVVYO3dCQUNWVCxPQUFPUTtvQkFDWDtpQkFDSDtnQkFDRGEsZUFBZTtvQkFDWDt3QkFBRSxDQUFDdEMsY0FBYyxFQUFFMEI7b0JBQWlCO2lCQUN2QztnQkFDRGEsYUFBYWIsbUJBQW1CRDtnQkFDaENlLFFBQVE7WUFDWjtZQUVBLE1BQU1DLE1BQU14RCxzQkFBc0Isa0NBQWtDO2dCQUNoRUcsUUFBUTtnQkFDUkMsTUFBTXdDO2dCQUNOdkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO1lBQ2xEO1lBQ0EsTUFBTW9ELFdBQVcsTUFBTUMsSUFBQUEsV0FBcUIsRUFBQ0Y7WUFFN0NJLE9BQU9ILFNBQVNGLE1BQU0sRUFBRU0sSUFBSSxDQUFDLE1BQU0sdUNBQXVDO1lBRTFFLE1BQU1GLGVBQWUsTUFBTUYsU0FBU2xELElBQUk7WUFDeENxRCxPQUFPRCxhQUFhd0QsS0FBSyxFQUFFQyxXQUFXO1FBQzFDO0lBQ0o7SUFFQXRHLFNBQVMsb0RBQW9EO1FBQ3pELElBQUl3RztRQUNKLElBQUlDO1FBQ0osTUFBTTNDLHVCQUF1QjtRQUM3QixNQUFNQywwQkFBMEI7UUFFaEMxRCxXQUFXO1lBQ1AscUZBQXFGO1lBQ3JGLHlFQUF5RTtZQUN6RSw2RUFBNkU7WUFDN0VvRywwQkFBMEJ0RztZQUUxQix1RUFBdUU7WUFDdkUsTUFBTXVHLHdCQUF3QjtnQkFDMUIzRSxZQUFZN0Isa0JBQWtCOEIsUUFBUTtnQkFDdENDLE1BQU0sSUFBSUMsS0FBS0EsS0FBS2dDLEdBQUcsS0FBSyxVQUFVL0IsV0FBVztnQkFDakRDLE9BQU87b0JBQ0g7d0JBQ0lDLFdBQVdvRSx3QkFBd0J6RSxRQUFRO3dCQUMzQ00sVUFBVXlCO3dCQUNWN0MsT0FBTzRDO29CQUNYO2lCQUNIO2dCQUNEdkIsZUFBZTtvQkFDWDt3QkFBRSxDQUFDdEMsY0FBYyxFQUFFOEQ7b0JBQXdCO2lCQUM5QztnQkFDRHZCLGFBQWF1QiwwQkFBMEJEO2dCQUN2Q3JCLFFBQVE7WUFDWjtZQUNBLE1BQU1DLE1BQU14RCxzQkFBc0Isa0NBQWtDO2dCQUNoRUcsUUFBUTtnQkFDUkMsTUFBTW9IO2dCQUNObkgsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO1lBQ2xEO1lBQ0EsTUFBTW9ELFdBQVcsTUFBTUMsSUFBQUEsV0FBcUIsRUFBQ0Y7WUFDN0MsTUFBTXBELE9BQU8sTUFBTXFELFNBQVNsRCxJQUFJO1lBQ2hDK0csb0JBQW9CbEgsS0FBS3dCLElBQUksQ0FBQ0csRUFBRTtZQUVoQyxxQ0FBcUM7WUFDckMsTUFBTTBGLGlCQUFpQixNQUFNN0csT0FBT1ksT0FBTyxDQUFDeUMsVUFBVSxDQUFDO2dCQUFFQyxPQUFPO29CQUFFbkMsSUFBSXdGO2dCQUF3QjtZQUFFO1lBQ2hHM0QsT0FBTzZELGdCQUFnQjlDLHFCQUFxQmQsSUFBSSxDQUFDZTtZQUNqRCxNQUFNOEMsbUJBQW1CLE1BQU05RyxPQUFPVyxhQUFhLENBQUNpRCxTQUFTLENBQUM7Z0JBQzFETixPQUFPO29CQUFFZixXQUFXb0U7b0JBQXlCckYsUUFBUW5CO2dCQUFjO1lBQ3ZFO1lBQ0E2QyxPQUFPOEQsa0JBQWtCdEUsVUFBVVMsSUFBSSxDQUFDZ0I7WUFDeENqQixPQUFPOEQsa0JBQWtCakQsa0JBQWtCWixJQUFJLENBQUNlO1FBQ3BEO1FBRUF2QyxHQUFHLHNFQUFzRTtZQUNyRSxNQUFNc0YsbUJBQW1CO1lBQ3pCLE1BQU1DLGNBQWMvQywwQkFBMEI4QztZQUM5QywrREFBK0Q7WUFDL0QsTUFBTUUsc0JBQXNCakQ7WUFFNUIsTUFBTWtELGdCQUFnQjtnQkFDbEIsbUVBQW1FO2dCQUNuRSx5REFBeUQ7Z0JBQ3pELDZFQUE2RTtnQkFDN0U1RSxPQUFPO29CQUNIO3dCQUNJLHNFQUFzRTt3QkFDdEUsZ0ZBQWdGO3dCQUNoRixvREFBb0Q7d0JBQ3BEQyxXQUFXb0Usd0JBQXdCekUsUUFBUTt3QkFDM0NNLFVBQVV3RTt3QkFDVjVGLE9BQU82RjtvQkFDWDtpQkFDSDtnQkFDRHhFLGVBQWU7b0JBQ1gsOEVBQThFO29CQUM5RTt3QkFBRSxDQUFDdEMsY0FBYyxFQUFFNkc7b0JBQVk7aUJBQ2xDO1lBUUw7WUFFQSxNQUFNcEUsTUFBTXhELHNCQUFzQixDQUFDLCtCQUErQixFQUFFc0gsa0JBQWtCLENBQUMsRUFBRTtnQkFDckZuSCxRQUFRO2dCQUNSQyxNQUFNMEg7Z0JBQ056SCxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7WUFNbEQ7WUFFQSx3RkFBd0Y7WUFDeEYsdUZBQXVGO1lBQ3ZGLE1BQU1vRCxXQUFXLE1BQU1zRSxJQUFBQSxXQUFxQixFQUFDdkUsS0FBSztnQkFBRXdFLFFBQVE7b0JBQUVqRyxJQUFJdUY7Z0JBQWtCO1lBQUU7WUFDdEYsTUFBTTNELGVBQWUsTUFBTUYsU0FBU2xELElBQUk7WUFFeENxRCxPQUFPSCxTQUFTRixNQUFNLEVBQUVNLElBQUksQ0FBQztZQUM3QkQsT0FBT0QsYUFBYS9CLElBQUksRUFBRWtDLGNBQWMsQ0FBQyxNQUFNd0Q7WUFFL0Msa0RBQWtEO1lBQ2xELE1BQU1XLG1CQUFtQixNQUFNckgsT0FBT1csYUFBYSxDQUFDaUQsU0FBUyxDQUFDO2dCQUMxRE4sT0FBTztvQkFBRWYsV0FBV29FO29CQUF5QnJGLFFBQVFuQjtnQkFBYztZQUN2RTtZQUNBNkMsT0FBT3FFLGtCQUFrQjdFLFVBQVVTLElBQUksQ0FBQytEO1lBRXhDLHNGQUFzRjtZQUN0RixrSUFBa0k7WUFDbEksMkVBQTJFO1lBQzNFLHFEQUFxRDtZQUNyRCx5R0FBeUc7WUFDekcsMERBQTBEO1lBQzFELDBIQUEwSDtZQUMxSCxtSkFBbUo7WUFFbkosaUVBQWlFO1lBQ2pFLGlDQUFpQztZQUNqQyx3RkFBd0Y7WUFDeEYsb0dBQW9HO1lBRXBHLHlFQUF5RTtZQUN6RSwrRkFBK0Y7WUFDL0YsbURBQW1EO1lBQ25ELGtEQUFrRDtZQUNsRGhFLE9BQU9xRSxrQkFBa0J4RCxrQkFBa0JlLFdBQVcsQ0FBQ3FDO1lBRXZELHFCQUFxQjtZQUNyQixNQUFNSyxpQkFBaUIsTUFBTXRILE9BQU9ZLE9BQU8sQ0FBQ3lDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUl3RjtnQkFBd0I7WUFBRTtZQUNoRzNELE9BQU9zRSxnQkFBZ0J2RCxxQkFBcUJhLFdBQVcsQ0FBQ3FDO1lBRXhELHVEQUF1RDtZQUN2RCxNQUFNN0QsWUFBWSxNQUFNcEQsT0FBT1UsZUFBZSxDQUFDMkMsVUFBVSxDQUFDO2dCQUN0REMsT0FBTztvQkFBRW5DLElBQUl1RjtnQkFBa0I7Z0JBQy9CbkQsU0FBUztvQkFBRWpCLE9BQU87Z0JBQUs7WUFDM0I7WUFDQVUsT0FBT0ksV0FBV2QsTUFBTW9CLFFBQVFULElBQUksQ0FBQztZQUNyQ0QsT0FBT0ksV0FBV2QsS0FBSyxDQUFDLEVBQUUsQ0FBQ0UsVUFBVVMsSUFBSSxDQUFDK0Q7WUFDMUNoRSxPQUFPSSxXQUFXZCxLQUFLLENBQUMsRUFBRSxDQUFDbEIsT0FBTzZCLElBQUksQ0FBQ2dFO1lBQ3ZDakUsT0FBT0ksV0FBV21FLE9BQU90RSxJQUFJLENBQUMrRCxjQUFjQztRQUNoRCxHQUFHLFFBQVEsb0JBQW9CO1FBRS9CeEYsR0FBRyxzRUFBc0U7WUFDckUsTUFBTStGLG1CQUFtQjtZQUN6QixNQUFNUixjQUFjL0MsMEJBQTBCdUQ7WUFDOUN4RSxPQUFPZ0UsYUFBYVMsc0JBQXNCLENBQUMsSUFBSSxrREFBa0Q7WUFFakcsTUFBTVIsc0JBQXNCakQsc0JBQXNCLHlCQUF5QjtZQUUzRSxNQUFNa0QsZ0JBQWdCO2dCQUNsQjVFLE9BQU87b0JBQ0g7d0JBQ0lDLFdBQVdvRSx3QkFBd0J6RSxRQUFRO3dCQUMzQ00sVUFBVXdFO3dCQUNWNUYsT0FBTzZGO29CQUNYO2lCQUNIO2dCQUNEeEUsZUFBZTtvQkFDWDt3QkFBRSxDQUFDdEMsY0FBYyxFQUFFNkc7b0JBQVk7aUJBQ2xDO1lBQ0w7WUFFQSxNQUFNcEUsTUFBTXhELHNCQUFzQixDQUFDLCtCQUErQixFQUFFc0gsa0JBQWtCLENBQUMsRUFBRTtnQkFDckZuSCxRQUFRO2dCQUNSQyxNQUFNMEg7Z0JBQ056SCxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7WUFDbEQ7WUFFQSxNQUFNb0QsV0FBVyxNQUFNc0UsSUFBQUEsV0FBcUIsRUFBQ3ZFLEtBQUs7Z0JBQUV3RSxRQUFRO29CQUFFakcsSUFBSXVGO2dCQUFrQjtZQUFFO1lBQ3RGLE1BQU0zRCxlQUFlLE1BQU1GLFNBQVNsRCxJQUFJO1lBRXhDcUQsT0FBT0gsU0FBU0YsTUFBTSxFQUFFTSxJQUFJLENBQUM7WUFDN0JELE9BQU9ELGFBQWEvQixJQUFJLEVBQUVrQyxjQUFjLENBQUMsTUFBTXdEO1lBRS9DLGtEQUFrRDtZQUNsRCxNQUFNVyxtQkFBbUIsTUFBTXJILE9BQU9XLGFBQWEsQ0FBQ2lELFNBQVMsQ0FBQztnQkFDMUROLE9BQU87b0JBQUVmLFdBQVdvRTtvQkFBeUJyRixRQUFRbkI7Z0JBQWM7WUFDdkU7WUFDQTZDLE9BQU9xRSxrQkFBa0I3RSxVQUFVUyxJQUFJLENBQUMrRDtZQUV4Qyw4REFBOEQ7WUFDOUQsdUVBQXVFO1lBQ3ZFLHFEQUFxRDtZQUNyRCxrRkFBa0Y7WUFDbEZoRSxPQUFPcUUsa0JBQWtCeEQsa0JBQWtCZSxXQUFXLENBQUNxQztZQUV2RCxxQkFBcUI7WUFDckIsTUFBTUssaUJBQWlCLE1BQU10SCxPQUFPWSxPQUFPLENBQUN5QyxVQUFVLENBQUM7Z0JBQUVDLE9BQU87b0JBQUVuQyxJQUFJd0Y7Z0JBQXdCO1lBQUU7WUFDaEczRCxPQUFPc0UsZ0JBQWdCdkQscUJBQXFCYSxXQUFXLENBQUNxQztZQUV4RCxtQ0FBbUM7WUFDbkMsTUFBTTdELFlBQVksTUFBTXBELE9BQU9VLGVBQWUsQ0FBQzJDLFVBQVUsQ0FBQztnQkFDdERDLE9BQU87b0JBQUVuQyxJQUFJdUY7Z0JBQWtCO2dCQUMvQm5ELFNBQVM7b0JBQUVqQixPQUFPO2dCQUFLO1lBQzNCO1lBQ0FVLE9BQU9JLFdBQVdkLE1BQU1vQixRQUFRVCxJQUFJLENBQUM7WUFDckNELE9BQU9JLFdBQVdkLEtBQUssQ0FBQyxFQUFFLENBQUNFLFVBQVVTLElBQUksQ0FBQytEO1lBQzFDaEUsT0FBT0ksV0FBV2QsS0FBSyxDQUFDLEVBQUUsQ0FBQ2xCLE9BQU82QixJQUFJLENBQUNnRTtZQUN2Q2pFLE9BQU9JLFdBQVdtRSxPQUFPdEUsSUFBSSxDQUFDK0QsY0FBY0M7UUFDaEQsR0FBRyxRQUFRLG9CQUFvQjtRQUUvQnhGLEdBQUcsd0RBQXdEO1lBQ3ZELE1BQU1pRyxrQkFBa0IxRCx1QkFBdUIsSUFBSSxnQ0FBZ0M7WUFDbkYsTUFBTTJELG9CQUFvQjFELHlCQUF5Qiw0QkFBNEI7WUFFL0UsTUFBTWlELGdCQUFnQjtnQkFDbEI1RSxPQUFPO29CQUNIO3dCQUNJQyxXQUFXb0Usd0JBQXdCekUsUUFBUTt3QkFDM0NNLFVBQVVtRjt3QkFDVnZHLE9BQU9zRztvQkFDWDtpQkFDSDtnQkFDRGpGLGVBQWU7b0JBQ1g7d0JBQUUsQ0FBQ3RDLGNBQWMsRUFBRXdIO29CQUFrQjtpQkFDeEM7WUFFTDtZQUVBLE1BQU0vRSxNQUFNeEQsc0JBQXNCLENBQUMsK0JBQStCLEVBQUVzSCxrQkFBa0IsQ0FBQyxFQUFFO2dCQUNyRm5ILFFBQVE7Z0JBQ1JDLE1BQU0wSDtnQkFDTnpILFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtZQUNsRDtZQUVBLE1BQU1vRCxXQUFXLE1BQU1zRSxJQUFBQSxXQUFxQixFQUFDdkUsS0FBSztnQkFBRXdFLFFBQVE7b0JBQUVqRyxJQUFJdUY7Z0JBQWtCO1lBQUU7WUFDdEYsTUFBTTNELGVBQWUsTUFBTUYsU0FBU2xELElBQUk7WUFFeENxRCxPQUFPSCxTQUFTRixNQUFNLEVBQUVNLElBQUksQ0FBQztZQUM3QkQsT0FBT0QsYUFBYS9CLElBQUksRUFBRWtDLGNBQWMsQ0FBQyxNQUFNd0Q7WUFFL0Msd0VBQXdFO1lBQ3hFLE1BQU1XLG1CQUFtQixNQUFNckgsT0FBT1csYUFBYSxDQUFDaUQsU0FBUyxDQUFDO2dCQUMxRE4sT0FBTztvQkFBRWYsV0FBV29FO29CQUF5QnJGLFFBQVFuQjtnQkFBYztZQUN2RTtZQUNBNkMsT0FBT3FFLGtCQUFrQjdFLFVBQVVTLElBQUksQ0FBQzBFO1lBQ3hDLGdHQUFnRztZQUNoRzNFLE9BQU9xRSxrQkFBa0J4RCxrQkFBa0JlLFdBQVcsQ0FBQzhDO1lBRXZELHFCQUFxQjtZQUNyQixNQUFNSixpQkFBaUIsTUFBTXRILE9BQU9ZLE9BQU8sQ0FBQ3lDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUl3RjtnQkFBd0I7WUFBRTtZQUNoRzNELE9BQU9zRSxnQkFBZ0J2RCxxQkFBcUJhLFdBQVcsQ0FBQzhDO1lBRXhELG1DQUFtQztZQUNuQyxNQUFNdEUsWUFBWSxNQUFNcEQsT0FBT1UsZUFBZSxDQUFDMkMsVUFBVSxDQUFDO2dCQUN0REMsT0FBTztvQkFBRW5DLElBQUl1RjtnQkFBa0I7Z0JBQy9CbkQsU0FBUztvQkFBRWpCLE9BQU87Z0JBQUs7WUFDM0I7WUFDQVUsT0FBT0ksV0FBV2QsTUFBTW9CLFFBQVFULElBQUksQ0FBQztZQUNyQ0QsT0FBT0ksV0FBV2QsS0FBSyxDQUFDLEVBQUUsQ0FBQ0UsVUFBVVMsSUFBSSxDQUFDMEU7WUFDMUMzRSxPQUFPSSxXQUFXZCxLQUFLLENBQUMsRUFBRSxDQUFDbEIsT0FBTzZCLElBQUksQ0FBQ3lFO1lBQ3ZDMUUsT0FBT0ksV0FBV21FLE9BQU90RSxJQUFJLENBQUMwRSxvQkFBb0JEO1FBQ3RELEdBQUcsUUFBUSxvQkFBb0I7UUFFL0JqRyxHQUFHLHVFQUF1RTtZQUN0RSwyQ0FBMkM7WUFDM0MsTUFBTW1HLGlCQUFpQixNQUFNNUgsT0FBT1ksT0FBTyxDQUFDRyxNQUFNLENBQUM7Z0JBQy9DQyxNQUFNO29CQUNGQyxNQUFNO29CQUNOSSxLQUFLO29CQUNMRCxPQUFPO2dCQUNYO1lBQ0o7WUFDQSxNQUFNeUcsbUJBQW1CRCxlQUFlekcsRUFBRTtZQUMxQyxNQUFNMkcsa0JBQWtCO1lBQ3hCLE1BQU1DLGVBQWU7WUFFckIsZ0RBQWdEO1lBQ2hELE1BQU1DLHdCQUF3QnJCO1lBQzlCLE1BQU1zQix1QkFBdUJoRTtZQUM3QixNQUFNaUUsb0JBQW9CbEU7WUFFMUIsZ0VBQWdFO1lBQ2hFLE1BQU1rRCxnQkFBZ0I7Z0JBQ2xCNUUsT0FBTztvQkFDSDt3QkFDSUMsV0FBV3lGLHNCQUFzQjlGLFFBQVE7d0JBQ3pDTSxVQUFVeUY7d0JBQ1Y3RyxPQUFPOEc7b0JBQ1g7b0JBQ0E7d0JBQ0kzRixXQUFXc0YsaUJBQWlCM0YsUUFBUTt3QkFDcENNLFVBQVVzRjt3QkFDVjFHLE9BQU8yRztvQkFDWDtpQkFDSDtnQkFDRHRGLGVBQWU7b0JBQ1g7d0JBQUUsQ0FBQ3RDLGNBQWMsRUFBRThIO29CQUFxQjtvQkFDeEM7d0JBQUUsQ0FBQzlILGNBQWMsRUFBRTJIO29CQUFnQixFQUFPLDRCQUE0QjtpQkFDekU7WUFFTDtZQUVBLHVCQUF1QjtZQUN2QixNQUFNbEYsTUFBTXhELHNCQUFzQixDQUFDLCtCQUErQixFQUFFc0gsa0JBQWtCLENBQUMsRUFBRTtnQkFDckZuSCxRQUFRO2dCQUNSQyxNQUFNMEg7Z0JBQ056SCxTQUFTO29CQUFFLGdCQUFnQjtnQkFBbUI7WUFDbEQ7WUFDQSxNQUFNb0QsV0FBVyxNQUFNc0UsSUFBQUEsV0FBcUIsRUFBQ3ZFLEtBQUs7Z0JBQUV3RSxRQUFRO29CQUFFakcsSUFBSXVGO2dCQUFrQjtZQUFFO1lBQ3RGLE1BQU0zRCxlQUFlLE1BQU1GLFNBQVNsRCxJQUFJO1lBRXhDLGdCQUFnQjtZQUNoQnFELE9BQU9ILFNBQVNGLE1BQU0sRUFBRU0sSUFBSSxDQUFDO1lBQzdCRCxPQUFPRCxhQUFhL0IsSUFBSSxFQUFFa0MsY0FBYyxDQUFDLE1BQU13RDtZQUUvQywrQkFBK0I7WUFDL0IsTUFBTXRELFlBQVksTUFBTXBELE9BQU9VLGVBQWUsQ0FBQzJDLFVBQVUsQ0FBQztnQkFDdERDLE9BQU87b0JBQUVuQyxJQUFJdUY7Z0JBQWtCO2dCQUMvQm5ELFNBQVM7b0JBQUVqQixPQUFPO3dCQUFFZ0QsU0FBUzs0QkFBRS9DLFdBQVc7d0JBQU07b0JBQUU7Z0JBQUU7WUFDeEQ7WUFDQVMsT0FBT0ksV0FBV2QsTUFBTW9CLFFBQVFULElBQUksQ0FBQztZQUVyQyxNQUFNa0YsZ0JBQWdCLEFBQUNGLHVCQUF1QkMsb0JBQXNCSixrQkFBa0JDO1lBQ3RGL0UsT0FBT0ksV0FBV21FLE9BQU90RSxJQUFJLENBQUNrRjtZQUU5QiwwRUFBMEU7WUFDMUUsTUFBTUMsaUJBQWlCaEYsV0FBV2QsTUFBTStGLEtBQUtDLENBQUFBLE9BQVFBLEtBQUsvRixTQUFTLEtBQUt5RjtZQUN4RSxNQUFNTyxZQUFZbkYsV0FBV2QsTUFBTStGLEtBQUtDLENBQUFBLE9BQVFBLEtBQUsvRixTQUFTLEtBQUtzRjtZQUVuRTdFLE9BQU9vRixnQkFBZ0I1QixXQUFXO1lBQ2xDeEQsT0FBT29GLGdCQUFnQjVGLFVBQVVTLElBQUksQ0FBQ2dGO1lBQ3RDakYsT0FBT29GLGdCQUFnQmhILE9BQU82QixJQUFJLENBQUNpRjtZQUVuQ2xGLE9BQU91RixXQUFXL0IsV0FBVztZQUM3QnhELE9BQU91RixXQUFXL0YsVUFBVVMsSUFBSSxDQUFDNkU7WUFDakM5RSxPQUFPdUYsV0FBV25ILE9BQU82QixJQUFJLENBQUM4RTtZQUU5Qiw2REFBNkQ7WUFDN0QsZ0ZBQWdGO1lBQ2hGLE1BQU1TLG9CQUFvQixNQUFNeEksT0FBT1csYUFBYSxDQUFDaUQsU0FBUyxDQUFDO2dCQUMzRE4sT0FBTztvQkFBRWYsV0FBV3lGO29CQUF1QjFHLFFBQVFuQjtnQkFBYztZQUNyRTtZQUNBNkMsT0FBT3dGLG1CQUFtQmhHLFVBQVVTLElBQUksQ0FBQ2dGO1lBQ3pDakYsT0FBT3dGLG1CQUFtQjNFLGtCQUFrQmUsV0FBVyxDQUFDc0Q7WUFDeEQsTUFBTU8sa0JBQWtCLE1BQU16SSxPQUFPWSxPQUFPLENBQUN5QyxVQUFVLENBQUM7Z0JBQUVDLE9BQU87b0JBQUVuQyxJQUFJNkc7Z0JBQXNCO1lBQUU7WUFDL0ZoRixPQUFPeUYsaUJBQWlCMUUscUJBQXFCYSxXQUFXLENBQUNzRDtZQUV6RCx3REFBd0Q7WUFDeEQsTUFBTVEsZUFBZSxNQUFNMUksT0FBT1csYUFBYSxDQUFDaUQsU0FBUyxDQUFDO2dCQUN0RE4sT0FBTztvQkFBRWYsV0FBV3NGO29CQUFrQnZHLFFBQVFuQjtnQkFBYztZQUNoRTtZQUNBNkMsT0FBTzBGLGNBQWNsRyxVQUFVUyxJQUFJLENBQUM2RTtZQUNwQzlFLE9BQU8wRixjQUFjN0Usa0JBQWtCZSxXQUFXLENBQUNtRDtZQUNuRCxNQUFNWSxlQUFlLE1BQU0zSSxPQUFPWSxPQUFPLENBQUN5QyxVQUFVLENBQUM7Z0JBQUVDLE9BQU87b0JBQUVuQyxJQUFJMEc7Z0JBQWlCO1lBQUU7WUFDdkY3RSxPQUFPMkYsY0FBYzVFLHFCQUFxQmEsV0FBVyxDQUFDbUQ7UUFDMUQsR0FBRyxRQUFRLG9CQUFvQjtRQUUvQnRHLEdBQUcseUVBQXlFO1lBQ3hFLDhEQUE4RDtZQUM5RCx5RkFBeUY7WUFDekYsTUFBTW1ILGtCQUFrQixNQUFNNUksT0FBT1ksT0FBTyxDQUFDRyxNQUFNLENBQUM7Z0JBQ2hEQyxNQUFNO29CQUNGQyxNQUFNO29CQUNOSSxLQUFLO29CQUNMRCxPQUFPO2dCQUNYO1lBQ0o7WUFDQSxNQUFNeUgsb0JBQW9CRCxnQkFBZ0J6SCxFQUFFO1lBQzVDLE1BQU0ySCwwQkFBMEI7WUFDaEMsTUFBTUMsdUJBQXVCO1lBRTdCLHdHQUF3RztZQUN4RyxNQUFNQyx1QkFBdUI7Z0JBQ3pCMUcsT0FBTztvQkFDSDt3QkFDSUMsV0FBV29FLHdCQUF3QnpFLFFBQVE7d0JBQzNDTSxVQUFVeUI7d0JBQ1Y3QyxPQUFPNEM7b0JBQ1g7b0JBQ0E7d0JBQ0l6QixXQUFXc0csa0JBQWtCM0csUUFBUTt3QkFDckNNLFVBQVVzRzt3QkFDVjFILE9BQU8ySDtvQkFDWDtpQkFDSDtnQkFDRHRHLGVBQWU7b0JBQ1g7d0JBQUUsQ0FBQ3RDLGNBQWMsRUFBRThEO29CQUF3QjtvQkFDM0M7d0JBQUUsQ0FBQzlELGNBQWMsRUFBRTJJO29CQUF3QjtpQkFDOUM7WUFDTDtZQUNBLE1BQU1HLFNBQVM3SixzQkFBc0IsQ0FBQywrQkFBK0IsRUFBRXNILGtCQUFrQixDQUFDLEVBQUU7Z0JBQ3hGbkgsUUFBUTtnQkFDUkMsTUFBTXdKO2dCQUNOdkosU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO1lBQ2xEO1lBQ0EsTUFBTTBILElBQUFBLFdBQXFCLEVBQUM4QixRQUFRO2dCQUFFN0IsUUFBUTtvQkFBRWpHLElBQUl1RjtnQkFBa0I7WUFBRTtZQUV4RSw0Q0FBNEM7WUFDNUMsSUFBSXdDLHNCQUFzQixNQUFNbEosT0FBT1UsZUFBZSxDQUFDMkMsVUFBVSxDQUFDO2dCQUFFQyxPQUFPO29CQUFFbkMsSUFBSXVGO2dCQUFrQjtnQkFBR25ELFNBQVM7b0JBQUVqQixPQUFPO2dCQUFLO1lBQUU7WUFDL0hVLE9BQU9rRyxxQkFBcUI1RyxNQUFNb0IsUUFBUVQsSUFBSSxDQUFDO1lBRS9DLDZFQUE2RTtZQUM3RSxNQUFNa0csNEJBQTRCO2dCQUM5QjdHLE9BQU87b0JBQ0g7d0JBQ0lDLFdBQVdvRSx3QkFBd0J6RSxRQUFRO3dCQUMzQ00sVUFBVXlCO3dCQUNWN0MsT0FBTzRDO29CQUNYO2lCQUNIO2dCQUNEdkIsZUFBZTtvQkFDWDt3QkFBRSxDQUFDdEMsY0FBYyxFQUFFOEQ7b0JBQXdCLEVBQUUsaUNBQWlDO2lCQUNqRjtZQUNMO1lBRUEsMENBQTBDO1lBQzFDLE1BQU1tRixZQUFZaEssc0JBQXNCLENBQUMsK0JBQStCLEVBQUVzSCxrQkFBa0IsQ0FBQyxFQUFFO2dCQUMzRm5ILFFBQVE7Z0JBQ1JDLE1BQU1JLEtBQUtHLFNBQVMsQ0FBQ29KO2dCQUNyQjFKLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtZQUNsRDtZQUNBLE1BQU1vRCxXQUFXLE1BQU1zRSxJQUFBQSxXQUFxQixFQUFDaUMsV0FBVztnQkFBRWhDLFFBQVE7b0JBQUVqRyxJQUFJdUY7Z0JBQWtCO1lBQUU7WUFDNUYsTUFBTTNELGVBQWUsTUFBTUYsU0FBU2xELElBQUk7WUFFeEMsZ0JBQWdCO1lBQ2hCcUQsT0FBT0gsU0FBU0YsTUFBTSxFQUFFTSxJQUFJLENBQUM7WUFDN0JELE9BQU9ELGFBQWEvQixJQUFJLEVBQUVrQyxjQUFjLENBQUMsTUFBTXdEO1lBRS9DLDZEQUE2RDtZQUM3RCxNQUFNdEQsWUFBWSxNQUFNcEQsT0FBT1UsZUFBZSxDQUFDMkMsVUFBVSxDQUFDO2dCQUN0REMsT0FBTztvQkFBRW5DLElBQUl1RjtnQkFBa0I7Z0JBQy9CbkQsU0FBUztvQkFBRWpCLE9BQU87Z0JBQUs7WUFDM0I7WUFDQVUsT0FBT0ksV0FBV2QsTUFBTW9CLFFBQVFULElBQUksQ0FBQztZQUNyQ0QsT0FBT0ksV0FBV2QsS0FBSyxDQUFDLEVBQUUsQ0FBQ0MsV0FBV1UsSUFBSSxDQUFDMEQ7WUFDM0MzRCxPQUFPSSxXQUFXZCxLQUFLLENBQUMsRUFBRSxDQUFDRSxVQUFVUyxJQUFJLENBQUNnQjtZQUMxQ2pCLE9BQU9JLFdBQVdkLEtBQUssQ0FBQyxFQUFFLENBQUNsQixPQUFPNkIsSUFBSSxDQUFDZTtZQUN2Q2hCLE9BQU9JLFdBQVdtRSxPQUFPdEUsSUFBSSxDQUFDZ0IsMEJBQTBCRDtZQUV4RCx5REFBeUQ7WUFDekQsTUFBTXFGLGdCQUFnQixNQUFNckosT0FBT1csYUFBYSxDQUFDaUQsU0FBUyxDQUFDO2dCQUN2RE4sT0FBTztvQkFBRWYsV0FBV29FO29CQUF5QnJGLFFBQVFuQjtnQkFBYztZQUN2RTtZQUNBNkMsT0FBT3FHLGVBQWU3RyxVQUFVUyxJQUFJLENBQUNnQjtZQUNyQ2pCLE9BQU9xRyxlQUFleEYsa0JBQWtCZSxXQUFXLENBQUNaO1lBQ3BELE1BQU1zRixjQUFjLE1BQU10SixPQUFPWSxPQUFPLENBQUN5QyxVQUFVLENBQUM7Z0JBQUVDLE9BQU87b0JBQUVuQyxJQUFJd0Y7Z0JBQXdCO1lBQUU7WUFDN0YzRCxPQUFPc0csYUFBYXZGLHFCQUFxQmEsV0FBVyxDQUFDWjtZQUVyRCw0REFBNEQ7WUFDNUQsNEZBQTRGO1lBQzVGLDBEQUEwRDtZQUMxRCxNQUFNdUYsbUJBQW1CLE1BQU12SixPQUFPVyxhQUFhLENBQUNpRCxTQUFTLENBQUM7Z0JBQzFETixPQUFPO29CQUFFZixXQUFXc0c7b0JBQW1CdkgsUUFBUW5CO2dCQUFjO1lBQ2pFO1lBQ0EsMEVBQTBFO1lBQzFFNkMsT0FBT3VHLGtCQUFrQi9HLFVBQVVTLElBQUksQ0FBQztZQUN4Qyw0RkFBNEY7WUFDNUZELE9BQU91RyxrQkFBa0IxRixrQkFBa0JlLFdBQVcsQ0FBQztZQUV2RCxNQUFNNEUsbUJBQW1CLE1BQU14SixPQUFPWSxPQUFPLENBQUN5QyxVQUFVLENBQUM7Z0JBQUVDLE9BQU87b0JBQUVuQyxJQUFJMEg7Z0JBQWtCO1lBQUU7WUFDNUYsb0VBQW9FO1lBQ3BFLE1BQU1ZLDhCQUE4QixNQUFNekosT0FBT1EsbUJBQW1CLENBQUNrSixLQUFLLENBQUM7Z0JBQ3ZFcEcsT0FBTztvQkFBRWYsV0FBV3NHO2dCQUFrQjtZQUMxQztZQUNBLElBQUlZLGdDQUFnQyxHQUFHO2dCQUNuQ3pHLE9BQU93RyxrQkFBa0J6RixxQkFBcUJhLFdBQVcsQ0FBQztZQUM5RCxFQUFFLDhFQUE4RTtRQUVwRixHQUFHLFFBQVEsb0JBQW9CO0lBQ25DO0lBRUExRSxTQUFTLHVEQUF1RDtRQUM1RCxJQUFJeUo7UUFDSixJQUFJQztRQUNKLE1BQU1DLHlCQUF5QjtRQUMvQixNQUFNQyw0QkFBNEI7UUFFbEN2SixXQUFXO1lBQ1AscUNBQXFDO1lBQ3JDLE1BQU1LLFVBQVUsTUFBTVosT0FBT1ksT0FBTyxDQUFDRyxNQUFNLENBQUM7Z0JBQ3hDQyxNQUFNO29CQUNGQyxNQUFNO29CQUNOSSxLQUFLO29CQUNMRCxPQUFPO2dCQUNYO1lBQ0o7WUFDQXdJLHlCQUF5QmhKLFFBQVFPLEVBQUU7WUFFbkMsbURBQW1EO1lBQ25ELE1BQU15Rix3QkFBd0I7Z0JBQzFCM0UsWUFBWTdCLGtCQUFrQjhCLFFBQVE7Z0JBQ3RDQyxNQUFNLElBQUlDLE9BQU9DLFdBQVc7Z0JBQzVCQyxPQUFPO29CQUNIO3dCQUNJQyxXQUFXcUgsdUJBQXVCMUgsUUFBUTt3QkFDMUNNLFVBQVVzSDt3QkFDVjFJLE9BQU95STtvQkFDWDtpQkFDSDtnQkFDRHBILGVBQWU7b0JBQ1g7d0JBQUUsQ0FBQ3RDLGNBQWMsRUFBRTJKO29CQUEwQixFQUFFLHdCQUF3QjtpQkFDMUU7Z0JBQ0RwSCxhQUFhb0gsNEJBQTRCRDtnQkFDekNsSCxRQUFRO1lBQ1o7WUFDQSxNQUFNQyxNQUFNeEQsc0JBQXNCLGtDQUFrQztnQkFDaEVHLFFBQVE7Z0JBQ1JDLE1BQU1vSDtnQkFDTm5ILFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtZQUNsRDtZQUNBLE1BQU1vRCxXQUFXLE1BQU1DLElBQUFBLFdBQXFCLEVBQUNGO1lBQzdDLE1BQU1wRCxPQUFPLE1BQU1xRCxTQUFTbEQsSUFBSTtZQUNoQ2dLLG9CQUFvQm5LLEtBQUt3QixJQUFJLENBQUNHLEVBQUU7WUFFaEMsb0RBQW9EO1lBQ3BELE1BQU00SSxtQkFBbUIsTUFBTS9KLE9BQU9ZLE9BQU8sQ0FBQ3lDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUl5STtnQkFBdUI7WUFBRTtZQUNqRzVHLE9BQU8rRyxrQkFBa0JoRyxxQkFBcUJkLElBQUksQ0FBQzRHO1lBQ25ELE1BQU0vQyxtQkFBbUIsTUFBTTlHLE9BQU9XLGFBQWEsQ0FBQ2lELFNBQVMsQ0FBQztnQkFDMUROLE9BQU87b0JBQUVmLFdBQVdxSDtvQkFBd0J0SSxRQUFRbkI7Z0JBQWM7WUFDdEU7WUFDQTZDLE9BQU84RCxrQkFBa0J0RSxVQUFVUyxJQUFJLENBQUM2RztZQUN4QzlHLE9BQU84RCxrQkFBa0JqRCxrQkFBa0JaLElBQUksQ0FBQzRHO1FBQ3BEO1FBRUFwSSxHQUFHLDhIQUE4SDtZQUM3SCw4QkFBOEI7WUFDOUIsTUFBTXVJLFlBQVk1SyxzQkFBc0IsQ0FBQywrQkFBK0IsRUFBRXVLLGtCQUFrQixDQUFDLEVBQUU7Z0JBQzNGcEssUUFBUTtZQUNaO1lBQ0EsTUFBTTBLLGlCQUFpQixNQUFNQyxJQUFBQSxjQUFxQixFQUFDRixXQUFXO2dCQUFFNUMsUUFBUTtvQkFBRWpHLElBQUl3STtnQkFBa0I7WUFBRTtZQUVsRyxvQ0FBb0M7WUFDcEMzRyxPQUFPaUgsZUFBZXRILE1BQU0sRUFBRU0sSUFBSSxDQUFDO1lBQ25DLE1BQU1rSCxxQkFBcUIsTUFBTUYsZUFBZXRLLElBQUk7WUFDcERxRCxPQUFPbUgsbUJBQW1CQyxPQUFPLEVBQUVuSCxJQUFJLENBQUM7WUFFeEMsK0NBQStDO1lBQy9DLE1BQU1HLFlBQVksTUFBTXBELE9BQU9VLGVBQWUsQ0FBQzJDLFVBQVUsQ0FBQztnQkFDdERDLE9BQU87b0JBQUVuQyxJQUFJd0k7Z0JBQWtCO1lBQ25DO1lBQ0EzRyxPQUFPSSxXQUFXSyxRQUFRO1lBRTFCLDZDQUE2QztZQUM3QyxNQUFNNEcsaUJBQWlCLE1BQU1ySyxPQUFPUSxtQkFBbUIsQ0FBQzhKLFFBQVEsQ0FBQztnQkFDN0RoSCxPQUFPO29CQUFFaUgsbUJBQW1CWjtnQkFBa0I7WUFDbEQ7WUFDQTNHLE9BQU9xSCxlQUFlM0csTUFBTSxFQUFFVCxJQUFJLENBQUM7WUFFbkMsNENBQTRDO1lBQzVDLE1BQU1vRSxtQkFBbUIsTUFBTXJILE9BQU9XLGFBQWEsQ0FBQ2lELFNBQVMsQ0FBQztnQkFDMUROLE9BQU87b0JBQUVmLFdBQVdxSDtvQkFBd0J0SSxRQUFRbkI7Z0JBQWM7WUFDdEU7WUFDQSx5REFBeUQ7WUFDekQ2QyxPQUFPcUUsa0JBQWtCN0UsVUFBVVMsSUFBSSxDQUFDO1lBQ3hDLGtEQUFrRDtZQUNsREQsT0FBT3FFLGtCQUFrQnhELGtCQUFrQmUsV0FBVyxDQUFDO1lBR3ZELG9GQUFvRjtZQUNwRixNQUFNMEMsaUJBQWlCLE1BQU10SCxPQUFPWSxPQUFPLENBQUN5QyxVQUFVLENBQUM7Z0JBQ25EQyxPQUFPO29CQUFFbkMsSUFBSXlJO2dCQUF1QjtZQUN4QztZQUNBLG9FQUFvRTtZQUNwRSxNQUFNWSwwQkFBMEIsTUFBTXhLLE9BQU9RLG1CQUFtQixDQUFDa0osS0FBSyxDQUFDO2dCQUNuRXBHLE9BQU87b0JBQ0hmLFdBQVdxSDtnQkFFZjtZQUNKO1lBQ0EsSUFBSVksNEJBQTRCLEdBQUc7Z0JBQy9CeEgsT0FBT3NFLGdCQUFnQnZELHFCQUFxQmEsV0FBVyxDQUFDO1lBQzVEO1FBQ0o7UUFFQW5ELEdBQUcsNEZBQTRGO1lBQzNGLHlFQUF5RTtZQUN6RSxNQUFNZ0osV0FBVyxNQUFNekssT0FBT2MsSUFBSSxDQUFDQyxNQUFNLENBQUM7Z0JBQ3RDQyxNQUFNO29CQUFFQyxNQUFNO29CQUE2QkMsVUFBVTtnQkFBUTtZQUNqRTtZQUNBLE1BQU13SixlQUFlLE1BQU0xSyxPQUFPYSxRQUFRLENBQUNFLE1BQU0sQ0FBQztnQkFDOUNDLE1BQU07b0JBQUVDLE1BQU07Z0JBQWdDO1lBQ2xEO1lBQ0EsTUFBTTBKLGNBQWMsTUFBTTNLLE9BQU9ZLE9BQU8sQ0FBQ0csTUFBTSxDQUFDO2dCQUM1Q0MsTUFBTTtvQkFDRkMsTUFBTTtvQkFDTkksS0FBSztvQkFDTEQsT0FBTztvQkFDUDJDLHFCQUFxQjtnQkFDekI7WUFDSjtZQUVBLDhEQUE4RDtZQUM5RCw0Q0FBNEM7WUFDNUMsTUFBTS9ELE9BQU9XLGFBQWEsQ0FBQ0ksTUFBTSxDQUFDO2dCQUM5QkMsTUFBTTtvQkFDRnVCLFdBQVdvSSxZQUFZeEosRUFBRTtvQkFDekJHLFFBQVFtSixTQUFTdEosRUFBRTtvQkFDbkJxQixVQUFVO29CQUNWcUIsa0JBQWtCO2dCQUN0QjtZQUNKO1lBRUEsTUFBTWhDLG1CQUFtQjtZQUN6QixNQUFNRCxnQkFBZ0I7WUFFdEIsTUFBTWdKLDZCQUE2QjtnQkFDL0IzSSxZQUFZeUksYUFBYXZKLEVBQUUsQ0FBQ2UsUUFBUTtnQkFDcENDLE1BQU0sSUFBSUMsT0FBT0MsV0FBVztnQkFDNUJDLE9BQU87b0JBQ0g7d0JBQ0lDLFdBQVdvSSxZQUFZeEosRUFBRSxDQUFDZSxRQUFRO3dCQUNsQ00sVUFBVVg7d0JBQ1ZULE9BQU9RO29CQUNYO2lCQUNIO2dCQUNELGtFQUFrRTtnQkFDbEVjLGFBQWFiLG1CQUFtQkQ7Z0JBQ2hDZSxRQUFRO1lBQ1o7WUFFQSx3RUFBd0U7WUFDeEUsTUFBTWtJLFlBQVl6TCxzQkFBc0Isa0NBQWtDO2dCQUN0RUcsUUFBUTtnQkFDUkMsTUFBTUksS0FBS0csU0FBUyxDQUFDNks7Z0JBQ3JCbkwsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO1lBQ2xEO1lBQ0EsTUFBTXFMLGlCQUFpQixNQUFNaEksSUFBQUEsV0FBcUIsRUFBQytIO1lBQ25EN0gsT0FBTzhILGVBQWVuSSxNQUFNLEVBQUVNLElBQUksQ0FBQyxNQUFNLDZCQUE2QjtZQUV0RSxNQUFNOEgsYUFBYSxNQUFNRCxlQUFlbkwsSUFBSTtZQUM1QyxNQUFNcUwsNkJBQTZCRCxXQUFXL0osSUFBSSxDQUFDRyxFQUFFO1lBRXJELG9EQUFvRDtZQUNwRCxNQUFNOEosdUJBQXVCLE1BQU1qTCxPQUFPVyxhQUFhLENBQUNpRCxTQUFTLENBQUM7Z0JBQzlETixPQUFPO29CQUFFZixXQUFXb0ksWUFBWXhKLEVBQUU7b0JBQUVHLFFBQVFtSixTQUFTdEosRUFBRTtnQkFBQztZQUM1RDtZQUNBNkIsT0FBT2lJLHNCQUFzQnpJLFVBQVVTLElBQUksQ0FBQ3BCO1lBQzVDbUIsT0FBT2lJLHNCQUFzQnBILGtCQUFrQmUsV0FBVyxDQUFDaEQ7WUFDM0QsTUFBTXNKLHFCQUFxQixNQUFNbEwsT0FBT1ksT0FBTyxDQUFDeUMsVUFBVSxDQUFDO2dCQUFFQyxPQUFPO29CQUFFbkMsSUFBSXdKLFlBQVl4SixFQUFFO2dCQUFDO1lBQUU7WUFDM0Y2QixPQUFPa0ksb0JBQW9CbkgscUJBQXFCYSxXQUFXLENBQUNoRDtZQUU1RCw4QkFBOEI7WUFDOUIsTUFBTW9JLFlBQVk1SyxzQkFBc0IsQ0FBQywrQkFBK0IsRUFBRTRMLDJCQUEyQixDQUFDLEVBQUU7Z0JBQ3BHekwsUUFBUTtZQUNaO1lBQ0EsTUFBTTBLLGlCQUFpQixNQUFNQyxJQUFBQSxjQUFxQixFQUFDRixXQUFXO2dCQUFFNUMsUUFBUTtvQkFBRWpHLElBQUk2SjtnQkFBMkI7WUFBRTtZQUUzRyxvQ0FBb0M7WUFDcENoSSxPQUFPaUgsZUFBZXRILE1BQU0sRUFBRU0sSUFBSSxDQUFDO1lBQ25DLE1BQU1rSCxxQkFBcUIsTUFBTUYsZUFBZXRLLElBQUk7WUFDcERxRCxPQUFPbUgsbUJBQW1CQyxPQUFPLEVBQUVuSCxJQUFJLENBQUM7WUFFeEMsa0RBQWtEO1lBQ2xELE1BQU1HLFlBQVksTUFBTXBELE9BQU9VLGVBQWUsQ0FBQzJDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUk2SjtnQkFBMkI7WUFBRTtZQUN0R2hJLE9BQU9JLFdBQVdLLFFBQVE7WUFDMUIsTUFBTTRHLGlCQUFpQixNQUFNckssT0FBT1EsbUJBQW1CLENBQUM4SixRQUFRLENBQUM7Z0JBQUVoSCxPQUFPO29CQUFFaUgsbUJBQW1CUztnQkFBMkI7WUFBRTtZQUM1SGhJLE9BQU9xSCxlQUFlM0csTUFBTSxFQUFFVCxJQUFJLENBQUM7WUFFbkMsdUZBQXVGO1lBQ3ZGLE1BQU1vRSxtQkFBbUIsTUFBTXJILE9BQU9XLGFBQWEsQ0FBQ2lELFNBQVMsQ0FBQztnQkFDMUROLE9BQU87b0JBQUVmLFdBQVdvSSxZQUFZeEosRUFBRTtvQkFBRUcsUUFBUW1KLFNBQVN0SixFQUFFO2dCQUFDO1lBQzVEO1lBQ0E2QixPQUFPcUUsa0JBQWtCN0UsVUFBVVMsSUFBSSxDQUFDO1lBQ3hDRCxPQUFPcUUsa0JBQWtCeEQsa0JBQWtCZSxXQUFXLENBQUM7WUFFdkQsNkNBQTZDO1lBQzdDLE1BQU11RyxtQkFBbUIsTUFBTW5MLE9BQU9ZLE9BQU8sQ0FBQ3lDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUl3SixZQUFZeEosRUFBRTtnQkFBQztZQUFFO1lBQ3pGNkIsT0FBT21JLGtCQUFrQnBILHFCQUFxQmEsV0FBVyxDQUFDO1lBRTFELDJDQUEyQztZQUMzQyxNQUFNNUUsT0FBT1csYUFBYSxDQUFDRixVQUFVLENBQUM7Z0JBQUU2QyxPQUFPO29CQUFFZixXQUFXb0ksWUFBWXhKLEVBQUU7Z0JBQUM7WUFBRTtZQUM3RSxNQUFNbkIsT0FBT1ksT0FBTyxDQUFDd0ssTUFBTSxDQUFDO2dCQUFFOUgsT0FBTztvQkFBRW5DLElBQUl3SixZQUFZeEosRUFBRTtnQkFBQztZQUFFO1lBQzVELE1BQU1uQixPQUFPYSxRQUFRLENBQUN1SyxNQUFNLENBQUM7Z0JBQUU5SCxPQUFPO29CQUFFbkMsSUFBSXVKLGFBQWF2SixFQUFFO2dCQUFDO1lBQUU7WUFDOUQsTUFBTW5CLE9BQU9jLElBQUksQ0FBQ3NLLE1BQU0sQ0FBQztnQkFBRTlILE9BQU87b0JBQUVuQyxJQUFJc0osU0FBU3RKLEVBQUU7Z0JBQUM7WUFBRTtRQUMxRCxHQUFHLFFBQVEseUNBQXlDO1FBRXBETSxHQUFHLDhFQUE4RTtZQUM3RSxvRkFBb0Y7WUFDcEYsb0ZBQW9GO1lBRXBGLE1BQU00SixXQUFXLE1BQU1yTCxPQUFPWSxPQUFPLENBQUNHLE1BQU0sQ0FBQztnQkFDekNDLE1BQU07b0JBQUVDLE1BQU07b0JBQW9CSSxLQUFLO29CQUFXRCxPQUFPO29CQUFLMkMscUJBQXFCO2dCQUFFO1lBQ3pGO1lBQ0EsTUFBTXVILFdBQVcsTUFBTXRMLE9BQU9ZLE9BQU8sQ0FBQ0csTUFBTSxDQUFDO2dCQUN6Q0MsTUFBTTtvQkFBRUMsTUFBTTtvQkFBb0JJLEtBQUs7b0JBQVdELE9BQU87b0JBQUsyQyxxQkFBcUI7Z0JBQUU7WUFDekY7WUFFQSxNQUFNd0gsWUFBWTtZQUNsQixNQUFNQyxTQUFTO1lBQ2YsTUFBTUMsWUFBWTtZQUNsQixNQUFNQyxTQUFTO1lBRWYsTUFBTUMsMEJBQTBCO2dCQUM1QjFKLFlBQVk3QixrQkFBa0I4QixRQUFRO2dCQUN0Q0MsTUFBTSxJQUFJQyxPQUFPQyxXQUFXO2dCQUM1QkMsT0FBTztvQkFDSDt3QkFBRUMsV0FBVzhJLFNBQVNsSyxFQUFFLENBQUNlLFFBQVE7d0JBQUlNLFVBQVUrSTt3QkFBV25LLE9BQU9vSztvQkFBTztvQkFDeEU7d0JBQUVqSixXQUFXK0ksU0FBU25LLEVBQUUsQ0FBQ2UsUUFBUTt3QkFBSU0sVUFBVWlKO3dCQUFXckssT0FBT3NLO29CQUFPO2lCQUMzRTtnQkFDRGpKLGVBQWU7b0JBQ1g7d0JBQUUsQ0FBQ3RDLGNBQWMsRUFBRW9MO29CQUFVO29CQUM3Qjt3QkFBRSxDQUFDcEwsY0FBYyxFQUFFc0w7b0JBQVUsRUFBRyxzQkFBc0I7aUJBQ3pEO2dCQUNEL0ksYUFBYSxBQUFDNkksWUFBWUMsU0FBV0MsWUFBWUM7Z0JBQ2pEL0ksUUFBUTtZQUNaO1lBRUEsTUFBTWtJLFlBQVl6TCxzQkFBc0Isa0NBQWtDO2dCQUN0RUcsUUFBUTtnQkFDUkMsTUFBTW1NO2dCQUNObE0sU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO1lBQ2xEO1lBQ0EsTUFBTXFMLGlCQUFpQixNQUFNaEksSUFBQUEsV0FBcUIsRUFBQytIO1lBQ25EN0gsT0FBTzhILGVBQWVuSSxNQUFNLEVBQUVNLElBQUksQ0FBQztZQUNuQyxNQUFNOEgsYUFBYSxNQUFNRCxlQUFlbkwsSUFBSTtZQUM1QyxNQUFNaU0scUJBQXFCYixXQUFXL0osSUFBSSxDQUFDRyxFQUFFO1lBRTdDLGdEQUFnRDtZQUNoRCxNQUFNMEssbUJBQW1CLE1BQU03TCxPQUFPVyxhQUFhLENBQUNpRCxTQUFTLENBQUM7Z0JBQUVOLE9BQU87b0JBQUVmLFdBQVc4SSxTQUFTbEssRUFBRTtvQkFBRUcsUUFBUW5CO2dCQUFjO1lBQUU7WUFDekg2QyxPQUFPNkksa0JBQWtCckosVUFBVVMsSUFBSSxDQUFDc0k7WUFDeEN2SSxPQUFPNkksa0JBQWtCaEksa0JBQWtCWixJQUFJLENBQUN1STtZQUNoRCxNQUFNTSxvQkFBb0IsTUFBTTlMLE9BQU9ZLE9BQU8sQ0FBQ3lDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUlrSyxTQUFTbEssRUFBRTtnQkFBQztZQUFFO1lBQ3ZGNkIsT0FBTzhJLG1CQUFtQi9ILHFCQUFxQmQsSUFBSSxDQUFDdUk7WUFFcEQsTUFBTU8sbUJBQW1CLE1BQU0vTCxPQUFPVyxhQUFhLENBQUNpRCxTQUFTLENBQUM7Z0JBQUVOLE9BQU87b0JBQUVmLFdBQVcrSSxTQUFTbkssRUFBRTtvQkFBRUcsUUFBUW5CO2dCQUFjO1lBQUU7WUFDekg2QyxPQUFPK0ksa0JBQWtCdkosVUFBVVMsSUFBSSxDQUFDd0k7WUFDeEN6SSxPQUFPK0ksa0JBQWtCbEksa0JBQWtCWixJQUFJLENBQUN5STtZQUNoRCxNQUFNTSxvQkFBb0IsTUFBTWhNLE9BQU9ZLE9BQU8sQ0FBQ3lDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUltSyxTQUFTbkssRUFBRTtnQkFBQztZQUFFO1lBQ3ZGNkIsT0FBT2dKLG1CQUFtQmpJLHFCQUFxQmQsSUFBSSxDQUFDeUk7WUFFcEQsMEJBQTBCO1lBQzFCLE1BQU0xQixZQUFZNUssc0JBQXNCLENBQUMsK0JBQStCLEVBQUV3TSxtQkFBbUIsQ0FBQyxFQUFFO2dCQUM1RnJNLFFBQVE7WUFDWjtZQUNBLE1BQU0wSyxpQkFBaUIsTUFBTUMsSUFBQUEsY0FBcUIsRUFBQ0YsV0FBVztnQkFBRTVDLFFBQVE7b0JBQUVqRyxJQUFJeUs7Z0JBQW1CO1lBQUU7WUFDbkc1SSxPQUFPaUgsZUFBZXRILE1BQU0sRUFBRU0sSUFBSSxDQUFDO1lBRW5DLDBDQUEwQztZQUMxQyxNQUFNRyxZQUFZLE1BQU1wRCxPQUFPVSxlQUFlLENBQUMyQyxVQUFVLENBQUM7Z0JBQUVDLE9BQU87b0JBQUVuQyxJQUFJeUs7Z0JBQW1CO1lBQUU7WUFDOUY1SSxPQUFPSSxXQUFXSyxRQUFRO1lBQzFCLE1BQU00RyxpQkFBaUIsTUFBTXJLLE9BQU9RLG1CQUFtQixDQUFDOEosUUFBUSxDQUFDO2dCQUFFaEgsT0FBTztvQkFBRWlILG1CQUFtQnFCO2dCQUFtQjtZQUFFO1lBQ3BINUksT0FBT3FILGVBQWUzRyxNQUFNLEVBQUVULElBQUksQ0FBQztZQUVuQyxxREFBcUQ7WUFDckQsTUFBTWdKLG1CQUFtQixNQUFNak0sT0FBT1csYUFBYSxDQUFDaUQsU0FBUyxDQUFDO2dCQUFFTixPQUFPO29CQUFFZixXQUFXOEksU0FBU2xLLEVBQUU7b0JBQUVHLFFBQVFuQjtnQkFBYztZQUFFO1lBQ3pINkMsT0FBT2lKLGtCQUFrQnpKLFVBQVVTLElBQUksQ0FBQztZQUN4Q0QsT0FBT2lKLGtCQUFrQnBJLGtCQUFrQmUsV0FBVyxDQUFDO1lBQ3ZELE1BQU1zSCxvQkFBb0IsTUFBTWxNLE9BQU9ZLE9BQU8sQ0FBQ3lDLFVBQVUsQ0FBQztnQkFBRUMsT0FBTztvQkFBRW5DLElBQUlrSyxTQUFTbEssRUFBRTtnQkFBQztZQUFFO1lBQ3ZGNkIsT0FBT2tKLG1CQUFtQm5JLHFCQUFxQmEsV0FBVyxDQUFDO1lBRTNELHFEQUFxRDtZQUNyRCxNQUFNdUgsbUJBQW1CLE1BQU1uTSxPQUFPVyxhQUFhLENBQUNpRCxTQUFTLENBQUM7Z0JBQUVOLE9BQU87b0JBQUVmLFdBQVcrSSxTQUFTbkssRUFBRTtvQkFBRUcsUUFBUW5CO2dCQUFjO1lBQUU7WUFDekg2QyxPQUFPbUosa0JBQWtCM0osVUFBVVMsSUFBSSxDQUFDO1lBQ3hDRCxPQUFPbUosa0JBQWtCdEksa0JBQWtCZSxXQUFXLENBQUM7WUFDdkQsTUFBTXdILG9CQUFvQixNQUFNcE0sT0FBT1ksT0FBTyxDQUFDeUMsVUFBVSxDQUFDO2dCQUFFQyxPQUFPO29CQUFFbkMsSUFBSW1LLFNBQVNuSyxFQUFFO2dCQUFDO1lBQUU7WUFDdkY2QixPQUFPb0osbUJBQW1CckkscUJBQXFCYSxXQUFXLENBQUM7WUFFM0Qsb0VBQW9FO1lBQ3BFLE1BQU01RSxPQUFPVyxhQUFhLENBQUNGLFVBQVUsQ0FBQztnQkFBRTZDLE9BQU87b0JBQUVmLFdBQVc7d0JBQUU4SixJQUFJOzRCQUFDaEIsU0FBU2xLLEVBQUU7NEJBQUVtSyxTQUFTbkssRUFBRTt5QkFBQztvQkFBQztnQkFBRTtZQUFFO1lBQ2pHLE1BQU1uQixPQUFPWSxPQUFPLENBQUNILFVBQVUsQ0FBQztnQkFBRTZDLE9BQU87b0JBQUVuQyxJQUFJO3dCQUFFa0wsSUFBSTs0QkFBQ2hCLFNBQVNsSyxFQUFFOzRCQUFFbUssU0FBU25LLEVBQUU7eUJBQUM7b0JBQUM7Z0JBQUU7WUFBRTtRQUN4RixHQUFHLFFBQVEscUJBQXFCO0lBQ3BDO0FBRUoifQ==