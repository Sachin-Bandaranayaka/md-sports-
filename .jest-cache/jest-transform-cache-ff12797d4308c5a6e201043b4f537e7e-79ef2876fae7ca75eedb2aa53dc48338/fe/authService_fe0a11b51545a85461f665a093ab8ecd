717401b344783d5af29ab3265afb7e2e
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    authenticateUser: function() {
        return authenticateUser;
    },
    generateToken: function() {
        return generateToken;
    },
    getUserFromDecodedPayload: function() {
        return getUserFromDecodedPayload;
    },
    getUserFromToken: function() {
        return getUserFromToken;
    },
    hasPermission: function() {
        return hasPermission;
    },
    parseTimeStringToSeconds: function() {
        return parseTimeStringToSeconds;
    },
    verifyToken: function() {
        return verifyToken;
    }
});
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
const _prisma = /*#__PURE__*/ _interop_require_default(require("../lib/prisma"));
const _cache = require("../lib/cache");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Secret key for JWT - should be moved to environment variables in production
const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
// Changed token expiration to 12h (from 24h) for better security
const JWT_EXPIRES_IN = process.env.JWT_ACCESS_TOKEN_EXPIRES_IN || "12h";
const parseTimeStringToSeconds = (timeStr)=>{
    if (!timeStr) return 0;
    const lastChar = timeStr.slice(-1);
    const num = parseInt(timeStr.slice(0, -1));
    if (isNaN(num)) return 0;
    switch(lastChar){
        case "s":
            return num;
        case "m":
            return num * 60;
        case "h":
            return num * 60 * 60;
        case "d":
            return num * 60 * 60 * 24;
        default:
            if (!isNaN(parseInt(timeStr))) return parseInt(timeStr);
            return 0;
    }
};
const authenticateUser = async (email, password)=>{
    try {
        console.time("user authentication query");
        // Optimized single query using the new composite index
        const user = await _prisma.default.user.findFirst({
            where: {
                email: email,
                isActive: true
            },
            include: {
                role: {
                    include: {
                        permissions: {
                            select: {
                                name: true
                            }
                        }
                    }
                }
            }
        });
        console.timeEnd("user authentication query");
        // If user not found
        if (!user) {
            return {
                success: false,
                message: "Invalid email or password"
            };
        }
        // Verify password
        const isPasswordValid = await _bcryptjs.default.compare(password, user.password);
        if (!isPasswordValid) {
            return {
                success: false,
                message: "Invalid email or password"
            };
        }
        // Get permissions from role (handle case where user has no role)
        let permissions = [];
        if (user.role?.permissions) {
            permissions = user.role.permissions.map((p)=>p.name);
        } else if (user.permissions && Array.isArray(user.permissions)) {
            // Handle special case for "ALL" permissions
            if (user.permissions.includes("ALL")) {
                permissions = [
                    "ALL"
                ];
            } else {
                // Convert permission IDs to names, filtering out invalid values
                const validPermissionIds = user.permissions.map((id)=>parseInt(id.toString())).filter((id)=>!isNaN(id));
                if (validPermissionIds.length > 0) {
                    const permissionRecords = await _prisma.default.permission.findMany({
                        where: {
                            id: {
                                in: validPermissionIds
                            }
                        },
                        select: {
                            name: true
                        }
                    });
                    permissions = permissionRecords.map((p)=>p.name);
                }
            }
        }
        // Generate JWT token
        const token = generateToken({
            sub: user.id,
            username: user.name,
            email: user.email,
            roleId: user.roleId,
            shopId: user.shopId,
            permissions
        });
        const userSession = {
            id: user.id,
            username: user.name,
            fullName: user.name,
            email: user.email,
            roleId: user.roleId,
            roleName: user.role?.name || user.roleName || null,
            shopId: user.shopId,
            permissions,
            role: user.role
        };
        // Cache user session for faster subsequent requests
        const cacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_SESSION, {
            userId: user.id
        });
        await _cache.cacheService.set(cacheKey, userSession, _cache.CACHE_CONFIG.TTL.USER_SESSION);
        return {
            success: true,
            token,
            user: {
                id: user.id,
                username: user.name,
                fullName: user.name,
                email: user.email,
                roleId: user.roleId,
                roleName: user.role?.name || user.roleName || null,
                shopId: user.shopId,
                permissions
            }
        };
    } catch (error) {
        console.error("Authentication error:", error);
        return {
            success: false,
            message: "Authentication failed"
        };
    }
};
const generateToken = (payload)=>{
    return _jsonwebtoken.default.sign(payload, JWT_SECRET, {
        expiresIn: JWT_EXPIRES_IN
    });
};
const verifyToken = async (token)=>{
    // Validate token input
    if (!token || token.trim() === "") {
        throw new Error("jwt must be provided");
    }
    const tokenKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.TOKEN_VALIDATION, {
        token: token.substring(0, 20)
    });
    try {
        // Check cache first for token validation result
        const cachedResult = await _cache.cacheService.get(tokenKey);
        if (cachedResult) {
            return cachedResult;
        }
        // Verify token
        const payload = _jsonwebtoken.default.verify(token, JWT_SECRET);
        // Cache the valid token payload (shorter TTL for security)
        await _cache.cacheService.set(tokenKey, payload, _cache.CACHE_CONFIG.TTL.TOKEN_VALIDATION);
        return payload;
    } catch (error) {
        // Log the error here if desired
        if (error instanceof _jsonwebtoken.default.TokenExpiredError) {
            console.error("Token expired during verification:", error.expiredAt);
        } else if (error instanceof _jsonwebtoken.default.JsonWebTokenError) {
            console.error("Invalid token during verification:", error.message);
        } else {
            console.error("Unknown token verification error:", error);
        }
        throw error; // Re-throw the error
    }
};
const hasPermission = async (tokenPayload, permission)=>{
    // Import the proper permission checking utility
    const { hasPermission: checkPermission } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../lib/utils/permissions")));
    // Quick check from token payload first
    if (tokenPayload.permissions) {
        if (checkPermission(tokenPayload.permissions, permission)) {
            return true;
        }
    }
    // If not in token, check cached user permissions
    const permissionsCacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_PERMISSIONS, {
        userId: tokenPayload.sub
    });
    try {
        const cachedPermissions = await _cache.cacheService.get(permissionsCacheKey);
        if (cachedPermissions) {
            return checkPermission(cachedPermissions, permission);
        }
        // Fallback to database query if not cached
        const user = await _prisma.default.user.findFirst({
            where: {
                id: tokenPayload.sub,
                isActive: true
            },
            include: {
                role: {
                    include: {
                        permissions: {
                            select: {
                                name: true
                            }
                        }
                    }
                }
            }
        });
        if (user) {
            const permissions = user.role.permissions.map((p)=>p.name);
            // Cache permissions for future checks
            await _cache.cacheService.set(permissionsCacheKey, permissions, _cache.CACHE_CONFIG.TTL.USER_PERMISSIONS);
            return checkPermission(permissions, permission);
        }
    } catch (error) {
        console.error("Error checking permissions:", error);
    }
    return false;
};
const getUserFromDecodedPayload = async (payload)=>{
    console.log("getUserFromDecodedPayload received payload:", payload);
    if (!payload) {
        console.error("Invalid token payload provided to getUserFromDecodedPayload");
        return null;
    }
    if (!payload.sub) {
        console.error("Token payload missing user ID (sub claim)");
        return null;
    }
    const userId = payload.sub;
    const cacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_SESSION, {
        userId
    });
    try {
        // Try to get user from cache first
        const cachedUser = await _cache.cacheService.get(cacheKey);
        if (cachedUser) {
            console.log("User found in cache:", userId);
            return cachedUser;
        }
        console.log("Looking up user with ID:", userId);
        console.time("prisma.user.findFirst for auth"); // Start timer
        const user = await _prisma.default.user.findFirst({
            where: {
                id: userId,
                isActive: true
            },
            include: {
                role: {
                    include: {
                        permissions: {
                            select: {
                                name: true
                            }
                        }
                    }
                }
            }
        });
        console.timeEnd("prisma.user.findFirst for auth"); // End timer
        if (!user) {
            console.error("User not found for ID:", userId);
            return null;
        }
        const userWithPermissions = {
            ...user,
            roleName: user.role.name,
            permissions: user.role.permissions.map((p)=>p.name)
        };
        // Cache the user session
        await _cache.cacheService.set(cacheKey, userWithPermissions, _cache.CACHE_CONFIG.TTL.USER_SESSION);
        console.log("User found and cached:", user.id, user.name);
        return userWithPermissions;
    } catch (error) {
        console.error("Error getting user from decoded payload:", error);
        return null;
    }
};
const getUserFromToken = async (token)=>{
    const payload = await verifyToken(token);
    return getUserFromDecodedPayload(payload);
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vc3JjL3NlcnZpY2VzL2F1dGhTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJztcbmltcG9ydCBiY3J5cHQgZnJvbSAnYmNyeXB0anMnO1xuaW1wb3J0IHByaXNtYSBmcm9tICdAL2xpYi9wcmlzbWEnO1xuaW1wb3J0IHsgY2FjaGVTZXJ2aWNlLCBDQUNIRV9DT05GSUcgfSBmcm9tICdAL2xpYi9jYWNoZSc7XG5cbi8vIFNlY3JldCBrZXkgZm9yIEpXVCAtIHNob3VsZCBiZSBtb3ZlZCB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW4gcHJvZHVjdGlvblxuY29uc3QgSldUX1NFQ1JFVCA9IHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgfHwgJ3lvdXItc2VjcmV0LWtleSc7XG4vLyBDaGFuZ2VkIHRva2VuIGV4cGlyYXRpb24gdG8gMTJoIChmcm9tIDI0aCkgZm9yIGJldHRlciBzZWN1cml0eVxuY29uc3QgSldUX0VYUElSRVNfSU4gPSBwcm9jZXNzLmVudi5KV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4gfHwgJzEyaCc7XG5cbi8qKlxuICogUGFyc2VzIGEgdGltZSBzdHJpbmcgbGlrZSBcIjE1bVwiLCBcIjJoXCIsIFwiMWRcIiBpbnRvIHNlY29uZHMuXG4gKiBAcGFyYW0gdGltZVN0ciBUaGUgdGltZSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHNlY29uZHMsIG9yIDAgaWYgcGFyc2luZyBmYWlscy5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcyA9ICh0aW1lU3RyOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGlmICghdGltZVN0cikgcmV0dXJuIDA7XG4gICAgY29uc3QgbGFzdENoYXIgPSB0aW1lU3RyLnNsaWNlKC0xKTtcbiAgICBjb25zdCBudW0gPSBwYXJzZUludCh0aW1lU3RyLnNsaWNlKDAsIC0xKSk7XG5cbiAgICBpZiAoaXNOYU4obnVtKSkgcmV0dXJuIDA7XG5cbiAgICBzd2l0Y2ggKGxhc3RDaGFyKSB7XG4gICAgICAgIGNhc2UgJ3MnOiByZXR1cm4gbnVtO1xuICAgICAgICBjYXNlICdtJzogcmV0dXJuIG51bSAqIDYwO1xuICAgICAgICBjYXNlICdoJzogcmV0dXJuIG51bSAqIDYwICogNjA7XG4gICAgICAgIGNhc2UgJ2QnOiByZXR1cm4gbnVtICogNjAgKiA2MCAqIDI0O1xuICAgICAgICBkZWZhdWx0OiAvLyBJZiBubyB1bml0LCBhc3N1bWUgc2Vjb25kcyBpZiBpdCdzIGp1c3QgYSBudW1iZXIgc3RyaW5nXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHRpbWVTdHIpKSkgcmV0dXJuIHBhcnNlSW50KHRpbWVTdHIpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuaW50ZXJmYWNlIFRva2VuUGF5bG9hZCB7XG4gICAgc3ViOiBudW1iZXI7IC8vIFVzZXIgSUQgYXMgJ3N1YicgY2xhaW1cbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgcm9sZUlkOiBudW1iZXI7XG4gICAgc2hvcElkPzogbnVtYmVyIHwgbnVsbDtcbiAgICBwZXJtaXNzaW9ucz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZSBhIHVzZXIgd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgKG9wdGltaXplZCB3aXRoIHNpbmdsZSBxdWVyeSlcbiAqL1xuZXhwb3J0IGNvbnN0IGF1dGhlbnRpY2F0ZVVzZXIgPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUudGltZSgndXNlciBhdXRoZW50aWNhdGlvbiBxdWVyeScpO1xuICAgICAgICAvLyBPcHRpbWl6ZWQgc2luZ2xlIHF1ZXJ5IHVzaW5nIHRoZSBuZXcgY29tcG9zaXRlIGluZGV4XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgcm9sZToge1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDogeyBuYW1lOiB0cnVlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgndXNlciBhdXRoZW50aWNhdGlvbiBxdWVyeScpO1xuXG4gICAgICAgIC8vIElmIHVzZXIgbm90IGZvdW5kXG4gICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgcGFzc3dvcmRcbiAgICAgICAgY29uc3QgaXNQYXNzd29yZFZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUocGFzc3dvcmQsIHVzZXIucGFzc3dvcmQpO1xuICAgICAgICBpZiAoIWlzUGFzc3dvcmRWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgcGVybWlzc2lvbnMgZnJvbSByb2xlIChoYW5kbGUgY2FzZSB3aGVyZSB1c2VyIGhhcyBubyByb2xlKVxuICAgICAgICBsZXQgcGVybWlzc2lvbnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmICh1c2VyLnJvbGU/LnBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgICBwZXJtaXNzaW9ucyA9IHVzZXIucm9sZS5wZXJtaXNzaW9ucy5tYXAocCA9PiBwLm5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHVzZXIucGVybWlzc2lvbnMgJiYgQXJyYXkuaXNBcnJheSh1c2VyLnBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBmb3IgXCJBTExcIiBwZXJtaXNzaW9uc1xuICAgICAgICAgICAgaWYgKHVzZXIucGVybWlzc2lvbnMuaW5jbHVkZXMoJ0FMTCcpKSB7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnMgPSBbJ0FMTCddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHBlcm1pc3Npb24gSURzIHRvIG5hbWVzLCBmaWx0ZXJpbmcgb3V0IGludmFsaWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRQZXJtaXNzaW9uSWRzID0gdXNlci5wZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAubWFwKGlkID0+IHBhcnNlSW50KGlkLnRvU3RyaW5nKCkpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGlkID0+ICFpc05hTihpZCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh2YWxpZFBlcm1pc3Npb25JZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uUmVjb3JkcyA9IGF3YWl0IHByaXNtYS5wZXJtaXNzaW9uLmZpbmRNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW46IHZhbGlkUGVybWlzc2lvbklkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25SZWNvcmRzLm1hcChwID0+IHAubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgSldUIHRva2VuXG4gICAgICAgIGNvbnN0IHRva2VuID0gZ2VuZXJhdGVUb2tlbih7XG4gICAgICAgICAgICBzdWI6IHVzZXIuaWQsXG4gICAgICAgICAgICB1c2VybmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgICAgICByb2xlSWQ6IHVzZXIucm9sZUlkLFxuICAgICAgICAgICAgc2hvcElkOiB1c2VyLnNob3BJZCxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVzZXJTZXNzaW9uID0ge1xuICAgICAgICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICB1c2VybmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgZnVsbE5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgICAgcm9sZUlkOiB1c2VyLnJvbGVJZCxcbiAgICAgICAgICAgIHJvbGVOYW1lOiB1c2VyLnJvbGU/Lm5hbWUgfHwgdXNlci5yb2xlTmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgc2hvcElkOiB1c2VyLnNob3BJZCxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgICAgICAgcm9sZTogdXNlci5yb2xlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FjaGUgdXNlciBzZXNzaW9uIGZvciBmYXN0ZXIgc3Vic2VxdWVudCByZXF1ZXN0c1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGNhY2hlU2VydmljZS5nZW5lcmF0ZUtleShDQUNIRV9DT05GSUcuS0VZUy5VU0VSX1NFU1NJT04sIHsgdXNlcklkOiB1c2VyLmlkIH0pO1xuICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KGNhY2hlS2V5LCB1c2VyU2Vzc2lvbiwgQ0FDSEVfQ09ORklHLlRUTC5VU0VSX1NFU1NJT04pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgICAgICAgICBmdWxsTmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgICAgICAgIHJvbGVJZDogdXNlci5yb2xlSWQsXG4gICAgICAgICAgICAgICAgcm9sZU5hbWU6IHVzZXIucm9sZT8ubmFtZSB8fCB1c2VyLnJvbGVOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc2hvcElkOiB1c2VyLnNob3BJZCxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCdcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgSldUIHRva2VuXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVRva2VuID0gKHBheWxvYWQ6IFRva2VuUGF5bG9hZCkgPT4ge1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBKV1RfU0VDUkVULCB7IGV4cGlyZXNJbjogSldUX0VYUElSRVNfSU4gfSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhIEpXVCB0b2tlbiB3aXRoIGNhY2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHZlcmlmeVRva2VuID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAvLyBWYWxpZGF0ZSB0b2tlbiBpbnB1dFxuICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHJpbSgpID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2p3dCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRva2VuS2V5ID0gY2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5KENBQ0hFX0NPTkZJRy5LRVlTLlRPS0VOX1ZBTElEQVRJT04sIHsgdG9rZW46IHRva2VuLnN1YnN0cmluZygwLCAyMCkgfSk7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdCBmb3IgdG9rZW4gdmFsaWRhdGlvbiByZXN1bHRcbiAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0ID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldCh0b2tlbktleSk7XG4gICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQgYXMgVG9rZW5QYXlsb2FkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRva2VuXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBqd3QudmVyaWZ5KHRva2VuLCBKV1RfU0VDUkVUKSBhcyBUb2tlblBheWxvYWQ7XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIHZhbGlkIHRva2VuIHBheWxvYWQgKHNob3J0ZXIgVFRMIGZvciBzZWN1cml0eSlcbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldCh0b2tlbktleSwgcGF5bG9hZCwgQ0FDSEVfQ09ORklHLlRUTC5UT0tFTl9WQUxJREFUSU9OKTtcblxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBMb2cgdGhlIGVycm9yIGhlcmUgaWYgZGVzaXJlZFxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBqd3QuVG9rZW5FeHBpcmVkRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIGV4cGlyZWQgZHVyaW5nIHZlcmlmaWNhdGlvbjonLCBlcnJvci5leHBpcmVkQXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2Ygand0Lkpzb25XZWJUb2tlbkVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHRva2VuIGR1cmluZyB2ZXJpZmljYXRpb246JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIHRva2VuIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRoZSBlcnJvclxuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0b2tlbiBoYXMgYSBzcGVjaWZpYyBwZXJtaXNzaW9uIHdpdGggY2FjaGluZ1xuICovXG5leHBvcnQgY29uc3QgaGFzUGVybWlzc2lvbiA9IGFzeW5jICh0b2tlblBheWxvYWQ6IFRva2VuUGF5bG9hZCwgcGVybWlzc2lvbjogc3RyaW5nKSA9PiB7XG4gICAgLy8gSW1wb3J0IHRoZSBwcm9wZXIgcGVybWlzc2lvbiBjaGVja2luZyB1dGlsaXR5XG4gICAgY29uc3QgeyBoYXNQZXJtaXNzaW9uOiBjaGVja1Blcm1pc3Npb24gfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvdXRpbHMvcGVybWlzc2lvbnMnKTtcbiAgICBcbiAgICAvLyBRdWljayBjaGVjayBmcm9tIHRva2VuIHBheWxvYWQgZmlyc3RcbiAgICBpZiAodG9rZW5QYXlsb2FkLnBlcm1pc3Npb25zKSB7XG4gICAgICAgIGlmIChjaGVja1Blcm1pc3Npb24odG9rZW5QYXlsb2FkLnBlcm1pc3Npb25zLCBwZXJtaXNzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgaW4gdG9rZW4sIGNoZWNrIGNhY2hlZCB1c2VyIHBlcm1pc3Npb25zXG4gICAgY29uc3QgcGVybWlzc2lvbnNDYWNoZUtleSA9IGNhY2hlU2VydmljZS5nZW5lcmF0ZUtleShDQUNIRV9DT05GSUcuS0VZUy5VU0VSX1BFUk1JU1NJT05TLCB7IHVzZXJJZDogdG9rZW5QYXlsb2FkLnN1YiB9KTtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZFBlcm1pc3Npb25zID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldChwZXJtaXNzaW9uc0NhY2hlS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJtaXNzaW9uKGNhY2hlZFBlcm1pc3Npb25zLCBwZXJtaXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGRhdGFiYXNlIHF1ZXJ5IGlmIG5vdCBjYWNoZWRcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHByaXNtYS51c2VyLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICB3aGVyZTogeyBpZDogdG9rZW5QYXlsb2FkLnN1YiwgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICByb2xlOiB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiB7IHNlbGVjdDogeyBuYW1lOiB0cnVlIH0gfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSB1c2VyLnJvbGUucGVybWlzc2lvbnMubWFwKHAgPT4gcC5uYW1lKTtcbiAgICAgICAgICAgIC8vIENhY2hlIHBlcm1pc3Npb25zIGZvciBmdXR1cmUgY2hlY2tzXG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KHBlcm1pc3Npb25zQ2FjaGVLZXksIHBlcm1pc3Npb25zLCBDQUNIRV9DT05GSUcuVFRMLlVTRVJfUEVSTUlTU0lPTlMpO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVybWlzc2lvbihwZXJtaXNzaW9ucywgcGVybWlzc2lvbik7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBwZXJtaXNzaW9uczonLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdXNlciBkZXRhaWxzIGZyb20gYSBkZWNvZGVkIHRva2VuIHBheWxvYWQgd2l0aCBjYWNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkID0gYXN5bmMgKHBheWxvYWQ6IFRva2VuUGF5bG9hZCB8IG51bGwpID0+IHtcbiAgICBjb25zb2xlLmxvZygnZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCByZWNlaXZlZCBwYXlsb2FkOicsIHBheWxvYWQpO1xuXG4gICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdG9rZW4gcGF5bG9hZCBwcm92aWRlZCB0byBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gcGF5bG9hZCBtaXNzaW5nIHVzZXIgSUQgKHN1YiBjbGFpbSknKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlcklkID0gcGF5bG9hZC5zdWI7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBjYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkoQ0FDSEVfQ09ORklHLktFWVMuVVNFUl9TRVNTSU9OLCB7IHVzZXJJZCB9KTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgdXNlciBmcm9tIGNhY2hlIGZpcnN0XG4gICAgICAgIGNvbnN0IGNhY2hlZFVzZXIgPSBhd2FpdCBjYWNoZVNlcnZpY2UuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGZvdW5kIGluIGNhY2hlOicsIHVzZXJJZCk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkVXNlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb29raW5nIHVwIHVzZXIgd2l0aCBJRDonLCB1c2VySWQpO1xuICAgICAgICBjb25zb2xlLnRpbWUoJ3ByaXNtYS51c2VyLmZpbmRGaXJzdCBmb3IgYXV0aCcpOyAvLyBTdGFydCB0aW1lclxuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJpc21hLnVzZXIuZmluZEZpcnN0KHtcbiAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICByb2xlOiB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB7IG5hbWU6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS50aW1lRW5kKCdwcmlzbWEudXNlci5maW5kRmlyc3QgZm9yIGF1dGgnKTsgLy8gRW5kIHRpbWVyXG5cbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVc2VyIG5vdCBmb3VuZCBmb3IgSUQ6JywgdXNlcklkKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXNlcldpdGhQZXJtaXNzaW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnVzZXIsXG4gICAgICAgICAgICByb2xlTmFtZTogdXNlci5yb2xlLm5hbWUsXG4gICAgICAgICAgICBwZXJtaXNzaW9uczogdXNlci5yb2xlLnBlcm1pc3Npb25zLm1hcChwID0+IHAubmFtZSlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUgdXNlciBzZXNzaW9uXG4gICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5zZXQoY2FjaGVLZXksIHVzZXJXaXRoUGVybWlzc2lvbnMsIENBQ0hFX0NPTkZJRy5UVEwuVVNFUl9TRVNTSU9OKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnVXNlciBmb3VuZCBhbmQgY2FjaGVkOicsIHVzZXIuaWQsIHVzZXIubmFtZSk7XG4gICAgICAgIHJldHVybiB1c2VyV2l0aFBlcm1pc3Npb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciBmcm9tIGRlY29kZWQgcGF5bG9hZDonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHVzZXIgZGV0YWlscyBmcm9tIHRva2VuIChMZWdhY3kgLSBjb25zaWRlciBwaGFzaW5nIG91dCBvciByZWZhY3RvcmluZylcbiAqIFRoaXMgZnVuY3Rpb24gbm93IGNhbGxzIHZlcmlmeVRva2VuIGFuZCB0aGVuIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVc2VyRnJvbVRva2VuID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdmVyaWZ5VG9rZW4odG9rZW4pO1xuICAgIHJldHVybiBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHBheWxvYWQpO1xufTsiXSwibmFtZXMiOlsiYXV0aGVudGljYXRlVXNlciIsImdlbmVyYXRlVG9rZW4iLCJnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkIiwiZ2V0VXNlckZyb21Ub2tlbiIsImhhc1Blcm1pc3Npb24iLCJwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMiLCJ2ZXJpZnlUb2tlbiIsIkpXVF9TRUNSRVQiLCJwcm9jZXNzIiwiZW52IiwiSldUX0VYUElSRVNfSU4iLCJKV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4iLCJ0aW1lU3RyIiwibGFzdENoYXIiLCJzbGljZSIsIm51bSIsInBhcnNlSW50IiwiaXNOYU4iLCJlbWFpbCIsInBhc3N3b3JkIiwiY29uc29sZSIsInRpbWUiLCJ1c2VyIiwicHJpc21hIiwiZmluZEZpcnN0Iiwid2hlcmUiLCJpc0FjdGl2ZSIsImluY2x1ZGUiLCJyb2xlIiwicGVybWlzc2lvbnMiLCJzZWxlY3QiLCJuYW1lIiwidGltZUVuZCIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwiaXNQYXNzd29yZFZhbGlkIiwiYmNyeXB0IiwiY29tcGFyZSIsIm1hcCIsInAiLCJBcnJheSIsImlzQXJyYXkiLCJpbmNsdWRlcyIsInZhbGlkUGVybWlzc2lvbklkcyIsImlkIiwidG9TdHJpbmciLCJmaWx0ZXIiLCJsZW5ndGgiLCJwZXJtaXNzaW9uUmVjb3JkcyIsInBlcm1pc3Npb24iLCJmaW5kTWFueSIsImluIiwidG9rZW4iLCJzdWIiLCJ1c2VybmFtZSIsInJvbGVJZCIsInNob3BJZCIsInVzZXJTZXNzaW9uIiwiZnVsbE5hbWUiLCJyb2xlTmFtZSIsImNhY2hlS2V5IiwiY2FjaGVTZXJ2aWNlIiwiZ2VuZXJhdGVLZXkiLCJDQUNIRV9DT05GSUciLCJLRVlTIiwiVVNFUl9TRVNTSU9OIiwidXNlcklkIiwic2V0IiwiVFRMIiwiZXJyb3IiLCJwYXlsb2FkIiwiand0Iiwic2lnbiIsImV4cGlyZXNJbiIsInRyaW0iLCJFcnJvciIsInRva2VuS2V5IiwiVE9LRU5fVkFMSURBVElPTiIsInN1YnN0cmluZyIsImNhY2hlZFJlc3VsdCIsImdldCIsInZlcmlmeSIsIlRva2VuRXhwaXJlZEVycm9yIiwiZXhwaXJlZEF0IiwiSnNvbldlYlRva2VuRXJyb3IiLCJ0b2tlblBheWxvYWQiLCJjaGVja1Blcm1pc3Npb24iLCJwZXJtaXNzaW9uc0NhY2hlS2V5IiwiVVNFUl9QRVJNSVNTSU9OUyIsImNhY2hlZFBlcm1pc3Npb25zIiwibG9nIiwiY2FjaGVkVXNlciIsInVzZXJXaXRoUGVybWlzc2lvbnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBNkNhQSxnQkFBZ0I7ZUFBaEJBOztJQXNIQUMsYUFBYTtlQUFiQTs7SUE2RkFDLHlCQUF5QjtlQUF6QkE7O0lBcUVBQyxnQkFBZ0I7ZUFBaEJBOztJQXJIQUMsYUFBYTtlQUFiQTs7SUFqTUFDLHdCQUF3QjtlQUF4QkE7O0lBMkpBQyxXQUFXO2VBQVhBOzs7cUVBMUtHO2lFQUNHOytEQUNBO3VCQUN3Qjs7Ozs7Ozs7Ozs7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