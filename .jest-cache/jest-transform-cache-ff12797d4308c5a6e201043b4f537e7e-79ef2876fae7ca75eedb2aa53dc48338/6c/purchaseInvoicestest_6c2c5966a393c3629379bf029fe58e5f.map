{"version":3,"sources":["/Users/sachin/Documents/md-sports-/tests/integration/purchaseInvoices.test.ts"],"sourcesContent":["/**\n * @jest-environment node\n */\nimport { PrismaClient } from '@prisma/client';\nimport { POST as createPurchaseInvoice } from '@/app/api/purchases/route'; // Adjust if direct import isn't feasible\nimport { PUT as updatePurchaseInvoice } from '@/app/api/purchases/[id]/route'; // Adjust\nimport { DELETE as deletePurchaseInvoice } from '@/app/api/purchases/[id]/route'; // Adjust\n// Mock NextRequest interface\ninterface NextRequest {\n  method: string;\n  url: string;\n  headers: Headers;\n  json(): Promise<any>;\n  text(): Promise<string>;\n}\n\n// Helper function to create mock NextRequest\nconst createMockNextRequest = (url: string, options: {\n  method?: string;\n  body?: any;\n  headers?: Record<string, string>;\n} = {}): NextRequest => {\n  const { method = 'GET', body, headers = {} } = options;\n  return {\n    method,\n    url,\n    headers: new Headers(headers),\n    json: async () => body ? (typeof body === 'string' ? JSON.parse(body) : body) : {},\n    text: async () => body ? (typeof body === 'string' ? body : JSON.stringify(body)) : '',\n  } as NextRequest;\n};\n\nimport { createMocks } from 'node-mocks-http'; // Or any other way to mock NextRequest/Response\n\nconst prisma = new PrismaClient();\n\ndescribe('Purchase Invoice API Integration Tests', () => {\n    let createdShopId: string;\n    let createdSupplierId: number;\n    let createdProductId: number;\n\n    beforeAll(async () => {\n        // Seed initial data if necessary, e.g., a default supplier or shop\n        // For now, we'll create them in beforeEach or specific tests\n    });\n\n    beforeEach(async () => {\n        // Clean up database tables to ensure test isolation\n        await prisma.purchaseInvoiceItem.deleteMany({});\n        await prisma.purchaseInvoice.deleteMany({});\n        await prisma.inventoryItem.deleteMany({});\n        await prisma.product.deleteMany({});\n        await prisma.supplier.deleteMany({});\n        await prisma.shop.deleteMany({});\n\n        // Create a shop for testing\n        const shop = await prisma.shop.create({\n            data: {\n                name: 'Test Shop Local',\n                location: 'Test Location',\n                // Add other required fields if any\n            },\n        });\n        createdShopId = shop.id;\n\n        // Create a supplier for testing\n        const supplier = await prisma.supplier.create({\n            data: {\n                name: 'Test Supplier Local',\n                // Add other required fields\n            },\n        });\n        createdSupplierId = supplier.id;\n\n        // Create a product for testing updates/deletes (not for create new product test)\n        const product = await prisma.product.create({\n            data: {\n                name: 'Existing Product',\n                price: 100, // retail price\n                sku: 'EXISTING001',\n                shopId: createdShopId, // Optional: associate with a shop by default\n                // weightedAverageCost will be set by purchases\n            }\n        });\n        createdProductId = product.id;\n    });\n\n    afterAll(async () => {\n        // Clean up database after all tests\n        await prisma.purchaseInvoiceItem.deleteMany({});\n        await prisma.purchaseInvoice.deleteMany({});\n        await prisma.inventoryItem.deleteMany({});\n        await prisma.product.deleteMany({});\n        await prisma.supplier.deleteMany({});\n        await prisma.shop.deleteMany({});\n        await prisma.$disconnect();\n    });\n\n    describe('POST /api/purchases (Create Purchase Invoice)', () => {\n        it('should create a purchase invoice for a new product, update inventory, and set WAC', async () => {\n            // 1. Define data for a new product\n            const newProductName = 'Brand New Racket';\n            const newProductSku = 'NEWB001';\n            const purchasePrice = 150;\n            const purchaseQuantity = 10;\n\n            // Create product first (as API expects productId)\n            // In a real scenario, the UI might create product then purchase, or purchase API handles product creation\n            // For this test, assume product is created just before, or API implies its creation from purchase (not current API)\n            // Let's assume for now product must exist, if API doesn't create it from purchase items.\n            // The current API's POST /api/purchases expects item.productId, implying product exists.\n\n            const newTestProduct = await prisma.product.create({\n                data: {\n                    name: newProductName,\n                    sku: newProductSku,\n                    price: 250, // Retail price\n                    shopId: createdShopId // Optional default shop association\n                }\n            });\n            const newTestProductId = newTestProduct.id;\n\n            // 2. Prepare the request body for POST /api/purchases\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: newTestProductId.toString(),\n                        quantity: purchaseQuantity,\n                        price: purchasePrice,\n                    },\n                ],\n                distributions: [ // Explicit distribution is crucial based on current POST API\n                    {\n                        [createdShopId]: purchaseQuantity\n                    }\n                ],\n                totalAmount: purchaseQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            // 3. Construct a NextRequest instance\n            const req = createMockNextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: purchaseInvoicePayload,\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            });\n\n            // Simulate the API call\n            const response = await createPurchaseInvoice(req);\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(201); // Or 200 depending on your API's success response for POST\n            expect(responseBody.data).toHaveProperty('id');\n            const createdInvoiceId = responseBody.data.id;\n\n            // Verify PurchaseInvoice in DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: createdInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice).not.toBeNull();\n            expect(dbInvoice?.supplierId).toBe(createdSupplierId);\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].productId).toBe(newTestProductId);\n            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity);\n            expect(dbInvoice?.items[0].price).toBe(purchasePrice);\n\n            // Verify InventoryItem in DB\n            const dbInventoryItem = await prisma.inventoryItem.findFirst({\n                where: {\n                    productId: newTestProductId,\n                    shopId: createdShopId,\n                },\n            });\n            expect(dbInventoryItem).not.toBeNull();\n            expect(dbInventoryItem?.quantity).toBe(purchaseQuantity);\n            // The POST route seems to calculate shopSpecificCost too.\n            // WAC = (Current Total Value + New Purchase Value) / (Current Quantity + New Quantity)\n            // For new item, existing shopSpecificCost is 0, currentQuantity is 0.\n            // So newShopSpecificCost should be newCost (purchasePrice)\n            expect(dbInventoryItem?.shopSpecificCost).toBe(purchasePrice);\n\n\n            // Verify Product WAC in DB\n            const dbProduct = await prisma.product.findUnique({\n                where: { id: newTestProductId },\n            });\n            expect(dbProduct).not.toBeNull();\n            // For a new product, WAC should be equal to the purchase price of this first batch\n            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);\n        }, 15000); // Increased timeout\n\n        it('should create a purchase for an existing product, update inventory, and recalculate WACs', async () => {\n            // 0. Initial state: Product exists, potentially with some inventory and WAC\n            const initialPurchasePrice = 120;\n            const initialPurchaseQuantity = 5;\n            const existingProductId = createdProductId; // From beforeEach\n\n            // Create an initial purchase to set up existing inventory and WAC\n            const initialPayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date(Date.now() - 86400000).toISOString(), // Yesterday\n                items: [{\n                    productId: existingProductId.toString(),\n                    quantity: initialPurchaseQuantity,\n                    price: initialPurchasePrice,\n                }],\n                distributions: [{ [createdShopId]: initialPurchaseQuantity }],\n                totalAmount: initialPurchaseQuantity * initialPurchasePrice,\n                status: 'paid',\n            };\n            const initialReq = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(initialPayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            await createPurchaseInvoice(initialReq);\n\n            const productBeforeNewPurchase = await prisma.product.findUnique({ where: { id: existingProductId } });\n            const inventoryBeforeNewPurchase = await prisma.inventoryItem.findFirst({ where: { productId: existingProductId, shopId: createdShopId } });\n\n            expect(productBeforeNewPurchase?.weightedAverageCost).toBe(initialPurchasePrice);\n            expect(inventoryBeforeNewPurchase?.quantity).toBe(initialPurchaseQuantity);\n            expect(inventoryBeforeNewPurchase?.shopSpecificCost).toBe(initialPurchasePrice);\n\n            // 1. Define data for the new purchase of the existing product\n            const newPurchasePrice = 100;\n            const newPurchaseQuantity = 8;\n\n            // 2. Prepare the request body\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: existingProductId.toString(),\n                        quantity: newPurchaseQuantity,\n                        price: newPurchasePrice,\n                    },\n                ],\n                distributions: [\n                    {\n                        [createdShopId]: newPurchaseQuantity\n                    }\n                ],\n                totalAmount: newPurchaseQuantity * newPurchasePrice,\n                status: 'paid',\n            };\n\n            // 3. Simulate API call\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(201);\n            const createdInvoiceId = responseBody.data.id;\n\n            // Verify InventoryItem\n            const dbInventoryItem = await prisma.inventoryItem.findFirst({\n                where: {\n                    productId: existingProductId,\n                    shopId: createdShopId,\n                },\n            });\n            const expectedTotalQuantity = initialPurchaseQuantity + newPurchaseQuantity;\n            expect(dbInventoryItem?.quantity).toBe(expectedTotalQuantity);\n\n            // Verify shopSpecificCost recalculation\n            // SSC = ((oldQty * oldSSC) + (newQty * newPrice)) / (oldQty + newQty)\n            const expectedShopSpecificCost =\n                ((initialPurchaseQuantity * initialPurchasePrice) + (newPurchaseQuantity * newPurchasePrice)) /\n                (initialPurchaseQuantity + newPurchaseQuantity);\n            expect(dbInventoryItem?.shopSpecificCost).toBeCloseTo(expectedShopSpecificCost);\n\n            // Verify Product WAC recalculation\n            // WAC = ((oldTotalQty * oldWAC) + (newPurchaseQty * newPurchasePrice)) / (newTotalQty + newPurchaseQty)\n            // In this case, product WAC was initialPurchasePrice for initialPurchaseQuantity.\n            const expectedProductWAC =\n                ((initialPurchaseQuantity * initialPurchasePrice) + (newPurchaseQuantity * newPurchasePrice)) /\n                (initialPurchaseQuantity + newPurchaseQuantity);\n            const dbProduct = await prisma.product.findUnique({ where: { id: existingProductId } });\n            expect(dbProduct?.weightedAverageCost).toBeCloseTo(expectedProductWAC);\n        }, 15000); // Increased timeout\n\n        it('should create a purchase with multiple items and update inventory/WAC for each', async () => {\n            // 1. Create two distinct products for this test\n            const product1Data = { name: 'MultiItem Product A', sku: 'MULTI001', price: 50, shopId: createdShopId };\n            const product2Data = { name: 'MultiItem Product B', sku: 'MULTI002', price: 75, shopId: createdShopId };\n            const product1 = await prisma.product.create({ data: product1Data });\n            const product2 = await prisma.product.create({ data: product2Data });\n\n            const purchasePrice1 = 40;\n            const purchaseQuantity1 = 5;\n            const purchasePrice2 = 60;\n            const purchaseQuantity2 = 3;\n\n            // 2. Prepare the request body\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: product1.id.toString(),\n                        quantity: purchaseQuantity1,\n                        price: purchasePrice1,\n                    },\n                    {\n                        productId: product2.id.toString(),\n                        quantity: purchaseQuantity2,\n                        price: purchasePrice2,\n                    },\n                ],\n                distributions: [ // Explicit distribution for each item\n                    { [createdShopId]: purchaseQuantity1 }, // Distribution for item 1\n                    { [createdShopId]: purchaseQuantity2 }  // Distribution for item 2\n                ],\n                totalAmount: (purchaseQuantity1 * purchasePrice1) + (purchaseQuantity2 * purchasePrice2),\n                status: 'pending',\n            };\n\n            // 3. Simulate API call\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(201);\n            const createdInvoiceId = responseBody.data.id;\n\n            // Verify PurchaseInvoice and its items\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: createdInvoiceId },\n                include: { items: { orderBy: { productId: 'asc' } } } // Order to ensure consistent assertion\n            });\n            expect(dbInvoice?.items.length).toBe(2);\n            // Assuming product1.id < product2.id due to creation order for consistent checks\n            const sortedProducts = [product1, product2].sort((a, b) => a.id - b.id);\n\n            expect(dbInvoice?.items[0].productId).toBe(sortedProducts[0].id);\n            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity1);\n            expect(dbInvoice?.items[0].price).toBe(purchasePrice1);\n\n            expect(dbInvoice?.items[1].productId).toBe(sortedProducts[1].id);\n            expect(dbInvoice?.items[1].quantity).toBe(purchaseQuantity2);\n            expect(dbInvoice?.items[1].price).toBe(purchasePrice2);\n\n            // Verify InventoryItem and Product WAC for Product 1\n            const dbInventoryItem1 = await prisma.inventoryItem.findFirst({\n                where: { productId: product1.id, shopId: createdShopId },\n            });\n            expect(dbInventoryItem1?.quantity).toBe(purchaseQuantity1);\n            expect(dbInventoryItem1?.shopSpecificCost).toBe(purchasePrice1);\n            const dbProduct1 = await prisma.product.findUnique({ where: { id: product1.id } });\n            expect(dbProduct1?.weightedAverageCost).toBe(purchasePrice1);\n\n            // Verify InventoryItem and Product WAC for Product 2\n            const dbInventoryItem2 = await prisma.inventoryItem.findFirst({\n                where: { productId: product2.id, shopId: createdShopId },\n            });\n            expect(dbInventoryItem2?.quantity).toBe(purchaseQuantity2);\n            expect(dbInventoryItem2?.shopSpecificCost).toBe(purchasePrice2);\n            const dbProduct2 = await prisma.product.findUnique({ where: { id: product2.id } });\n            expect(dbProduct2?.weightedAverageCost).toBe(purchasePrice2);\n        }, 15000); // Increased timeout\n\n        it('should distribute a single purchase item to multiple shops', async () => {\n            // 1. Create two new shops for this test\n            const shopA = await prisma.shop.create({ data: { name: 'Test Shop A', location: 'Loc A' } });\n            const shopB = await prisma.shop.create({ data: { name: 'Test Shop B', location: 'Loc B' } });\n\n            // 2. Create a new product\n            const product = await prisma.product.create({ data: { name: 'Split Product', sku: 'SPLIT001', price: 200 } });\n            const purchasePrice = 180;\n            const totalQuantity = 10;\n            const quantityForShopA = 6;\n            const quantityForShopB = 4;\n\n            expect(quantityForShopA + quantityForShopB).toBe(totalQuantity); // Sanity check\n\n            // 3. Prepare request body\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: product.id.toString(),\n                        quantity: totalQuantity, // Total quantity for the item line\n                        price: purchasePrice,\n                    },\n                ],\n                distributions: [\n                    { // Distribution for the single item, split into two shops\n                        [shopA.id]: quantityForShopA,\n                        [shopB.id]: quantityForShopB,\n                    }\n                ],\n                totalAmount: totalQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            // 4. Simulate API call\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n            const responseBody = await response.json();\n\n            // 5. Assertions\n            expect(response.status).toBe(201);\n\n            // Verify InventoryItem for Shop A\n            const invItemA = await prisma.inventoryItem.findFirst({\n                where: { productId: product.id, shopId: shopA.id }\n            });\n            expect(invItemA).not.toBeNull();\n            expect(invItemA?.quantity).toBe(quantityForShopA);\n            expect(invItemA?.shopSpecificCost).toBe(purchasePrice);\n\n            // Verify InventoryItem for Shop B\n            const invItemB = await prisma.inventoryItem.findFirst({\n                where: { productId: product.id, shopId: shopB.id }\n            });\n            expect(invItemB).not.toBeNull();\n            expect(invItemB?.quantity).toBe(quantityForShopB);\n            expect(invItemB?.shopSpecificCost).toBe(purchasePrice);\n\n            // Verify Product WAC (should be the purchase price as it's all new stock)\n            const dbProduct = await prisma.product.findUnique({ where: { id: product.id } });\n            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);\n        }, 15000); // Increased timeout\n\n        it('should fail to create a purchase if a productId does not exist', async () => {\n            const nonExistentProductId = 999999; // Assuming this ID won't exist\n            const purchasePrice = 100;\n            const purchaseQuantity = 5;\n\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: nonExistentProductId.toString(),\n                        quantity: purchaseQuantity,\n                        price: purchasePrice,\n                    },\n                ],\n                distributions: [\n                    { [createdShopId]: purchaseQuantity }\n                ],\n                totalAmount: purchaseQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n\n            // Expect a client error (e.g., 400 or 404) or potentially 500 if not handled gracefully\n            // For robust error handling, API should return specific error code.\n            // Prisma will throw an error if a related record (product) is not found for foreign key.\n            // This will likely result in a 500 if not caught and handled by the API route.\n            // Let's aim for the API to catch this and return a more specific client error.\n            // For now, we'll check if it's NOT a success (201).\n            // A more precise check would be for 400/404/422 depending on planned error handling.\n            expect(response.status).toBe(500); // Or 400/404 if you implement specific error handling\n\n            const responseBody = await response.json();\n            expect(responseBody.error).toBeDefined();\n            // Optionally, check for a specific error message or code if your API provides one.\n        }, 15000); // Increased timeout\n\n        it('should fail to create a purchase if a supplierId does not exist', async () => {\n            const newTestProduct = await prisma.product.create({\n                data: {\n                    name: 'Product For Invalid Supplier Test',\n                    sku: 'INV SUP001',\n                    price: 100,\n                }\n            });\n            const purchasePrice = 80;\n            const purchaseQuantity = 5;\n            const nonExistentSupplierId = 999999; // Assuming this ID won't exist\n\n            const purchaseInvoicePayload = {\n                supplierId: nonExistentSupplierId.toString(), // Invalid supplier\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: newTestProduct.id.toString(),\n                        quantity: purchaseQuantity,\n                        price: purchasePrice,\n                    },\n                ],\n                distributions: [\n                    { [createdShopId]: purchaseQuantity }\n                ],\n                totalAmount: purchaseQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n\n            expect(response.status).toBe(500); // Expecting 500 as Prisma throws P2003\n\n            const responseBody = await response.json();\n            expect(responseBody.error).toBeDefined();\n        });\n    });\n\n    describe('PUT /api/purchases/:id (Update Purchase Invoice)', () => {\n        let existingInvoiceId: string;\n        let productForUpdateTestsId: number;\n        const initialPurchasePrice = 50;\n        const initialPurchaseQuantity = 10;\n\n        beforeEach(async () => {\n            // Create a product specifically for these update/delete tests if not already created\n            // The global createdProductId can be used if it fits, or make a new one.\n            // Let's use the global one for simplicity, assuming beforeEach cleans it up.\n            productForUpdateTestsId = createdProductId;\n\n            // Create an initial purchase invoice to be updated or deleted in tests\n            const initialInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date(Date.now() - 86400000).toISOString(), // Yesterday\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: initialPurchaseQuantity,\n                        price: initialPurchasePrice,\n                    },\n                ],\n                distributions: [\n                    { [createdShopId]: initialPurchaseQuantity }\n                ],\n                totalAmount: initialPurchaseQuantity * initialPurchasePrice,\n                status: 'paid',\n            };\n            const req = createMockNextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: initialInvoicePayload,\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const response = await createPurchaseInvoice(req);\n            const body = await response.json();\n            existingInvoiceId = body.data.id;\n\n            // Sanity check: verify initial state\n            const initialProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(initialProduct?.weightedAverageCost).toBe(initialPurchasePrice);\n            const initialInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(initialInventory?.quantity).toBe(initialPurchaseQuantity);\n            expect(initialInventory?.shopSpecificCost).toBe(initialPurchasePrice);\n        });\n\n        it('should update item quantity (increase), recalculate stock and WACs', async () => {\n            const quantityIncrease = 5;\n            const newQuantity = initialPurchaseQuantity + quantityIncrease;\n            // Price remains the same for this item in this update scenario\n            const updatedPriceForItem = initialPurchasePrice;\n\n            const updatePayload = {\n                // We need to send the complete structure expected by the PUT route\n                // This includes all items, even if only one is changing.\n                // The PUT route logic might compare with existing items to see what changed.\n                items: [\n                    {\n                        // If the item had an ID (PurchaseInvoiceItem id), it might be needed.\n                        // Let's assume for now the PUT matches items based on productId if not item ID.\n                        // Based on current PUT route, it expects productId.\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: newQuantity,\n                        price: updatedPriceForItem, // Send the original price if it hasn't changed\n                    }\n                ],\n                distributions: [\n                    // The distributions in PUT might need to reflect the *new total* for the item\n                    { [createdShopId]: newQuantity }\n                ],\n                // Other fields like supplierId, date, totalAmount might be updatable too.\n                // For this test, focus on item quantity change.\n                // The PUT route recalculates totalAmount based on items if not provided or if items change.\n                // Let's assume totalAmount will be recalculated by the API.\n                // supplierId and date could be part of the payload if they are updatable.\n                // For now, keeping it minimal to test item update.\n                // The PUT handler re-calculates total amount, so not sending it.\n            };\n\n            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayload),\n                headers: { 'Content-Type': 'application/json' },\n                // IMPORTANT: Need to pass route params for [id] to the handler\n                // This is not standard NextRequest but how test setup might need it or how handler expects it.\n                // The actual handler `updatePurchaseInvoice(request: NextRequest, { params }: { params: { id: string } })`\n                // needs `params`. node-mocks-http `createMocks` handles this well.\n                // For direct NextRequest, we pass it in context to the handler call.\n            });\n\n            // Simulate API call - updatePurchaseInvoice(req, { params: { id: existingInvoiceId } })\n            // This is how you call it if you are testing the handler directly in Jest with context\n            const response = await updatePurchaseInvoice(req, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify InventoryItem stock and shopSpecificCost\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(updatedInventory?.quantity).toBe(newQuantity);\n\n            // WAC calculation: ((oldQty * oldSSC) + (addedQty * priceOfAddedQty)) / (newTotalQty)\n            // In this specific update, the PUT route reverses the old item and adds the new one as if it's a new purchase line for WAC calcs.\n            // So, the old initialPurchaseQuantity at initialPurchasePrice is reversed.\n            // Then, newQuantity at updatedPriceForItem is added.\n            // However, the current PUT logic first reverses *all* old items based on their *original* recorded cost.\n            // Then it adds *all* new items based on their *new* cost.\n            // So for the product WAC: (TotalValueBefore - OldItemValue + NewItemValue) / (TotalStockBefore - OldItemQty + NewItemQty)\n            // And for shop specific WAC: (ShopValueBefore - OldItemValueInShop + NewItemValueInShop) / (ShopStockBefore - OldItemQtyInShop + NewItemQtyInShop)\n\n            // Let's check the logic from src/app/api/purchases/[id]/route.ts\n            // 1. It fetches the old invoice.\n            // 2. It reverses inventory adjustments for ALL old items (decrease stock, WAC updated).\n            // 3. It processes ALL new/updated items as if they are new purchases (increase stock, WAC updated).\n\n            // So, after reversal of initialPurchaseQuantity at initialPurchasePrice:\n            // Product WAC and ShopSpecificCost would be effectively 0 if this were the only product/stock.\n            // Then, adding newQuantity at updatedPriceForItem:\n            // The new WACs should become updatedPriceForItem.\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);\n\n            // Verify Product WAC\n            const updatedProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);\n\n            // Verify PurchaseInvoiceItem in DB reflects the change\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);\n            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);\n            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);\n        }, 15000); // Increased timeout\n\n        it('should update item quantity (decrease), recalculate stock and WACs', async () => {\n            const quantityDecrease = 3;\n            const newQuantity = initialPurchaseQuantity - quantityDecrease;\n            expect(newQuantity).toBeGreaterThanOrEqual(0); // Ensure we don't go negative for this test logic\n\n            const updatedPriceForItem = initialPurchasePrice; // Price remains the same\n\n            const updatePayload = {\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: newQuantity,\n                        price: updatedPriceForItem,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: newQuantity }\n                ],\n            };\n\n            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n\n            const response = await updatePurchaseInvoice(req, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify InventoryItem stock and shopSpecificCost\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(updatedInventory?.quantity).toBe(newQuantity);\n\n            // Due to the reversal and re-addition logic of the PUT route:\n            // The old initialPurchaseQuantity at initialPurchasePrice is reversed.\n            // Then, newQuantity at updatedPriceForItem is added.\n            // So, new WACs should become updatedPriceForItem (which is initialPurchasePrice).\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);\n\n            // Verify Product WAC\n            const updatedProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);\n\n            // Verify PurchaseInvoiceItem in DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);\n            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);\n            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);\n        }, 15000); // Increased timeout\n\n        it('should update item price, recalculate stock and WACs', async () => {\n            const newPriceForItem = initialPurchasePrice + 25; // New price, e.g., 50 + 25 = 75\n            const quantityUnchanged = initialPurchaseQuantity; // Quantity remains the same\n\n            const updatePayload = {\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: quantityUnchanged,\n                        price: newPriceForItem,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: quantityUnchanged }\n                ],\n                // totalAmount will be recalculated by the API\n            };\n\n            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n\n            const response = await updatePurchaseInvoice(req, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify InventoryItem stock (should be unchanged) and shopSpecificCost\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(updatedInventory?.quantity).toBe(quantityUnchanged);\n            // WAC logic in PUT: reverses old, adds new. So shopSpecificCost should reflect newPriceForItem.\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(newPriceForItem);\n\n            // Verify Product WAC\n            const updatedProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(newPriceForItem);\n\n            // Verify PurchaseInvoiceItem in DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].quantity).toBe(quantityUnchanged);\n            expect(dbInvoice?.items[0].price).toBe(newPriceForItem);\n            expect(dbInvoice?.total).toBe(quantityUnchanged * newPriceForItem);\n        }, 15000); // Increased timeout\n\n        it('should add a new item to an existing invoice, update stock and WACs', async () => {\n            // 1. Define a new product for the new item\n            const newItemProduct = await prisma.product.create({\n                data: {\n                    name: 'Newly Added Product for PUT',\n                    sku: 'PUTNEW001',\n                    price: 200, // Retail price\n                }\n            });\n            const newItemProductId = newItemProduct.id;\n            const newItemQuantity = 7;\n            const newItemPrice = 120;\n\n            // Original item details (from beforeEach setup)\n            const originalItemProductId = productForUpdateTestsId;\n            const originalItemQuantity = initialPurchaseQuantity;\n            const originalItemPrice = initialPurchasePrice;\n\n            // 2. Prepare the update payload with both original and new item\n            const updatePayload = {\n                items: [\n                    {\n                        productId: originalItemProductId.toString(),\n                        quantity: originalItemQuantity,\n                        price: originalItemPrice,\n                    },\n                    {\n                        productId: newItemProductId.toString(),\n                        quantity: newItemQuantity,\n                        price: newItemPrice,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: originalItemQuantity }, // Distribution for original item\n                    { [createdShopId]: newItemQuantity }      // Distribution for new item\n                ],\n                // totalAmount will be recalculated by the API\n            };\n\n            // 3. Simulate API call\n            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const response = await updatePurchaseInvoice(req, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify PurchaseInvoice in DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: { orderBy: { productId: 'asc' } } }, // Order for consistent checks\n            });\n            expect(dbInvoice?.items.length).toBe(2);\n\n            const expectedTotal = (originalItemQuantity * originalItemPrice) + (newItemQuantity * newItemPrice);\n            expect(dbInvoice?.total).toBe(expectedTotal);\n\n            // Find the items in the response (order might vary, so find by productId)\n            const dbOriginalItem = dbInvoice?.items.find(item => item.productId === originalItemProductId);\n            const dbNewItem = dbInvoice?.items.find(item => item.productId === newItemProductId);\n\n            expect(dbOriginalItem).toBeDefined();\n            expect(dbOriginalItem?.quantity).toBe(originalItemQuantity);\n            expect(dbOriginalItem?.price).toBe(originalItemPrice);\n\n            expect(dbNewItem).toBeDefined();\n            expect(dbNewItem?.quantity).toBe(newItemQuantity);\n            expect(dbNewItem?.price).toBe(newItemPrice);\n\n            // Verify InventoryItem and Product WAC for the original item\n            // (Due to PUT logic of reverse & re-add, WACs should reflect its current price)\n            const originalInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: originalItemProductId, shopId: createdShopId }\n            });\n            expect(originalInventory?.quantity).toBe(originalItemQuantity);\n            expect(originalInventory?.shopSpecificCost).toBeCloseTo(originalItemPrice);\n            const originalProduct = await prisma.product.findUnique({ where: { id: originalItemProductId } });\n            expect(originalProduct?.weightedAverageCost).toBeCloseTo(originalItemPrice);\n\n            // Verify InventoryItem and Product WAC for the NEW item\n            const newInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: newItemProductId, shopId: createdShopId }\n            });\n            expect(newInventory?.quantity).toBe(newItemQuantity);\n            expect(newInventory?.shopSpecificCost).toBeCloseTo(newItemPrice);\n            const newProductDb = await prisma.product.findUnique({ where: { id: newItemProductId } });\n            expect(newProductDb?.weightedAverageCost).toBeCloseTo(newItemPrice);\n        }, 15000); // Increased timeout\n\n        it('should remove an item from an existing invoice, update stock and WACs', async () => {\n            // 1. Setup: Ensure an invoice with at least two items exists.\n            // We'll use the existing `productForUpdateTestsId` and create one more product and item.\n            const productToRemove = await prisma.product.create({\n                data: {\n                    name: 'Product To Be Removed',\n                    sku: 'PUTRMV001',\n                    price: 300,\n                }\n            });\n            const productToRemoveId = productToRemove.id;\n            const productToRemoveQuantity = 4;\n            const productToRemovePrice = 40;\n\n            // Update the existing invoice (created in global beforeEach for PUT) to include this second item first.\n            const addSecondItemPayload = {\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: initialPurchaseQuantity,\n                        price: initialPurchasePrice,\n                    },\n                    {\n                        productId: productToRemoveId.toString(),\n                        quantity: productToRemoveQuantity,\n                        price: productToRemovePrice,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: initialPurchaseQuantity },\n                    { [createdShopId]: productToRemoveQuantity }\n                ],\n            };\n            const addReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(addSecondItemPayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            await updatePurchaseInvoice(addReq, { params: { id: existingInvoiceId } });\n\n            // Sanity check: Invoice should have 2 items\n            let invoiceWithTwoItems = await prisma.purchaseInvoice.findUnique({ where: { id: existingInvoiceId }, include: { items: true } });\n            expect(invoiceWithTwoItems?.items.length).toBe(2);\n\n            // 2. Prepare the update payload that only contains the item we want to keep.\n            const updatePayloadToRemoveItem = {\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(), // Keep this one\n                        quantity: initialPurchaseQuantity,\n                        price: initialPurchasePrice,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: initialPurchaseQuantity } // Distribution for the kept item\n                ],\n            };\n\n            // 3. Simulate API call to remove the item\n            const removeReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayloadToRemoveItem),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const response = await updatePurchaseInvoice(removeReq, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify PurchaseInvoice in DB - should now have only 1 item\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].productId).toBe(productForUpdateTestsId);\n            expect(dbInvoice?.items[0].quantity).toBe(initialPurchaseQuantity);\n            expect(dbInvoice?.items[0].price).toBe(initialPurchasePrice);\n            expect(dbInvoice?.total).toBe(initialPurchaseQuantity * initialPurchasePrice);\n\n            // Verify InventoryItem and Product WAC for the KEPT item\n            const keptInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(keptInventory?.quantity).toBe(initialPurchaseQuantity);\n            expect(keptInventory?.shopSpecificCost).toBeCloseTo(initialPurchasePrice);\n            const keptProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(keptProduct?.weightedAverageCost).toBeCloseTo(initialPurchasePrice);\n\n            // Verify InventoryItem and Product WAC for the REMOVED item\n            // Stock should be zero or the item might be gone from inventory if it was the only purchase\n            // WAC on product should be 0 if no other purchases exist.\n            const removedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productToRemoveId, shopId: createdShopId }\n            });\n            // The PUT logic reverses stock. If this was the only stock, it becomes 0.\n            expect(removedInventory?.quantity).toBe(0);\n            // ShopSpecificCost might become 0 or NaN if quantity is 0. The API sets it to 0 for safety.\n            expect(removedInventory?.shopSpecificCost).toBeCloseTo(0);\n\n            const removedProductDb = await prisma.product.findUnique({ where: { id: productToRemoveId } });\n            // If no other purchase items for this product, WAC should become 0.\n            const otherPurchasesOfRemovedItem = await prisma.purchaseInvoiceItem.count({\n                where: { productId: productToRemoveId }\n            });\n            if (otherPurchasesOfRemovedItem === 0) {\n                expect(removedProductDb?.weightedAverageCost).toBeCloseTo(0);\n            } // Else, it would be based on other purchases, which this test doesn't set up.\n\n        }, 15000); // Increased timeout\n    });\n\n    describe('DELETE /api/purchases/:id (Delete Purchase Invoice)', () => {\n        let invoiceToDeleteId: string;\n        let productForDeleteTestId: number;\n        const deleteTestInitialPrice = 60;\n        const deleteTestInitialQuantity = 12;\n\n        beforeEach(async () => {\n            // Ensure product exists for the test\n            const product = await prisma.product.create({\n                data: {\n                    name: 'Product For Delete Test',\n                    sku: 'DELPROD001',\n                    price: 100, // retail\n                }\n            });\n            productForDeleteTestId = product.id;\n\n            // Create an initial purchase invoice to be deleted\n            const initialInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: productForDeleteTestId.toString(),\n                        quantity: deleteTestInitialQuantity,\n                        price: deleteTestInitialPrice,\n                    },\n                ],\n                distributions: [\n                    { [createdShopId]: deleteTestInitialQuantity } // Explicit distribution\n                ],\n                totalAmount: deleteTestInitialQuantity * deleteTestInitialPrice,\n                status: 'paid',\n            };\n            const req = createMockNextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: initialInvoicePayload,\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const response = await createPurchaseInvoice(req);\n            const body = await response.json();\n            invoiceToDeleteId = body.data.id;\n\n            // Sanity check: verify initial state after creation\n            const initialProductDB = await prisma.product.findUnique({ where: { id: productForDeleteTestId } });\n            expect(initialProductDB?.weightedAverageCost).toBe(deleteTestInitialPrice);\n            const initialInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForDeleteTestId, shopId: createdShopId }\n            });\n            expect(initialInventory?.quantity).toBe(deleteTestInitialQuantity);\n            expect(initialInventory?.shopSpecificCost).toBe(deleteTestInitialPrice);\n        });\n\n        it('should delete a purchase invoice and correctly reverse stock and WACs for a single-item invoice with explicit distribution', async () => {\n            // 1. Call the DELETE endpoint\n            const deleteReq = createMockNextRequest(`http://localhost/api/purchases/${invoiceToDeleteId}`, {\n                method: 'DELETE',\n            });\n            const deleteResponse = await deletePurchaseInvoice(deleteReq, { params: { id: invoiceToDeleteId } });\n\n            // 2. Assertions for DELETE response\n            expect(deleteResponse.status).toBe(200);\n            const deleteResponseBody = await deleteResponse.json();\n            expect(deleteResponseBody.message).toBe('Purchase invoice deleted successfully');\n\n            // 3. Verify PurchaseInvoice is deleted from DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: invoiceToDeleteId },\n            });\n            expect(dbInvoice).toBeNull();\n\n            // 4. Verify PurchaseInvoiceItems are deleted\n            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({\n                where: { purchaseInvoiceId: invoiceToDeleteId },\n            });\n            expect(dbInvoiceItems.length).toBe(0);\n\n            // 5. Verify InventoryItem stock is reversed\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForDeleteTestId, shopId: createdShopId }\n            });\n            // Assuming this was the only purchase, stock should be 0\n            expect(updatedInventory?.quantity).toBe(0);\n            // ShopSpecificCost should also be 0 if stock is 0\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);\n\n\n            // 6. Verify Product WAC is recalculated (should be 0 if this was the only purchase)\n            const updatedProduct = await prisma.product.findUnique({\n                where: { id: productForDeleteTestId },\n            });\n            // If no other purchase items for this product, WAC should become 0.\n            const otherPurchasesOfProduct = await prisma.purchaseInvoiceItem.count({\n                where: {\n                    productId: productForDeleteTestId,\n                    // purchaseInvoiceId: { not: invoiceToDeleteId } // Not needed as original invoice items are gone\n                }\n            });\n            if (otherPurchasesOfProduct === 0) { // This should be true for this test\n                expect(updatedProduct?.weightedAverageCost).toBeCloseTo(0);\n            }\n        });\n\n        it('should delete a purchase and reverse stock/WAC when product is in a single inferred shop', async () => {\n            // 1. Setup: Create dedicated entities for this test to ensure isolation.\n            const testShop = await prisma.shop.create({\n                data: { name: 'Inferred Delete Test Shop', location: 'Loc X' }\n            });\n            const testSupplier = await prisma.supplier.create({\n                data: { name: 'Inferred Delete Test Supplier' }\n            });\n            const testProduct = await prisma.product.create({\n                data: {\n                    name: 'Product for Inferred Delete',\n                    sku: 'INFDEL001',\n                    price: 200, // retail price\n                    weightedAverageCost: 0\n                }\n            });\n\n            // Create an inventory item for this product in the test shop.\n            // This makes it the \"single inferred shop\".\n            await prisma.inventoryItem.create({\n                data: {\n                    productId: testProduct.id,\n                    shopId: testShop.id,\n                    quantity: 0, // Will be updated by the purchase\n                    shopSpecificCost: 0\n                }\n            });\n\n            const purchaseQuantity = 12;\n            const purchasePrice = 60;\n\n            const inferredShopInvoicePayload = {\n                supplierId: testSupplier.id.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: testProduct.id.toString(),\n                        quantity: purchaseQuantity,\n                        price: purchasePrice,\n                    },\n                ],\n                // NO distributions property here for inference to kick in on POST\n                totalAmount: purchaseQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            // Create the purchase invoice (this is where the failure was happening)\n            const createReq = createMockNextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(inferredShopInvoicePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const createResponse = await createPurchaseInvoice(createReq);\n            expect(createResponse.status).toBe(201); // Assert successful creation\n\n            const createBody = await createResponse.json();\n            const invoiceIdForInferredDelete = createBody.data.id;\n\n            // Sanity check: Verify stock and WAC after creation\n            const inventoryAfterCreate = await prisma.inventoryItem.findFirst({\n                where: { productId: testProduct.id, shopId: testShop.id }\n            });\n            expect(inventoryAfterCreate?.quantity).toBe(purchaseQuantity);\n            expect(inventoryAfterCreate?.shopSpecificCost).toBeCloseTo(purchasePrice);\n            const productAfterCreate = await prisma.product.findUnique({ where: { id: testProduct.id } });\n            expect(productAfterCreate?.weightedAverageCost).toBeCloseTo(purchasePrice);\n\n            // 2. Call the DELETE endpoint\n            const deleteReq = createMockNextRequest(`http://localhost/api/purchases/${invoiceIdForInferredDelete}`, {\n                method: 'DELETE',\n            });\n            const deleteResponse = await deletePurchaseInvoice(deleteReq, { params: { id: invoiceIdForInferredDelete } });\n\n            // 3. Assertions for DELETE response\n            expect(deleteResponse.status).toBe(200);\n            const deleteResponseBody = await deleteResponse.json();\n            expect(deleteResponseBody.message).toBe('Purchase invoice deleted successfully');\n\n            // 4. Verify PurchaseInvoice and Items are deleted\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({ where: { id: invoiceIdForInferredDelete } });\n            expect(dbInvoice).toBeNull();\n            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({ where: { purchaseInvoiceId: invoiceIdForInferredDelete } });\n            expect(dbInvoiceItems.length).toBe(0);\n\n            // 5. Verify InventoryItem stock and shopSpecificCost are reversed in the inferred shop\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: testProduct.id, shopId: testShop.id }\n            });\n            expect(updatedInventory?.quantity).toBe(0);\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);\n\n            // 6. Verify Product WAC is recalculated to 0\n            const updatedProductDB = await prisma.product.findUnique({ where: { id: testProduct.id } });\n            expect(updatedProductDB?.weightedAverageCost).toBeCloseTo(0);\n\n            // Cleanup dedicated entities for this test\n            await prisma.inventoryItem.deleteMany({ where: { productId: testProduct.id } });\n            await prisma.product.delete({ where: { id: testProduct.id } });\n            await prisma.supplier.delete({ where: { id: testSupplier.id } });\n            await prisma.shop.delete({ where: { id: testShop.id } });\n        }, 15000); // Added a longer timeout as a precaution\n\n        it('should delete an invoice with multiple items, reversing stock/WAC for each', async () => {\n            // 1. Setup: Create multiple products and an invoice with items from these products.\n            // For simplicity, distribute each to the main createdShopId from global beforeEach.\n\n            const productA = await prisma.product.create({\n                data: { name: 'Multi-Del Prod A', sku: 'MDEL00A', price: 100, weightedAverageCost: 0 }\n            });\n            const productB = await prisma.product.create({\n                data: { name: 'Multi-Del Prod B', sku: 'MDEL00B', price: 200, weightedAverageCost: 0 }\n            });\n\n            const quantityA = 5;\n            const priceA = 50;\n            const quantityB = 3;\n            const priceB = 120;\n\n            const multiItemInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    { productId: productA.id.toString(), quantity: quantityA, price: priceA },\n                    { productId: productB.id.toString(), quantity: quantityB, price: priceB },\n                ],\n                distributions: [\n                    { [createdShopId]: quantityA }, // Item A to main shop\n                    { [createdShopId]: quantityB }  // Item B to main shop\n                ],\n                totalAmount: (quantityA * priceA) + (quantityB * priceB),\n                status: 'paid',\n            };\n\n            const createReq = createMockNextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: multiItemInvoicePayload,\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const createResponse = await createPurchaseInvoice(createReq);\n            expect(createResponse.status).toBe(201);\n            const createBody = await createResponse.json();\n            const multiItemInvoiceId = createBody.data.id;\n\n            // Sanity check inventory and WAC after creation\n            const invA_afterCreate = await prisma.inventoryItem.findFirst({ where: { productId: productA.id, shopId: createdShopId } });\n            expect(invA_afterCreate?.quantity).toBe(quantityA);\n            expect(invA_afterCreate?.shopSpecificCost).toBe(priceA);\n            const prodA_afterCreate = await prisma.product.findUnique({ where: { id: productA.id } });\n            expect(prodA_afterCreate?.weightedAverageCost).toBe(priceA);\n\n            const invB_afterCreate = await prisma.inventoryItem.findFirst({ where: { productId: productB.id, shopId: createdShopId } });\n            expect(invB_afterCreate?.quantity).toBe(quantityB);\n            expect(invB_afterCreate?.shopSpecificCost).toBe(priceB);\n            const prodB_afterCreate = await prisma.product.findUnique({ where: { id: productB.id } });\n            expect(prodB_afterCreate?.weightedAverageCost).toBe(priceB);\n\n            // 2. Call DELETE endpoint\n            const deleteReq = createMockNextRequest(`http://localhost/api/purchases/${multiItemInvoiceId}`, {\n                method: 'DELETE',\n            });\n            const deleteResponse = await deletePurchaseInvoice(deleteReq, { params: { id: multiItemInvoiceId } });\n            expect(deleteResponse.status).toBe(200);\n\n            // 3. Verify invoice and items are deleted\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({ where: { id: multiItemInvoiceId } });\n            expect(dbInvoice).toBeNull();\n            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({ where: { purchaseInvoiceId: multiItemInvoiceId } });\n            expect(dbInvoiceItems.length).toBe(0);\n\n            // 4. Verify stock and WAC for Product A are reversed\n            const invA_afterDelete = await prisma.inventoryItem.findFirst({ where: { productId: productA.id, shopId: createdShopId } });\n            expect(invA_afterDelete?.quantity).toBe(0);\n            expect(invA_afterDelete?.shopSpecificCost).toBeCloseTo(0);\n            const prodA_afterDelete = await prisma.product.findUnique({ where: { id: productA.id } });\n            expect(prodA_afterDelete?.weightedAverageCost).toBeCloseTo(0);\n\n            // 5. Verify stock and WAC for Product B are reversed\n            const invB_afterDelete = await prisma.inventoryItem.findFirst({ where: { productId: productB.id, shopId: createdShopId } });\n            expect(invB_afterDelete?.quantity).toBe(0);\n            expect(invB_afterDelete?.shopSpecificCost).toBeCloseTo(0);\n            const prodB_afterDelete = await prisma.product.findUnique({ where: { id: productB.id } });\n            expect(prodB_afterDelete?.weightedAverageCost).toBeCloseTo(0);\n\n            // Clean up products and their inventory items created for this test\n            await prisma.inventoryItem.deleteMany({ where: { productId: { in: [productA.id, productB.id] } } });\n            await prisma.product.deleteMany({ where: { id: { in: [productA.id, productB.id] } } });\n        }, 15000); // Timeout for safety\n    });\n\n});"],"names":["createMockNextRequest","url","options","method","body","headers","Headers","json","JSON","parse","text","stringify","prisma","PrismaClient","describe","createdShopId","createdSupplierId","createdProductId","beforeAll","beforeEach","purchaseInvoiceItem","deleteMany","purchaseInvoice","inventoryItem","product","supplier","shop","create","data","name","location","id","price","sku","shopId","afterAll","$disconnect","it","newProductName","newProductSku","purchasePrice","purchaseQuantity","newTestProduct","newTestProductId","purchaseInvoicePayload","supplierId","toString","date","Date","toISOString","items","productId","quantity","distributions","totalAmount","status","req","response","createPurchaseInvoice","responseBody","expect","toBe","toHaveProperty","createdInvoiceId","dbInvoice","findUnique","where","include","not","toBeNull","length","dbInventoryItem","findFirst","shopSpecificCost","dbProduct","weightedAverageCost","initialPurchasePrice","initialPurchaseQuantity","existingProductId","initialPayload","now","initialReq","NextRequest","productBeforeNewPurchase","inventoryBeforeNewPurchase","newPurchasePrice","newPurchaseQuantity","expectedTotalQuantity","expectedShopSpecificCost","toBeCloseTo","expectedProductWAC","product1Data","product2Data","product1","product2","purchasePrice1","purchaseQuantity1","purchasePrice2","purchaseQuantity2","orderBy","sortedProducts","sort","a","b","dbInventoryItem1","dbProduct1","dbInventoryItem2","dbProduct2","shopA","shopB","totalQuantity","quantityForShopA","quantityForShopB","invItemA","invItemB","nonExistentProductId","error","toBeDefined","nonExistentSupplierId","existingInvoiceId","productForUpdateTestsId","initialInvoicePayload","initialProduct","initialInventory","quantityIncrease","newQuantity","updatedPriceForItem","updatePayload","updatePurchaseInvoice","params","updatedInventory","updatedProduct","total","quantityDecrease","toBeGreaterThanOrEqual","newPriceForItem","quantityUnchanged","newItemProduct","newItemProductId","newItemQuantity","newItemPrice","originalItemProductId","originalItemQuantity","originalItemPrice","expectedTotal","dbOriginalItem","find","item","dbNewItem","originalInventory","originalProduct","newInventory","newProductDb","productToRemove","productToRemoveId","productToRemoveQuantity","productToRemovePrice","addSecondItemPayload","addReq","invoiceWithTwoItems","updatePayloadToRemoveItem","removeReq","keptInventory","keptProduct","removedInventory","removedProductDb","otherPurchasesOfRemovedItem","count","invoiceToDeleteId","productForDeleteTestId","deleteTestInitialPrice","deleteTestInitialQuantity","initialProductDB","deleteReq","deleteResponse","deletePurchaseInvoice","deleteResponseBody","message","dbInvoiceItems","findMany","purchaseInvoiceId","otherPurchasesOfProduct","testShop","testSupplier","testProduct","inferredShopInvoicePayload","createReq","createResponse","createBody","invoiceIdForInferredDelete","inventoryAfterCreate","productAfterCreate","updatedProductDB","delete","productA","productB","quantityA","priceA","quantityB","priceB","multiItemInvoicePayload","multiItemInvoiceId","invA_afterCreate","prodA_afterCreate","invB_afterCreate","prodB_afterCreate","invA_afterDelete","prodA_afterDelete","invB_afterDelete","prodB_afterDelete","in"],"mappings":"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"}