55aec400484c19ce070f67d2f0b3ef9f
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    GET: function() {
        return GET;
    },
    POST: function() {
        return POST;
    }
});
const _server = require("next/server");
const _prisma = /*#__PURE__*/ _interop_require_default(require("../../../lib/prisma"));
const _cache = require("../../../lib/cache");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function GET(request) {
    try {
        const { searchParams } = new URL(request.url);
        const search = searchParams.get("search") || "";
        const status = searchParams.get("status");
        const supplierId = searchParams.get("supplierId");
        const startDate = searchParams.get("startDate");
        const endDate = searchParams.get("endDate");
        const page = parseInt(searchParams.get("page") || "1");
        const limit = parseInt(searchParams.get("limit") || "10");
        const skip = (page - 1) * limit;
        // Build the where clause for Prisma
        const whereClause = {};
        if (search) {
            // Search across multiple fields: invoiceNumber, supplier name, item product name
            whereClause.OR = [
                {
                    invoiceNumber: {
                        contains: search,
                        mode: "insensitive"
                    }
                },
                {
                    supplier: {
                        name: {
                            contains: search,
                            mode: "insensitive"
                        }
                    }
                }
            ];
        }
        if (status) {
            whereClause.status = status;
        }
        if (supplierId) {
            whereClause.supplierId = parseInt(supplierId);
        }
        if (startDate && endDate) {
            whereClause.date = {
                gte: new Date(startDate),
                lte: new Date(endDate)
            };
        } else if (startDate) {
            whereClause.date = {
                gte: new Date(startDate)
            };
        } else if (endDate) {
            whereClause.date = {
                lte: new Date(endDate)
            };
        }
        const [purchases, totalCount] = await _prisma.default.$transaction([
            _prisma.default.purchaseInvoice.findMany({
                where: whereClause,
                include: {
                    supplier: {
                        select: {
                            id: true,
                            name: true,
                            email: true,
                            phone: true
                        }
                    },
                    items: {
                        include: {
                            product: {
                                select: {
                                    id: true,
                                    name: true,
                                    sku: true
                                }
                            }
                        }
                    }
                },
                orderBy: {
                    date: "desc" // More common to sort by invoice date
                },
                skip: skip,
                take: limit
            }),
            _prisma.default.purchaseInvoice.count({
                where: whereClause
            })
        ]);
        return _server.NextResponse.json({
            data: purchases,
            pagination: {
                total: totalCount,
                page,
                limit,
                totalPages: Math.ceil(totalCount / limit)
            }
        });
    } catch (error) {
        console.error("Error fetching purchase invoices:", error);
        const message = error instanceof Error ? error.message : "An unknown error occurred";
        return _server.NextResponse.json({
            error: {
                message: "Failed to fetch purchase invoices",
                details: message
            }
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    try {
        const body = await request.json();
        // Generate a more robust invoice number
        if (!body.invoiceNumber) {
            const today = new Date();
            const year = today.getFullYear().toString().slice(-2); // Last 2 digits of year
            const month = (today.getMonth() + 1).toString().padStart(2, "0"); // Month (01-12)
            const day = today.getDate().toString().padStart(2, "0"); // Day (01-31)
            // Get count of invoices for today to make it sequential, or use a random part
            // For simplicity, using a timestamp fragment for uniqueness here.
            // In a real app, a dedicated sequence generator per day/month is better.
            const randomPart = Math.floor(Math.random() * 1000).toString().padStart(3, "0");
            body.invoiceNumber = `PI-${year}${month}${day}-${randomPart}`;
        }
        // Extract items and distributions from the request
        const { items, distributions, totalAmount, paidAmount, date, dueDate, notes: _notes, ..._rest } = body;
        // Only include fields that exist in the Prisma schema
        const invoiceData = {
            invoiceNumber: body.invoiceNumber,
            supplierId: parseInt(body.supplierId) || 0,
            total: totalAmount || 0,
            status: body.status || "unpaid",
            date: date ? new Date(date) : null,
            dueDate: dueDate ? new Date(dueDate) : null,
            distributions: distributions
        };
        // Create the purchase invoice with items in a transaction
        const purchase = await _prisma.default.$transaction(async (tx)=>{
            // Create the purchase invoice
            const createdInvoice = await tx.purchaseInvoice.create({
                data: invoiceData
            });
            const inventoryUpdates = [];
            // Create the purchase invoice items and update inventory
            if (items && Array.isArray(items)) {
                for(let i = 0; i < items.length; i++){
                    const item = items[i];
                    const itemDistribution = distributions && distributions[i] ? distributions[i] : null;
                    // Create purchase invoice item
                    await tx.purchaseInvoiceItem.create({
                        data: {
                            purchaseInvoiceId: createdInvoice.id,
                            productId: parseInt(item.productId),
                            quantity: item.quantity,
                            price: item.price || 0,
                            total: item.quantity * item.price || 0
                        }
                    });
                    // Get current product data
                    const product = await tx.product.findUnique({
                        where: {
                            id: parseInt(item.productId)
                        },
                        select: {
                            id: true,
                            weightedAverageCost: true
                        }
                    });
                    // Get current inventory quantity for this product across all shops
                    const inventoryItems = await tx.inventoryItem.findMany({
                        where: {
                            productId: parseInt(item.productId)
                        }
                    });
                    const currentTotalQuantity = inventoryItems.reduce((sum, inv)=>sum + inv.quantity, 0);
                    const newQuantity = item.quantity;
                    const currentCost = product?.weightedAverageCost || 0;
                    const newCost = item.price;
                    // Calculate new weighted average cost using proper formula
                    // WAC = (Current Total Value + New Purchase Value) / (Current Quantity + New Quantity)
                    let newWeightedAverageCost = newCost; // Default to new cost if there's no existing inventory
                    if (currentTotalQuantity > 0 && currentCost > 0) {
                        const currentTotalValue = currentTotalQuantity * currentCost;
                        const newPurchaseValue = newQuantity * newCost;
                        const totalValue = currentTotalValue + newPurchaseValue;
                        const totalQuantity = currentTotalQuantity + newQuantity;
                        newWeightedAverageCost = totalValue / totalQuantity;
                    }
                    // Ensure WAC is valid and positive
                    if (newWeightedAverageCost <= 0 || isNaN(newWeightedAverageCost)) {
                        newWeightedAverageCost = newCost;
                    }
                    // Update product with new weighted average cost
                    await tx.product.update({
                        where: {
                            id: parseInt(item.productId)
                        },
                        data: {
                            weightedAverageCost: newWeightedAverageCost
                        }
                    });
                    // Handle distribution across shops
                    if (itemDistribution && Object.keys(itemDistribution).length > 0) {
                        // Process only the current item's distribution object
                        const shopQuantities = {};
                        // Process only the distribution object for this specific item (at index i)
                        if (itemDistribution && typeof itemDistribution === "object") {
                            for (const [shopIdStr, quantity] of Object.entries(itemDistribution)){
                                const qty = Number(quantity);
                                if (qty > 0 && !isNaN(qty)) {
                                    shopQuantities[shopIdStr] = qty; // Use the exact quantity, not accumulated
                                }
                            }
                        }
                        // Distribute to specific shops as aggregated
                        for (const [shopIdStr, totalQty] of Object.entries(shopQuantities)){
                            const shopId = shopIdStr; // Keep shopId as string
                            const qty = totalQty;
                            if (qty <= 0) continue;
                            const existingInventory = await tx.inventoryItem.findFirst({
                                where: {
                                    productId: parseInt(item.productId),
                                    shopId: shopId
                                }
                            });
                            let finalQuantity = 0;
                            if (existingInventory) {
                                const currentQuantity = existingInventory.quantity;
                                const currentCost = existingInventory.shopSpecificCost || 0;
                                const newTotalQuantity = currentQuantity + qty;
                                let newShopSpecificCost = newCost; // item.price
                                if (currentQuantity > 0 && currentCost > 0) {
                                    const currentTotalValue = currentQuantity * currentCost;
                                    const newTotalValue = qty * newCost;
                                    newShopSpecificCost = (currentTotalValue + newTotalValue) / newTotalQuantity;
                                } else if (currentQuantity === 0 && newTotalQuantity > 0) {
                                    newShopSpecificCost = newCost;
                                }
                                finalQuantity = newTotalQuantity;
                                await tx.inventoryItem.update({
                                    where: {
                                        id: existingInventory.id
                                    },
                                    data: {
                                        quantity: finalQuantity,
                                        shopSpecificCost: newShopSpecificCost >= 0 ? newShopSpecificCost : 0
                                    }
                                });
                            } else {
                                finalQuantity = qty;
                                await tx.inventoryItem.create({
                                    data: {
                                        productId: parseInt(item.productId),
                                        shopId: shopId,
                                        quantity: finalQuantity,
                                        shopSpecificCost: newCost >= 0 ? newCost : 0
                                    }
                                });
                            }
                            inventoryUpdates.push({
                                productId: parseInt(item.productId),
                                shopId: parseInt(shopId),
                                newQuantity: finalQuantity
                            });
                        }
                    } else {
                        // No explicit distribution: attempt to infer shop
                        console.warn(`No distribution for product ${item.productId} in purchase. Attempting to infer shop.`);
                        const existingInventoriesForProduct = await tx.inventoryItem.findMany({
                            where: {
                                productId: parseInt(item.productId)
                            }
                        });
                        let inferredShopId = null;
                        if (existingInventoriesForProduct.length === 1) {
                            inferredShopId = existingInventoriesForProduct[0].shopId;
                            console.log(`Product ${item.productId} found in single shop ${inferredShopId}. Will update there.`);
                        } else if (existingInventoriesForProduct.length === 0) {
                            console.error(`Product ${item.productId} is new to inventory and no shop distribution provided. Cannot automatically assign to a shop. Inventory not updated for this item.`);
                        } else {
                            console.error(`Product ${item.productId} exists in multiple shops and no specific distribution provided. Ambiguous. Inventory not updated for this item.`);
                        }
                        if (inferredShopId) {
                            const qty = item.quantity;
                            if (qty > 0) {
                                const inventoryInInferredShop = await tx.inventoryItem.findFirst({
                                    where: {
                                        productId: parseInt(item.productId),
                                        shopId: inferredShopId
                                    }
                                });
                                let finalQuantity = 0;
                                if (inventoryInInferredShop) {
                                    const currentQuantity = inventoryInInferredShop.quantity;
                                    const currentShopCost = inventoryInInferredShop.shopSpecificCost || 0;
                                    const newTotalQuantity = currentQuantity + qty;
                                    let newShopSpecificCost = newCost; // item.price
                                    if (currentQuantity > 0 && currentShopCost > 0) {
                                        const currentTotalValue = currentQuantity * currentShopCost;
                                        const newTotalValue = qty * newCost;
                                        newShopSpecificCost = (currentTotalValue + newTotalValue) / newTotalQuantity;
                                    } else if (currentQuantity === 0 && newTotalQuantity > 0) {
                                        newShopSpecificCost = newCost;
                                    }
                                    finalQuantity = newTotalQuantity;
                                    await tx.inventoryItem.update({
                                        where: {
                                            id: inventoryInInferredShop.id
                                        },
                                        data: {
                                            quantity: finalQuantity,
                                            shopSpecificCost: newShopSpecificCost >= 0 ? newShopSpecificCost : 0
                                        }
                                    });
                                } else {
                                    // This case should ideally not be hit if existingInventoriesForProduct.length === 1
                                    // because it means we found it in that list. But for safety:
                                    finalQuantity = qty;
                                    await tx.inventoryItem.create({
                                        data: {
                                            productId: parseInt(item.productId),
                                            shopId: inferredShopId,
                                            quantity: finalQuantity,
                                            shopSpecificCost: newCost >= 0 ? newCost : 0
                                        }
                                    });
                                }
                                inventoryUpdates.push({
                                    productId: parseInt(item.productId),
                                    shopId: parseInt(inferredShopId),
                                    newQuantity: finalQuantity
                                });
                            } else {
                                console.warn(`Quantity for product ${item.productId} in inferred shop ${inferredShopId} is zero or negative. No inventory update.`);
                            }
                        }
                    }
                }
            }
            // If there's a paidAmount, create a payment record
            if (body.paidAmount && body.paidAmount > 0) {
                await tx.payment.create({
                    data: {
                        amount: parseFloat(body.paidAmount) || 0,
                        paymentMethod: body.paymentMethod || "cash",
                        invoice: {
                            connect: {
                                id: newInvoice.id
                            }
                        }
                    }
                });
            }
            // Fetch the complete invoice with items
            const fullInvoice = await tx.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoice.id
                },
                include: {
                    supplier: true,
                    items: {
                        include: {
                            product: true
                        }
                    }
                }
            });
            return {
                invoice: fullInvoice,
                inventoryUpdates
            };
        }, {
            timeout: 20000
        } // 20 seconds timeout
        );
        // Real-time updates now handled by polling system
        // After successful transaction, invalidate relevant caches
        try {
            await _cache.cacheService.invalidateInventory(); // Handles 'inventory:summary:*' and 'products:*'
            await _cache.cacheService.del("dashboard:inventory");
            await _cache.cacheService.del("dashboard:inventory-value");
            await _cache.cacheService.del("dashboard:shops");
            await _cache.cacheService.del("dashboard:all");
            await _cache.cacheService.del("dashboard:summary"); // As per DASHBOARD_PERFORMANCE_OPTIMIZATIONS.md
            // Invalidate purchases-specific caches
            await _cache.cacheService.invalidatePattern("purchases-optimized*");
            await _cache.cacheService.invalidatePattern("purchase-stats*");
            console.log("Relevant caches invalidated after purchase creation.");
        } catch (cacheError) {
            console.error("Error invalidating caches after purchase creation:", cacheError);
        // Do not let cache invalidation error fail the main operation
        }
        return _server.NextResponse.json({
            success: true,
            message: "Purchase invoice created successfully",
            data: purchase.invoice
        }, {
            status: 201
        });
    } catch (error) {
        console.error("Error creating purchase invoice:", error);
        const message = error instanceof Error ? error.message : "An unknown error occurred";
        return _server.NextResponse.json({
            error: {
                message: "Failed to create purchase invoice",
                details: message
            }
        }, {
            status: 500
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vc3JjL2FwcC9hcGkvcHVyY2hhc2VzL3JvdXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgcHJpc21hIGZyb20gJ0AvbGliL3ByaXNtYSc7XG5cblxuaW1wb3J0IHsgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IgfSBmcm9tICdAcHJpc21hL2NsaWVudC9ydW50aW1lL2xpYnJhcnknO1xuaW1wb3J0IHsgZ2V0VG9rZW4gfSBmcm9tICduZXh0LWF1dGgvand0JztcbmltcG9ydCB7IGNhY2hlU2VydmljZSB9IGZyb20gJ0AvbGliL2NhY2hlJztcblxuLy8gR0VUIC9hcGkvcHVyY2hhc2VzIC0gR2V0IGFsbCBwdXJjaGFzZSBpbnZvaWNlc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgY29uc3Qgc2VhcmNoID0gc2VhcmNoUGFyYW1zLmdldCgnc2VhcmNoJykgfHwgJyc7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHNlYXJjaFBhcmFtcy5nZXQoJ3N0YXR1cycpO1xuICAgICAgICBjb25zdCBzdXBwbGllcklkID0gc2VhcmNoUGFyYW1zLmdldCgnc3VwcGxpZXJJZCcpO1xuICAgICAgICBjb25zdCBzdGFydERhdGUgPSBzZWFyY2hQYXJhbXMuZ2V0KCdzdGFydERhdGUnKTtcbiAgICAgICAgY29uc3QgZW5kRGF0ZSA9IHNlYXJjaFBhcmFtcy5nZXQoJ2VuZERhdGUnKTtcbiAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KHNlYXJjaFBhcmFtcy5nZXQoJ3BhZ2UnKSB8fCAnMScpO1xuICAgICAgICBjb25zdCBsaW1pdCA9IHBhcnNlSW50KHNlYXJjaFBhcmFtcy5nZXQoJ2xpbWl0JykgfHwgJzEwJyk7XG4gICAgICAgIGNvbnN0IHNraXAgPSAocGFnZSAtIDEpICogbGltaXQ7XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIHdoZXJlIGNsYXVzZSBmb3IgUHJpc21hXG4gICAgICAgIGNvbnN0IHdoZXJlQ2xhdXNlOiBhbnkgPSB7fTtcblxuICAgICAgICBpZiAoc2VhcmNoKSB7XG4gICAgICAgICAgICAvLyBTZWFyY2ggYWNyb3NzIG11bHRpcGxlIGZpZWxkczogaW52b2ljZU51bWJlciwgc3VwcGxpZXIgbmFtZSwgaXRlbSBwcm9kdWN0IG5hbWVcbiAgICAgICAgICAgIHdoZXJlQ2xhdXNlLk9SID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2ljZU51bWJlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6IHNlYXJjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdpbnNlbnNpdGl2ZSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdXBwbGllcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBzZWFyY2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ2luc2Vuc2l0aXZlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2hpbmcgYnkgaXRlbSBwcm9kdWN0IG5hbWUgcmVxdWlyZXMgYSBtb3JlIGNvbXBsZXggcXVlcnkgaWYgd2Ugd2FudCB0byBrZWVwIGl0IGVmZmljaWVudC5cbiAgICAgICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSBub3csIHdlJ2xsIHN0aWNrIHRvIGludm9pY2VOdW1iZXIgYW5kIHN1cHBsaWVyIG5hbWUgZm9yIHRoZSBtYWluIHNlYXJjaC5cbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IG5hbWUgc2VhcmNoIGlzIGNyaXRpY2FsLCBpdCBtaWdodCBuZWVkIGEgc2VwYXJhdGUgaGFuZGxpbmcgb3IgZGlmZmVyZW50IGRhdGEgc3RydWN0dXJlLlxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHdoZXJlQ2xhdXNlLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdXBwbGllcklkKSB7XG4gICAgICAgICAgICB3aGVyZUNsYXVzZS5zdXBwbGllcklkID0gcGFyc2VJbnQoc3VwcGxpZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnREYXRlICYmIGVuZERhdGUpIHtcbiAgICAgICAgICAgIHdoZXJlQ2xhdXNlLmRhdGUgPSB7IC8vIEFzc3VtaW5nIGZpbHRlciBieSBpbnZvaWNlIGRhdGUsIG5vdCBjcmVhdGVkQXRcbiAgICAgICAgICAgICAgICBndGU6IG5ldyBEYXRlKHN0YXJ0RGF0ZSksXG4gICAgICAgICAgICAgICAgbHRlOiBuZXcgRGF0ZShlbmREYXRlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydERhdGUpIHtcbiAgICAgICAgICAgIHdoZXJlQ2xhdXNlLmRhdGUgPSB7XG4gICAgICAgICAgICAgICAgZ3RlOiBuZXcgRGF0ZShzdGFydERhdGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGVuZERhdGUpIHtcbiAgICAgICAgICAgIHdoZXJlQ2xhdXNlLmRhdGUgPSB7XG4gICAgICAgICAgICAgICAgbHRlOiBuZXcgRGF0ZShlbmREYXRlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFtwdXJjaGFzZXMsIHRvdGFsQ291bnRdID0gYXdhaXQgcHJpc21hLiR0cmFuc2FjdGlvbihbXG4gICAgICAgICAgICBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRNYW55KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogd2hlcmVDbGF1c2UsXG4gICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICBzdXBwbGllcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaG9uZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza3U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JkZXJCeToge1xuICAgICAgICAgICAgICAgICAgICBkYXRlOiAnZGVzYycgLy8gTW9yZSBjb21tb24gdG8gc29ydCBieSBpbnZvaWNlIGRhdGVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNraXA6IHNraXAsXG4gICAgICAgICAgICAgICAgdGFrZTogbGltaXRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5jb3VudCh7IHdoZXJlOiB3aGVyZUNsYXVzZSB9KVxuICAgICAgICBdKTtcblxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgZGF0YTogcHVyY2hhc2VzLFxuICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbENvdW50LFxuICAgICAgICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICAgICAgdG90YWxQYWdlczogTWF0aC5jZWlsKHRvdGFsQ291bnQgLyBsaW1pdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcHVyY2hhc2UgaW52b2ljZXM6JywgZXJyb3IpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCc7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgIHsgZXJyb3I6IHsgbWVzc2FnZTogJ0ZhaWxlZCB0byBmZXRjaCBwdXJjaGFzZSBpbnZvaWNlcycsIGRldGFpbHM6IG1lc3NhZ2UgfSB9LFxuICAgICAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vLyBQT1NUIC9hcGkvcHVyY2hhc2VzIC0gQ3JlYXRlIGEgbmV3IHB1cmNoYXNlIGludm9pY2VcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGEgbW9yZSByb2J1c3QgaW52b2ljZSBudW1iZXJcbiAgICAgICAgaWYgKCFib2R5Lmludm9pY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHllYXIgPSB0b2RheS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkuc2xpY2UoLTIpOyAvLyBMYXN0IDIgZGlnaXRzIG9mIHllYXJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoID0gKHRvZGF5LmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7IC8vIE1vbnRoICgwMS0xMilcbiAgICAgICAgICAgIGNvbnN0IGRheSA9IHRvZGF5LmdldERhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7IC8vIERheSAoMDEtMzEpXG4gICAgICAgICAgICAvLyBHZXQgY291bnQgb2YgaW52b2ljZXMgZm9yIHRvZGF5IHRvIG1ha2UgaXQgc2VxdWVudGlhbCwgb3IgdXNlIGEgcmFuZG9tIHBhcnRcbiAgICAgICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB1c2luZyBhIHRpbWVzdGFtcCBmcmFnbWVudCBmb3IgdW5pcXVlbmVzcyBoZXJlLlxuICAgICAgICAgICAgLy8gSW4gYSByZWFsIGFwcCwgYSBkZWRpY2F0ZWQgc2VxdWVuY2UgZ2VuZXJhdG9yIHBlciBkYXkvbW9udGggaXMgYmV0dGVyLlxuICAgICAgICAgICAgY29uc3QgcmFuZG9tUGFydCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApLnRvU3RyaW5nKCkucGFkU3RhcnQoMywgJzAnKTtcbiAgICAgICAgICAgIGJvZHkuaW52b2ljZU51bWJlciA9IGBQSS0ke3llYXJ9JHttb250aH0ke2RheX0tJHtyYW5kb21QYXJ0fWA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHRyYWN0IGl0ZW1zIGFuZCBkaXN0cmlidXRpb25zIGZyb20gdGhlIHJlcXVlc3RcbiAgICAgICAgY29uc3QgeyBpdGVtcywgZGlzdHJpYnV0aW9ucywgdG90YWxBbW91bnQsIHBhaWRBbW91bnQsIGRhdGUsIGR1ZURhdGUsIG5vdGVzOiBfbm90ZXMsIC4uLl9yZXN0IH0gPSBib2R5O1xuXG4gICAgICAgIC8vIE9ubHkgaW5jbHVkZSBmaWVsZHMgdGhhdCBleGlzdCBpbiB0aGUgUHJpc21hIHNjaGVtYVxuICAgICAgICBjb25zdCBpbnZvaWNlRGF0YTogYW55ID0ge1xuICAgICAgICAgICAgaW52b2ljZU51bWJlcjogYm9keS5pbnZvaWNlTnVtYmVyLFxuICAgICAgICAgICAgc3VwcGxpZXJJZDogcGFyc2VJbnQoYm9keS5zdXBwbGllcklkIGFzIHVua25vd24gYXMgc3RyaW5nKSB8fCAwLFxuICAgICAgICAgICAgdG90YWw6IHRvdGFsQW1vdW50IHx8IDAsXG4gICAgICAgICAgICBzdGF0dXM6IGJvZHkuc3RhdHVzIHx8ICd1bnBhaWQnLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZSA/IG5ldyBEYXRlKGRhdGUpIDogbnVsbCxcbiAgICAgICAgICAgIGR1ZURhdGU6IGR1ZURhdGUgPyBuZXcgRGF0ZShkdWVEYXRlKSA6IG51bGwsXG4gICAgICAgICAgICBkaXN0cmlidXRpb25zOiBkaXN0cmlidXRpb25zXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBwdXJjaGFzZSBpbnZvaWNlIHdpdGggaXRlbXMgaW4gYSB0cmFuc2FjdGlvblxuICAgICAgICBjb25zdCBwdXJjaGFzZSA9IGF3YWl0IHByaXNtYS4kdHJhbnNhY3Rpb24oXG4gICAgICAgICAgICBhc3luYyAodHgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHB1cmNoYXNlIGludm9pY2VcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGVkSW52b2ljZSA9IGF3YWl0IHR4LnB1cmNoYXNlSW52b2ljZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpbnZvaWNlRGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW52ZW50b3J5VXBkYXRlczogQXJyYXk8eyBwcm9kdWN0SWQ6IG51bWJlciwgc2hvcElkOiBudW1iZXIsIG5ld1F1YW50aXR5OiBudW1iZXIgfT4gPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcHVyY2hhc2UgaW52b2ljZSBpdGVtcyBhbmQgdXBkYXRlIGludmVudG9yeVxuICAgICAgICAgICAgICAgIGlmIChpdGVtcyAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtRGlzdHJpYnV0aW9uID0gZGlzdHJpYnV0aW9ucyAmJiBkaXN0cmlidXRpb25zW2ldID8gZGlzdHJpYnV0aW9uc1tpXSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwdXJjaGFzZSBpbnZvaWNlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LnB1cmNoYXNlSW52b2ljZUl0ZW0uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1cmNoYXNlSW52b2ljZUlkOiBjcmVhdGVkSW52b2ljZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwYXJzZUludChpdGVtLnByb2R1Y3RJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogaXRlbS5wcmljZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogKGl0ZW0ucXVhbnRpdHkgKiBpdGVtLnByaWNlKSB8fCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IHByb2R1Y3QgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IHR4LnByb2R1Y3QuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHBhcnNlSW50KGl0ZW0ucHJvZHVjdElkKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDogeyBpZDogdHJ1ZSwgd2VpZ2h0ZWRBdmVyYWdlQ29zdDogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgaW52ZW50b3J5IHF1YW50aXR5IGZvciB0aGlzIHByb2R1Y3QgYWNyb3NzIGFsbCBzaG9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW52ZW50b3J5SXRlbXMgPSBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLmZpbmRNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHBhcnNlSW50KGl0ZW0ucHJvZHVjdElkKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFRvdGFsUXVhbnRpdHkgPSBpbnZlbnRvcnlJdGVtcy5yZWR1Y2UoKHN1bSwgaW52KSA9PiBzdW0gKyBpbnYucXVhbnRpdHksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UXVhbnRpdHkgPSBpdGVtLnF1YW50aXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENvc3QgPSBwcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb3N0ID0gaXRlbS5wcmljZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyB3ZWlnaHRlZCBhdmVyYWdlIGNvc3QgdXNpbmcgcHJvcGVyIGZvcm11bGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdBQyA9IChDdXJyZW50IFRvdGFsIFZhbHVlICsgTmV3IFB1cmNoYXNlIFZhbHVlKSAvIChDdXJyZW50IFF1YW50aXR5ICsgTmV3IFF1YW50aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1dlaWdodGVkQXZlcmFnZUNvc3QgPSBuZXdDb3N0OyAvLyBEZWZhdWx0IHRvIG5ldyBjb3N0IGlmIHRoZXJlJ3Mgbm8gZXhpc3RpbmcgaW52ZW50b3J5XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VG90YWxRdWFudGl0eSA+IDAgJiYgY3VycmVudENvc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFRvdGFsVmFsdWUgPSBjdXJyZW50VG90YWxRdWFudGl0eSAqIGN1cnJlbnRDb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1B1cmNoYXNlVmFsdWUgPSBuZXdRdWFudGl0eSAqIG5ld0Nvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxWYWx1ZSA9IGN1cnJlbnRUb3RhbFZhbHVlICsgbmV3UHVyY2hhc2VWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFF1YW50aXR5ID0gY3VycmVudFRvdGFsUXVhbnRpdHkgKyBuZXdRdWFudGl0eTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1dlaWdodGVkQXZlcmFnZUNvc3QgPSB0b3RhbFZhbHVlIC8gdG90YWxRdWFudGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIFdBQyBpcyB2YWxpZCBhbmQgcG9zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdXZWlnaHRlZEF2ZXJhZ2VDb3N0IDw9IDAgfHwgaXNOYU4obmV3V2VpZ2h0ZWRBdmVyYWdlQ29zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdXZWlnaHRlZEF2ZXJhZ2VDb3N0ID0gbmV3Q29zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHByb2R1Y3Qgd2l0aCBuZXcgd2VpZ2h0ZWQgYXZlcmFnZSBjb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5wcm9kdWN0LnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHBhcnNlSW50KGl0ZW0ucHJvZHVjdElkKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgd2VpZ2h0ZWRBdmVyYWdlQ29zdDogbmV3V2VpZ2h0ZWRBdmVyYWdlQ29zdCB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGRpc3RyaWJ1dGlvbiBhY3Jvc3Mgc2hvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtRGlzdHJpYnV0aW9uICYmIE9iamVjdC5rZXlzKGl0ZW1EaXN0cmlidXRpb24pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIG9ubHkgdGhlIGN1cnJlbnQgaXRlbSdzIGRpc3RyaWJ1dGlvbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG9wUXVhbnRpdGllczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3Mgb25seSB0aGUgZGlzdHJpYnV0aW9uIG9iamVjdCBmb3IgdGhpcyBzcGVjaWZpYyBpdGVtIChhdCBpbmRleCBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtRGlzdHJpYnV0aW9uICYmIHR5cGVvZiBpdGVtRGlzdHJpYnV0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtzaG9wSWRTdHIsIHF1YW50aXR5XSBvZiBPYmplY3QuZW50cmllcyhpdGVtRGlzdHJpYnV0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcXR5ID0gTnVtYmVyKHF1YW50aXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdHkgPiAwICYmICFpc05hTihxdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcFF1YW50aXRpZXNbc2hvcElkU3RyXSA9IHF0eTsgLy8gVXNlIHRoZSBleGFjdCBxdWFudGl0eSwgbm90IGFjY3VtdWxhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzdHJpYnV0ZSB0byBzcGVjaWZpYyBzaG9wcyBhcyBhZ2dyZWdhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbc2hvcElkU3RyLCB0b3RhbFF0eV0gb2YgT2JqZWN0LmVudHJpZXMoc2hvcFF1YW50aXRpZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3BJZCA9IHNob3BJZFN0cjsgLy8gS2VlcCBzaG9wSWQgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF0eSA9IHRvdGFsUXR5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdHkgPD0gMCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJbnZlbnRvcnkgPSBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcGFyc2VJbnQoaXRlbS5wcm9kdWN0SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BJZDogc2hvcElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaW5hbFF1YW50aXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nSW52ZW50b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UXVhbnRpdHkgPSBleGlzdGluZ0ludmVudG9yeS5xdWFudGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb3N0ID0gZXhpc3RpbmdJbnZlbnRvcnkuc2hvcFNwZWNpZmljQ29zdCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VG90YWxRdWFudGl0eSA9IGN1cnJlbnRRdWFudGl0eSArIHF0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdTaG9wU3BlY2lmaWNDb3N0ID0gbmV3Q29zdDsgLy8gaXRlbS5wcmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWFudGl0eSA+IDAgJiYgY3VycmVudENvc3QgPiAwKSB7IC8vIGVuc3VyZSBjdXJyZW50Q29zdCBpcyBhbHNvIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFRvdGFsVmFsdWUgPSBjdXJyZW50UXVhbnRpdHkgKiBjdXJyZW50Q29zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUb3RhbFZhbHVlID0gcXR5ICogbmV3Q29zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTaG9wU3BlY2lmaWNDb3N0ID0gKGN1cnJlbnRUb3RhbFZhbHVlICsgbmV3VG90YWxWYWx1ZSkgLyBuZXdUb3RhbFF1YW50aXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UXVhbnRpdHkgPT09IDAgJiYgbmV3VG90YWxRdWFudGl0eSA+IDApIHsgLy8gRmlyc3Qgc3RvY2sgZm9yIHRoaXMgaXRlbSBpbiB0aGlzIHNob3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTaG9wU3BlY2lmaWNDb3N0ID0gbmV3Q29zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFF1YW50aXR5ID0gbmV3VG90YWxRdWFudGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0udXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZlbnRvcnkuaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBmaW5hbFF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wU3BlY2lmaWNDb3N0OiBuZXdTaG9wU3BlY2lmaWNDb3N0ID49IDAgPyBuZXdTaG9wU3BlY2lmaWNDb3N0IDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxRdWFudGl0eSA9IHF0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHR4LmludmVudG9yeUl0ZW0uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcGFyc2VJbnQoaXRlbS5wcm9kdWN0SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IHNob3BJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGZpbmFsUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BTcGVjaWZpY0Nvc3Q6IG5ld0Nvc3QgPj0gMCA/IG5ld0Nvc3QgOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52ZW50b3J5VXBkYXRlcy5wdXNoKHsgcHJvZHVjdElkOiBwYXJzZUludChpdGVtLnByb2R1Y3RJZCksIHNob3BJZDogcGFyc2VJbnQoc2hvcElkKSwgbmV3UXVhbnRpdHk6IGZpbmFsUXVhbnRpdHkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBleHBsaWNpdCBkaXN0cmlidXRpb246IGF0dGVtcHQgdG8gaW5mZXIgc2hvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgTm8gZGlzdHJpYnV0aW9uIGZvciBwcm9kdWN0ICR7aXRlbS5wcm9kdWN0SWR9IGluIHB1cmNoYXNlLiBBdHRlbXB0aW5nIHRvIGluZmVyIHNob3AuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJbnZlbnRvcmllc0ZvclByb2R1Y3QgPSBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLmZpbmRNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwYXJzZUludChpdGVtLnByb2R1Y3RJZCkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZmVycmVkU2hvcElkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdJbnZlbnRvcmllc0ZvclByb2R1Y3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmVycmVkU2hvcElkID0gZXhpc3RpbmdJbnZlbnRvcmllc0ZvclByb2R1Y3RbMF0uc2hvcElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvZHVjdCAke2l0ZW0ucHJvZHVjdElkfSBmb3VuZCBpbiBzaW5nbGUgc2hvcCAke2luZmVycmVkU2hvcElkfS4gV2lsbCB1cGRhdGUgdGhlcmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0ludmVudG9yaWVzRm9yUHJvZHVjdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUHJvZHVjdCAke2l0ZW0ucHJvZHVjdElkfSBpcyBuZXcgdG8gaW52ZW50b3J5IGFuZCBubyBzaG9wIGRpc3RyaWJ1dGlvbiBwcm92aWRlZC4gQ2Fubm90IGF1dG9tYXRpY2FsbHkgYXNzaWduIHRvIGEgc2hvcC4gSW52ZW50b3J5IG5vdCB1cGRhdGVkIGZvciB0aGlzIGl0ZW0uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gTW9yZSB0aGFuIDEgc2hvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBQcm9kdWN0ICR7aXRlbS5wcm9kdWN0SWR9IGV4aXN0cyBpbiBtdWx0aXBsZSBzaG9wcyBhbmQgbm8gc3BlY2lmaWMgZGlzdHJpYnV0aW9uIHByb3ZpZGVkLiBBbWJpZ3VvdXMuIEludmVudG9yeSBub3QgdXBkYXRlZCBmb3IgdGhpcyBpdGVtLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZlcnJlZFNob3BJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBxdHkgPSBpdGVtLnF1YW50aXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW52ZW50b3J5SW5JbmZlcnJlZFNob3AgPSBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwYXJzZUludChpdGVtLnByb2R1Y3RJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BJZDogaW5mZXJyZWRTaG9wSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsUXVhbnRpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludmVudG9yeUluSW5mZXJyZWRTaG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFF1YW50aXR5ID0gaW52ZW50b3J5SW5JbmZlcnJlZFNob3AucXVhbnRpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNob3BDb3N0ID0gaW52ZW50b3J5SW5JbmZlcnJlZFNob3Auc2hvcFNwZWNpZmljQ29zdCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RvdGFsUXVhbnRpdHkgPSBjdXJyZW50UXVhbnRpdHkgKyBxdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Nob3BTcGVjaWZpY0Nvc3QgPSBuZXdDb3N0OyAvLyBpdGVtLnByaWNlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFF1YW50aXR5ID4gMCAmJiBjdXJyZW50U2hvcENvc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb3RhbFZhbHVlID0gY3VycmVudFF1YW50aXR5ICogY3VycmVudFNob3BDb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUb3RhbFZhbHVlID0gcXR5ICogbmV3Q29zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2hvcFNwZWNpZmljQ29zdCA9IChjdXJyZW50VG90YWxWYWx1ZSArIG5ld1RvdGFsVmFsdWUpIC8gbmV3VG90YWxRdWFudGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRRdWFudGl0eSA9PT0gMCAmJiBuZXdUb3RhbFF1YW50aXR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTaG9wU3BlY2lmaWNDb3N0ID0gbmV3Q29zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFF1YW50aXR5ID0gbmV3VG90YWxRdWFudGl0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5pbnZlbnRvcnlJdGVtLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBpbnZlbnRvcnlJbkluZmVycmVkU2hvcC5pZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZmluYWxRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BTcGVjaWZpY0Nvc3Q6IG5ld1Nob3BTcGVjaWZpY0Nvc3QgPj0gMCA/IG5ld1Nob3BTcGVjaWZpY0Nvc3QgOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYXNlIHNob3VsZCBpZGVhbGx5IG5vdCBiZSBoaXQgaWYgZXhpc3RpbmdJbnZlbnRvcmllc0ZvclByb2R1Y3QubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBtZWFucyB3ZSBmb3VuZCBpdCBpbiB0aGF0IGxpc3QuIEJ1dCBmb3Igc2FmZXR5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsUXVhbnRpdHkgPSBxdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdHguaW52ZW50b3J5SXRlbS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHBhcnNlSW50KGl0ZW0ucHJvZHVjdElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BJZDogaW5mZXJyZWRTaG9wSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZmluYWxRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3BTcGVjaWZpY0Nvc3Q6IG5ld0Nvc3QgPj0gMCA/IG5ld0Nvc3QgOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmVudG9yeVVwZGF0ZXMucHVzaCh7IHByb2R1Y3RJZDogcGFyc2VJbnQoaXRlbS5wcm9kdWN0SWQpLCBzaG9wSWQ6IHBhcnNlSW50KGluZmVycmVkU2hvcElkKSwgbmV3UXVhbnRpdHk6IGZpbmFsUXVhbnRpdHkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFF1YW50aXR5IGZvciBwcm9kdWN0ICR7aXRlbS5wcm9kdWN0SWR9IGluIGluZmVycmVkIHNob3AgJHtpbmZlcnJlZFNob3BJZH0gaXMgemVybyBvciBuZWdhdGl2ZS4gTm8gaW52ZW50b3J5IHVwZGF0ZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBwYWlkQW1vdW50LCBjcmVhdGUgYSBwYXltZW50IHJlY29yZFxuICAgICAgICAgICAgICAgIGlmIChib2R5LnBhaWRBbW91bnQgJiYgYm9keS5wYWlkQW1vdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0eC5wYXltZW50LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBwYXJzZUZsb2F0KGJvZHkucGFpZEFtb3VudCBhcyB1bmtub3duIGFzIHN0cmluZykgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50TWV0aG9kOiBib2R5LnBheW1lbnRNZXRob2QgfHwgJ2Nhc2gnLCAvLyBEZWZhdWx0IG9yIGZyb20gYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9pY2U6IHsgY29ubmVjdDogeyBpZDogbmV3SW52b2ljZS5pZCB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGNvbXBsZXRlIGludm9pY2Ugd2l0aCBpdGVtc1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxJbnZvaWNlID0gYXdhaXQgdHgucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogY3JlYXRlZEludm9pY2UuaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcGxpZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogeyBpbmNsdWRlOiB7IHByb2R1Y3Q6IHRydWUgfSB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGludm9pY2U6IGZ1bGxJbnZvaWNlLCBpbnZlbnRvcnlVcGRhdGVzIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyB0aW1lb3V0OiAyMDAwMCB9IC8vIDIwIHNlY29uZHMgdGltZW91dFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFJlYWwtdGltZSB1cGRhdGVzIG5vdyBoYW5kbGVkIGJ5IHBvbGxpbmcgc3lzdGVtXG5cbiAgICAgICAgLy8gQWZ0ZXIgc3VjY2Vzc2Z1bCB0cmFuc2FjdGlvbiwgaW52YWxpZGF0ZSByZWxldmFudCBjYWNoZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5pbnZhbGlkYXRlSW52ZW50b3J5KCk7IC8vIEhhbmRsZXMgJ2ludmVudG9yeTpzdW1tYXJ5OionIGFuZCAncHJvZHVjdHM6KidcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5kZWwoJ2Rhc2hib2FyZDppbnZlbnRvcnknKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5kZWwoJ2Rhc2hib2FyZDppbnZlbnRvcnktdmFsdWUnKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5kZWwoJ2Rhc2hib2FyZDpzaG9wcycpO1xuICAgICAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLmRlbCgnZGFzaGJvYXJkOmFsbCcpO1xuICAgICAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLmRlbCgnZGFzaGJvYXJkOnN1bW1hcnknKTsgLy8gQXMgcGVyIERBU0hCT0FSRF9QRVJGT1JNQU5DRV9PUFRJTUlaQVRJT05TLm1kXG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHB1cmNoYXNlcy1zcGVjaWZpYyBjYWNoZXNcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5pbnZhbGlkYXRlUGF0dGVybigncHVyY2hhc2VzLW9wdGltaXplZConKTtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5pbnZhbGlkYXRlUGF0dGVybigncHVyY2hhc2Utc3RhdHMqJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVsZXZhbnQgY2FjaGVzIGludmFsaWRhdGVkIGFmdGVyIHB1cmNoYXNlIGNyZWF0aW9uLicpO1xuICAgICAgICB9IGNhdGNoIChjYWNoZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbnZhbGlkYXRpbmcgY2FjaGVzIGFmdGVyIHB1cmNoYXNlIGNyZWF0aW9uOicsIGNhY2hlRXJyb3IpO1xuICAgICAgICAgICAgLy8gRG8gbm90IGxldCBjYWNoZSBpbnZhbGlkYXRpb24gZXJyb3IgZmFpbCB0aGUgbWFpbiBvcGVyYXRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogJ1B1cmNoYXNlIGludm9pY2UgY3JlYXRlZCBzdWNjZXNzZnVsbHknLCBkYXRhOiBwdXJjaGFzZS5pbnZvaWNlIH0sXG4gICAgICAgICAgICB7IHN0YXR1czogMjAxIH1cbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBwdXJjaGFzZSBpbnZvaWNlOicsIGVycm9yKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICB7IGVycm9yOiB7IG1lc3NhZ2U6ICdGYWlsZWQgdG8gY3JlYXRlIHB1cmNoYXNlIGludm9pY2UnLCBkZXRhaWxzOiBtZXNzYWdlIH0gfSxcbiAgICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgICApO1xuICAgIH1cbn0iXSwibmFtZXMiOlsiR0VUIiwiUE9TVCIsInJlcXVlc3QiLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJ1cmwiLCJzZWFyY2giLCJnZXQiLCJzdGF0dXMiLCJzdXBwbGllcklkIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInBhZ2UiLCJwYXJzZUludCIsImxpbWl0Iiwic2tpcCIsIndoZXJlQ2xhdXNlIiwiT1IiLCJpbnZvaWNlTnVtYmVyIiwiY29udGFpbnMiLCJtb2RlIiwic3VwcGxpZXIiLCJuYW1lIiwiZGF0ZSIsImd0ZSIsIkRhdGUiLCJsdGUiLCJwdXJjaGFzZXMiLCJ0b3RhbENvdW50IiwicHJpc21hIiwiJHRyYW5zYWN0aW9uIiwicHVyY2hhc2VJbnZvaWNlIiwiZmluZE1hbnkiLCJ3aGVyZSIsImluY2x1ZGUiLCJzZWxlY3QiLCJpZCIsImVtYWlsIiwicGhvbmUiLCJpdGVtcyIsInByb2R1Y3QiLCJza3UiLCJvcmRlckJ5IiwidGFrZSIsImNvdW50IiwiTmV4dFJlc3BvbnNlIiwianNvbiIsImRhdGEiLCJwYWdpbmF0aW9uIiwidG90YWwiLCJ0b3RhbFBhZ2VzIiwiTWF0aCIsImNlaWwiLCJlcnJvciIsImNvbnNvbGUiLCJtZXNzYWdlIiwiRXJyb3IiLCJkZXRhaWxzIiwiYm9keSIsInRvZGF5IiwieWVhciIsImdldEZ1bGxZZWFyIiwidG9TdHJpbmciLCJzbGljZSIsIm1vbnRoIiwiZ2V0TW9udGgiLCJwYWRTdGFydCIsImRheSIsImdldERhdGUiLCJyYW5kb21QYXJ0IiwiZmxvb3IiLCJyYW5kb20iLCJkaXN0cmlidXRpb25zIiwidG90YWxBbW91bnQiLCJwYWlkQW1vdW50IiwiZHVlRGF0ZSIsIm5vdGVzIiwiX25vdGVzIiwiX3Jlc3QiLCJpbnZvaWNlRGF0YSIsInB1cmNoYXNlIiwidHgiLCJjcmVhdGVkSW52b2ljZSIsImNyZWF0ZSIsImludmVudG9yeVVwZGF0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwibGVuZ3RoIiwiaXRlbSIsIml0ZW1EaXN0cmlidXRpb24iLCJwdXJjaGFzZUludm9pY2VJdGVtIiwicHVyY2hhc2VJbnZvaWNlSWQiLCJwcm9kdWN0SWQiLCJxdWFudGl0eSIsInByaWNlIiwiZmluZFVuaXF1ZSIsIndlaWdodGVkQXZlcmFnZUNvc3QiLCJpbnZlbnRvcnlJdGVtcyIsImludmVudG9yeUl0ZW0iLCJjdXJyZW50VG90YWxRdWFudGl0eSIsInJlZHVjZSIsInN1bSIsImludiIsIm5ld1F1YW50aXR5IiwiY3VycmVudENvc3QiLCJuZXdDb3N0IiwibmV3V2VpZ2h0ZWRBdmVyYWdlQ29zdCIsImN1cnJlbnRUb3RhbFZhbHVlIiwibmV3UHVyY2hhc2VWYWx1ZSIsInRvdGFsVmFsdWUiLCJ0b3RhbFF1YW50aXR5IiwiaXNOYU4iLCJ1cGRhdGUiLCJPYmplY3QiLCJrZXlzIiwic2hvcFF1YW50aXRpZXMiLCJzaG9wSWRTdHIiLCJlbnRyaWVzIiwicXR5IiwiTnVtYmVyIiwidG90YWxRdHkiLCJzaG9wSWQiLCJleGlzdGluZ0ludmVudG9yeSIsImZpbmRGaXJzdCIsImZpbmFsUXVhbnRpdHkiLCJjdXJyZW50UXVhbnRpdHkiLCJzaG9wU3BlY2lmaWNDb3N0IiwibmV3VG90YWxRdWFudGl0eSIsIm5ld1Nob3BTcGVjaWZpY0Nvc3QiLCJuZXdUb3RhbFZhbHVlIiwicHVzaCIsIndhcm4iLCJleGlzdGluZ0ludmVudG9yaWVzRm9yUHJvZHVjdCIsImluZmVycmVkU2hvcElkIiwibG9nIiwiaW52ZW50b3J5SW5JbmZlcnJlZFNob3AiLCJjdXJyZW50U2hvcENvc3QiLCJwYXltZW50IiwiYW1vdW50IiwicGFyc2VGbG9hdCIsInBheW1lbnRNZXRob2QiLCJpbnZvaWNlIiwiY29ubmVjdCIsIm5ld0ludm9pY2UiLCJmdWxsSW52b2ljZSIsInRpbWVvdXQiLCJjYWNoZVNlcnZpY2UiLCJpbnZhbGlkYXRlSW52ZW50b3J5IiwiZGVsIiwiaW52YWxpZGF0ZVBhdHRlcm4iLCJjYWNoZUVycm9yIiwic3VjY2VzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7SUFTc0JBLEdBQUc7ZUFBSEE7O0lBa0hBQyxJQUFJO2VBQUpBOzs7d0JBM0hvQjsrREFDdkI7dUJBS1U7Ozs7OztBQUd0QixlQUFlRCxJQUFJRSxPQUFvQjtJQUMxQyxJQUFJO1FBQ0EsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBRyxJQUFJQyxJQUFJRixRQUFRRyxHQUFHO1FBQzVDLE1BQU1DLFNBQVNILGFBQWFJLEdBQUcsQ0FBQyxhQUFhO1FBQzdDLE1BQU1DLFNBQVNMLGFBQWFJLEdBQUcsQ0FBQztRQUNoQyxNQUFNRSxhQUFhTixhQUFhSSxHQUFHLENBQUM7UUFDcEMsTUFBTUcsWUFBWVAsYUFBYUksR0FBRyxDQUFDO1FBQ25DLE1BQU1JLFVBQVVSLGFBQWFJLEdBQUcsQ0FBQztRQUNqQyxNQUFNSyxPQUFPQyxTQUFTVixhQUFhSSxHQUFHLENBQUMsV0FBVztRQUNsRCxNQUFNTyxRQUFRRCxTQUFTVixhQUFhSSxHQUFHLENBQUMsWUFBWTtRQUNwRCxNQUFNUSxPQUFPLEFBQUNILENBQUFBLE9BQU8sQ0FBQSxJQUFLRTtRQUUxQixvQ0FBb0M7UUFDcEMsTUFBTUUsY0FBbUIsQ0FBQztRQUUxQixJQUFJVixRQUFRO1lBQ1IsaUZBQWlGO1lBQ2pGVSxZQUFZQyxFQUFFLEdBQUc7Z0JBQ2I7b0JBQ0lDLGVBQWU7d0JBQ1hDLFVBQVViO3dCQUNWYyxNQUFNO29CQUNWO2dCQUNKO2dCQUNBO29CQUNJQyxVQUFVO3dCQUNOQyxN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