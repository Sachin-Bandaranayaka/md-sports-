2b73a2b40f24235986db96a5992ac38b
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    authOptions: function() {
        return authOptions;
    },
    extractToken: function() {
        return extractToken;
    },
    getShopIdFromToken: function() {
        return getShopIdFromToken;
    },
    getUserIdFromToken: function() {
        return getUserIdFromToken;
    },
    validateTokenPermission: function() {
        return validateTokenPermission;
    },
    verifyToken: function() {
        return verifyToken;
    }
});
const _jose = /*#__PURE__*/ _interop_require_wildcard(require("jose"));
const _prisma = /*#__PURE__*/ _interop_require_default(require("./prisma"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const JWT_SECRET = process.env.JWT_SECRET || "default-secret-key-for-development";
const secretKey = new TextEncoder().encode(JWT_SECRET);
const authOptions = {
    secret: JWT_SECRET,
    session: {
        strategy: "jwt",
        maxAge: 24 * 60 * 60
    },
    callbacks: {
        async jwt ({ token, user }) {
            if (user) {
                token.id = user.id;
                token.permissions = user.permissions;
            }
            return token;
        },
        async session ({ session, token }) {
            if (token && session.user) {
                session.user.id = token.id;
                session.user.permissions = token.permissions;
            }
            return session;
        }
    }
};
const verifyToken = async (token)=>{
    try {
        const { payload } = await _jose.jwtVerify(token, secretKey, {
        });
        return payload;
    } catch (error) {
        if (error.code === "ERR_JWT_EXPIRED") {
            console.error("Token expired:", error.message);
        } else if (error.code === "ERR_JWS_INVALID" || error.code === "ERR_JWS_SIGNATURE_VERIFICATION_FAILED" || error.code === "ERR_JWT_CLAIM_VALIDATION_FAILED") {
            console.error("Invalid token:", error.message);
        } else {
            console.error("Token verification error:", error.message);
        }
        return null;
    }
};
const extractToken = (req)=>{
    const authHeader = req.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return null;
    }
    return authHeader.split(" ")[1];
};
const validateTokenPermission = async (req, permission)=>{
    try {
        const token = extractToken(req);
        console.log(`Checking permission "${permission}" with token: ${token ? `${token.substring(0, 10)}...` : "none"}`);
        if (!token) {
            console.error("No token provided when checking permission:", permission);
            return {
                isValid: false,
                message: "Authentication required"
            };
        }
        // Special case for development token
        if (token === "dev-token") {
            console.log(`Development mode: granting permission '${permission}'`);
            return {
                isValid: true
            };
        }
        const payload = await verifyToken(token);
        console.log("Token payload:", payload);
        if (!payload || typeof payload !== "object" || !("sub" in payload)) {
            console.error("Invalid token payload when checking permission:", permission);
            return {
                isValid: false,
                message: "Invalid authentication token"
            };
        }
        const userId = Number(payload.sub);
        // Check if permission is in the token payload directly
        if (payload.permissions && Array.isArray(payload.permissions)) {
            const hasPermission = payload.permissions.includes(permission);
            console.log(`Permission check from token for "${permission}": ${hasPermission ? "GRANTED" : "DENIED"}`);
            if (hasPermission) {
                return {
                    isValid: true
                };
            }
        }
        // If not in token or as fallback, get user with permissions from database
        const user = await _prisma.default.user.findUnique({
            where: {
                id: userId
            }
        });
        if (!user) {
            console.error(`User not found for ID: ${userId}`);
            return {
                isValid: false,
                message: "User not found"
            };
        }
        if (!user.permissions || !Array.isArray(user.permissions)) {
            console.error(`User ${userId} has no permissions array`);
            return {
                isValid: false,
                message: "User has no permissions"
            };
        }
        // Check if user has the required permission
        console.log(`User ${userId} permissions:`, user.permissions);
        const hasPermission = user.permissions.includes(permission);
        console.log(`Permission check result for "${permission}": ${hasPermission ? "GRANTED" : "DENIED"}`);
        return {
            isValid: hasPermission,
            message: hasPermission ? undefined : `Permission denied: '${permission}' is required`
        };
    } catch (error) {
        console.error(`Error checking permission ${permission}:`, error);
        return {
            isValid: false,
            message: `Error checking permission: ${error instanceof Error ? error.message : String(error)}`
        };
    }
};
const getUserIdFromToken = async (req)=>{
    const token = extractToken(req);
    if (!token) {
        return null;
    }
    // Special case for development token
    if (token === "dev-token") {
        return 1; // Development user ID
    }
    const payload = await verifyToken(token);
    if (!payload || typeof payload !== "object" || !("sub" in payload)) {
        return null;
    }
    return Number(payload.sub);
};
const getShopIdFromToken = async (req)=>{
    const token = extractToken(req);
    if (!token) {
        return null;
    }
    // Special case for development token - assign to first shop for testing shop staff behavior
    if (token === "dev-token") {
        return "cmbtr9q6l000061romoxi7uvf"; // Assign dev-token to first shop from database
    }
    const payload = await verifyToken(token);
    if (!payload || typeof payload !== "object") {
        return null;
    }
    // Extract shop ID from token as string to match database schema
    return "shopId" in payload ? String(payload.shopId) : null;
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vc3JjL2xpYi9hdXRoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuLy8gaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nOyByZXBsYWNlZFxuaW1wb3J0ICogYXMgam9zZSBmcm9tICdqb3NlJztcbmltcG9ydCBwcmlzbWEgZnJvbSAnQC9saWIvcHJpc21hJztcblxuY29uc3QgSldUX1NFQ1JFVCA9IHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgfHwgJ2RlZmF1bHQtc2VjcmV0LWtleS1mb3ItZGV2ZWxvcG1lbnQnO1xuY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKEpXVF9TRUNSRVQpO1xuXG4vLyBFeHBvcnQgYXV0aE9wdGlvbnMgZm9yIE5leHRBdXRoXG5leHBvcnQgY29uc3QgYXV0aE9wdGlvbnMgPSB7XG4gIHNlY3JldDogSldUX1NFQ1JFVCxcbiAgc2Vzc2lvbjoge1xuICAgIHN0cmF0ZWd5OiAnand0JyBhcyBjb25zdCxcbiAgICBtYXhBZ2U6IDI0ICogNjAgKiA2MCwgLy8gMjQgaG91cnNcbiAgfSxcbiAgY2FsbGJhY2tzOiB7XG4gICAgYXN5bmMgand0KHsgdG9rZW4sIHVzZXIgfTogeyB0b2tlbjogYW55OyB1c2VyPzogYW55IH0pIHtcbiAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgIHRva2VuLmlkID0gdXNlci5pZDtcbiAgICAgICAgdG9rZW4ucGVybWlzc2lvbnMgPSB1c2VyLnBlcm1pc3Npb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0sXG4gICAgYXN5bmMgc2Vzc2lvbih7IHNlc3Npb24sIHRva2VuIH06IHsgc2Vzc2lvbjogYW55OyB0b2tlbjogYW55IH0pIHtcbiAgICAgIGlmICh0b2tlbiAmJiBzZXNzaW9uLnVzZXIpIHtcbiAgICAgICAgc2Vzc2lvbi51c2VyLmlkID0gdG9rZW4uaWQ7XG4gICAgICAgIHNlc3Npb24udXNlci5wZXJtaXNzaW9ucyA9IHRva2VuLnBlcm1pc3Npb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhIEpXVCB0b2tlblxuICovXG5leHBvcnQgY29uc3QgdmVyaWZ5VG9rZW4gPSBhc3luYyAodG9rZW46IHN0cmluZyk6IFByb21pc2U8am9zZS5KV1RQYXlsb2FkIHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgam9zZS5qd3RWZXJpZnkodG9rZW4sIHNlY3JldEtleSwge1xuICAgICAgICAgICAgLy8gQXNzdW1pbmcgSFMyNTYgYWxnb3JpdGhtLCBhZGp1c3QgaWYgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBhbGdvcml0aG1zOiBbJ0hTMjU2J10gXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnRVJSX0pXVF9FWFBJUkVEJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gZXhwaXJlZDonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5jb2RlID09PSAnRVJSX0pXU19JTlZBTElEJyB8fCBlcnJvci5jb2RlID09PSAnRVJSX0pXU19TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxFRCcgfHwgZXJyb3IuY29kZSA9PT0gJ0VSUl9KV1RfQ0xBSU1fVkFMSURBVElPTl9GQUlMRUQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHRva2VuOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gdmVyaWZpY2F0aW9uIGVycm9yOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogRXh0cmFjdCB0b2tlbiBmcm9tIGF1dGhvcml6YXRpb24gaGVhZGVyXG4gKi9cbmV4cG9ydCBjb25zdCBleHRyYWN0VG9rZW4gPSAocmVxOiBOZXh0UmVxdWVzdCk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgIGNvbnN0IGF1dGhIZWFkZXIgPSByZXEuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aEhlYWRlci5zcGxpdCgnICcpWzFdO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBpZiBhIHVzZXIgaGFzIGEgc3BlY2lmaWMgcGVybWlzc2lvblxuICogQHBhcmFtIHJlcSAtIE5leHQuanMgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSBwZXJtaXNzaW9uIC0gUGVybWlzc2lvbiBzdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGlzVmFsaWQgZmxhZyBhbmQgb3B0aW9uYWwgZXJyb3IgbWVzc2FnZVxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVUb2tlblBlcm1pc3Npb24gPSBhc3luYyAocmVxOiBOZXh0UmVxdWVzdCwgcGVybWlzc2lvbjogc3RyaW5nKTogUHJvbWlzZTx7IGlzVmFsaWQ6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gZXh0cmFjdFRva2VuKHJlcSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDaGVja2luZyBwZXJtaXNzaW9uIFwiJHtwZXJtaXNzaW9ufVwiIHdpdGggdG9rZW46ICR7dG9rZW4gPyBgJHt0b2tlbi5zdWJzdHJpbmcoMCwgMTApfS4uLmAgOiAnbm9uZSd9YCk7XG5cbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gdG9rZW4gcHJvdmlkZWQgd2hlbiBjaGVja2luZyBwZXJtaXNzaW9uOicsIHBlcm1pc3Npb24pO1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIG1lc3NhZ2U6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZGV2ZWxvcG1lbnQgdG9rZW5cbiAgICAgICAgaWYgKHRva2VuID09PSAnZGV2LXRva2VuJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYERldmVsb3BtZW50IG1vZGU6IGdyYW50aW5nIHBlcm1pc3Npb24gJyR7cGVybWlzc2lvbn0nYCk7XG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdmVyaWZ5VG9rZW4odG9rZW4pO1xuICAgICAgICBjb25zb2xlLmxvZygnVG9rZW4gcGF5bG9hZDonLCBwYXlsb2FkKTtcblxuICAgICAgICBpZiAoIXBheWxvYWQgfHwgdHlwZW9mIHBheWxvYWQgIT09ICdvYmplY3QnIHx8ICEoJ3N1YicgaW4gcGF5bG9hZCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdG9rZW4gcGF5bG9hZCB3aGVuIGNoZWNraW5nIHBlcm1pc3Npb246JywgcGVybWlzc2lvbik7XG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgbWVzc2FnZTogJ0ludmFsaWQgYXV0aGVudGljYXRpb24gdG9rZW4nIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1c2VySWQgPSBOdW1iZXIocGF5bG9hZC5zdWIpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHBlcm1pc3Npb24gaXMgaW4gdGhlIHRva2VuIHBheWxvYWQgZGlyZWN0bHlcbiAgICAgICAgaWYgKHBheWxvYWQucGVybWlzc2lvbnMgJiYgQXJyYXkuaXNBcnJheShwYXlsb2FkLnBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgY29uc3QgaGFzUGVybWlzc2lvbiA9IHBheWxvYWQucGVybWlzc2lvbnMuaW5jbHVkZXMocGVybWlzc2lvbik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUGVybWlzc2lvbiBjaGVjayBmcm9tIHRva2VuIGZvciBcIiR7cGVybWlzc2lvbn1cIjogJHtoYXNQZXJtaXNzaW9uID8gJ0dSQU5URUQnIDogJ0RFTklFRCd9YCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChoYXNQZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm90IGluIHRva2VuIG9yIGFzIGZhbGxiYWNrLCBnZXQgdXNlciB3aXRoIHBlcm1pc3Npb25zIGZyb20gZGF0YWJhc2VcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHByaXNtYS51c2VyLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVXNlciBub3QgZm91bmQgZm9yIElEOiAke3VzZXJJZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnVXNlciBub3QgZm91bmQnIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVzZXIucGVybWlzc2lvbnMgfHwgIUFycmF5LmlzQXJyYXkodXNlci5wZXJtaXNzaW9ucykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVzZXIgJHt1c2VySWR9IGhhcyBubyBwZXJtaXNzaW9ucyBhcnJheWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIG1lc3NhZ2U6ICdVc2VyIGhhcyBubyBwZXJtaXNzaW9ucycgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgaGFzIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uXG4gICAgICAgIGNvbnNvbGUubG9nKGBVc2VyICR7dXNlcklkfSBwZXJtaXNzaW9uczpgLCB1c2VyLnBlcm1pc3Npb25zKTtcbiAgICAgICAgY29uc3QgaGFzUGVybWlzc2lvbiA9IHVzZXIucGVybWlzc2lvbnMuaW5jbHVkZXMocGVybWlzc2lvbik7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQZXJtaXNzaW9uIGNoZWNrIHJlc3VsdCBmb3IgXCIke3Blcm1pc3Npb259XCI6ICR7aGFzUGVybWlzc2lvbiA/ICdHUkFOVEVEJyA6ICdERU5JRUQnfWApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1ZhbGlkOiBoYXNQZXJtaXNzaW9uLFxuICAgICAgICAgICAgbWVzc2FnZTogaGFzUGVybWlzc2lvbiA/IHVuZGVmaW5lZCA6IGBQZXJtaXNzaW9uIGRlbmllZDogJyR7cGVybWlzc2lvbn0nIGlzIHJlcXVpcmVkYFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNoZWNraW5nIHBlcm1pc3Npb24gJHtwZXJtaXNzaW9ufTpgLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiBgRXJyb3IgY2hlY2tpbmcgcGVybWlzc2lvbjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHVzZXIgSUQgZnJvbSB0b2tlblxuICovXG5leHBvcnQgY29uc3QgZ2V0VXNlcklkRnJvbVRva2VuID0gYXN5bmMgKHJlcTogTmV4dFJlcXVlc3QpOiBQcm9taXNlPG51bWJlciB8IG51bGw+ID0+IHtcbiAgICBjb25zdCB0b2tlbiA9IGV4dHJhY3RUb2tlbihyZXEpO1xuXG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGRldmVsb3BtZW50IHRva2VuXG4gICAgaWYgKHRva2VuID09PSAnZGV2LXRva2VuJykge1xuICAgICAgICByZXR1cm4gMTsgLy8gRGV2ZWxvcG1lbnQgdXNlciBJRFxuICAgIH1cblxuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB2ZXJpZnlUb2tlbih0b2tlbik7XG5cbiAgICBpZiAoIXBheWxvYWQgfHwgdHlwZW9mIHBheWxvYWQgIT09ICdvYmplY3QnIHx8ICEoJ3N1YicgaW4gcGF5bG9hZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIE51bWJlcihwYXlsb2FkLnN1Yik7XG59O1xuXG4vKipcbiAqIEdldCBzaG9wIElEIGZyb20gdG9rZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNob3BJZEZyb21Ub2tlbiA9IGFzeW5jIChyZXE6IE5leHRSZXF1ZXN0KTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiA9PiB7XG4gICAgY29uc3QgdG9rZW4gPSBleHRyYWN0VG9rZW4ocmVxKTtcblxuICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBkZXZlbG9wbWVudCB0b2tlbiAtIGFzc2lnbiB0byBmaXJzdCBzaG9wIGZvciB0ZXN0aW5nIHNob3Agc3RhZmYgYmVoYXZpb3JcbiAgICBpZiAodG9rZW4gPT09ICdkZXYtdG9rZW4nKSB7XG4gICAgICAgIHJldHVybiAnY21idHI5cTZsMDAwMDYxcm9tb3hpN3V2Zic7IC8vIEFzc2lnbiBkZXYtdG9rZW4gdG8gZmlyc3Qgc2hvcCBmcm9tIGRhdGFiYXNlXG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHZlcmlmeVRva2VuKHRva2VuKTtcblxuICAgIGlmICghcGF5bG9hZCB8fCB0eXBlb2YgcGF5bG9hZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBzaG9wIElEIGZyb20gdG9rZW4gYXMgc3RyaW5nIHRvIG1hdGNoIGRhdGFiYXNlIHNjaGVtYVxuICAgIHJldHVybiAnc2hvcElkJyBpbiBwYXlsb2FkID8gU3RyaW5nKHBheWxvYWQuc2hvcElkKSA6IG51bGw7XG59OyJdLCJuYW1lcyI6WyJhdXRoT3B0aW9ucyIsImV4dHJhY3RUb2tlbiIsImdldFNob3BJZEZyb21Ub2tlbiIsImdldFVzZXJJZEZyb21Ub2tlbiIsInZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uIiwidmVyaWZ5VG9rZW4iLCJKV1RfU0VDUkVUIiwicHJvY2VzcyIsImVudiIsInNlY3JldEtleSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwic2VjcmV0Iiwic2Vzc2lvbiIsInN0cmF0ZWd5IiwibWF4QWdlIiwiY2FsbGJhY2tzIiwiand0IiwidG9rZW4iLCJ1c2VyIiwiaWQiLCJwZXJtaXNzaW9ucyIsInBheWxvYWQiLCJqb3NlIiwiand0VmVyaWZ5IiwiZXJyb3IiLCJjb2RlIiwiY29uc29sZSIsIm1lc3NhZ2UiLCJyZXEiLCJhdXRoSGVhZGVyIiwiaGVhZGVycyIsImdldCIsInN0YXJ0c1dpdGgiLCJzcGxpdCIsInBlcm1pc3Npb24iLCJsb2ciLCJzdWJzdHJpbmciLCJpc1ZhbGlkIiwidXNlcklkIiwiTnVtYmVyIiwic3ViIiwiQXJyYXkiLCJpc0FycmF5IiwiaGFzUGVybWlzc2lvbiIsImluY2x1ZGVzIiwicHJpc21hIiwiZmluZFVuaXF1ZSIsIndoZXJlIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJTdHJpbmciLCJzaG9wSWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBU2FBLFdBQVc7ZUFBWEE7O0lBaURBQyxZQUFZO2VBQVpBOztJQTJHQUMsa0JBQWtCO2VBQWxCQTs7SUF4QkFDLGtCQUFrQjtlQUFsQkE7O0lBckVBQyx1QkFBdUI7ZUFBdkJBOztJQXBDQUMsV0FBVztlQUFYQTs7OzhEQWxDUzsrREFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFbkIsTUFBTUMsYUFBYUMsUUFBUUMsR0FBRyxDQUFDRixVQUFVLElBQUk7QUFDN0MsTUFBTUcsWUFBWSxJQUFJQyxjQUFjQyxNQUFNLENBQUNMO0FBR3BDLE1BQU1OLGNBQWM7SUFDekJZLFFBQVFOO0lBQ1JPLFNBQVM7UUFDUEMsVUFBVTtRQUNWQyxRQUFRLEtBQUssS0FBSztJQUNwQjtJQUNBQyxXQUFXO1FBQ1QsTUFBTUMsS0FBSSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBOEI7WUFDbkQsSUFBSUEsTUFBTTtnQkFDUkQsTUFBTUUsRUFBRSxHQUFHRCxLQUFLQyxFQUFFO2dCQUNsQkYsTUFBTUcsV0FBVyxHQUFHRixLQUFLRSxXQUFXO1lBQ3RDO1lBQ0EsT0FBT0g7UUFDVDtRQUNBLE1BQU1MLFNBQVEsRUFBRUEsT0FBTyxFQUFFSyxLQUFLLEVBQWdDO1lBQzVELElBQUlBLFNBQVNMLFFBQVFNLElBQUksRUFBRTtnQkFDekJOLFFBQVFNLElBQUksQ0FBQ0MsRUFBRSxHQUFHRixNQUFNRSxFQUFFO2dCQUMxQlAsUUFBUU0sSUFBSSxDQUFDRSxXQUFXLEdBQUdILE1BQU1HLFdBQVc7WUFDOUM7WUFDQSxPQUFPUjtRQUNUO0lBQ0Y7QUFDRjtBQUtPLE1BQU1SLGNBQWMsT0FBT2E7SUFDOUIsSUFBSTtRQUNBLE1BQU0sRUFBRUksT0FBTyxFQUFFLEdBQUcsTUFBTUMsTUFBS0MsU0FBUyxDQUFDTixPQUFPVCxXQUFXO1FBRzNEO1FBQ0EsT0FBT2E7SUFDWCxFQUFFLE9BQU9HLE9BQVk7UUFDakIsSUFBSUEsTUFBTUMsSUFBSSxLQUFLLG1CQUFtQjtZQUNsQ0MsUUFBUUYsS0FBSyxDQUFDLGtCQUFrQkEsTUFBTUcsT0FBTztRQUNqRCxPQUFPLElBQUlILE1BQU1DLElBQUksS0FBSyxxQkFBcUJELE1BQU1DLElBQUksS0FBSywyQ0FBMkNELE1BQU1DLElBQUksS0FBSyxtQ0FBbUM7WUFDdkpDLFFBQVFGLEtBQUssQ0FBQyxrQkFBa0JBLE1BQU1HLE9BQU87UUFDakQsT0FBTztZQUNIRCxRQUFRRixLQUFLLENBQUMsNkJBQTZCQSxNQUFNRyxPQUFPO1FBQzVEO1FBQ0EsT0FBTztJQUNYO0FBQ0o7QUFLTyxNQUFNM0IsZUFBZSxDQUFDNEI7SUFDekIsTUFBTUMsYUFBYUQsSUFBSUUsT0FBTyxDQUFDQyxHQUFHLENBQUM7SUFDbkMsSUFBSSxDQUFDRixjQUFjLENBQUNBLFdBQVdHLFVBQVUsQ0FBQyxZQUFZO1FBQ2xELE9BQU87SUFDWDtJQUNBLE9BQU9ILFdBQVdJLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNuQztBQVFPLE1BQU05QiwwQkFBMEIsT0FBT3lCLEtBQWtCTTtJQUM1RCxJQUFJO1FBQ0EsTUFBTWpCLFFBQVFqQixhQUFhNEI7UUFDM0JGLFFBQVFTLEdBQUcsQ0FBQyxDQUFDLHFCQUFxQixFQUFFRCxXQUFXLGNBQWMsRUFBRWpCLFFBQVEsQ0FBQyxFQUFFQSxNQUFNbUIsU0FBUyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7UUFFaEgsSUFBSSxDQUFDbkIsT0FBTztZQUNSUyxRQUFRRixLQUFLLENBQUMsK0NBQStDVTtZQUM3RCxPQUFPO2dCQUFFRyxTQUFTO2dCQUFPVixTQUFTO1lBQTBCO1FBQ2hFO1FBRUEscUNBQXFDO1FBQ3JDLElBQUlWLFVBQVUsYUFBYTtZQUN2QlMsUUFBUVMsR0FBRyxDQUFDLENBQUMsdUNBQXVDLEVBQUVELFdBQVcsQ0FBQyxDQUFDO1lBQ25FLE9BQU87Z0JBQUVHLFNBQVM7WUFBSztRQUMzQjtRQUVBLE1BQU1oQixVQUFVLE1BQU1qQixZQUFZYTtRQUNsQ1MsUUFBUVMsR0FBRyxDQUFDLGtCQUFrQmQ7UUFFOUIsSUFBSSxDQUFDQSxXQUFXLE9BQU9BLFlBQVksWUFBWSxDQUFFLENBQUEsU0FBU0EsT0FBTSxHQUFJO1lBQ2hFSyxRQUFRRixLQUFLLENBQUMsbURBQW1EVTtZQUNqRSxPQUFPO2dCQUFFRyxTQUFTO2dCQUFPVixTQUFTO1lBQStCO1FBQ3JFO1FBRUEsTUFBTVcsU0FBU0MsT0FBT2xCLFFBQVFtQixHQUFHO1FBRWpDLHVEQUF1RDtRQUN2RCxJQUFJbkIsUUFBUUQsV0FBVyxJQUFJcUIsTUFBTUMsT0FBTyxDQUFDckIsUUFBUUQsV0FBVyxHQUFHO1lBQzNELE1BQU11QixnQkFBZ0J0QixRQUFRRCxXQUFXLENBQUN3QixRQUFRLENBQUNWO1lBQ25EUixRQUFRUyxHQUFHLENBQUMsQ0FBQyxpQ0FBaUMsRUFBRUQsV0FBVyxHQUFHLEVBQUVTLGdCQUFnQixZQUFZLFNBQVMsQ0FBQztZQUV0RyxJQUFJQSxlQUFlO2dCQUNmLE9BQU87b0JBQUVOLFNBQVM7Z0JBQUs7WUFDM0I7UUFDSjtRQUVBLDBFQUEwRTtRQUMxRSxNQUFNbkIsT0FBTyxNQUFNMkIsZUFBTSxDQUFDM0IsSUFBSSxDQUFDNEIsVUFBVSxDQUFDO1lBQ3RDQyxPQUFPO2dCQUFFNUIsSUFBSW1CO1lBQU87UUFDeEI7UUFFQSxJQUFJLENBQUNwQixNQUFNO1lBQ1BRLFFBQVFGLEtBQUssQ0FBQyxDQUFDLHVCQUF1QixFQUFFYyxPQUFPLENBQUM7WUFDaEQsT0FBTztnQkFBRUQsU0FBUztnQkFBT1YsU0FBUztZQUFpQjtRQUN2RDtRQUVBLElBQUksQ0FBQ1QsS0FBS0UsV0FBVyxJQUFJLENBQUNxQixNQUFNQyxPQUFPLENBQUN4QixLQUFLRSxXQUFXLEdBQUc7WUFDdkRNLFFBQVFGLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRWMsT0FBTyx5QkFBeUIsQ0FBQztZQUN2RCxPQUFPO2dCQUFFRCxTQUFTO2dCQUFPVixTQUFTO1lBQTBCO1FBQ2hFO1FBRUEsNENBQTRDO1FBQzVDRCxRQUFRUyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUVHLE9BQU8sYUFBYSxDQUFDLEVBQUVwQixLQUFLRSxXQUFXO1FBQzNELE1BQU11QixnQkFBZ0J6QixLQUFLRSxXQUFXLENBQUN3QixRQUFRLENBQUNWO1FBQ2hEUixRQUFRUyxHQUFHLENBQUMsQ0FBQyw2QkFBNkIsRUFBRUQsV0FBVyxHQUFHLEVBQUVTLGdCQUFnQixZQUFZLFNBQVMsQ0FBQztRQUVsRyxPQUFPO1lBQ0hOLFNBQVNNO1lBQ1RoQixTQUFTZ0IsZ0JBQWdCSyxZQUFZLENBQUMsb0JBQW9CLEVBQUVkLFdBQVcsYUFBYSxDQUFDO1FBQ3pGO0lBQ0osRUFBRSxPQUFPVixPQUFPO1FBQ1pFLFFBQVFGLEtBQUssQ0FBQyxDQUFDLDBCQUEwQixFQUFFVSxXQUFXLENBQUMsQ0FBQyxFQUFFVjtRQUMxRCxPQUFPO1lBQUVhLFNBQVM7WUFBT1YsU0FBUyxDQUFDLDJCQUEyQixFQUFFSCxpQkFBaUJ5QixRQUFRekIsTUFBTUcsT0FBTyxHQUFHdUIsT0FBTzFCLE9BQU8sQ0FBQztRQUFDO0lBQzdIO0FBQ0o7QUFLTyxNQUFNdEIscUJBQXFCLE9BQU8wQjtJQUNyQyxNQUFNWCxRQUFRakIsYUFBYTRCO0lBRTNCLElBQUksQ0FBQ1gsT0FBTztRQUNSLE9BQU87SUFDWDtJQUVBLHFDQUFxQztJQUNyQyxJQUFJQSxVQUFVLGFBQWE7UUFDdkIsT0FBTyxHQUFHLHNCQUFzQjtJQUNwQztJQUVBLE1BQU1JLFVBQVUsTUFBTWpCLFlBQVlhO0lBRWxDLElBQUksQ0FBQ0ksV0FBVyxPQUFPQSxZQUFZLFlBQVksQ0FBRSxDQUFBLFNBQVNBLE9BQU0sR0FBSTtRQUNoRSxPQUFPO0lBQ1g7SUFFQSxPQUFPa0IsT0FBT2xCLFFBQVFtQixHQUFHO0FBQzdCO0FBS08sTUFBTXZDLHFCQUFxQixPQUFPMkI7SUFDckMsTUFBTVgsUUFBUWpCLGFBQWE0QjtJQUUzQixJQUFJLENBQUNYLE9BQU87UUFDUixPQUFPO0lBQ1g7SUFFQSw0RkFBNEY7SUFDNUYsSUFBSUEsVUFBVSxhQUFhO1FBQ3ZCLE9BQU8sNkJBQTZCLCtDQUErQztJQUN2RjtJQUVBLE1BQU1JLFVBQVUsTUFBTWpCLFlBQVlhO0lBRWxDLElBQUksQ0FBQ0ksV0FBVyxPQUFPQSxZQUFZLFVBQVU7UUFDekMsT0FBTztJQUNYO0lBRUEsZ0VBQWdFO0lBQ2hFLE9BQU8sWUFBWUEsVUFBVTZCLE9BQU83QixRQUFROEIsTUFBTSxJQUFJO0FBQzFEIn0=