{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/services/refreshTokenService.ts"],"sourcesContent":["import prisma from '@/lib/prisma';\n\n// Configuration\nconst REFRESH_TOKEN_EXPIRES_IN_DAYS = 30;\n\n// Generate a secure random token using Web Crypto API\nconst generateSecureToken = (length = 40): string => {\n    // Use Web Crypto API which is supported in Edge Runtime\n    if (typeof crypto !== 'undefined') {\n        const bytes = new Uint8Array(length);\n        crypto.getRandomValues(bytes);\n        return Array.from(bytes)\n            .map(byte => byte.toString(16).padStart(2, '0'))\n            .join('');\n    }\n\n    // Fallback (less secure but works everywhere)\n    return Array.from(\n        { length },\n        () => Math.floor(Math.random() * 16).toString(16)\n    ).join('');\n};\n\n/**\n * Generate a new refresh token for a user\n */\nexport const generateRefreshToken = async (userId: string): Promise<string> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            throw new Error('Database client not initialized correctly');\n        }\n\n        // Log for debugging\n        console.log('Generating refresh token for user ID:', userId);\n\n        // Generate a random token\n        const token = generateSecureToken(40);\n\n        // Calculate expiration date (30 days from now)\n        const expiresAt = new Date();\n        expiresAt.setDate(expiresAt.getDate() + REFRESH_TOKEN_EXPIRES_IN_DAYS);\n\n        // Log the token details before creating\n        console.log('Preparing to create refresh token with:', {\n            userId,\n            token: token.substring(0, 10) + '...',\n            expiresAt,\n        });\n\n        // Store the token in the database with retry logic\n        const createdToken = await executeWithRetry(() => \n            prisma.refreshToken.create({\n                data: {\n                    userId,\n                    token,\n                    expiresAt,\n                    updatedAt: new Date(),\n                },\n            })\n        );\n\n        console.log('Successfully created refresh token with ID:', createdToken.id);\n\n        return token;\n    } catch (error) {\n        // More detailed error logging\n        console.error('Error generating refresh token:', error);\n        if (error instanceof Error) {\n            console.error('Error message:', error.message);\n            console.error('Error stack:', error.stack);\n        }\n        throw new Error('Failed to generate refresh token');\n    }\n};\n\n/**\n * Helper function to execute Prisma queries with retry logic for prepared statement conflicts\n */\nconst executeWithRetry = async <T>(operation: () => Promise<T>, maxRetries = 3): Promise<T> => {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n            return await operation();\n        } catch (error: any) {\n            // Check if it's a prepared statement conflict error\n            if (error?.code === '42P05' && error?.message?.includes('prepared statement') && attempt < maxRetries) {\n                console.warn(`Prepared statement conflict on attempt ${attempt}, retrying...`);\n                // Small delay before retry\n                await new Promise(resolve => setTimeout(resolve, 100 * attempt));\n                continue;\n            }\n            throw error;\n        }\n    }\n    throw new Error('Max retries exceeded');\n};\n\n/**\n * Verify a refresh token and return the associated user ID if valid\n */\nexport const verifyRefreshToken = async (token: string): Promise<string | null> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return null;\n        }\n\n        // Find the token in the database with retry logic\n        const refreshToken = await executeWithRetry(() => \n            prisma.refreshToken.findUnique({\n                where: { token },\n            })\n        );\n\n        // Check if token exists and is not revoked\n        if (!refreshToken || refreshToken.isRevoked) {\n            console.log('Token not found or revoked:', token.substring(0, 10) + '...');\n            return null;\n        }\n\n        // Check if token is expired\n        if (new Date() > refreshToken.expiresAt) {\n            console.log('Token expired:', token.substring(0, 10) + '...');\n\n            // Revoke expired token with retry logic\n            await executeWithRetry(() => \n                prisma.refreshToken.update({\n                    where: { id: refreshToken.id },\n                    data: { isRevoked: true },\n                })\n            );\n\n            return null;\n        }\n\n        return refreshToken.userId;\n    } catch (error) {\n        console.error('Error verifying refresh token:', error);\n        return null;\n    }\n};\n\n/**\n * Revoke a specific refresh token\n */\nexport const revokeRefreshToken = async (token: string): Promise<boolean> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return false;\n        }\n\n        await executeWithRetry(() => \n            prisma.refreshToken.updateMany({\n                where: { token },\n                data: { isRevoked: true },\n            })\n        );\n\n        return true;\n    } catch (error) {\n        console.error('Error revoking refresh token:', error);\n        return false;\n    }\n};\n\n/**\n * Revoke all refresh tokens for a specific user\n */\nexport const revokeAllUserRefreshTokens = async (userId: string): Promise<boolean> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return false;\n        }\n\n        await executeWithRetry(() => \n            prisma.refreshToken.updateMany({\n                where: { userId },\n                data: { isRevoked: true },\n            })\n        );\n\n        return true;\n    } catch (error) {\n        console.error('Error revoking user refresh tokens:', error);\n        return false;\n    }\n};\n\n/**\n * Clean up expired and revoked tokens\n * Note: This should be run periodically via a cron job\n */\nexport const cleanupRefreshTokens = async (): Promise<void> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return;\n        }\n\n        const now = new Date();\n\n        await executeWithRetry(() => \n            prisma.refreshToken.deleteMany({\n                where: {\n                    OR: [\n                        { expiresAt: { lt: now } },\n                        { isRevoked: true },\n                    ],\n                },\n            })\n        );\n    } catch (error) {\n        console.error('Error cleaning up refresh tokens:', error);\n    }\n};"],"names":["cleanupRefreshTokens","generateRefreshToken","revokeAllUserRefreshTokens","revokeRefreshToken","verifyRefreshToken","REFRESH_TOKEN_EXPIRES_IN_DAYS","generateSecureToken","length","crypto","bytes","Uint8Array","getRandomValues","Array","from","map","byte","toString","padStart","join","Math","floor","random","userId","prisma","refreshToken","console","error","Error","log","token","expiresAt","Date","setDate","getDate","substring","createdToken","executeWithRetry","create","data","updatedAt","id","message","stack","operation","maxRetries","attempt","code","includes","warn","Promise","resolve","setTimeout","findUnique","where","isRevoked","update","updateMany","now","deleteMany","OR","lt"],"mappings":"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"}