{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/lib/services/PermissionService.ts"],"sourcesContent":["/**\n * Centralized Permission Service\n * \n * Provides a unified interface for permission checking with caching,\n * context-aware validation, and performance optimizations.\n */\n\nimport { PERMISSIONS, Permission, isValidPermission } from '@/lib/constants/permissions';\nimport { AuthenticatedUser } from '@/types/auth';\n\ninterface PermissionContext {\n  shopId?: string;\n  userId?: string;\n  resourceId?: string;\n  action?: string;\n}\n\ninterface CacheEntry {\n  result: boolean;\n  timestamp: number;\n  ttl: number;\n}\n\nclass PermissionService {\n  private cache = new Map<string, CacheEntry>();\n  private readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes\n  private readonly MAX_CACHE_SIZE = 1000;\n\n  /**\n   * Check if user has a specific permission\n   */\n  hasPermission(\n    user: AuthenticatedUser | null,\n    permission: Permission | string,\n    context?: PermissionContext\n  ): boolean {\n    if (!user || !user.permissions) {\n      return false;\n    }\n\n    // Validate permission format\n    if (!isValidPermission(permission)) {\n      console.warn(`Invalid permission format: ${permission}`);\n      return false;\n    }\n\n    // Generate cache key\n    const cacheKey = this.generateCacheKey(user.id, permission, context);\n    \n    // Check cache first\n    const cached = this.getFromCache(cacheKey);\n    if (cached !== null) {\n      return cached;\n    }\n\n    // Perform permission check\n    const result = this.checkPermission(user, permission, context);\n    \n    // Cache the result\n    this.setCache(cacheKey, result);\n    \n    return result;\n  }\n\n  /**\n   * Check if user has any of the specified permissions\n   */\n  hasAnyPermission(\n    user: AuthenticatedUser | null,\n    permissions: (Permission | string)[],\n    context?: PermissionContext\n  ): boolean {\n    return permissions.some(permission => \n      this.hasPermission(user, permission, context)\n    );\n  }\n\n  /**\n   * Check if user has all of the specified permissions\n   */\n  hasAllPermissions(\n    user: AuthenticatedUser | null,\n    permissions: (Permission | string)[],\n    context?: PermissionContext\n  ): boolean {\n    return permissions.every(permission => \n      this.hasPermission(user, permission, context)\n    );\n  }\n\n  /**\n   * Check if user is admin (has admin permissions)\n   */\n  isAdmin(user: AuthenticatedUser | null): boolean {\n    if (!user) return false;\n    \n    return this.hasAnyPermission(user, [\n      PERMISSIONS.ADMIN_ALL,\n      PERMISSIONS.LEGACY_ALL,\n      PERMISSIONS.WILDCARD\n    ]);\n  }\n\n  /**\n   * Check if user has shop-specific access\n   */\n  hasShopAccess(\n    user: AuthenticatedUser | null,\n    targetShopId: string,\n    permission: Permission | string\n  ): boolean {\n    if (!user) return false;\n\n    // Admin users have access to all shops\n    if (this.isAdmin(user)) {\n      return true;\n    }\n\n    // Check if user has shop:assigned_only restriction\n    if (user.permissions.includes(PERMISSIONS.SHOP_ASSIGNED_ONLY)) {\n      // User can only access their assigned shop\n      if (user.shopId !== targetShopId) {\n        return false;\n      }\n    }\n\n    // Check the specific permission\n    return this.hasPermission(user, permission, { shopId: targetShopId });\n  }\n\n  /**\n   * Checks if a user has a specific permission, ignoring wildcards.\n   * This is useful for checking for explicit restrictions.\n   */\n  hasExactPermission(\n    user: AuthenticatedUser | null,\n    permission: Permission | string\n  ): boolean {\n    if (!user || !user.permissions) {\n      return false;\n    }\n    return user.permissions.includes(permission);\n  }\n\n  /**\n   * Get user's accessible shop IDs based on permissions\n   */\n  getAccessibleShopIds(user: AuthenticatedUser | null): string[] {\n    if (!user) return [];\n\n    // Admin users have access to all shops\n    if (this.isAdmin(user)) {\n      return ['*']; // Wildcard for all shops\n    }\n\n    // Check if user has shop:assigned_only restriction\n    if (user.permissions.includes(PERMISSIONS.SHOP_ASSIGNED_ONLY)) {\n      return user.shopId ? [user.shopId] : [];\n    }\n\n    // For other users, return their assigned shop or all if they have shop:manage\n    if (this.hasPermission(user, PERMISSIONS.SHOP_MANAGE)) {\n      return ['*']; // Can manage all shops\n    }\n\n    return user.shopId ? [user.shopId] : [];\n  }\n\n  /**\n   * Clear permission cache for a user\n   */\n  clearUserCache(userId: string): void {\n    const keysToDelete = Array.from(this.cache.keys())\n      .filter(key => key.startsWith(`${userId}:`));\n    \n    keysToDelete.forEach(key => this.cache.delete(key));\n  }\n\n  /**\n   * Clear all permission cache\n   */\n  clearAllCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; hitRate: number } {\n    return {\n      size: this.cache.size,\n      hitRate: 0 // TODO: Implement hit rate tracking\n    };\n  }\n\n  // Private methods\n\n  private checkPermission(\n    user: AuthenticatedUser,\n    permission: Permission | string,\n    context?: PermissionContext\n  ): boolean {\n    // Check if permission is defined\n    if (!permission) {\n      return false;\n    }\n\n    const userPermissions = user.permissions || [];\n\n    // Check for wildcard permissions\n    if (userPermissions.includes(PERMISSIONS.WILDCARD) ||\n        userPermissions.includes(PERMISSIONS.LEGACY_ALL) ||\n        userPermissions.includes(PERMISSIONS.ADMIN_ALL)) {\n      return true;\n    }\n\n    // Check for exact permission match\n    if (userPermissions.includes(permission)) {\n      return true;\n    }\n\n    // Check for module-level permissions (e.g., 'sales:manage' includes 'sales:view')\n    if (permission && typeof permission === 'string' && permission.includes(':')) {\n      const [module, action] = permission.split(':');\n      if (action && userPermissions.includes(`${module}:manage`)) {\n        return true;\n      }\n    }\n\n    // Context-specific checks\n    if (context) {\n      return this.checkContextualPermission(user, permission, context);\n    }\n\n    return false;\n  }\n\n  private checkContextualPermission(\n    user: AuthenticatedUser,\n    permission: Permission | string,\n    context: PermissionContext\n  ): boolean {\n    // Shop-specific permission checks\n    if (context.shopId) {\n      // Check if user has shop:assigned_only and is accessing their shop\n      if (user.permissions.includes(PERMISSIONS.SHOP_ASSIGNED_ONLY)) {\n        return user.shopId === context.shopId;\n      }\n    }\n\n    // Add more contextual checks as needed\n    return false;\n  }\n\n  private generateCacheKey(\n    userId: string,\n    permission: Permission | string,\n    context?: PermissionContext\n  ): string {\n    const contextStr = context ? JSON.stringify(context) : '';\n    return `${userId}:${permission}:${contextStr}`;\n  }\n\n  private getFromCache(key: string): boolean | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    // Check if cache entry is expired\n    if (Date.now() > entry.timestamp + entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.result;\n  }\n\n  private setCache(key: string, result: boolean, ttl?: number): void {\n    // Implement LRU eviction if cache is full\n    if (this.cache.size >= this.MAX_CACHE_SIZE) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n\n    this.cache.set(key, {\n      result,\n      timestamp: Date.now(),\n      ttl: ttl || this.DEFAULT_TTL\n    });\n  }\n}\n\n// Export singleton instance\nexport const permissionService = new PermissionService();\nexport default permissionService;"],"names":["permissionService","PermissionService","hasPermission","user","permission","context","permissions","isValidPermission","console","warn","cacheKey","generateCacheKey","id","cached","getFromCache","result","checkPermission","setCache","hasAnyPermission","some","hasAllPermissions","every","isAdmin","PERMISSIONS","ADMIN_ALL","LEGACY_ALL","WILDCARD","hasShopAccess","targetShopId","includes","SHOP_ASSIGNED_ONLY","shopId","hasExactPermission","getAccessibleShopIds","SHOP_MANAGE","clearUserCache","userId","keysToDelete","Array","from","cache","keys","filter","key","startsWith","forEach","delete","clearAllCache","clear","getCacheStats","size","hitRate","userPermissions","module","action","split","checkContextualPermission","contextStr","JSON","stringify","entry","get","Date","now","timestamp","ttl","MAX_CACHE_SIZE","firstKey","next","value","set","DEFAULT_TTL","Map"],"mappings":"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"}