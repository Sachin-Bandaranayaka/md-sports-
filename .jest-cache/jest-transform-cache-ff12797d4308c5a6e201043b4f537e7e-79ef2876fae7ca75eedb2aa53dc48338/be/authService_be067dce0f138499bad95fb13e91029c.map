{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/services/authService.ts"],"sourcesContent":["import * as jwt from 'jsonwebtoken';\nimport * as bcrypt from 'bcryptjs';\nimport prisma from '../lib/prisma';\nimport { cacheService, CACHE_CONFIG } from '../lib/cache';\nimport { hasPermission as checkPermission } from '../lib/utils/permissions';\n\n/**\n * Helper function to execute Prisma queries with retry logic for prepared statement conflicts\n */\nconst executeWithRetry = async <T>(operation: () => Promise<T>, maxRetries = 3): Promise<T> => {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n            return await operation();\n        } catch (error: any) {\n            // Check if this is a prepared statement conflict error\n            if (error?.code === '42P05' && attempt < maxRetries) {\n                console.log(`Prepared statement conflict detected, retrying... (attempt ${attempt}/${maxRetries})`);\n                // Exponential backoff: wait longer between retries\n                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 100));\n                continue;\n            }\n            // If it's not a retryable error or we've exhausted retries, throw the error\n            throw error;\n        }\n    }\n    throw new Error('Max retries exceeded');\n};\n\n// Secret key for JWT - should be moved to environment variables in production\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';\n// Changed token expiration to 12h (from 24h) for better security\nconst JWT_EXPIRES_IN = process.env.JWT_ACCESS_TOKEN_EXPIRES_IN || '12h';\n\n/**\n * Parses a time string like \"15m\", \"2h\", \"1d\" into seconds.\n * @param timeStr The time string.\n * @returns The number of seconds, or 0 if parsing fails.\n */\nexport const parseTimeStringToSeconds = (timeStr: string): number => {\n    if (!timeStr) return 0;\n    const lastChar = timeStr.slice(-1);\n    const num = parseInt(timeStr.slice(0, -1));\n\n    if (isNaN(num)) return 0;\n\n    switch (lastChar) {\n        case 's': return num;\n        case 'm': return num * 60;\n        case 'h': return num * 60 * 60;\n        case 'd': return num * 60 * 60 * 24;\n        default: // If no unit, assume seconds if it's just a number string\n            if (!isNaN(parseInt(timeStr))) return parseInt(timeStr);\n            return 0;\n    }\n};\n\ninterface TokenPayload {\n    sub: number; // User ID as 'sub' claim\n    username: string;\n    email: string;\n    roleId: number;\n    shopId?: number | null;\n    permissions?: string[];\n}\n\n/**\n * Authenticate a user with email and password (optimized with single query)\n */\nexport const authenticateUser = async (email: string, password: string) => {\n    try {\n        console.time('user authentication query');\n        // Optimized single query using the new composite index with retry logic\n        const user = await executeWithRetry(() => \n            prisma.user.findFirst({\n                where: {\n                    email: email,\n                    isActive: true\n                },\n                include: {\n                    role: {\n                        include: {\n                            permissions: {\n                                select: { name: true }\n                            }\n                        }\n                    }\n                }\n            })\n        ) as any;\n        console.timeEnd('user authentication query');\n\n        // If user not found\n        if (!user) {\n            return {\n                success: false,\n                message: 'Invalid email or password'\n            };\n        }\n\n        // Verify password\n        const isPasswordValid = await bcrypt.compare(password, user.password);\n        if (!isPasswordValid) {\n            return {\n                success: false,\n                message: 'Invalid email or password'\n            };\n        }\n\n        // Get permissions from role (handle case where user has no role)\n        let permissions: string[] = [];\n        if (user.role?.permissions) {\n            permissions = user.role.permissions.map(p => p.name);\n        } else if (user.permissions && Array.isArray(user.permissions)) {\n            // Handle special case for \"ALL\" permissions\n            if (user.permissions.includes('ALL')) {\n                permissions = ['ALL'];\n            } else {\n                // Convert permission IDs to names, filtering out invalid values\n                const validPermissionIds = user.permissions\n                    .map(id => parseInt(id.toString()))\n                    .filter(id => !isNaN(id));\n                \n                if (validPermissionIds.length > 0) {\n                    const permissionRecords = await executeWithRetry(() =>\n                        prisma.permission.findMany({\n                            where: {\n                                id: {\n                                    in: validPermissionIds\n                                }\n                            },\n                            select: { name: true }\n                        })\n                    );\n                    permissions = (permissionRecords as any[]).map((p: any) => p.name);\n                }\n            }\n        }\n\n        // Generate JWT token\n        const token = generateToken({\n            sub: user.id,\n            username: user.name,\n            email: user.email,\n            roleId: user.roleId,\n            shopId: user.shopId,\n            permissions\n        });\n\n        const userSession = {\n            id: user.id,\n            username: user.name,\n            fullName: user.name,\n            email: user.email,\n            roleId: user.roleId,\n            roleName: user.role?.name || user.roleName || null,\n            shopId: user.shopId,\n            permissions,\n            role: user.role\n        };\n\n        // Cache user session for faster subsequent requests\n        const cacheKey = cacheService.generateKey(CACHE_CONFIG.KEYS.USER_SESSION, { userId: user.id });\n        await cacheService.set(cacheKey, userSession, CACHE_CONFIG.TTL.USER_SESSION);\n\n        return {\n            success: true,\n            token,\n            user: {\n                id: user.id,\n                username: user.name,\n                fullName: user.name,\n                email: user.email,\n                roleId: user.roleId,\n                roleName: user.role?.name || user.roleName || null,\n                shopId: user.shopId,\n                permissions\n            }\n        };\n    } catch (error) {\n        console.error('Authentication error:', error);\n        return {\n            success: false,\n            message: 'Authentication failed'\n        };\n    }\n};\n\n/**\n * Generate a JWT token\n */\nexport const generateToken = (payload: TokenPayload) => {\n    return jwt.sign(payload, JWT_SECRET as string, { expiresIn: JWT_EXPIRES_IN as any });\n};\n\n/**\n * Verify a JWT token with caching\n */\nexport const verifyToken = async (token: string) => {\n    // Validate token input\n    if (!token || token.trim() === '') {\n        throw new Error('jwt must be provided');\n    }\n\n    try {\n        // Verify token first\n        const decoded = jwt.verify(token, JWT_SECRET) as unknown as TokenPayload;\n\n        // Only generate cache key for valid tokens (ensure token is long enough for substring)\n        if (token.length >= 20) {\n            const tokenKey = cacheService.generateKey(CACHE_CONFIG.KEYS.TOKEN_VALIDATION, { token: token.substring(0, 20) });\n            \n            // Check cache first for token validation result\n            const cachedResult = await cacheService.get(tokenKey);\n            if (cachedResult) {\n                return cachedResult as TokenPayload;\n            }\n\n            // Cache the valid token payload (shorter TTL for security)\n            await cacheService.set(tokenKey, decoded, CACHE_CONFIG.TTL.TOKEN_VALIDATION);\n        }\n\n        return decoded;\n    } catch (error) {\n        // Log the error here if desired\n        if (error instanceof jwt.TokenExpiredError) {\n            console.error('Token expired during verification:', error.expiredAt);\n        } else if (error instanceof jwt.JsonWebTokenError) {\n            console.error('Invalid token during verification:', error.message);\n        } else {\n            console.error('Unknown token verification error:', error);\n        }\n        throw error; // Re-throw the error\n    }\n};\n\n/**\n * Check if a token has a specific permission with caching\n */\nexport const hasPermission = async (tokenPayload: TokenPayload, permission: string) => {\n    // Use the imported permission checking utility\n    \n    // Quick check from token payload first\n    if (tokenPayload.permissions) {\n        if (checkPermission(tokenPayload.permissions, permission)) {\n            return true;\n        }\n    }\n\n    // If not in token, check cached user permissions\n    const permissionsCacheKey = cacheService.generateKey(CACHE_CONFIG.KEYS.USER_PERMISSIONS, { userId: tokenPayload.sub });\n\n    try {\n        const cachedPermissions = await cacheService.get(permissionsCacheKey);\n        if (cachedPermissions) {\n            return checkPermission(cachedPermissions, permission);\n        }\n\n        // Fallback to database query if not cached\n        const user = await executeWithRetry(() =>\n            prisma.user.findFirst({\n                where: { id: String(tokenPayload.sub), isActive: true },\n                include: {\n                    role: {\n                        include: {\n                            permissions: { select: { name: true } }\n                        }\n                    }\n                }\n            })\n        ) as any;\n\n        if (user) {\n            const permissions = user.role.permissions.map((p: any) => p.name);\n            // Cache permissions for future checks\n            await cacheService.set(permissionsCacheKey, permissions, CACHE_CONFIG.TTL.USER_PERMISSIONS);\n            return checkPermission(permissions, permission);\n        }\n    } catch (error) {\n        console.error('Error checking permissions:', error);\n    }\n\n    return false;\n};\n\n/**\n * Get user details from a decoded token payload with caching\n */\nexport const getUserFromDecodedPayload = async (payload: TokenPayload | null) => {\n    console.log('getUserFromDecodedPayload received payload:', payload);\n\n    if (!payload) {\n        console.error('Invalid token payload provided to getUserFromDecodedPayload');\n        return null;\n    }\n\n    if (!payload.sub) {\n        console.error('Token payload missing user ID (sub claim)');\n        return null;\n    }\n\n    const userId = payload.sub;\n    const cacheKey = cacheService.generateKey(CACHE_CONFIG.KEYS.USER_SESSION, { userId });\n\n    try {\n        // Try to get user from cache first\n        const cachedUser = await cacheService.get(cacheKey);\n        if (cachedUser) {\n            console.log('User found in cache:', userId);\n            return cachedUser;\n        }\n\n        console.log('Looking up user with ID:', userId);\n        console.time('prisma.user.findFirst for auth'); // Start timer\n        const user = await executeWithRetry(() =>\n            prisma.user.findFirst({\n                where: {\n                    id: String(userId),\n                    isActive: true\n                },\n                include: {\n                    role: {\n                        include: {\n                            permissions: {\n                                select: { name: true }\n                            }\n                        }\n                    }\n                }\n            })\n        ) as any;\n        console.timeEnd('prisma.user.findFirst for auth'); // End timer\n\n        if (!user) {\n            console.error('User not found for ID:', userId);\n            return null;\n        }\n\n        const userWithPermissions = {\n            ...user,\n            roleName: user.role.name,\n            permissions: user.role.permissions.map((p: any) => p.name)\n        };\n\n        // Cache the user session\n        await cacheService.set(cacheKey, userWithPermissions, CACHE_CONFIG.TTL.USER_SESSION);\n\n        console.log('User found and cached:', user.id, user.name);\n        return userWithPermissions;\n    } catch (error) {\n        console.error('Error getting user from decoded payload:', error);\n        return null;\n    }\n};\n\n/**\n * Get user details from token (Legacy - consider phasing out or refactoring)\n * This function now calls verifyToken and then getUserFromDecodedPayload.\n */\nexport const getUserFromToken = async (token: string) => {\n    const payload = await verifyToken(token);\n    return getUserFromDecodedPayload(payload);\n};"],"names":["authenticateUser","generateToken","getUserFromDecodedPayload","getUserFromToken","hasPermission","parseTimeStringToSeconds","verifyToken","executeWithRetry","operation","maxRetries","attempt","error","code","console","log","Promise","resolve","setTimeout","Math","pow","Error","JWT_SECRET","process","env","JWT_EXPIRES_IN","JWT_ACCESS_TOKEN_EXPIRES_IN","timeStr","lastChar","slice","num","parseInt","isNaN","email","password","time","user","prisma","findFirst","where","isActive","include","role","permissions","select","name","timeEnd","success","message","isPasswordValid","bcrypt","compare","map","p","Array","isArray","includes","validPermissionIds","id","toString","filter","length","permissionRecords","permission","findMany","in","token","sub","username","roleId","shopId","userSession","fullName","roleName","cacheKey","cacheService","generateKey","CACHE_CONFIG","KEYS","USER_SESSION","userId","set","TTL","payload","jwt","sign","expiresIn","trim","decoded","verify","tokenKey","TOKEN_VALIDATION","substring","cachedResult","get","TokenExpiredError","expiredAt","JsonWebTokenError","tokenPayload","checkPermission","permissionsCacheKey","USER_PERMISSIONS","cachedPermissions","String","cachedUser","userWithPermissions"],"mappings":"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"}