dea178ccd2dd0b0cc3e67c5ef16b70e6
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    authenticateUser: function() {
        return authenticateUser;
    },
    generateToken: function() {
        return generateToken;
    },
    getUserFromDecodedPayload: function() {
        return getUserFromDecodedPayload;
    },
    getUserFromToken: function() {
        return getUserFromToken;
    },
    hasPermission: function() {
        return hasPermission;
    },
    parseTimeStringToSeconds: function() {
        return parseTimeStringToSeconds;
    },
    verifyToken: function() {
        return verifyToken;
    }
});
const _jsonwebtoken = /*#__PURE__*/ _interop_require_wildcard(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_wildcard(require("bcryptjs"));
const _prisma = /*#__PURE__*/ _interop_require_default(require("../lib/prisma"));
const _cache = require("../lib/cache");
const _permissions = require("../lib/utils/permissions");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Helper function to execute Prisma queries with retry logic for prepared statement conflicts
 */ const executeWithRetry = async (operation, maxRetries = 3)=>{
    for(let attempt = 1; attempt <= maxRetries; attempt++){
        try {
            return await operation();
        } catch (error) {
            // Check if this is a prepared statement conflict error
            if (error?.code === "42P05" && attempt < maxRetries) {
                console.log(`Prepared statement conflict detected, retrying... (attempt ${attempt}/${maxRetries})`);
                // Exponential backoff: wait longer between retries
                await new Promise((resolve)=>setTimeout(resolve, Math.pow(2, attempt) * 100));
                continue;
            }
            // If it's not a retryable error or we've exhausted retries, throw the error
            throw error;
        }
    }
    throw new Error("Max retries exceeded");
};
// Secret key for JWT - should be moved to environment variables in production
const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
// Changed token expiration to 12h (from 24h) for better security
const JWT_EXPIRES_IN = process.env.JWT_ACCESS_TOKEN_EXPIRES_IN || "12h";
const parseTimeStringToSeconds = (timeStr)=>{
    if (!timeStr) return 0;
    const lastChar = timeStr.slice(-1);
    const num = parseInt(timeStr.slice(0, -1));
    if (isNaN(num)) return 0;
    switch(lastChar){
        case "s":
            return num;
        case "m":
            return num * 60;
        case "h":
            return num * 60 * 60;
        case "d":
            return num * 60 * 60 * 24;
        default:
            if (!isNaN(parseInt(timeStr))) return parseInt(timeStr);
            return 0;
    }
};
const authenticateUser = async (email, password)=>{
    try {
        console.time("user authentication query");
        // Optimized single query using the new composite index with retry logic
        const user = await executeWithRetry(()=>_prisma.default.user.findFirst({
                where: {
                    email: email,
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            }));
        console.timeEnd("user authentication query");
        // If user not found
        if (!user) {
            return {
                success: false,
                message: "Invalid email or password"
            };
        }
        // Verify password
        const isPasswordValid = await _bcryptjs.compare(password, user.password);
        if (!isPasswordValid) {
            return {
                success: false,
                message: "Invalid email or password"
            };
        }
        // Get permissions from role (handle case where user has no role)
        let permissions = [];
        if (user.role?.permissions) {
            permissions = user.role.permissions.map((p)=>p.name);
        } else if (user.permissions && Array.isArray(user.permissions)) {
            // Handle special case for "ALL" permissions
            if (user.permissions.includes("ALL")) {
                permissions = [
                    "ALL"
                ];
            } else {
                // Convert permission IDs to names, filtering out invalid values
                const validPermissionIds = user.permissions.map((id)=>parseInt(id.toString())).filter((id)=>!isNaN(id));
                if (validPermissionIds.length > 0) {
                    const permissionRecords = await executeWithRetry(()=>_prisma.default.permission.findMany({
                            where: {
                                id: {
                                    in: validPermissionIds
                                }
                            },
                            select: {
                                name: true
                            }
                        }));
                    permissions = permissionRecords.map((p)=>p.name);
                }
            }
        }
        // Generate JWT token
        const token = generateToken({
            sub: user.id,
            username: user.name,
            email: user.email,
            roleId: user.roleId,
            shopId: user.shopId,
            permissions
        });
        const userSession = {
            id: user.id,
            username: user.name,
            fullName: user.name,
            email: user.email,
            roleId: user.roleId,
            roleName: user.role?.name || user.roleName || null,
            shopId: user.shopId,
            permissions,
            role: user.role
        };
        // Cache user session for faster subsequent requests
        const cacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_SESSION, {
            userId: user.id
        });
        await _cache.cacheService.set(cacheKey, userSession, _cache.CACHE_CONFIG.TTL.USER_SESSION);
        return {
            success: true,
            token,
            user: {
                id: user.id,
                username: user.name,
                fullName: user.name,
                email: user.email,
                roleId: user.roleId,
                roleName: user.role?.name || user.roleName || null,
                shopId: user.shopId,
                permissions
            }
        };
    } catch (error) {
        console.error("Authentication error:", error);
        return {
            success: false,
            message: "Authentication failed"
        };
    }
};
const generateToken = (payload)=>{
    return _jsonwebtoken.sign(payload, JWT_SECRET, {
        expiresIn: JWT_EXPIRES_IN
    });
};
const verifyToken = async (token)=>{
    // Validate token input
    if (!token || token.trim() === "") {
        throw new Error("jwt must be provided");
    }
    try {
        // Verify token first
        const decoded = _jsonwebtoken.verify(token, JWT_SECRET);
        // Only generate cache key for valid tokens (ensure token is long enough for substring)
        if (token.length >= 20) {
            const tokenKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.TOKEN_VALIDATION, {
                token: token.substring(0, 20)
            });
            // Check cache first for token validation result
            const cachedResult = await _cache.cacheService.get(tokenKey);
            if (cachedResult) {
                return cachedResult;
            }
            // Cache the valid token payload (shorter TTL for security)
            await _cache.cacheService.set(tokenKey, decoded, _cache.CACHE_CONFIG.TTL.TOKEN_VALIDATION);
        }
        return decoded;
    } catch (error) {
        // Log the error here if desired
        if (error instanceof _jsonwebtoken.TokenExpiredError) {
            console.error("Token expired during verification:", error.expiredAt);
        } else if (error instanceof _jsonwebtoken.JsonWebTokenError) {
            console.error("Invalid token during verification:", error.message);
        } else {
            console.error("Unknown token verification error:", error);
        }
        throw error; // Re-throw the error
    }
};
const hasPermission = async (tokenPayload, permission)=>{
    // Use the imported permission checking utility
    // Quick check from token payload first
    if (tokenPayload.permissions) {
        if ((0, _permissions.hasPermission)(tokenPayload.permissions, permission)) {
            return true;
        }
    }
    // If not in token, check cached user permissions
    const permissionsCacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_PERMISSIONS, {
        userId: tokenPayload.sub
    });
    try {
        const cachedPermissions = await _cache.cacheService.get(permissionsCacheKey);
        if (cachedPermissions) {
            return (0, _permissions.hasPermission)(cachedPermissions, permission);
        }
        // Fallback to database query if not cached
        const user = await executeWithRetry(()=>_prisma.default.user.findFirst({
                where: {
                    id: String(tokenPayload.sub),
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            }));
        if (user) {
            const permissions = user.role.permissions.map((p)=>p.name);
            // Cache permissions for future checks
            await _cache.cacheService.set(permissionsCacheKey, permissions, _cache.CACHE_CONFIG.TTL.USER_PERMISSIONS);
            return (0, _permissions.hasPermission)(permissions, permission);
        }
    } catch (error) {
        console.error("Error checking permissions:", error);
    }
    return false;
};
const getUserFromDecodedPayload = async (payload)=>{
    console.log("getUserFromDecodedPayload received payload:", payload);
    if (!payload) {
        console.error("Invalid token payload provided to getUserFromDecodedPayload");
        return null;
    }
    if (!payload.sub) {
        console.error("Token payload missing user ID (sub claim)");
        return null;
    }
    const userId = payload.sub;
    const cacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_SESSION, {
        userId
    });
    try {
        // Try to get user from cache first
        const cachedUser = await _cache.cacheService.get(cacheKey);
        if (cachedUser) {
            console.log("User found in cache:", userId);
            return cachedUser;
        }
        console.log("Looking up user with ID:", userId);
        console.time("prisma.user.findFirst for auth"); // Start timer
        const user = await executeWithRetry(()=>_prisma.default.user.findFirst({
                where: {
                    id: String(userId),
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            }));
        console.timeEnd("prisma.user.findFirst for auth"); // End timer
        if (!user) {
            console.error("User not found for ID:", userId);
            return null;
        }
        const userWithPermissions = {
            ...user,
            roleName: user.role.name,
            permissions: user.role.permissions.map((p)=>p.name)
        };
        // Cache the user session
        await _cache.cacheService.set(cacheKey, userWithPermissions, _cache.CACHE_CONFIG.TTL.USER_SESSION);
        console.log("User found and cached:", user.id, user.name);
        return userWithPermissions;
    } catch (error) {
        console.error("Error getting user from decoded payload:", error);
        return null;
    }
};
const getUserFromToken = async (token)=>{
    const payload = await verifyToken(token);
    return getUserFromDecodedPayload(payload);
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vc3JjL3NlcnZpY2VzL2F1dGhTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuaW1wb3J0ICogYXMgYmNyeXB0IGZyb20gJ2JjcnlwdGpzJztcbmltcG9ydCBwcmlzbWEgZnJvbSAnLi4vbGliL3ByaXNtYSc7XG5pbXBvcnQgeyBjYWNoZVNlcnZpY2UsIENBQ0hFX0NPTkZJRyB9IGZyb20gJy4uL2xpYi9jYWNoZSc7XG5pbXBvcnQgeyBoYXNQZXJtaXNzaW9uIGFzIGNoZWNrUGVybWlzc2lvbiB9IGZyb20gJy4uL2xpYi91dGlscy9wZXJtaXNzaW9ucyc7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgUHJpc21hIHF1ZXJpZXMgd2l0aCByZXRyeSBsb2dpYyBmb3IgcHJlcGFyZWQgc3RhdGVtZW50IGNvbmZsaWN0c1xuICovXG5jb25zdCBleGVjdXRlV2l0aFJldHJ5ID0gYXN5bmMgPFQ+KG9wZXJhdGlvbjogKCkgPT4gUHJvbWlzZTxUPiwgbWF4UmV0cmllcyA9IDMpOiBQcm9taXNlPFQ+ID0+IHtcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBvcGVyYXRpb24oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHByZXBhcmVkIHN0YXRlbWVudCBjb25mbGljdCBlcnJvclxuICAgICAgICAgICAgaWYgKGVycm9yPy5jb2RlID09PSAnNDJQMDUnICYmIGF0dGVtcHQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFByZXBhcmVkIHN0YXRlbWVudCBjb25mbGljdCBkZXRlY3RlZCwgcmV0cnlpbmcuLi4gKGF0dGVtcHQgJHthdHRlbXB0fS8ke21heFJldHJpZXN9KWApO1xuICAgICAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmY6IHdhaXQgbG9uZ2VyIGJldHdlZW4gcmV0cmllc1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnBvdygyLCBhdHRlbXB0KSAqIDEwMCkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBub3QgYSByZXRyeWFibGUgZXJyb3Igb3Igd2UndmUgZXhoYXVzdGVkIHJldHJpZXMsIHRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXggcmV0cmllcyBleGNlZWRlZCcpO1xufTtcblxuLy8gU2VjcmV0IGtleSBmb3IgSldUIC0gc2hvdWxkIGJlIG1vdmVkIHRvIGVudmlyb25tZW50IHZhcmlhYmxlcyBpbiBwcm9kdWN0aW9uXG5jb25zdCBKV1RfU0VDUkVUID0gcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCB8fCAneW91ci1zZWNyZXQta2V5Jztcbi8vIENoYW5nZWQgdG9rZW4gZXhwaXJhdGlvbiB0byAxMmggKGZyb20gMjRoKSBmb3IgYmV0dGVyIHNlY3VyaXR5XG5jb25zdCBKV1RfRVhQSVJFU19JTiA9IHByb2Nlc3MuZW52LkpXVF9BQ0NFU1NfVE9LRU5fRVhQSVJFU19JTiB8fCAnMTJoJztcblxuLyoqXG4gKiBQYXJzZXMgYSB0aW1lIHN0cmluZyBsaWtlIFwiMTVtXCIsIFwiMmhcIiwgXCIxZFwiIGludG8gc2Vjb25kcy5cbiAqIEBwYXJhbSB0aW1lU3RyIFRoZSB0aW1lIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygc2Vjb25kcywgb3IgMCBpZiBwYXJzaW5nIGZhaWxzLlxuICovXG5leHBvcnQgY29uc3QgcGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzID0gKHRpbWVTdHI6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gICAgaWYgKCF0aW1lU3RyKSByZXR1cm4gMDtcbiAgICBjb25zdCBsYXN0Q2hhciA9IHRpbWVTdHIuc2xpY2UoLTEpO1xuICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KHRpbWVTdHIuc2xpY2UoMCwgLTEpKTtcblxuICAgIGlmIChpc05hTihudW0pKSByZXR1cm4gMDtcblxuICAgIHN3aXRjaCAobGFzdENoYXIpIHtcbiAgICAgICAgY2FzZSAncyc6IHJldHVybiBudW07XG4gICAgICAgIGNhc2UgJ20nOiByZXR1cm4gbnVtICogNjA7XG4gICAgICAgIGNhc2UgJ2gnOiByZXR1cm4gbnVtICogNjAgKiA2MDtcbiAgICAgICAgY2FzZSAnZCc6IHJldHVybiBudW0gKiA2MCAqIDYwICogMjQ7XG4gICAgICAgIGRlZmF1bHQ6IC8vIElmIG5vIHVuaXQsIGFzc3VtZSBzZWNvbmRzIGlmIGl0J3MganVzdCBhIG51bWJlciBzdHJpbmdcbiAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQodGltZVN0cikpKSByZXR1cm4gcGFyc2VJbnQodGltZVN0cik7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5pbnRlcmZhY2UgVG9rZW5QYXlsb2FkIHtcbiAgICBzdWI6IG51bWJlcjsgLy8gVXNlciBJRCBhcyAnc3ViJyBjbGFpbVxuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgZW1haWw6IHN0cmluZztcbiAgICByb2xlSWQ6IG51bWJlcjtcbiAgICBzaG9wSWQ/OiBudW1iZXIgfCBudWxsO1xuICAgIHBlcm1pc3Npb25zPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogQXV0aGVudGljYXRlIGEgdXNlciB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZCAob3B0aW1pemVkIHdpdGggc2luZ2xlIHF1ZXJ5KVxuICovXG5leHBvcnQgY29uc3QgYXV0aGVudGljYXRlVXNlciA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS50aW1lKCd1c2VyIGF1dGhlbnRpY2F0aW9uIHF1ZXJ5Jyk7XG4gICAgICAgIC8vIE9wdGltaXplZCBzaW5nbGUgcXVlcnkgdXNpbmcgdGhlIG5ldyBjb21wb3NpdGUgaW5kZXggd2l0aCByZXRyeSBsb2dpY1xuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgZXhlY3V0ZVdpdGhSZXRyeSgoKSA9PiBcbiAgICAgICAgICAgIHByaXNtYS51c2VyLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB7IG5hbWU6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICkgYXMgYW55O1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ3VzZXIgYXV0aGVudGljYXRpb24gcXVlcnknKTtcblxuICAgICAgICAvLyBJZiB1c2VyIG5vdCBmb3VuZFxuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZ5IHBhc3N3b3JkXG4gICAgICAgIGNvbnN0IGlzUGFzc3dvcmRWYWxpZCA9IGF3YWl0IGJjcnlwdC5jb21wYXJlKHBhc3N3b3JkLCB1c2VyLnBhc3N3b3JkKTtcbiAgICAgICAgaWYgKCFpc1Bhc3N3b3JkVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHBlcm1pc3Npb25zIGZyb20gcm9sZSAoaGFuZGxlIGNhc2Ugd2hlcmUgdXNlciBoYXMgbm8gcm9sZSlcbiAgICAgICAgbGV0IHBlcm1pc3Npb25zOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBpZiAodXNlci5yb2xlPy5wZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgcGVybWlzc2lvbnMgPSB1c2VyLnJvbGUucGVybWlzc2lvbnMubWFwKHAgPT4gcC5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmICh1c2VyLnBlcm1pc3Npb25zICYmIEFycmF5LmlzQXJyYXkodXNlci5wZXJtaXNzaW9ucykpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2UgZm9yIFwiQUxMXCIgcGVybWlzc2lvbnNcbiAgICAgICAgICAgIGlmICh1c2VyLnBlcm1pc3Npb25zLmluY2x1ZGVzKCdBTEwnKSkge1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zID0gWydBTEwnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBwZXJtaXNzaW9uIElEcyB0byBuYW1lcywgZmlsdGVyaW5nIG91dCBpbnZhbGlkIHZhbHVlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkUGVybWlzc2lvbklkcyA9IHVzZXIucGVybWlzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgLm1hcChpZCA9PiBwYXJzZUludChpZC50b1N0cmluZygpKSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpZCA9PiAhaXNOYU4oaWQpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRQZXJtaXNzaW9uSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvblJlY29yZHMgPSBhd2FpdCBleGVjdXRlV2l0aFJldHJ5KCgpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlzbWEucGVybWlzc2lvbi5maW5kTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluOiB2YWxpZFBlcm1pc3Npb25JZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB7IG5hbWU6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbnMgPSAocGVybWlzc2lvblJlY29yZHMgYXMgYW55W10pLm1hcCgocDogYW55KSA9PiBwLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIEpXVCB0b2tlblxuICAgICAgICBjb25zdCB0b2tlbiA9IGdlbmVyYXRlVG9rZW4oe1xuICAgICAgICAgICAgc3ViOiB1c2VyLmlkLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgICAgcm9sZUlkOiB1c2VyLnJvbGVJZCxcbiAgICAgICAgICAgIHNob3BJZDogdXNlci5zaG9wSWQsXG4gICAgICAgICAgICBwZXJtaXNzaW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB1c2VyU2Vzc2lvbiA9IHtcbiAgICAgICAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgICAgIGZ1bGxOYW1lOiB1c2VyLm5hbWUsXG4gICAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgICAgIHJvbGVJZDogdXNlci5yb2xlSWQsXG4gICAgICAgICAgICByb2xlTmFtZTogdXNlci5yb2xlPy5uYW1lIHx8IHVzZXIucm9sZU5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgIHNob3BJZDogdXNlci5zaG9wSWQsXG4gICAgICAgICAgICBwZXJtaXNzaW9ucyxcbiAgICAgICAgICAgIHJvbGU6IHVzZXIucm9sZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhY2hlIHVzZXIgc2Vzc2lvbiBmb3IgZmFzdGVyIHN1YnNlcXVlbnQgcmVxdWVzdHNcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBjYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkoQ0FDSEVfQ09ORklHLktFWVMuVVNFUl9TRVNTSU9OLCB7IHVzZXJJZDogdXNlci5pZCB9KTtcbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdXNlclNlc3Npb24sIENBQ0hFX0NPTkZJRy5UVEwuVVNFUl9TRVNTSU9OKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VyLm5hbWUsXG4gICAgICAgICAgICAgICAgZnVsbE5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgICAgICAgICByb2xlSWQ6IHVzZXIucm9sZUlkLFxuICAgICAgICAgICAgICAgIHJvbGVOYW1lOiB1c2VyLnJvbGU/Lm5hbWUgfHwgdXNlci5yb2xlTmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHNob3BJZDogdXNlci5zaG9wSWQsXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdXRoZW50aWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIEpXVCB0b2tlblxuICovXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVUb2tlbiA9IChwYXlsb2FkOiBUb2tlblBheWxvYWQpID0+IHtcbiAgICByZXR1cm4gand0LnNpZ24ocGF5bG9hZCwgSldUX1NFQ1JFVCBhcyBzdHJpbmcsIHsgZXhwaXJlc0luOiBKV1RfRVhQSVJFU19JTiBhcyBhbnkgfSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhIEpXVCB0b2tlbiB3aXRoIGNhY2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHZlcmlmeVRva2VuID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAvLyBWYWxpZGF0ZSB0b2tlbiBpbnB1dFxuICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHJpbSgpID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2p3dCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVmVyaWZ5IHRva2VuIGZpcnN0XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBqd3QudmVyaWZ5KHRva2VuLCBKV1RfU0VDUkVUKSBhcyB1bmtub3duIGFzIFRva2VuUGF5bG9hZDtcblxuICAgICAgICAvLyBPbmx5IGdlbmVyYXRlIGNhY2hlIGtleSBmb3IgdmFsaWQgdG9rZW5zIChlbnN1cmUgdG9rZW4gaXMgbG9uZyBlbm91Z2ggZm9yIHN1YnN0cmluZylcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+PSAyMCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5LZXkgPSBjYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkoQ0FDSEVfQ09ORklHLktFWVMuVE9LRU5fVkFMSURBVElPTiwgeyB0b2tlbjogdG9rZW4uc3Vic3RyaW5nKDAsIDIwKSB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3QgZm9yIHRva2VuIHZhbGlkYXRpb24gcmVzdWx0XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRSZXN1bHQgPSBhd2FpdCBjYWNoZVNlcnZpY2UuZ2V0KHRva2VuS2V5KTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0IGFzIFRva2VuUGF5bG9hZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHZhbGlkIHRva2VuIHBheWxvYWQgKHNob3J0ZXIgVFRMIGZvciBzZWN1cml0eSlcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5zZXQodG9rZW5LZXksIGRlY29kZWQsIENBQ0hFX0NPTkZJRy5UVEwuVE9LRU5fVkFMSURBVElPTik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBMb2cgdGhlIGVycm9yIGhlcmUgaWYgZGVzaXJlZFxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBqd3QuVG9rZW5FeHBpcmVkRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIGV4cGlyZWQgZHVyaW5nIHZlcmlmaWNhdGlvbjonLCBlcnJvci5leHBpcmVkQXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2Ygand0Lkpzb25XZWJUb2tlbkVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHRva2VuIGR1cmluZyB2ZXJpZmljYXRpb246JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIHRva2VuIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRoZSBlcnJvclxuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0b2tlbiBoYXMgYSBzcGVjaWZpYyBwZXJtaXNzaW9uIHdpdGggY2FjaGluZ1xuICovXG5leHBvcnQgY29uc3QgaGFzUGVybWlzc2lvbiA9IGFzeW5jICh0b2tlblBheWxvYWQ6IFRva2VuUGF5bG9hZCwgcGVybWlzc2lvbjogc3RyaW5nKSA9PiB7XG4gICAgLy8gVXNlIHRoZSBpbXBvcnRlZCBwZXJtaXNzaW9uIGNoZWNraW5nIHV0aWxpdHlcbiAgICBcbiAgICAvLyBRdWljayBjaGVjayBmcm9tIHRva2VuIHBheWxvYWQgZmlyc3RcbiAgICBpZiAodG9rZW5QYXlsb2FkLnBlcm1pc3Npb25zKSB7XG4gICAgICAgIGlmIChjaGVja1Blcm1pc3Npb24odG9rZW5QYXlsb2FkLnBlcm1pc3Npb25zLCBwZXJtaXNzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgaW4gdG9rZW4sIGNoZWNrIGNhY2hlZCB1c2VyIHBlcm1pc3Npb25zXG4gICAgY29uc3QgcGVybWlzc2lvbnNDYWNoZUtleSA9IGNhY2hlU2VydmljZS5nZW5lcmF0ZUtleShDQUNIRV9DT05GSUcuS0VZUy5VU0VSX1BFUk1JU1NJT05TLCB7IHVzZXJJZDogdG9rZW5QYXlsb2FkLnN1YiB9KTtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZFBlcm1pc3Npb25zID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldChwZXJtaXNzaW9uc0NhY2hlS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJtaXNzaW9uKGNhY2hlZFBlcm1pc3Npb25zLCBwZXJtaXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGRhdGFiYXNlIHF1ZXJ5IGlmIG5vdCBjYWNoZWRcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGV4ZWN1dGVXaXRoUmV0cnkoKCkgPT5cbiAgICAgICAgICAgIHByaXNtYS51c2VyLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IFN0cmluZyh0b2tlblBheWxvYWQuc3ViKSwgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogeyBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICkgYXMgYW55O1xuXG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHVzZXIucm9sZS5wZXJtaXNzaW9ucy5tYXAoKHA6IGFueSkgPT4gcC5uYW1lKTtcbiAgICAgICAgICAgIC8vIENhY2hlIHBlcm1pc3Npb25zIGZvciBmdXR1cmUgY2hlY2tzXG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KHBlcm1pc3Npb25zQ2FjaGVLZXksIHBlcm1pc3Npb25zLCBDQUNIRV9DT05GSUcuVFRMLlVTRVJfUEVSTUlTU0lPTlMpO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVybWlzc2lvbihwZXJtaXNzaW9ucywgcGVybWlzc2lvbik7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBwZXJtaXNzaW9uczonLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdXNlciBkZXRhaWxzIGZyb20gYSBkZWNvZGVkIHRva2VuIHBheWxvYWQgd2l0aCBjYWNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkID0gYXN5bmMgKHBheWxvYWQ6IFRva2VuUGF5bG9hZCB8IG51bGwpID0+IHtcbiAgICBjb25zb2xlLmxvZygnZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCByZWNlaXZlZCBwYXlsb2FkOicsIHBheWxvYWQpO1xuXG4gICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdG9rZW4gcGF5bG9hZCBwcm92aWRlZCB0byBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gcGF5bG9hZCBtaXNzaW5nIHVzZXIgSUQgKHN1YiBjbGFpbSknKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlcklkID0gcGF5bG9hZC5zdWI7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBjYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkoQ0FDSEVfQ09ORklHLktFWVMuVVNFUl9TRVNTSU9OLCB7IHVzZXJJZCB9KTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgdXNlciBmcm9tIGNhY2hlIGZpcnN0XG4gICAgICAgIGNvbnN0IGNhY2hlZFVzZXIgPSBhd2FpdCBjYWNoZVNlcnZpY2UuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGZvdW5kIGluIGNhY2hlOicsIHVzZXJJZCk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkVXNlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb29raW5nIHVwIHVzZXIgd2l0aCBJRDonLCB1c2VySWQpO1xuICAgICAgICBjb25zb2xlLnRpbWUoJ3ByaXNtYS51c2VyLmZpbmRGaXJzdCBmb3IgYXV0aCcpOyAvLyBTdGFydCB0aW1lclxuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgZXhlY3V0ZVdpdGhSZXRyeSgoKSA9PlxuICAgICAgICAgICAgcHJpc21hLnVzZXIuZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKHVzZXJJZCksXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKSBhcyBhbnk7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJpc21hLnVzZXIuZmluZEZpcnN0IGZvciBhdXRoJyk7IC8vIEVuZCB0aW1lclxuXG4gICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVXNlciBub3QgZm91bmQgZm9yIElEOicsIHVzZXJJZCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVzZXJXaXRoUGVybWlzc2lvbnMgPSB7XG4gICAgICAgICAgICAuLi51c2VyLFxuICAgICAgICAgICAgcm9sZU5hbWU6IHVzZXIucm9sZS5uYW1lLFxuICAgICAgICAgICAgcGVybWlzc2lvbnM6IHVzZXIucm9sZS5wZXJtaXNzaW9ucy5tYXAoKHA6IGFueSkgPT4gcC5uYW1lKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSB1c2VyIHNlc3Npb25cbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdXNlcldpdGhQZXJtaXNzaW9ucywgQ0FDSEVfQ09ORklHLlRUTC5VU0VSX1NFU1NJT04pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGZvdW5kIGFuZCBjYWNoZWQ6JywgdXNlci5pZCwgdXNlci5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHVzZXJXaXRoUGVybWlzc2lvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGZyb20gZGVjb2RlZCBwYXlsb2FkOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgdXNlciBkZXRhaWxzIGZyb20gdG9rZW4gKExlZ2FjeSAtIGNvbnNpZGVyIHBoYXNpbmcgb3V0IG9yIHJlZmFjdG9yaW5nKVxuICogVGhpcyBmdW5jdGlvbiBub3cgY2FsbHMgdmVyaWZ5VG9rZW4gYW5kIHRoZW4gZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVzZXJGcm9tVG9rZW4gPSBhc3luYyAodG9rZW46IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB2ZXJpZnlUb2tlbih0b2tlbik7XG4gICAgcmV0dXJuIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG59OyJdLCJuYW1lcyI6WyJhdXRoZW50aWNhdGVVc2VyIiwiZ2VuZXJhdGVUb2tlbiIsImdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQiLCJnZXRVc2VyRnJvbVRva2VuIiwiaGFzUGVybWlzc2lvbiIsInBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcyIsInZlcmlmeVRva2VuIiwiZXhlY3V0ZVdpdGhSZXRyeSIsIm9wZXJhdGlvbiIsIm1heFJldHJpZXMiLCJhdHRlbXB0IiwiZXJyb3IiLCJjb2RlIiwiY29uc29sZSIsImxvZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIk1hdGgiLCJwb3ciLCJFcnJvciIsIkpXVF9TRUNSRVQiLCJwcm9jZXNzIiwiZW52IiwiSldUX0VYUElSRVNfSU4iLCJKV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4iLCJ0aW1lU3RyIiwibGFzdENoYXIiLCJzbGljZSIsIm51bSIsInBhcnNlSW50IiwiaXNOYU4iLCJlbWFpbCIsInBhc3N3b3JkIiwidGltZSIsInVzZXIiLCJwcmlzbWEiLCJmaW5kRmlyc3QiLCJ3aGVyZSIsImlzQWN0aXZlIiwiaW5jbHVkZSIsInJvbGUiLCJwZXJtaXNzaW9ucyIsInNlbGVjdCIsIm5hbWUiLCJ0aW1lRW5kIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJpc1Bhc3N3b3JkVmFsaWQiLCJiY3J5cHQiLCJjb21wYXJlIiwibWFwIiwicCIsIkFycmF5IiwiaXNBcnJheSIsImluY2x1ZGVzIiwidmFsaWRQZXJtaXNzaW9uSWRzIiwiaWQiLCJ0b1N0cmluZyIsImZpbHRlciIsImxlbmd0aCIsInBlcm1pc3Npb25SZWNvcmRzIiwicGVybWlzc2lvbiIsImZpbmRNYW55IiwiaW4iLCJ0b2tlbiIsInN1YiIsInVzZXJuYW1lIiwicm9sZUlkIiwic2hvcElkIiwidXNlclNlc3Npb24iLCJmdWxsTmFtZSIsInJvbGVOYW1lIiwiY2FjaGVLZXkiLCJjYWNoZVNlcnZpY2UiLCJnZW5lcmF0ZUtleSIsIkNBQ0hFX0NPTkZJRyIsIktFWVMiLCJVU0VSX1NFU1NJT04iLCJ1c2VySWQiLCJzZXQiLCJUVEwiLCJwYXlsb2FkIiwiand0Iiwic2lnbiIsImV4cGlyZXNJbiIsInRyaW0iLCJkZWNvZGVkIiwidmVyaWZ5IiwidG9rZW5LZXkiLCJUT0tFTl9WQUxJREFUSU9OIiwic3Vic3RyaW5nIiwiY2FjaGVkUmVzdWx0IiwiZ2V0IiwiVG9rZW5FeHBpcmVkRXJyb3IiLCJleHBpcmVkQXQiLCJKc29uV2ViVG9rZW5FcnJvciIsInRva2VuUGF5bG9hZCIsImNoZWNrUGVybWlzc2lvbiIsInBlcm1pc3Npb25zQ2FjaGVLZXkiLCJVU0VSX1BFUk1JU1NJT05TIiwiY2FjaGVkUGVybWlzc2lvbnMiLCJTdHJpbmciLCJjYWNoZWRVc2VyIiwidXNlcldpdGhQZXJtaXNzaW9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7SUFvRWFBLGdCQUFnQjtlQUFoQkE7O0lBMEhBQyxhQUFhO2VBQWJBOztJQWlHQUMseUJBQXlCO2VBQXpCQTs7SUF1RUFDLGdCQUFnQjtlQUFoQkE7O0lBeEhBQyxhQUFhO2VBQWJBOztJQXhNQUMsd0JBQXdCO2VBQXhCQTs7SUErSkFDLFdBQVc7ZUFBWEE7OztzRUFyTVE7a0VBQ0c7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