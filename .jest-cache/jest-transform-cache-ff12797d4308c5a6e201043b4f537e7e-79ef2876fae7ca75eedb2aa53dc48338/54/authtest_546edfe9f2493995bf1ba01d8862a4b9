b93f4d4d9bd35e22810d4c6c646c2443
"use strict";
// Mock jose
jest.mock("jose");
jest.mock("@/lib/prisma", ()=>mockPrisma);
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jose = /*#__PURE__*/ _interop_require_wildcard(require("jose"));
const _auth = require("../../src/lib/auth");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const mockedJose = _jose;
// Mock prisma
const mockPrisma = {
    user: {
        findUnique: jest.fn()
    }
};
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{})
};
describe("Auth Library", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
    });
    describe("authOptions", ()=>{
        it("should have correct configuration", ()=>{
            expect(_auth.authOptions.secret).toBeDefined();
            expect(_auth.authOptions.session.strategy).toBe("jwt");
            expect(_auth.authOptions.session.maxAge).toBe(24 * 60 * 60);
            expect(_auth.authOptions.callbacks.jwt).toBeDefined();
            expect(_auth.authOptions.callbacks.session).toBeDefined();
        });
        it("should handle jwt callback with user", async ()=>{
            const token = {
                id: 1
            };
            const user = {
                id: 2,
                permissions: [
                    "read"
                ]
            };
            const result = await _auth.authOptions.callbacks.jwt({
                token,
                user
            });
            expect(result.id).toBe(2);
            expect(result.permissions).toEqual([
                "read"
            ]);
        });
        it("should handle jwt callback without user", async ()=>{
            const token = {
                id: 1,
                permissions: [
                    "read"
                ]
            };
            const result = await _auth.authOptions.callbacks.jwt({
                token
            });
            expect(result.id).toBe(1);
            expect(result.permissions).toEqual([
                "read"
            ]);
        });
        it("should handle session callback", async ()=>{
            const session = {
                user: {
                    name: "test"
                }
            };
            const token = {
                id: 1,
                permissions: [
                    "read"
                ]
            };
            const result = await _auth.authOptions.callbacks.session({
                session,
                token
            });
            expect(result.user.id).toBe(1);
            expect(result.user.permissions).toEqual([
                "read"
            ]);
        });
        it("should handle session callback without token", async ()=>{
            const session = {
                user: {
                    name: "test"
                }
            };
            const result = await _auth.authOptions.callbacks.session({
                session,
                token: null
            });
            expect(result.user.name).toBe("test");
            expect(result.user.id).toBeUndefined();
        });
    });
    describe("verifyToken", ()=>{
        it("should verify valid token", async ()=>{
            const mockPayload = {
                sub: "1",
                permissions: [
                    "read"
                ]
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: mockPayload
            });
            const result = await (0, _auth.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockedJose.jwtVerify).toHaveBeenCalledWith("valid-token", expect.any(Uint8Array));
        });
        it("should handle expired token", async ()=>{
            const error = new Error("Token expired");
            error.code = "ERR_JWT_EXPIRED";
            mockedJose.jwtVerify.mockRejectedValue(error);
            const result = await (0, _auth.verifyToken)("expired-token");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Token expired:", "Token expired");
        });
        it("should handle invalid token signature", async ()=>{
            const error = new Error("Invalid signature");
            error.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
            mockedJose.jwtVerify.mockRejectedValue(error);
            const result = await (0, _auth.verifyToken)("invalid-token");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Invalid token:", "Invalid signature");
        });
        it("should handle invalid JWS", async ()=>{
            const error = new Error("Invalid JWS");
            error.code = "ERR_JWS_INVALID";
            mockedJose.jwtVerify.mockRejectedValue(error);
            const result = await (0, _auth.verifyToken)("invalid-jws");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Invalid token:", "Invalid JWS");
        });
        it("should handle claim validation failed", async ()=>{
            const error = new Error("Claim validation failed");
            error.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
            mockedJose.jwtVerify.mockRejectedValue(error);
            const result = await (0, _auth.verifyToken)("invalid-claims");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Invalid token:", "Claim validation failed");
        });
        it("should handle other verification errors", async ()=>{
            const error = new Error("Unknown error");
            error.code = "ERR_UNKNOWN";
            mockedJose.jwtVerify.mockRejectedValue(error);
            const result = await (0, _auth.verifyToken)("error-token");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Token verification error:", "Unknown error");
        });
    });
    describe("extractToken", ()=>{
        it("should extract token from valid authorization header", ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token-123")
                }
            };
            const result = (0, _auth.extractToken)(req);
            expect(result).toBe("valid-token-123");
            expect(req.headers.get).toHaveBeenCalledWith("authorization");
        });
        it("should return null for missing authorization header", ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            const result = (0, _auth.extractToken)(req);
            expect(result).toBeNull();
        });
        it("should return null for invalid authorization header format", ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Invalid token-123")
                }
            };
            const result = (0, _auth.extractToken)(req);
            expect(result).toBeNull();
        });
        it("should return null for empty authorization header", ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("")
                }
            };
            const result = (0, _auth.extractToken)(req);
            expect(result).toBeNull();
        });
    });
    describe("validateTokenPermission", ()=>{
        it("should return invalid for missing token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "Authentication required"
            });
        });
        it("should grant permission for dev-token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer dev-token")
                }
            };
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: true
            });
            expect(consoleSpy.log).toHaveBeenCalledWith("Development mode: granting permission 'read'");
        });
        it("should return invalid for invalid token payload", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer invalid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: null
            });
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "Invalid authentication token"
            });
        });
        it("should return invalid for token without sub claim", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer no-sub-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    permissions: [
                        "read"
                    ]
                }
            });
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "Invalid authentication token"
            });
        });
        it("should grant permission from token payload", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "1",
                    permissions: [
                        "read",
                        "write"
                    ]
                }
            });
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: true
            });
        });
        it("should deny permission not in token payload", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "1",
                    permissions: [
                        "write"
                    ]
                }
            });
            mockPrisma.user.findUnique.mockResolvedValue({
                id: 1,
                permissions: [
                    "write"
                ]
            });
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "Permission denied: 'read' is required"
            });
        });
        it("should fallback to database when permission not in token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "1",
                    permissions: [
                        "write"
                    ]
                }
            });
            mockPrisma.user.findUnique.mockResolvedValue({
                id: 1,
                permissions: [
                    "read",
                    "write"
                ]
            });
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: true
            });
        });
        it("should return invalid for user not found", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "999"
                }
            });
            mockPrisma.user.findUnique.mockResolvedValue(null);
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "User not found"
            });
        });
        it("should return invalid for user without permissions", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "1"
                }
            });
            mockPrisma.user.findUnique.mockResolvedValue({
                id: 1,
                permissions: null
            });
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "User has no permissions"
            });
        });
        it("should handle database errors", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "1"
                }
            });
            mockPrisma.user.findUnique.mockRejectedValue(new Error("Database error"));
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "Error checking permission: Database error"
            });
        });
    });
    describe("getUserIdFromToken", ()=>{
        it("should return null for missing token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            const result = await (0, _auth.getUserIdFromToken)(req);
            expect(result).toBeNull();
        });
        it("should return 1 for dev-token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer dev-token")
                }
            };
            const result = await (0, _auth.getUserIdFromToken)(req);
            expect(result).toBe(1);
        });
        it("should return user ID from valid token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "123"
                }
            });
            const result = await (0, _auth.getUserIdFromToken)(req);
            expect(result).toBe(123);
        });
        it("should return null for invalid token payload", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer invalid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: null
            });
            const result = await (0, _auth.getUserIdFromToken)(req);
            expect(result).toBeNull();
        });
        it("should return null for token without sub claim", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer no-sub-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    permissions: [
                        "read"
                    ]
                }
            });
            const result = await (0, _auth.getUserIdFromToken)(req);
            expect(result).toBeNull();
        });
    });
    describe("getShopIdFromToken", ()=>{
        it("should return null for missing token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBeNull();
        });
        it("should return default shop ID for dev-token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer dev-token")
                }
            };
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBe("cmbtr9q6l000061romoxi7uvf");
        });
        it("should return shop ID from valid token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "1",
                    shopId: "shop123"
                }
            });
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBe("shop123");
        });
        it("should return null for token without shopId", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer no-shop-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "1"
                }
            });
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBeNull();
        });
        it("should return null for invalid token payload", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer invalid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: null
            });
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBeNull();
        });
        it("should convert numeric shopId to string", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockedJose.jwtVerify.mockResolvedValue({
                payload: {
                    sub: "1",
                    shopId: 123
                }
            });
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBe("123");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9hdXRoLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgKiBhcyBqb3NlIGZyb20gJ2pvc2UnO1xuaW1wb3J0IHsgdmVyaWZ5VG9rZW4sIGV4dHJhY3RUb2tlbiwgdmFsaWRhdGVUb2tlblBlcm1pc3Npb24sIGdldFVzZXJJZEZyb21Ub2tlbiwgZ2V0U2hvcElkRnJvbVRva2VuLCBhdXRoT3B0aW9ucyB9IGZyb20gJ0AvbGliL2F1dGgnO1xuaW1wb3J0IHByaXNtYSBmcm9tICdAL2xpYi9wcmlzbWEnO1xuXG4vLyBNb2NrIGpvc2Vcbmplc3QubW9jaygnam9zZScpO1xuY29uc3QgbW9ja2VkSm9zZSA9IGpvc2UgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGpvc2U+O1xuXG4vLyBNb2NrIHByaXNtYVxuY29uc3QgbW9ja1ByaXNtYSA9IHtcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSxcbiAgfSxcbn07XG5cbmplc3QubW9jaygnQC9saWIvcHJpc21hJywgKCkgPT4gbW9ja1ByaXNtYSk7XG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBjb25zb2xlU3B5ID0ge1xuICBsb2c6IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIGVycm9yOiBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG59O1xuXG5kZXNjcmliZSgnQXV0aCBMaWJyYXJ5JywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBjb25zb2xlU3B5LmxvZy5tb2NrQ2xlYXIoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgY29uc29sZVNweS5sb2cubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhdXRoT3B0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhdmUgY29ycmVjdCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGF1dGhPcHRpb25zLnNlY3JldCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChhdXRoT3B0aW9ucy5zZXNzaW9uLnN0cmF0ZWd5KS50b0JlKCdqd3QnKTtcbiAgICAgIGV4cGVjdChhdXRoT3B0aW9ucy5zZXNzaW9uLm1heEFnZSkudG9CZSgyNCAqIDYwICogNjApO1xuICAgICAgZXhwZWN0KGF1dGhPcHRpb25zLmNhbGxiYWNrcy5qd3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoYXV0aE9wdGlvbnMuY2FsbGJhY2tzLnNlc3Npb24pLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBqd3QgY2FsbGJhY2sgd2l0aCB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSB7IGlkOiAxIH07XG4gICAgICBjb25zdCB1c2VyID0geyBpZDogMiwgcGVybWlzc2lvbnM6IFsncmVhZCddIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoT3B0aW9ucy5jYWxsYmFja3Muand0KHsgdG9rZW4sIHVzZXIgfSk7XG4gICAgICBleHBlY3QocmVzdWx0LmlkKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wZXJtaXNzaW9ucykudG9FcXVhbChbJ3JlYWQnXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBqd3QgY2FsbGJhY2sgd2l0aG91dCB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSB7IGlkOiAxLCBwZXJtaXNzaW9uczogWydyZWFkJ10gfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhPcHRpb25zLmNhbGxiYWNrcy5qd3QoeyB0b2tlbiB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuaWQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LnBlcm1pc3Npb25zKS50b0VxdWFsKFsncmVhZCddKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlc3Npb24gY2FsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzZXNzaW9uID0geyB1c2VyOiB7IG5hbWU6ICd0ZXN0JyB9IH07XG4gICAgICBjb25zdCB0b2tlbiA9IHsgaWQ6IDEsIHBlcm1pc3Npb25zOiBbJ3JlYWQnXSB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aE9wdGlvbnMuY2FsbGJhY2tzLnNlc3Npb24oeyBzZXNzaW9uLCB0b2tlbiB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5pZCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5wZXJtaXNzaW9ucykudG9FcXVhbChbJ3JlYWQnXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXNzaW9uIGNhbGxiYWNrIHdpdGhvdXQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzZXNzaW9uID0geyB1c2VyOiB7IG5hbWU6ICd0ZXN0JyB9IH07XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoT3B0aW9ucy5jYWxsYmFja3Muc2Vzc2lvbih7IHNlc3Npb24sIHRva2VuOiBudWxsIH0pO1xuICAgICAgZXhwZWN0KHJlc3VsdC51c2VyLm5hbWUpLnRvQmUoJ3Rlc3QnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5pZCkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmVyaWZ5VG9rZW4nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2ZXJpZnkgdmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUGF5bG9hZCA9IHsgc3ViOiAnMScsIHBlcm1pc3Npb25zOiBbJ3JlYWQnXSB9O1xuICAgICAgbW9ja2VkSm9zZS5qd3RWZXJpZnkubW9ja1Jlc29sdmVkVmFsdWUoeyBwYXlsb2FkOiBtb2NrUGF5bG9hZCB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCd2YWxpZC10b2tlbicpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUGF5bG9hZCk7XG4gICAgICBleHBlY3QobW9ja2VkSm9zZS5qd3RWZXJpZnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAndmFsaWQtdG9rZW4nLFxuICAgICAgICBleHBlY3QuYW55KFVpbnQ4QXJyYXkpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXhwaXJlZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUb2tlbiBleHBpcmVkJyk7XG4gICAgICAoZXJyb3IgYXMgYW55KS5jb2RlID0gJ0VSUl9KV1RfRVhQSVJFRCc7XG4gICAgICBtb2NrZWRKb3NlLmp3dFZlcmlmeS5tb2NrUmVqZWN0ZWRWYWx1ZShlcnJvcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCdleHBpcmVkLXRva2VuJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdUb2tlbiBleHBpcmVkOicsICdUb2tlbiBleHBpcmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHRva2VuIHNpZ25hdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgKGVycm9yIGFzIGFueSkuY29kZSA9ICdFUlJfSldTX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTEVEJztcbiAgICAgIG1vY2tlZEpvc2Uuand0VmVyaWZ5Lm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJ2ludmFsaWQtdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0ludmFsaWQgdG9rZW46JywgJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIEpXUycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIEpXUycpO1xuICAgICAgKGVycm9yIGFzIGFueSkuY29kZSA9ICdFUlJfSldTX0lOVkFMSUQnO1xuICAgICAgbW9ja2VkSm9zZS5qd3RWZXJpZnkubW9ja1JlamVjdGVkVmFsdWUoZXJyb3IpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbignaW52YWxpZC1qd3MnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0ludmFsaWQgdG9rZW46JywgJ0ludmFsaWQgSldTJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjbGFpbSB2YWxpZGF0aW9uIGZhaWxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdDbGFpbSB2YWxpZGF0aW9uIGZhaWxlZCcpO1xuICAgICAgKGVycm9yIGFzIGFueSkuY29kZSA9ICdFUlJfSldUX0NMQUlNX1ZBTElEQVRJT05fRkFJTEVEJztcbiAgICAgIG1vY2tlZEpvc2Uuand0VmVyaWZ5Lm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJ2ludmFsaWQtY2xhaW1zJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdJbnZhbGlkIHRva2VuOicsICdDbGFpbSB2YWxpZGF0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgb3RoZXIgdmVyaWZpY2F0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdVbmtub3duIGVycm9yJyk7XG4gICAgICAoZXJyb3IgYXMgYW55KS5jb2RlID0gJ0VSUl9VTktOT1dOJztcbiAgICAgIG1vY2tlZEpvc2Uuand0VmVyaWZ5Lm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJ2Vycm9yLXRva2VuJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdUb2tlbiB2ZXJpZmljYXRpb24gZXJyb3I6JywgJ1Vua25vd24gZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2V4dHJhY3RUb2tlbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGV4dHJhY3QgdG9rZW4gZnJvbSB2YWxpZCBhdXRob3JpemF0aW9uIGhlYWRlcicsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIHZhbGlkLXRva2VuLTEyMycpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdFRva2VuKHJlcSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCd2YWxpZC10b2tlbi0xMjMnKTtcbiAgICAgIGV4cGVjdChyZXEuaGVhZGVycy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhdXRob3JpemF0aW9uJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBtaXNzaW5nIGF1dGhvcml6YXRpb24gaGVhZGVyJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG51bGwpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZXh0cmFjdFRva2VuKHJlcSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgaW52YWxpZCBhdXRob3JpemF0aW9uIGhlYWRlciBmb3JtYXQnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0ludmFsaWQgdG9rZW4tMTIzJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBleHRyYWN0VG9rZW4ocmVxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBlbXB0eSBhdXRob3JpemF0aW9uIGhlYWRlcicsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBleHRyYWN0VG9rZW4ocmVxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd2YWxpZGF0ZVRva2VuUGVybWlzc2lvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBpbnZhbGlkIGZvciBtaXNzaW5nIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG51bGwpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVUb2tlblBlcm1pc3Npb24ocmVxLCAncmVhZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiAnQXV0aGVudGljYXRpb24gcmVxdWlyZWQnXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ3JhbnQgcGVybWlzc2lvbiBmb3IgZGV2LXRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgZGV2LXRva2VuJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVRva2VuUGVybWlzc2lvbihyZXEsICdyZWFkJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgaXNWYWxpZDogdHJ1ZSB9KTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5LmxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJEZXZlbG9wbWVudCBtb2RlOiBncmFudGluZyBwZXJtaXNzaW9uICdyZWFkJ1wiKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGludmFsaWQgZm9yIGludmFsaWQgdG9rZW4gcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIGludmFsaWQtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tlZEpvc2Uuand0VmVyaWZ5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgcGF5bG9hZDogbnVsbCB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uKHJlcSwgJ3JlYWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgYXV0aGVudGljYXRpb24gdG9rZW4nXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGludmFsaWQgZm9yIHRva2VuIHdpdGhvdXQgc3ViIGNsYWltJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgbm8tc3ViLXRva2VuJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBtb2NrZWRKb3NlLmp3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHBheWxvYWQ6IHsgcGVybWlzc2lvbnM6IFsncmVhZCddIH0gfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVRva2VuUGVybWlzc2lvbihyZXEsICdyZWFkJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGF1dGhlbnRpY2F0aW9uIHRva2VuJ1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdyYW50IHBlcm1pc3Npb24gZnJvbSB0b2tlbiBwYXlsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgdmFsaWQtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tlZEpvc2Uuand0VmVyaWZ5Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgcGF5bG9hZDogeyBzdWI6ICcxJywgcGVybWlzc2lvbnM6IFsncmVhZCcsICd3cml0ZSddIH1cbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVUb2tlblBlcm1pc3Npb24ocmVxLCAncmVhZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IGlzVmFsaWQ6IHRydWUgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRlbnkgcGVybWlzc2lvbiBub3QgaW4gdG9rZW4gcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIHZhbGlkLXRva2VuJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBtb2NrZWRKb3NlLmp3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHBheWxvYWQ6IHsgc3ViOiAnMScsIHBlcm1pc3Npb25zOiBbJ3dyaXRlJ10gfVxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAobW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICBpZDogMSxcbiAgICAgICAgIHBlcm1pc3Npb25zOiBbJ3dyaXRlJ11cbiAgICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVUb2tlblBlcm1pc3Npb24ocmVxLCAncmVhZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiBcIlBlcm1pc3Npb24gZGVuaWVkOiAncmVhZCcgaXMgcmVxdWlyZWRcIlxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZhbGxiYWNrIHRvIGRhdGFiYXNlIHdoZW4gcGVybWlzc2lvbiBub3QgaW4gdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0JlYXJlciB2YWxpZC10b2tlbicpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgbW9ja2VkSm9zZS5qd3RWZXJpZnkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBwYXlsb2FkOiB7IHN1YjogJzEnLCBwZXJtaXNzaW9uczogWyd3cml0ZSddIH1cbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgKG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgaWQ6IDEsXG4gICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkJywgJ3dyaXRlJ11cbiAgICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVUb2tlblBlcm1pc3Npb24ocmVxLCAncmVhZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IGlzVmFsaWQ6IHRydWUgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBpbnZhbGlkIGZvciB1c2VyIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIHZhbGlkLXRva2VuJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBtb2NrZWRKb3NlLmp3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHBheWxvYWQ6IHsgc3ViOiAnOTk5JyB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIChtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVRva2VuUGVybWlzc2lvbihyZXEsICdyZWFkJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6ICdVc2VyIG5vdCBmb3VuZCdcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gaW52YWxpZCBmb3IgdXNlciB3aXRob3V0IHBlcm1pc3Npb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgdmFsaWQtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tlZEpvc2Uuand0VmVyaWZ5Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgcGF5bG9hZDogeyBzdWI6ICcxJyB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIChtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgIGlkOiAxLFxuICAgICAgICAgcGVybWlzc2lvbnM6IG51bGxcbiAgICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVUb2tlblBlcm1pc3Npb24ocmVxLCAncmVhZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiAnVXNlciBoYXMgbm8gcGVybWlzc2lvbnMnXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIHZhbGlkLXRva2VuJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBtb2NrZWRKb3NlLmp3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHBheWxvYWQ6IHsgc3ViOiAnMScgfVxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAobW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0RhdGFiYXNlIGVycm9yJykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVRva2VuUGVybWlzc2lvbihyZXEsICdyZWFkJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6ICdFcnJvciBjaGVja2luZyBwZXJtaXNzaW9uOiBEYXRhYmFzZSBlcnJvcidcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VXNlcklkRnJvbVRva2VuJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG1pc3NpbmcgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobnVsbClcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VySWRGcm9tVG9rZW4ocmVxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiAxIGZvciBkZXYtdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0JlYXJlciBkZXYtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHVzZXIgSUQgZnJvbSB2YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIHZhbGlkLXRva2VuJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBtb2NrZWRKb3NlLmp3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHBheWxvYWQ6IHsgc3ViOiAnMTIzJyB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgxMjMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgaW52YWxpZCB0b2tlbiBwYXlsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgaW52YWxpZC10b2tlbicpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgbW9ja2VkSm9zZS5qd3RWZXJpZnkubW9ja1Jlc29sdmVkVmFsdWUoeyBwYXlsb2FkOiBudWxsIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlcklkRnJvbVRva2VuKHJlcSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgdG9rZW4gd2l0aG91dCBzdWIgY2xhaW0nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0JlYXJlciBuby1zdWItdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tlZEpvc2Uuand0VmVyaWZ5Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgcGF5bG9hZDogeyBwZXJtaXNzaW9uczogWydyZWFkJ10gfVxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VySWRGcm9tVG9rZW4ocmVxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRTaG9wSWRGcm9tVG9rZW4nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgbWlzc2luZyB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShudWxsKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFNob3BJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGRlZmF1bHQgc2hvcCBJRCBmb3IgZGV2LXRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgZGV2LXRva2VuJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRTaG9wSWRGcm9tVG9rZW4ocmVxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ2NtYnRyOXE2bDAwMDA2MXJvbW94aTd1dmYnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHNob3AgSUQgZnJvbSB2YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIHZhbGlkLXRva2VuJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBtb2NrZWRKb3NlLmp3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHBheWxvYWQ6IHsgc3ViOiAnMScsIHNob3BJZDogJ3Nob3AxMjMnIH1cbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0U2hvcElkRnJvbVRva2VuKHJlcSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdzaG9wMTIzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciB0b2tlbiB3aXRob3V0IHNob3BJZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIG5vLXNob3AtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tlZEpvc2Uuand0VmVyaWZ5Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgcGF5bG9hZDogeyBzdWI6ICcxJyB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFNob3BJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGludmFsaWQgdG9rZW4gcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIGludmFsaWQtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tlZEpvc2Uuand0VmVyaWZ5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgcGF5bG9hZDogbnVsbCB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFNob3BJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29udmVydCBudW1lcmljIHNob3BJZCB0byBzdHJpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0JlYXJlciB2YWxpZC10b2tlbicpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgbW9ja2VkSm9zZS5qd3RWZXJpZnkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBwYXlsb2FkOiB7IHN1YjogJzEnLCBzaG9wSWQ6IDEyMyB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFNob3BJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgnMTIzJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwibW9ja1ByaXNtYSIsIm1vY2tlZEpvc2UiLCJqb3NlIiwidXNlciIsImZpbmRVbmlxdWUiLCJmbiIsImNvbnNvbGVTcHkiLCJsb2ciLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJlcnJvciIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJhZnRlckFsbCIsIm1vY2tSZXN0b3JlIiwiaXQiLCJleHBlY3QiLCJhdXRoT3B0aW9ucyIsInNlY3JldCIsInRvQmVEZWZpbmVkIiwic2Vzc2lvbiIsInN0cmF0ZWd5IiwidG9CZSIsIm1heEFnZSIsImNhbGxiYWNrcyIsImp3dCIsInRva2VuIiwiaWQiLCJwZXJtaXNzaW9ucyIsInJlc3VsdCIsInRvRXF1YWwiLCJuYW1lIiwidG9CZVVuZGVmaW5lZCIsIm1vY2tQYXlsb2FkIiwic3ViIiwiand0VmVyaWZ5IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJwYXlsb2FkIiwidmVyaWZ5VG9rZW4iLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImFueSIsIlVpbnQ4QXJyYXkiLCJFcnJvciIsImNvZGUiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsInRvQmVOdWxsIiwicmVxIiwiaGVhZGVycyIsImdldCIsIm1vY2tSZXR1cm5WYWx1ZSIsImV4dHJhY3RUb2tlbiIsInZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uIiwiaXNWYWxpZCIsIm1lc3NhZ2UiLCJnZXRVc2VySWRGcm9tVG9rZW4iLCJnZXRTaG9wSWRG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