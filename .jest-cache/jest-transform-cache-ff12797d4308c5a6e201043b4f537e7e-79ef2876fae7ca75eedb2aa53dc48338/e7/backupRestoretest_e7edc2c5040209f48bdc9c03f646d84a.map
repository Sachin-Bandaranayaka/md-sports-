{"version":3,"sources":["/Users/sachin/Documents/md-sports-/tests/integration/backupRestore.test.ts"],"sourcesContent":["import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from '@jest/globals';\nimport { PrismaClient } from '@prisma/client';\nimport fetch from 'node-fetch';\nimport fs from 'fs/promises';\nimport path from 'path';\n\n// Initialize test database\nconst prisma = new PrismaClient({\n  datasources: {\n    db: {\n      url: process.env.TEST_DATABASE_URL || process.env.DATABASE_URL\n    }\n  }\n});\n\n// Test configuration\nconst BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:3000';\nconst TEST_ADMIN_TOKEN = 'test-admin-token';\nconst TEST_USER_TOKEN = 'test-user-token';\n\n// Mock data for testing\nconst mockTestData = {\n  categories: [\n    {\n      id: 999901,\n      name: 'Test Category 1',\n      description: 'Test category for backup/restore testing',\n    },\n    {\n      id: 999902,\n      name: 'Test Category 2',\n      description: 'Another test category',\n    }\n  ],\n  suppliers: [\n    {\n      id: 999901,\n      name: 'Test Supplier 1',\n      email: 'supplier1@test.com',\n      phone: '1234567890',\n      address: '123 Test Street',\n      city: 'Test City',\n      status: 'active',\n    }\n  ],\n  customers: [\n    {\n      id: 999901,\n      name: 'Test Customer 1',\n      email: 'customer1@test.com',\n      phone: '0987654321',\n      address: '456 Test Avenue',\n      city: 'Test City',\n    }\n  ],\n  products: [\n    {\n      id: 999901,\n      name: 'Test Product 1',\n      description: 'Test product for backup/restore',\n      price: 99.99,\n      sku: 'TEST-001',\n      categoryId: 999901,\n      weightedAverageCost: 50.00,\n    }\n  ],\n  inventoryItems: [\n    {\n      id: 999901,\n      productId: 999901,\n      shopId: 'test-shop-1',\n      quantity: 100,\n      shopSpecificCost: 45.00,\n    }\n  ],\n  invoices: [\n    {\n      id: 999901,\n      invoiceNumber: 'TEST-INV-001',\n      customerId: 999901,\n      total: 199.98,\n      status: 'paid',\n      shopId: 'test-shop-1',\n    }\n  ]\n};\n\n// Mock authentication middleware\njest.mock('@/lib/auth', () => ({\n  extractToken: jest.fn((request) => {\n    const authHeader = request.headers.get?.('authorization') || request.headers.authorization;\n    return authHeader?.replace('Bearer ', '');\n  }),\n  verifyToken: jest.fn((token) => {\n    if (token === TEST_ADMIN_TOKEN) {\n      return Promise.resolve({ sub: 'admin-user-id' });\n    } else if (token === TEST_USER_TOKEN) {\n      return Promise.resolve({ sub: 'regular-user-id' });\n    }\n    return Promise.resolve(null);\n  }),\n}));\n\n// Mock user permissions\njest.mock('@/lib/utils/permissions', () => ({\n  hasPermission: jest.fn((permissions, permission) => {\n    if (permission === 'admin:all') {\n      return permissions.includes('admin:all');\n    }\n    return false;\n  }),\n}));\n\ndescribe('Backup and Restore Integration Tests', () => {\n  let testShopId: string;\n  let backupFilePath: string;\n\n  beforeAll(async () => {\n    // Connect to test database\n    await prisma.$connect();\n    \n    // Create test shop if it doesn't exist\n    const existingShop = await prisma.shop.findFirst({\n      where: { id: 'test-shop-1' }\n    });\n    \n    if (!existingShop) {\n      await prisma.shop.create({\n        data: {\n          id: 'test-shop-1',\n          name: 'Test Shop 1',\n          location: 'Test Location',\n        }\n      });\n    }\n    testShopId = 'test-shop-1';\n\n    // Create backup directory\n    backupFilePath = path.join(__dirname, '../temp/test-backup.json');\n  });\n\n  afterAll(async () => {\n    // Clean up test data\n    await cleanupTestData();\n    await prisma.$disconnect();\n    \n    // Clean up backup file\n    try {\n      await fs.unlink(backupFilePath);\n    } catch (error) {\n      // File doesn't exist, ignore\n    }\n  });\n\n  beforeEach(async () => {\n    // Clean up before each test\n    await cleanupTestData();\n  });\n\n  afterEach(async () => {\n    // Clean up after each test\n    await cleanupTestData();\n  });\n\n  async function cleanupTestData() {\n    // Delete in proper order to respect foreign key constraints\n    await prisma.inventoryItem.deleteMany({\n      where: { id: { gte: 999900 } }\n    });\n    await prisma.invoice.deleteMany({\n      where: { id: { gte: 999900 } }\n    });\n    await prisma.product.deleteMany({\n      where: { id: { gte: 999900 } }\n    });\n    await prisma.customer.deleteMany({\n      where: { id: { gte: 999900 } }\n    });\n    await prisma.category.deleteMany({\n      where: { id: { gte: 999900 } }\n    });\n    await prisma.supplier.deleteMany({\n      where: { id: { gte: 999900 } }\n    });\n  }\n\n  async function createTestData() {\n    // Create test data in proper order\n    for (const category of mockTestData.categories) {\n      await prisma.category.create({ data: category });\n    }\n    \n    for (const supplier of mockTestData.suppliers) {\n      await prisma.supplier.create({ data: supplier });\n    }\n    \n    for (const customer of mockTestData.customers) {\n      await prisma.customer.create({ data: customer });\n    }\n    \n    for (const product of mockTestData.products) {\n      await prisma.product.create({ data: product });\n    }\n    \n    for (const item of mockTestData.inventoryItems) {\n      await prisma.inventoryItem.create({ data: item });\n    }\n    \n    for (const invoice of mockTestData.invoices) {\n      await prisma.invoice.create({ data: invoice });\n    }\n  }\n\n  describe('Backup Functionality (GET /api/backup)', () => {\n    beforeEach(async () => {\n      await createTestData();\n    });\n\n    it('should successfully generate a backup with admin permissions', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      expect(response.status).toBe(200);\n      \n      const backupData = await response.json();\n      \n      // Verify backup structure\n      expect(backupData).toHaveProperty('timestamp');\n      expect(backupData).toHaveProperty('version', '1.0');\n      expect(backupData).toHaveProperty('users');\n      expect(backupData).toHaveProperty('products');\n      expect(backupData).toHaveProperty('shops');\n      expect(backupData).toHaveProperty('inventoryItems');\n      expect(backupData).toHaveProperty('invoices');\n      expect(backupData).toHaveProperty('customers');\n      expect(backupData).toHaveProperty('categories');\n      expect(backupData).toHaveProperty('suppliers');\n\n      // Verify test data is included\n      expect(backupData.categories).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({ name: 'Test Category 1' })\n        ])\n      );\n      expect(backupData.products).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({ name: 'Test Product 1' })\n        ])\n      );\n\n      // Save backup for restore tests\n      await fs.mkdir(path.dirname(backupFilePath), { recursive: true });\n      await fs.writeFile(backupFilePath, JSON.stringify(backupData, null, 2));\n    });\n\n    it('should reject backup request with insufficient permissions', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${TEST_USER_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      expect(response.status).toBe(403);\n      \n      const errorData = await response.json();\n      expect(errorData).toHaveProperty('error');\n      expect(errorData.error).toContain('Insufficient permissions');\n    });\n\n    it('should reject backup request without authentication', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      expect(response.status).toBe(401);\n      \n      const errorData = await response.json();\n      expect(errorData).toHaveProperty('error');\n      expect(errorData.error).toContain('No authorization token provided');\n    });\n\n    it('should reject backup request with invalid token', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'GET',\n        headers: {\n          'Authorization': 'Bearer invalid-token',\n          'Content-Type': 'application/json',\n        },\n      });\n\n      expect(response.status).toBe(401);\n      \n      const errorData = await response.json();\n      expect(errorData).toHaveProperty('error');\n      expect(errorData.error).toContain('Invalid or expired token');\n    });\n\n    it('should include proper headers for file download', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      expect(response.status).toBe(200);\n      expect(response.headers.get('content-type')).toBe('application/json');\n      expect(response.headers.get('content-disposition')).toBe('attachment; filename=backup.json');\n    });\n  });\n\n  describe('Restore Functionality (POST /api/backup)', () => {\n    let validBackupData: any;\n\n    beforeEach(async () => {\n      // Create some initial data and generate a backup\n      await createTestData();\n      \n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n      });\n      \n      validBackupData = await response.json();\n      \n      // Clear database for restore tests\n      await cleanupTestData();\n    });\n\n    it('should successfully restore from valid backup data', async () => {\n      // Verify database is empty\n      const initialCategoryCount = await prisma.category.count({\n        where: { id: { gte: 999900 } }\n      });\n      expect(initialCategoryCount).toBe(0);\n\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(validBackupData),\n      });\n\n      expect(response.status).toBe(200);\n      \n      const restoreResult = await response.json();\n      expect(restoreResult).toHaveProperty('success', true);\n      expect(restoreResult).toHaveProperty('message', 'Database restored successfully');\n      expect(restoreResult).toHaveProperty('restoredCounts');\n\n      // Verify data was restored\n      const restoredCategories = await prisma.category.findMany({\n        where: { id: { gte: 999900 } }\n      });\n      expect(restoredCategories).toHaveLength(2);\n      \n      const restoredProducts = await prisma.product.findMany({\n        where: { id: { gte: 999900 } }\n      });\n      expect(restoredProducts).toHaveLength(1);\n      expect(restoredProducts[0].name).toBe('Test Product 1');\n    });\n\n    it('should reject restore with insufficient permissions', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_USER_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(validBackupData),\n      });\n\n      expect(response.status).toBe(403);\n      \n      const errorData = await response.json();\n      expect(errorData).toHaveProperty('error');\n      expect(errorData.error).toContain('Insufficient permissions');\n    });\n\n    it('should reject restore without authentication', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(validBackupData),\n      });\n\n      expect(response.status).toBe(401);\n      \n      const errorData = await response.json();\n      expect(errorData).toHaveProperty('error');\n      expect(errorData.error).toContain('No authorization token provided');\n    });\n\n    it('should reject invalid backup data format', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ invalid: 'data' }),\n      });\n\n      expect(response.status).toBe(400);\n      \n      const errorData = await response.json();\n      expect(errorData).toHaveProperty('error');\n      expect(errorData.error).toContain('Invalid backup data format');\n    });\n\n    it('should reject incompatible backup version', async () => {\n      const incompatibleBackup = {\n        ...validBackupData,\n        version: '2.0'\n      };\n\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(incompatibleBackup),\n      });\n\n      expect(response.status).toBe(400);\n      \n      const errorData = await response.json();\n      expect(errorData).toHaveProperty('error');\n      expect(errorData.error).toContain('Backup version incompatible');\n    });\n\n    it('should handle malformed JSON gracefully', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: '{ invalid json',\n      });\n\n      expect(response.status).toBe(400);\n    });\n\n    it('should restore data in correct order respecting foreign key constraints', async () => {\n      // Create a backup with complex relationships\n      const complexBackupData = {\n        ...validBackupData,\n        categories: [\n          { id: 999903, name: 'Parent Category', description: 'Parent' },\n          { id: 999904, name: 'Child Category', description: 'Child', parentId: 999903 }\n        ],\n        products: [\n          { \n            id: 999903, \n            name: 'Complex Product', \n            price: 150.00, \n            categoryId: 999904,\n            weightedAverageCost: 75.00 \n          }\n        ]\n      };\n\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(complexBackupData),\n      });\n\n      expect(response.status).toBe(200);\n\n      // Verify relationships are maintained\n      const restoredProduct = await prisma.product.findUnique({\n        where: { id: 999903 },\n        include: { category: true }\n      });\n      \n      expect(restoredProduct).toBeDefined();\n      expect(restoredProduct?.category?.name).toBe('Child Category');\n    });\n\n    it('should provide detailed restore counts', async () => {\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(validBackupData),\n      });\n\n      expect(response.status).toBe(200);\n      \n      const restoreResult = await response.json();\n      expect(restoreResult.restoredCounts).toEqual({\n        users: 0, // We don't restore users in this implementation\n        products: expect.any(Number),\n        shops: 0, // We don't restore shops in this implementation\n        inventoryItems: expect.any(Number),\n        invoices: expect.any(Number),\n        customers: expect.any(Number),\n        categories: expect.any(Number),\n        suppliers: expect.any(Number),\n      });\n    });\n  });\n\n  describe('End-to-End Backup and Restore Workflow', () => {\n    it('should complete full backup and restore cycle maintaining data integrity', async () => {\n      // Step 1: Create initial test data\n      await createTestData();\n      \n      // Step 2: Generate backup\n      const backupResponse = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n        },\n      });\n      \n      expect(backupResponse.status).toBe(200);\n      const backupData = await backupResponse.json();\n      \n      // Step 3: Verify initial data exists\n      const initialProductCount = await prisma.product.count({\n        where: { id: { gte: 999900 } }\n      });\n      expect(initialProductCount).toBeGreaterThan(0);\n      \n      // Step 4: Clear all data (simulating data loss)\n      await cleanupTestData();\n      \n      // Step 5: Verify data is gone\n      const afterClearCount = await prisma.product.count({\n        where: { id: { gte: 999900 } }\n      });\n      expect(afterClearCount).toBe(0);\n      \n      // Step 6: Restore from backup\n      const restoreResponse = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(backupData),\n      });\n      \n      expect(restoreResponse.status).toBe(200);\n      \n      // Step 7: Verify data is restored correctly\n      const restoredProductCount = await prisma.product.count({\n        where: { id: { gte: 999900 } }\n      });\n      expect(restoredProductCount).toBe(initialProductCount);\n      \n      // Step 8: Verify data integrity\n      const restoredProduct = await prisma.product.findFirst({\n        where: { name: 'Test Product 1' },\n        include: { \n          category: true,\n          inventoryItems: true \n        }\n      });\n      \n      expect(restoredProduct).toBeDefined();\n      expect(restoredProduct?.name).toBe('Test Product 1');\n      expect(restoredProduct?.category?.name).toBe('Test Category 1');\n      expect(restoredProduct?.inventoryItems).toHaveLength(1);\n      expect(restoredProduct?.inventoryItems[0].quantity).toBe(100);\n    });\n\n    it('should handle large dataset backup and restore', async () => {\n      // Create larger dataset\n      const largeDataset = {\n        categories: Array.from({ length: 10 }, (_, i) => ({\n          id: 999910 + i,\n          name: `Large Test Category ${i + 1}`,\n          description: `Description for category ${i + 1}`,\n        })),\n        products: Array.from({ length: 50 }, (_, i) => ({\n          id: 999910 + i,\n          name: `Large Test Product ${i + 1}`,\n          price: 10.00 + i,\n          sku: `LARGE-${(i + 1).toString().padStart(3, '0')}`,\n          categoryId: 999910 + (i % 10),\n          weightedAverageCost: 5.00 + i,\n        })),\n      };\n\n      // Create large dataset\n      for (const category of largeDataset.categories) {\n        await prisma.category.create({ data: category });\n      }\n      for (const product of largeDataset.products) {\n        await prisma.product.create({ data: product });\n      }\n\n      // Test backup performance\n      const startTime = Date.now();\n      const backupResponse = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n        },\n      });\n      const backupTime = Date.now() - startTime;\n      \n      expect(backupResponse.status).toBe(200);\n      expect(backupTime).toBeLessThan(10000); // Should complete within 10 seconds\n      \n      const backupData = await backupResponse.json();\n      expect(backupData.categories.length).toBeGreaterThanOrEqual(10);\n      expect(backupData.products.length).toBeGreaterThanOrEqual(50);\n\n      // Clean and restore\n      await cleanupTestData();\n      \n      const restoreStartTime = Date.now();\n      const restoreResponse = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(backupData),\n      });\n      const restoreTime = Date.now() - restoreStartTime;\n      \n      expect(restoreResponse.status).toBe(200);\n      expect(restoreTime).toBeLessThan(15000); // Should complete within 15 seconds\n      \n      // Verify all data was restored\n      const restoredCategories = await prisma.category.count({\n        where: { id: { gte: 999910 } }\n      });\n      const restoredProducts = await prisma.product.count({\n        where: { id: { gte: 999910 } }\n      });\n      \n      expect(restoredCategories).toBe(10);\n      expect(restoredProducts).toBe(50);\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    it('should handle database connection issues during backup', async () => {\n      // This test would need to mock database failures\n      // For now, we'll test the basic error handling structure\n      \n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n        },\n      });\n      \n      // Should either succeed or return a proper error response\n      expect([200, 500]).toContain(response.status);\n      \n      if (response.status === 500) {\n        const errorData = await response.json();\n        expect(errorData).toHaveProperty('error');\n        expect(errorData.error).toContain('Failed to generate backup');\n      }\n    });\n\n    it('should handle database transaction failures during restore', async () => {\n      // Create a backup with invalid foreign key references\n      const invalidBackupData = {\n        version: '1.0',\n        timestamp: new Date().toISOString(),\n        categories: [],\n        suppliers: [],\n        customers: [],\n        users: [],\n        shops: [],\n        products: [\n          {\n            id: 999950,\n            name: 'Invalid Product',\n            price: 100.00,\n            categoryId: 999999, // Non-existent category\n            weightedAverageCost: 50.00,\n          }\n        ],\n        inventoryItems: [],\n        invoices: [],\n      };\n\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(invalidBackupData),\n      });\n\n      expect(response.status).toBe(500);\n      \n      const errorData = await response.json();\n      expect(errorData).toHaveProperty('error');\n      expect(errorData.error).toContain('Failed to restore backup');\n    });\n\n    it('should handle empty backup data gracefully', async () => {\n      const emptyBackupData = {\n        version: '1.0',\n        timestamp: new Date().toISOString(),\n        categories: [],\n        suppliers: [],\n        customers: [],\n        users: [],\n        shops: [],\n        products: [],\n        inventoryItems: [],\n        invoices: [],\n      };\n\n      const response = await fetch(`${BASE_URL}/api/backup`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${TEST_ADMIN_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(emptyBackupData),\n      });\n\n      expect(response.status).toBe(200);\n      \n      const restoreResult = await response.json();\n      expect(restoreResult.success).toBe(true);\n      expect(restoreResult.restoredCounts).toEqual({\n        users: 0,\n        products: 0,\n        shops: 0,\n        inventoryItems: 0,\n        invoices: 0,\n        customers: 0,\n        categories: 0,\n        suppliers: 0,\n      });\n    });\n  });\n}); "],"names":["jest","mock","extractToken","fn","request","authHeader","headers","get","authorization","replace","verifyToken","token","TEST_ADMIN_TOKEN","Promise","resolve","sub","TEST_USER_TOKEN","hasPermission","permissions","permission","includes","prisma","PrismaClient","datasources","db","url","process","env","TEST_DATABASE_URL","DATABASE_URL","BASE_URL","TEST_BASE_URL","mockTestData","categories","id","name","description","suppliers","email","phone","address","city","status","customers","products","price","sku","categoryId","weightedAverageCost","inventoryItems","productId","shopId","quantity","shopSpecificCost","invoices","invoiceNumber","customerId","total","describe","testShopId","backupFilePath","beforeAll","$connect","existingShop","shop","findFirst","where","create","data","location","path","join","__dirname","afterAll","cleanupTestData","$disconnect","fs","unlink","error","beforeEach","afterEach","inventoryItem","deleteMany","gte","invoice","product","customer","category","supplier","createTestData","item","it","response","fetch","method","expect","toBe","backupData","json","toHaveProperty","toEqual","arrayContaining","objectContaining","mkdir","dirname","recursive","writeFile","JSON","stringify","errorData","toContain","validBackupData","initialCategoryCount","count","body","restoreResult","restoredCategories","findMany","toHaveLength","restoredProducts","invalid","incompatibleBackup","version","complexBackupData","parentId","restoredProduct","findUnique","include","toBeDefined","restoredCounts","users","any","Number","shops","backupResponse","initialProductCount","toBeGreaterThan","afterClearCount","restoreResponse","restoredProductCount","largeDataset","Array","from","length","_","i","toString","padStart","startTime","Date","now","backupTime","toBeLessThan","toBeGreaterThanOrEqual","restoreStartTime","restoreTime","invalidBackupData","timestamp","toISOString","emptyBackupData","success"],"mappings":"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"}