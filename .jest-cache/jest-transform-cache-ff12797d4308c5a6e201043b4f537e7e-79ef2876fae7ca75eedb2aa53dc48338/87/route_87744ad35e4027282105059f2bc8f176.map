{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/app/api/purchases/[id]/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { revalidateTag, revalidatePath } from 'next/cache';\nimport prisma from '@/lib/prisma';\nimport { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';\nimport { getToken } from 'next-auth/jwt';\nimport { cacheService } from '@/lib/cache';\n\n// GET /api/purchases/[id] - Get a specific purchase invoice\nexport async function GET(\n    request: NextRequest,\n    { params }: { params: { id: string } }\n) {\n    const id = params.id; // Store params.id early to avoid async issues\n    try {\n        const purchaseId = parseInt(id);\n\n        if (isNaN(purchaseId)) {\n            return NextResponse.json(\n                { error: { message: 'Invalid purchase ID format' } },\n                { status: 400 }\n            );\n        }\n\n        const purchase = await prisma.purchaseInvoice.findUnique({\n            where: {\n                id: purchaseId\n            },\n            include: {\n                supplier: true,\n                items: {\n                    include: {\n                        product: true\n                    }\n                }\n            }\n        });\n\n        if (!purchase) {\n            return NextResponse.json(\n                { error: { message: 'Purchase invoice not found' } },\n                { status: 404 }\n            );\n        }\n\n        return NextResponse.json(purchase);\n    } catch (error) {\n        console.error(`Error fetching purchase invoice ${id}:`, error);\n        const details = error instanceof Error ? error.message : 'An unknown error occurred';\n        return NextResponse.json(\n            { error: { message: 'Failed to fetch purchase invoice', details: details } },\n            { status: 500 }\n        );\n    }\n}\n\n// PUT /api/purchases/[id] - Update a purchase invoice\nexport async function PUT(\n    request: NextRequest,\n    { params }: { params: { id: string } }\n) {\n    const id = params.id;\n    try {\n        const purchaseId = parseInt(id);\n        if (isNaN(purchaseId)) {\n            return NextResponse.json(\n                { error: { message: 'Invalid purchase ID format' } },\n                { status: 400 });\n        }\n        const body = await request.json();\n        const originalPurchase = await prisma.purchaseInvoice.findUnique({\n            where: { id: purchaseId },\n            include: { items: { include: { product: true } } },\n        });\n        if (!originalPurchase) {\n            return NextResponse.json(\n                { error: { message: 'Purchase invoice not found to update' } },\n                { status: 404 });\n        }\n        const { items: newItemsData, distributions: newDistributionsData, ...invoiceData } = body;\n        const { id: _, createdAt, updatedAt, supplier, notes, ...dirtyData } = invoiceData;\n        const cleanedInvoiceData: any = {};\n        if (dirtyData.invoiceNumber) cleanedInvoiceData.invoiceNumber = dirtyData.invoiceNumber;\n        if (dirtyData.status) cleanedInvoiceData.status = dirtyData.status;\n        if (dirtyData.date) cleanedInvoiceData.date = new Date(dirtyData.date);\n        if (dirtyData.dueDate !== undefined) cleanedInvoiceData.dueDate = dirtyData.dueDate ? new Date(dirtyData.dueDate) : null;\n        if (dirtyData.totalAmount !== undefined) cleanedInvoiceData.total = Number(dirtyData.totalAmount);\n        else if (dirtyData.total !== undefined) cleanedInvoiceData.total = Number(dirtyData.total);\n        cleanedInvoiceData.distributions = newDistributionsData !== undefined ? newDistributionsData : originalPurchase.distributions;\n        if (dirtyData.supplierId) cleanedInvoiceData.supplier = { connect: { id: Number(dirtyData.supplierId) } };\n        else if (dirtyData.supplierId === null && originalPurchase.supplierId) cleanedInvoiceData.supplier = { disconnect: true };\n\n        const result = await prisma.$transaction(async (tx) => {\n            const inventoryUpdates: Array<{ productId: number, shopId: number, newQuantity: number, oldQuantity?: number }> = [];\n\n            if (originalPurchase.items && originalPurchase.items.length > 0) {\n                for (const oldItem of originalPurchase.items) {\n                    const productToUpdate = await tx.product.findUnique({ where: { id: oldItem.productId } });\n                    if (!productToUpdate) continue;\n\n                    const oldItemDistribution = originalPurchase.distributions && Array.isArray(originalPurchase.distributions) && originalPurchase.items.indexOf(oldItem) < originalPurchase.distributions.length\n                        ? originalPurchase.distributions[originalPurchase.items.indexOf(oldItem)]\n                        : (originalPurchase.distributions && typeof originalPurchase.distributions === 'object' && !Array.isArray(originalPurchase.distributions) ? originalPurchase.distributions : null);\n\n                    if (oldItemDistribution && Object.keys(oldItemDistribution).length > 0) {\n                        for (const [shopIdStr, quantityInShop] of Object.entries(oldItemDistribution as any)) {\n                            const shopId = shopIdStr;\n                            const qtyToRemove = Number(quantityInShop);\n                            if (qtyToRemove <= 0 || isNaN(qtyToRemove)) continue;\n                            const inventory = await tx.inventoryItem.findFirst({ where: { productId: oldItem.productId, shopId: shopId } });\n                            if (inventory) {\n                                const oldShopQuantity = inventory.quantity;\n                                const newQuantity = Math.max(0, inventory.quantity - qtyToRemove);\n                                await tx.inventoryItem.update({\n                                    where: { id: inventory.id },\n                                    data: {\n                                        quantity: newQuantity,\n                                        // If new quantity is 0, reset shopSpecificCost, else keep existing\n                                        shopSpecificCost: newQuantity === 0 ? 0 : inventory.shopSpecificCost\n                                    }\n                                });\n                                inventoryUpdates.push({ productId: oldItem.productId, shopId: Number(shopId), newQuantity, oldQuantity: oldShopQuantity });\n                            }\n                        }\n                    } else {\n                        // oldItemDistribution is missing. Attempt to infer shop for stock reversal.\n                        console.warn(`Old item ${oldItem.productId} in purchase ${purchaseId} has no distribution. Attempting to infer shop for stock reversal.`);\n                        const existingInventoriesForOldItem = await tx.inventoryItem.findMany({\n                            where: { productId: oldItem.productId }\n                        });\n                        if (existingInventoriesForOldItem.length === 1) {\n                            const shopIdToReverseFrom = existingInventoriesForOldItem[0].shopId;\n                            const inventory = existingInventoriesForOldItem[0]; // Already fetched\n                            const oldShopQuantity = inventory.quantity;\n                            const newQuantity = Math.max(0, inventory.quantity - oldItem.quantity); // Use total oldItem.quantity\n                            await tx.inventoryItem.update({\n                                where: { id: inventory.id },\n                                data: {\n                                    quantity: newQuantity,\n                                    // If new quantity is 0, reset shopSpecificCost, else keep existing\n                                    shopSpecificCost: newQuantity === 0 ? 0 : inventory.shopSpecificCost\n                                }\n                            });\n                            inventoryUpdates.push({ productId: oldItem.productId, shopId: Number(shopIdToReverseFrom), newQuantity, oldQuantity: oldShopQuantity });\n                            console.log(`Reversed ${oldItem.quantity} from product ${oldItem.productId} in inferred shop ${shopIdToReverseFrom}.`);\n                        } else if (existingInventoriesForOldItem.length === 0) {\n                            console.error(`Old item ${oldItem.productId} not found in any inventory. Cannot reverse stock for this item line from a specific shop.`);\n                        } else { // Multiple shops\n                            console.error(`Old item ${oldItem.productId} exists in multiple shops and no specific distribution for reversal. Ambiguous. Stock not reversed from a specific shop for this item line.`);\n                        }\n                    }\n\n                    let currentTotalProductQuantity = 0;\n                    const allInventoryForProductAfterReversal = await tx.inventoryItem.findMany({ where: { productId: oldItem.productId } });\n                    currentTotalProductQuantity = allInventoryForProductAfterReversal.reduce((sum, inv) => sum + inv.quantity, 0);\n\n                    // Recalculate WAC based on remaining purchase history after removing this item\n                    const remainingPurchaseItems = await tx.purchaseInvoiceItem.findMany({\n                        where: {\n                            productId: oldItem.productId,\n                            purchaseInvoiceId: { not: purchaseId } // Exclude current invoice being updated\n                        }\n                    });\n\n                    let totalRemainingQuantity = 0;\n                    let totalRemainingValue = 0;\n\n                    remainingPurchaseItems.forEach(purchaseItem => {\n                        totalRemainingQuantity += purchaseItem.quantity;\n                        totalRemainingValue += purchaseItem.quantity * purchaseItem.price;\n                    });\n\n                    let newWAC = 0;\n                    if (totalRemainingQuantity > 0) {\n                        newWAC = totalRemainingValue / totalRemainingQuantity;\n                    }\n\n                    await tx.product.update({\n                        where: { id: oldItem.productId },\n                        data: { weightedAverageCost: newWAC >= 0 ? newWAC : 0 }\n                    });\n                }\n            }\n\n            await tx.purchaseInvoiceItem.deleteMany({ where: { purchaseInvoiceId: purchaseId } });\n\n            // Recalculate totalAmount for the invoice based on new/updated items\n            let newTotalInvoiceAmount = 0;\n            if (newItemsData && Array.isArray(newItemsData)) {\n                newItemsData.forEach(item => {\n                    newTotalInvoiceAmount += Number(item.quantity) * Number(item.price || 0);\n                });\n            }\n            cleanedInvoiceData.total = newTotalInvoiceAmount; // Ensure this is assigned to the correct field for DB update\n\n            const updatedInvoice = await tx.purchaseInvoice.update({ where: { id: purchaseId }, data: cleanedInvoiceData });\n\n            if (newItemsData && Array.isArray(newItemsData)) {\n                for (let i = 0; i < newItemsData.length; i++) {\n                    const newItem = newItemsData[i];\n                    if (!newItem.productId || !newItem.quantity || newItem.quantity <= 0) continue;\n                    await tx.purchaseInvoiceItem.create({\n                        data: {\n                            purchaseInvoiceId: purchaseId, productId: Number(newItem.productId),\n                            quantity: Number(newItem.quantity), price: Number(newItem.price || 0),\n                            total: Number(newItem.quantity) * Number(newItem.price || 0)\n                        }\n                    });\n                    const productToUpdate = await tx.product.findUnique({ where: { id: Number(newItem.productId) } });\n                    if (!productToUpdate) continue;\n\n                    const newItemDistribution = newDistributionsData && Array.isArray(newDistributionsData) && newDistributionsData[i]\n                        ? newDistributionsData[i]\n                        : (newDistributionsData && typeof newDistributionsData === 'object' && !Array.isArray(newDistributionsData) ? newDistributionsData : null);\n\n                    const itemQuantityTotal = Number(newItem.quantity);\n\n                    if (newItemDistribution && Object.keys(newItemDistribution).length > 0) {\n                        for (const [shopIdStr, quantityInShop] of Object.entries(newItemDistribution as any)) {\n                            const shopId = shopIdStr;\n                            const qtyToAdd = Number(quantityInShop);\n                            if (qtyToAdd <= 0 || isNaN(qtyToAdd)) continue;\n\n                            const inventory = await tx.inventoryItem.findFirst({ where: { productId: Number(newItem.productId), shopId: shopId } });\n                            let finalQuantity = 0;\n                            const oldInvQty = inventory?.quantity || 0;\n                            let newShopSpecificCostValue = 0;\n                            const itemPrice = Number(newItem.price || 0);\n\n                            if (inventory) {\n                                finalQuantity = inventory.quantity + qtyToAdd;\n                                const oldShopTotalValue = (inventory.quantity || 0) * (inventory.shopSpecificCost || 0);\n                                const valueOfThisBatch = qtyToAdd * itemPrice;\n                                if (finalQuantity > 0) {\n                                    newShopSpecificCostValue = (oldShopTotalValue + valueOfThisBatch) / finalQuantity;\n                                } else {\n                                    newShopSpecificCostValue = 0;\n                                }\n                                await tx.inventoryItem.update({\n                                    where: { id: inventory.id },\n                                    data: { quantity: finalQuantity, shopSpecificCost: newShopSpecificCostValue >= 0 ? newShopSpecificCostValue : 0 }\n                                });\n                            } else {\n                                finalQuantity = qtyToAdd;\n                                newShopSpecificCostValue = itemPrice;\n                                await tx.inventoryItem.create({\n                                    data: {\n                                        productId: Number(newItem.productId),\n                                        shopId: shopId,\n                                        quantity: finalQuantity,\n                                        shopSpecificCost: newShopSpecificCostValue >= 0 ? newShopSpecificCostValue : 0\n                                    }\n                                });\n                            }\n                            inventoryUpdates.push({ productId: Number(newItem.productId), shopId: Number(shopId), newQuantity: finalQuantity, oldQuantity: oldInvQty });\n                        }\n                    } else {\n                        // newItemDistribution is missing or empty. Try to infer shop or log error.\n                        console.warn(`Purchase item with productId ${newItem.productId} in invoice ${purchaseId} does not have explicit shop distribution data. Attempting to infer target shop.`);\n                        const existingInventoryItems = await tx.inventoryItem.findMany({\n                            where: { productId: Number(newItem.productId) }\n                        });\n\n                        let targetShopId: string | null = null;\n\n                        if (existingInventoryItems.length === 1) {\n                            targetShopId = existingInventoryItems[0].shopId;\n                            console.log(`Product ${newItem.productId} exists in one shop (${targetShopId}). Attributing new stock there.`);\n                        } else if (existingInventoryItems.length === 0) {\n                            console.error(`Product ${newItem.productId} is new to inventory and no shop distribution provided. Cannot automatically assign to a shop. Inventory not updated for this item.`);\n                        } else { // existingInventoryItems.length > 1\n                            console.error(`Product ${newItem.productId} exists in multiple shops and no specific distribution provided. Ambiguous. Inventory not updated for this item.`);\n                        }\n\n                        if (targetShopId) {\n                            const qtyToAdd = itemQuantityTotal; // The total quantity for this newItem.\n                            if (qtyToAdd > 0) {\n                                const inventory = await tx.inventoryItem.findFirst({ where: { productId: Number(newItem.productId), shopId: targetShopId } });\n                                let finalQuantity = 0;\n                                const oldInvQty = inventory?.quantity || 0;\n                                let newShopSpecificCostValue = 0;\n                                const itemPrice = Number(newItem.price || 0);\n\n                                if (inventory) {\n                                    finalQuantity = inventory.quantity + qtyToAdd;\n                                    const oldShopTotalValue = (inventory.quantity || 0) * (inventory.shopSpecificCost || 0);\n                                    const valueOfThisBatch = qtyToAdd * itemPrice;\n                                    if (finalQuantity > 0) {\n                                        newShopSpecificCostValue = (oldShopTotalValue + valueOfThisBatch) / finalQuantity;\n                                    } else {\n                                        newShopSpecificCostValue = 0;\n                                    }\n                                    await tx.inventoryItem.update({\n                                        where: { id: inventory.id },\n                                        data: { quantity: finalQuantity, shopSpecificCost: newShopSpecificCostValue >= 0 ? newShopSpecificCostValue : 0 }\n                                    });\n                                } else {\n                                    finalQuantity = qtyToAdd;\n                                    newShopSpecificCostValue = itemPrice;\n                                    console.warn(`InventoryItem for product ${newItem.productId} in targetShopId ${targetShopId} not found during update, attempting create.`);\n                                    await tx.inventoryItem.create({\n                                        data: {\n                                            productId: Number(newItem.productId),\n                                            shopId: targetShopId,\n                                            quantity: finalQuantity,\n                                            shopSpecificCost: newShopSpecificCostValue >= 0 ? newShopSpecificCostValue : 0\n                                        }\n                                    });\n                                }\n                                inventoryUpdates.push({ productId: Number(newItem.productId), shopId: Number(targetShopId), newQuantity: finalQuantity, oldQuantity: oldInvQty });\n                            } else {\n                                console.warn(`Quantity for product ${newItem.productId} is zero or negative. No inventory update performed for this item.`);\n                            }\n                        }\n                    }\n\n                    // Recalculate WAC based on all purchase history for this product\n                    // This ensures accuracy regardless of update order\n                    const allPurchaseItems = await tx.purchaseInvoiceItem.findMany({\n                        where: { productId: Number(newItem.productId) }\n                    });\n\n                    let totalPurchaseQuantity = 0;\n                    let totalPurchaseValue = 0;\n\n                    allPurchaseItems.forEach(purchaseItem => {\n                        totalPurchaseQuantity += purchaseItem.quantity;\n                        totalPurchaseValue += purchaseItem.quantity * purchaseItem.price;\n                    });\n\n                    let newWeightedAverageCost = 0;\n                    if (totalPurchaseQuantity > 0) {\n                        newWeightedAverageCost = totalPurchaseValue / totalPurchaseQuantity;\n                    }\n\n                    // Ensure WAC is valid\n                    if (newWeightedAverageCost <= 0 || isNaN(newWeightedAverageCost)) {\n                        newWeightedAverageCost = Number(newItem.price);\n                    }\n\n                    await tx.product.update({\n                        where: { id: Number(newItem.productId) },\n                        data: { weightedAverageCost: newWeightedAverageCost }\n                    });\n                }\n            }\n            const fullUpdatedInvoice = await tx.purchaseInvoice.findUnique({\n                where: { id: purchaseId },\n                include: { supplier: true, items: { include: { product: true } } }\n            });\n            return { fullUpdatedInvoice, inventoryUpdates };\n        }, { timeout: 30000 });\n\n        // Real-time updates now handled by polling system\n        if (result && result.fullUpdatedInvoice) {\n            console.log('Purchase invoice updated successfully');\n        }\n\n        // After successful transaction, invalidate relevant caches\n        try {\n            await cacheService.invalidateInventory(); // Handles 'inventory:summary:*' and 'products:*'\n            await cacheService.del('dashboard:inventory');\n            await cacheService.del('dashboard:inventory-value');\n            await cacheService.del('dashboard:shops');\n            await cacheService.del('dashboard:all');\n            await cacheService.del('dashboard:summary');\n            // Invalidate purchases-specific caches\n            await cacheService.invalidatePattern('purchases-optimized*');\n            await cacheService.invalidatePattern('purchase-stats*');\n            console.log('Relevant caches invalidated after purchase update.');\n        } catch (cacheError) {\n            console.error('Error invalidating caches after purchase update:', cacheError);\n            // Do not let cache invalidation error fail the main operation\n        }\n\n        // Revalidate Next.js cached pages\n        try {\n            revalidateTag('purchase-invoices');\n            revalidateTag(`purchase-${purchaseId}`);\n            revalidatePath(`/purchases/${purchaseId}`);\n            revalidatePath(`/purchases/${purchaseId}/edit`);\n            revalidatePath('/purchases');\n            console.log('Next.js pages revalidated after purchase update.');\n        } catch (revalidateError) {\n            console.error('Error revalidating Next.js pages after purchase update:', revalidateError);\n        }\n\n        return NextResponse.json({\n            message: 'Purchase invoice updated successfully',\n            data: result.fullUpdatedInvoice\n        });\n    } catch (error) {\n        console.error(`Error updating purchase invoice ${id}:`, error);\n        const details = error instanceof Error ? error.message : String(error);\n        return NextResponse.json(\n            { error: { message: 'Failed to update purchase invoice', details: details } },\n            { status: 500 });\n    }\n}\n\n// DELETE /api/purchases/[id] - Delete a purchase invoice\nexport async function DELETE(\n    request: NextRequest,\n    { params }: { params: { id: string } }\n) {\n    const purchaseIdStr = params.id;\n    try {\n        const purchaseId = parseInt(purchaseIdStr);\n        if (isNaN(purchaseId)) {\n            return NextResponse.json(\n                { error: { message: 'Invalid purchase ID format' } },\n                { status: 400 });\n        }\n\n        const purchaseToDelete = await prisma.purchaseInvoice.findUnique({\n            where: { id: purchaseId },\n            include: {\n                items: { include: { product: true } },\n                // Ensure 'distributions' is included if it's a relation,\n                // or directly accessible if it's a JSON field on PurchaseInvoice\n            },\n        });\n\n        if (!purchaseToDelete) {\n            return NextResponse.json(\n                { error: { message: 'Purchase invoice not found to delete' } },\n                { status: 404 });\n        }\n\n        const result = await prisma.$transaction(async (tx) => {\n            const inventoryUpdates: Array<{ productId: number, shopId: number, newQuantity: number, oldQuantity?: number }> = [];\n\n            if (purchaseToDelete.items && purchaseToDelete.items.length > 0) {\n                for (const item of purchaseToDelete.items) {\n                    if (!item.product) {\n                        console.warn(`Item ${item.id} for purchase ${purchaseId} is missing product data. Skipping stock adjustment.`);\n                        continue;\n                    }\n\n                    const productId = item.productId;\n                    const quantityToRemoveForItemTotal = item.quantity; // Total quantity for this item line\n\n                    let itemDistributionInfo: { [shopId: string]: number } | null = null;\n                    const distributionsOnInvoice = (purchaseToDelete as any).distributions;\n\n                    // Attempt to get specific distribution for this item\n                    if (\n                        distributionsOnInvoice &&\n                        Array.isArray(distributionsOnInvoice) &&\n                        purchaseToDelete.items.indexOf(item) < distributionsOnInvoice.length\n                    ) {\n                        const distData = distributionsOnInvoice[purchaseToDelete.items.indexOf(item)];\n                        if (distData && typeof distData === 'object' && Object.keys(distData).length > 0) {\n                            itemDistributionInfo = distData as { [shopId: string]: number };\n                        }\n                    }\n\n                    if (itemDistributionInfo) {\n                        // Case 1: Explicit distribution data found for the item\n                        console.log(`Reversing item-specific distribution for product ${productId}, purchase ${purchaseId}`);\n                        for (const [shopIdStr, distributedQuantityStr] of Object.entries(itemDistributionInfo)) {\n                            const shopId = shopIdStr;\n                            const qtyInShopToRemove = Number(distributedQuantityStr);\n\n                            if (isNaN(qtyInShopToRemove) || qtyInShopToRemove <= 0) continue;\n\n                            const inventoryItem = await tx.inventoryItem.findFirst({ where: { productId, shopId: shopId } });\n                            if (inventoryItem) {\n                                const oldShopQuantity = inventoryItem.quantity;\n                                const newShopQuantity = Math.max(0, inventoryItem.quantity - qtyInShopToRemove);\n                                const updateData = {\n                                    quantity: newShopQuantity,\n                                    shopSpecificCost: newShopQuantity === 0 ? 0 : inventoryItem.shopSpecificCost\n                                };\n                                await tx.inventoryItem.update({\n                                    where: { id: inventoryItem.id },\n                                    data: updateData,\n                                });\n                                inventoryUpdates.push({ productId, shopId: Number(shopId), newQuantity: newShopQuantity, oldQuantity: oldShopQuantity });\n                                console.log(`  - Reduced inventory for product ${productId} in shop ${shopId} by ${qtyInShopToRemove}. Old: ${oldShopQuantity}, New: ${newShopQuantity}`);\n                            } else {\n                                console.warn(`  - Inventory item not found for product ${productId} in shop ${shopId} during purchase deletion with explicit distribution. Stock may be inaccurate.`);\n                            }\n                        }\n                    } else {\n                        // Case 2: No explicit distribution for this item. Attempt to infer.\n                        console.warn(`No specific distribution found for item ${productId} in deleted purchase ${purchaseId}. Attempting to infer shop(s) for stock reversal of total quantity ${quantityToRemoveForItemTotal}.`);\n                        const existingInventoriesForItem = await tx.inventoryItem.findMany({\n                            where: { productId: productId }\n                        });\n\n                        if (existingInventoriesForItem.length === 1) {\n                            const singleShopInventory = existingInventoriesForItem[0];\n                            const shopIdToDeductFrom = singleShopInventory.shopId;\n\n                            console.log(`Product ${productId} found in single shop ${shopIdToDeductFrom}. Deducting total item quantity ${quantityToRemoveForItemTotal}.`);\n                            const oldShopQuantity = singleShopInventory.quantity;\n                            const newShopQuantity = Math.max(0, singleShopInventory.quantity - quantityToRemoveForItemTotal);\n                            const updateDataInferred = {\n                                quantity: newShopQuantity,\n                                shopSpecificCost: newShopQuantity === 0 ? 0 : singleShopInventory.shopSpecificCost\n                            };\n                            await tx.inventoryItem.update({\n                                where: { id: singleShopInventory.id },\n                                data: updateDataInferred,\n                            });\n                            inventoryUpdates.push({ productId, shopId: Number(shopIdToDeductFrom), newQuantity: newShopQuantity, oldQuantity: oldShopQuantity });\n                            console.log(`  - Reduced inventory for product ${productId} in inferred shop ${shopIdToDeductFrom} by ${quantityToRemoveForItemTotal}. Old: ${oldShopQuantity}, New: ${newShopQuantity}`);\n                        } else if (existingInventoriesForItem.length === 0) {\n                            console.error(`Product ${productId} (from deleted purchase ${purchaseId}) not found in any inventory. Cannot reverse stock for this item.`);\n                        } else { // Product exists in multiple shops\n                            console.error(`Product ${productId} (from deleted purchase ${purchaseId}) exists in multiple shops, but no specific distribution data was found on the invoice for reversal. Ambiguous. Stock not automatically reversed for this item. Manual adjustment may be needed.`);\n                        }\n                    }\n\n                    // ---- BEGIN WAC Recalculation for the deleted item ----\n                    const remainingPurchaseItems = await tx.purchaseInvoiceItem.findMany({\n                        where: {\n                            productId: productId,\n                            purchaseInvoiceId: { not: purchaseId }\n                        }\n                    });\n\n                    let totalRemainingQuantity = 0;\n                    let totalRemainingValue = 0;\n                    remainingPurchaseItems.forEach(pItem => {\n                        totalRemainingQuantity += pItem.quantity;\n                        totalRemainingValue += pItem.quantity * pItem.price;\n                    });\n\n                    let newCalculatedWAC = 0;\n                    if (totalRemainingQuantity > 0) {\n                        newCalculatedWAC = totalRemainingValue / totalRemainingQuantity;\n                    }\n                    await tx.product.update({\n                        where: { id: productId },\n                        data: { weightedAverageCost: newCalculatedWAC >= 0 ? newCalculatedWAC : 0 }\n                    });\n                    // ---- END WAC Recalculation ----\n                }\n            }\n\n            await tx.purchaseInvoiceItem.deleteMany({ where: { purchaseInvoiceId: purchaseId } });\n            await tx.purchaseInvoice.delete({ where: { id: purchaseId } });\n\n            return { deletedInvoiceId: purchaseId, inventoryUpdates };\n        });\n\n        // Real-time updates now handled by polling system\n        if (result && result.deletedInvoiceId) {\n            console.log(`Purchase invoice ${result.deletedInvoiceId} deleted successfully`);\n        }\n\n        // After successful transaction, invalidate relevant caches\n        try {\n            await cacheService.invalidateInventory(); // Handles 'inventory:summary:*' and 'products:*'\n            await cacheService.del('dashboard:inventory');\n            await cacheService.del('dashboard:inventory-value');\n            await cacheService.del('dashboard:shops');\n            await cacheService.del('dashboard:all');\n            await cacheService.del('dashboard:summary');\n            // Invalidate purchases-specific caches\n            await cacheService.invalidatePattern('purchases-optimized*');\n            await cacheService.invalidatePattern('purchase-stats*');\n            console.log('Relevant caches invalidated after purchase deletion.');\n        } catch (cacheError) {\n            console.error('Error invalidating caches after purchase deletion:', cacheError);\n            // Do not let cache invalidation error fail the main operation\n        }\n\n        // Revalidate Next.js cached pages\n        try {\n            revalidateTag('purchase-invoices');\n            revalidateTag(`purchase-${purchaseId}`);\n            revalidatePath(`/purchases/${purchaseId}`);\n            revalidatePath(`/purchases/${purchaseId}/edit`);\n            revalidatePath('/purchases');\n            console.log('Next.js pages revalidated after purchase deletion.');\n        } catch (revalidateError) {\n            console.error('Error revalidating Next.js pages after purchase deletion:', revalidateError);\n        }\n\n        return NextResponse.json({ message: 'Purchase invoice deleted successfully' });\n\n    } catch (error) {\n        console.error(`Error deleting purchase invoice ${purchaseIdStr}:`, error);\n        const details = error instanceof Error ? error.message : 'An unknown error occurred';\n        return NextResponse.json(\n            { error: { message: 'Failed to delete purchase invoice', details: details } },\n            { status: 500 });\n    }\n}"],"names":["DELETE","GET","PUT","request","params","id","purchaseId","parseInt","isNaN","NextResponse","json","error","message","status","purchase","prisma","purchaseInvoice","findUnique","where","include","supplier","items","product","console","details","Error","body","originalPurchase","newItemsData","distributions","newDistributionsData","invoiceData","_","createdAt","updatedAt","notes","dirtyData","cleanedInvoiceData","invoiceNumber","date","Date","dueDate","undefined","totalAmount","total","Number","supplierId","connect","disconnect","result","$transaction","tx","inventoryUpdates","length","oldItem","productToUpdate","productId","oldItemDistribution","Array","isArray","indexOf","Object","keys","shopIdStr","quantityInShop","entries","shopId","qtyToRemove","inventory","inventoryItem","findFirst","oldShopQuantity","quantity","newQuantity","Math","max","update","data","shopSpecificCost","push","oldQuantity","warn","existingInventoriesForOldItem","findMany","shopIdToReverseFrom","log","currentTotalProductQuantity","allInventoryForProductAfterReversal","reduce","sum","inv","remainingPurchaseItems","purchaseInvoiceItem","purchaseInvoiceId","not","totalRemainingQuantity","totalRemainingValue","forEach","purchaseItem","price","newWAC","weightedAverageCost","deleteMany","newTotalInvoiceAmount","item","updatedInvoice","i","newItem","create","newItemDistribution","itemQuantityTotal","qtyToAdd","finalQuantity","oldInvQty","newShopSpecificCostValue","itemPrice","oldShopTotalValue","valueOfThisBatch","existingInventoryItems","targetShopId","allPurchaseItems","totalPurchaseQuantity","totalPurchaseValue","newWeightedAverageCost","fullUpdatedInvoice","timeout","cacheService","invalidateInventory","del","invalidatePattern","cacheError","revalidateTag","revalidatePath","revalidateError","String","purchaseIdStr","purchaseToDelete","quantityToRemoveForItemTotal","itemDistributionInfo","distributionsOnInvoice","distData","distributedQuantityStr","qtyInShopToRemove","newShopQuantity","updateData","existingInventoriesForItem","singleShopInventory","shopIdToDeductFrom","updateDataInferred","pItem","newCalculatedWAC","delete","deletedInvoiceId"],"mappings":"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"}