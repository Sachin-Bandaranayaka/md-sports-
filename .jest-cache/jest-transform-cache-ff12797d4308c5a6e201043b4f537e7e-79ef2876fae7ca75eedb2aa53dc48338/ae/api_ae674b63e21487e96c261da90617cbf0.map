{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/utils/api.ts"],"sourcesContent":["/**\n * Utility for making authenticated API requests\n */\n\n// Token provider - will be set by AuthProvider\nlet tokenProvider: (() => string | null) | null = null;\n\n/**\n * Set the token provider function\n * This should be called by the AuthProvider to provide access to the current token\n */\nexport const setTokenProvider = (provider: () => string | null) => {\n    tokenProvider = provider;\n};\n\n/**\n * Get the current authentication token\n */\nconst getAuthToken = (): string | null => {\n    // Use the token provider if available\n    if (tokenProvider) {\n        return tokenProvider();\n    }\n    \n    // Fallback to cookies only (not localStorage) for security\n    // This is only used during SSR or before the auth provider is initialized\n    if (typeof document !== 'undefined') {\n        // Try to get token from cookie (if server sets it as non-httpOnly for development)\n        const value = `; ${document.cookie}`;\n        const parts = value.split(`; accessToken=`);\n        if (parts.length === 2) {\n            const token = parts.pop()?.split(';').shift();\n            if (token) return token;\n        }\n    }\n    \n    return null;\n};\n\n/**\n * Get CSRF token from cookies\n */\nexport const getCsrfToken = (): string | undefined => {\n    if (typeof document === 'undefined') return undefined;\n\n    const value = `; ${document.cookie}`;\n    const parts = value.split(`; csrfToken=`);\n    if (parts.length === 2) return parts.pop()?.split(';').shift();\n    return undefined;\n};\n\n/**\n * Enhanced fetch function that automatically adds authentication token\n */\nexport const authFetch = async (url: string, options: RequestInit = {}) => {\n    // Get token using the centralized method\n    const token = getAuthToken();\n\n    if (!token) {\n        console.warn('No auth token found for request to:', url);\n    } else {\n        console.log(`Making authenticated request to ${url} with token: ${token.substring(0, 10)}...`);\n    }\n\n    // Prepare headers with authentication\n    const headers: Record<string, string> = {\n        ...(options.headers as Record<string, string> || {}),\n        'Authorization': token ? `Bearer ${token}` : '',\n    };\n\n    // If content type is not explicitly set and we're not sending FormData,\n    // default to JSON content type\n    if (\n        !options.headers?.hasOwnProperty('Content-Type') &&\n        !(options.body instanceof FormData)\n    ) {\n        headers['Content-Type'] = 'application/json';\n    }\n\n    // Add CSRF token for non-GET requests\n    if (options.method && options.method !== 'GET' && options.method !== 'HEAD') {\n        const csrfToken = getCsrfToken();\n        if (csrfToken) {\n            headers['X-CSRF-Token'] = csrfToken;\n        }\n    }\n\n    // Make the request with authentication header\n    const response = await fetch(url, {\n        ...options,\n        headers,\n    });\n\n    // If unauthorized and not on the login page, redirect to login\n    if (response.status === 401 && typeof window !== 'undefined' && !window.location.pathname.includes('/login')) {\n        console.warn('Authentication error (401) for request to:', url);\n        // Don't clear localStorage - let the auth provider handle this\n        window.location.href = '/login';\n        return response;\n    }\n\n    return response;\n};\n\n/**\n * GET request with authentication\n */\nexport const authGet = async (url: string, options: RequestInit = {}) => {\n    return authFetch(url, { ...options, method: 'GET' });\n};\n\n/**\n * POST request with authentication\n */\nexport const authPost = async (url: string, data: any, options: RequestInit = {}) => {\n    return authFetch(url, {\n        ...options,\n        method: 'POST',\n        body: JSON.stringify(data),\n    });\n};\n\n/**\n * PUT request with authentication\n */\nexport const authPut = async (url: string, data: any, options: RequestInit = {}) => {\n    return authFetch(url, {\n        ...options,\n        method: 'PUT',\n        body: JSON.stringify(data),\n    });\n};\n\n/**\n * DELETE request with authentication\n */\nexport const authDelete = async (url: string, options: RequestInit = {}) => {\n    return authFetch(url, { ...options, method: 'DELETE' });\n};\n\n/**\n * PATCH request with authentication\n */\nexport const authPatch = async (url: string, data: any, options: RequestInit = {}) => {\n    return authFetch(url, {\n        ...options,\n        method: 'PATCH',\n        body: JSON.stringify(data),\n    });\n};\n\n/**\n * Setup global fetch interceptor to add authentication token to all API calls\n * Call this once at the app initialization\n */\nexport const setupFetchInterceptor = () => {\n    if (typeof window !== 'undefined') {\n        const originalFetch = window.fetch;\n\n        window.fetch = async (url: RequestInfo | URL, options?: RequestInit) => {\n            // Only intercept API calls to our own API (starting with /api)\n            const urlString = url.toString();\n            if (urlString.startsWith('/api') || urlString.startsWith(window.location.origin + '/api')) {\n                options = options || {};\n                options.headers = options.headers || {};\n\n                // Cast headers to any to allow string indexing\n                const headers = options.headers as any;\n\n                // Add authentication header if token exists\n                const token = getAuthToken();\n                if (token && !headers['Authorization']) {\n                    headers['Authorization'] = `Bearer ${token}`;\n                }\n\n                // Add CSRF token for non-GET requests\n                if (options.method && options.method !== 'GET' && options.method !== 'HEAD') {\n                    const csrfToken = getCsrfToken();\n                    if (csrfToken && !headers['X-CSRF-Token']) {\n                        headers['X-CSRF-Token'] = csrfToken;\n                        console.log(`Adding CSRF token for ${options.method} request to ${urlString}`);\n                    }\n                }\n            }\n\n            return originalFetch(url, options);\n        };\n\n        console.log('Fetch interceptor set up successfully');\n    }\n};"],"names":["authDelete","authFetch","authGet","authPatch","authPost","authPut","getCsrfToken","setTokenProvider","setupFetchInterceptor","tokenProvider","provider","getAuthToken","document","value","cookie","parts","split","length","token","pop","shift","undefined","url","options","console","warn","log","substring","headers","hasOwnProperty","body","FormData","method","csrfToken","response","fetch","status","window","location","pathname","includes","href","data","JSON","stringify","originalFetch","urlString","toString","startsWith","origin"],"mappings":"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"}