{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/app/api/products/[id]/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { revalidateTag, revalidatePath } from 'next/cache';\nimport { prisma, safeQuery } from '@/lib/prisma';\nimport { Prisma } from '@prisma/client';\nimport { auditService } from '@/services/auditService';\nimport { verifyToken, extractToken } from '@/lib/auth';\n\nimport { cacheService } from '@/lib/cache';\n\n// Default fallback for a single product\nconst getDefaultProduct = (id: number) => ({\n    id,\n    name: 'Sample Product',\n    sku: `SKU-${id}`,\n    description: 'Product description not available',\n    price: 1000,\n    weightedAverageCost: 800,\n    category_name: 'General',\n    inventory: [],\n    inventoryItems: [],\n    category: null,\n    barcode: null,\n    categoryId: null,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    shopId: null,\n    minStockLevel: null,\n});\n\nexport async function GET(\n    req: NextRequest,\n    { params }: { params: { id: string } }\n) {\n    const { id: paramId } = params;\n    try {\n        const id = parseInt(paramId);\n\n        if (isNaN(id)) {\n            return NextResponse.json({\n                success: false,\n                message: 'Invalid product ID'\n            }, { status: 400 });\n        }\n\n        const product = await safeQuery(\n            async () => {\n                // Get product with its category\n                const productData = await prisma.product.findUnique({\n                    where: { id },\n                    include: {\n                        category: true,\n                        inventoryItems: {\n                            include: {\n                                shop: true\n                            }\n                        }\n                    }\n                });\n\n                if (!productData) {\n                    return null;\n                }\n\n                // Format the product data\n                return {\n                    ...productData,\n                    category_name: productData.category?.name,\n                    inventory: productData.inventoryItems.map(item => ({\n                        id: item.id,\n                        quantity: item.quantity,\n                        shop_id: item.shopId,\n                        shop_name: item.shop.name,\n                        shop_location: item.shop.location,\n                        shop_specific_cost: item.shopSpecificCost || 0\n                    }))\n                };\n            },\n            getDefaultProduct(parseInt(paramId)),\n            `Failed to fetch product with ID ${paramId}`\n        );\n\n        if (!product) {\n            return NextResponse.json({\n                success: false,\n                message: `Product with ID ${paramId} not found`\n            }, { status: 404 });\n        }\n\n        return NextResponse.json({\n            success: true,\n            data: product\n        });\n    } catch (error) {\n        console.error(`Error fetching product:`, error);\n        return NextResponse.json({\n            success: true,\n            data: getDefaultProduct(parseInt(paramId))\n        });\n    }\n}\n\nexport async function PUT(\n    req: NextRequest,\n    { params }: { params: { id: string } }\n) {\n    const { id: paramId } = params;\n    try {\n        const id = parseInt(paramId);\n        if (isNaN(id)) {\n            return NextResponse.json({ success: false, message: 'Invalid product ID' }, { status: 400 });\n        }\n\n        const productData = await req.json();\n\n        // Fetch existing product first to compare changes for audit log\n        const existingProduct = await prisma.product.findUnique({\n            where: { id }\n        });\n\n        if (!existingProduct) {\n            return NextResponse.json({ success: false, message: `Product with ID ${id} not found` }, { status: 404 });\n        }\n\n        // Prepare data for update, only including fields present in productData\n        const dataToUpdate: Prisma.ProductUpdateInput = {};\n        if (productData.name !== undefined) dataToUpdate.name = productData.name;\n        if (productData.sku !== undefined) dataToUpdate.sku = productData.sku;\n        if (productData.barcode !== undefined) dataToUpdate.barcode = productData.barcode || null;\n        if (productData.description !== undefined) dataToUpdate.description = productData.description || null;\n        if (productData.basePrice !== undefined) dataToUpdate.weightedAverageCost = productData.basePrice; // Assuming basePrice maps to WAC\n        if (productData.retailPrice !== undefined) dataToUpdate.price = productData.retailPrice;\n        if (productData.minStockLevel !== undefined) dataToUpdate.minStockLevel = productData.minStockLevel;\n        if (productData.categoryId !== undefined) {\n            dataToUpdate.category = productData.categoryId ? { connect: { id: parseInt(productData.categoryId) } } : { disconnect: true };\n        }\n\n        const updatedProduct = await prisma.product.update({\n            where: { id },\n            data: dataToUpdate\n        });\n\n        // Audit Log Generation\n        const token = extractToken(req);\n        const decoded = token ? verifyToken(token) : null;\n        const userId = decoded?.userId;\n\n        const changes: Record<string, { old: any, new: any }> = {};\n        (Object.keys(dataToUpdate) as Array<keyof typeof dataToUpdate>).forEach(key => {\n            // Type assertion for existingProduct keys\n            const typedKey = key as keyof typeof existingProduct;\n            if (existingProduct[typedKey] !== updatedProduct[typedKey]) {\n                changes[typedKey] = {\n                    old: existingProduct[typedKey],\n                    new: updatedProduct[typedKey]\n                };\n            }\n        });\n\n        if (Object.keys(changes).length > 0) {\n            try {\n                await auditService.log({\n                    userId: userId || null,\n                    action: 'UPDATE_PRODUCT',\n                    entity: 'Product',\n                    entityId: id,\n                    details: {\n                        productName: updatedProduct.name,\n                        sku: updatedProduct.sku,\n                        barcode: updatedProduct.barcode,\n                        changes: changes\n                    }\n                });\n            } catch (auditError) {\n                console.error('Failed to create audit log for product update:', auditError);\n                // Do not fail the main operation if audit logging fails\n            }\n        }\n\n        // Invalidate inventory cache\n        await cacheService.invalidateInventory();\n\n        // Revalidate Next.js cached pages\n        revalidateTag('products');\n        revalidateTag('inventory');\n        revalidateTag(`product-${paramId}`);\n        revalidatePath('/inventory');\n        revalidatePath('/products');\n\n        // Real-time updates now handled by polling system\n\n        return NextResponse.json({\n            success: true,\n            message: 'Product updated successfully',\n            data: updatedProduct\n        });\n    } catch (error) {\n        console.error(`Error updating product:`, error);\n        return NextResponse.json({\n            success: false,\n            message: 'Error updating product',\n            error: error instanceof Error ? error.message : String(error)\n        }, { status: 500 });\n    }\n}\n\nexport async function DELETE(\n    req: NextRequest,\n    { params }: { params: { id: string } }\n) {\n    const { id: paramId } = params;\n    try {\n        // Ensure params.id is properly awaited in Next.js 14+\n        const id = parseInt(paramId);\n\n        if (isNaN(id)) {\n            return NextResponse.json({\n                success: false,\n                message: 'Invalid product ID'\n            }, { status: 400 });\n        }\n\n        try {\n            // Check if product exists first\n            const existingProduct = await prisma.product.findUnique({\n                where: { id }\n            });\n\n            if (!existingProduct) {\n                return NextResponse.json({\n                    success: false,\n                    message: `Product with ID ${paramId} not found`\n                }, { status: 404 });\n            }\n\n            // Check for related records that prevent deletion\n            const relatedRecords = [];\n            \n            // Check if product is referenced in purchase invoices\n            const purchaseInvoiceItemsCount = await prisma.purchaseInvoiceItem.count({\n                where: { productId: id }\n            });\n            \n            if (purchaseInvoiceItemsCount > 0) {\n                relatedRecords.push(`${purchaseInvoiceItemsCount} purchase invoice item(s)`);\n            }\n\n            // Check if product is referenced in sales invoices\n            const salesInvoiceItemsCount = await prisma.invoiceItem.count({\n                where: { productId: id }\n            });\n            \n            if (salesInvoiceItemsCount > 0) {\n                relatedRecords.push(`${salesInvoiceItemsCount} sales invoice item(s)`);\n            }\n\n            // Check if product is referenced in quotations\n            const quotationItemsCount = await prisma.quotationItem.count({\n                where: { productId: id }\n            });\n            \n            if (quotationItemsCount > 0) {\n                relatedRecords.push(`${quotationItemsCount} quotation item(s)`);\n            }\n\n            // If any related records exist, prevent deletion\n            if (relatedRecords.length > 0) {\n                return NextResponse.json({\n                    success: false,\n                    message: `Cannot delete product \"${existingProduct.name}\" because it is referenced in: ${relatedRecords.join(', ')}. Please remove these references first.`,\n                    relatedRecords: {\n                        purchaseInvoiceItems: purchaseInvoiceItemsCount,\n                        salesInvoiceItems: salesInvoiceItemsCount,\n                        quotationItems: quotationItemsCount\n                    }\n                }, { status: 409 });\n            }\n\n            // Use a transaction to delete inventory items and then the product\n            await prisma.$transaction(async (tx) => {\n                // Delete all inventory items associated with this product\n                await tx.inventoryItem.deleteMany({\n                    where: { productId: id }\n                });\n\n                // Then, delete the product itself\n                await tx.product.delete({\n                    where: { id }\n                });\n            });\n\n            // Audit Log for Product Deletion\n            const token = extractToken(req);\n            const decoded = token ? verifyToken(token) : null;\n            const userId = decoded?.userId;\n\n            try {\n                await auditService.log({\n                    userId: userId || null,\n                    action: 'DELETE_PRODUCT',\n                    entity: 'Product',\n                    entityId: id,\n                    details: {\n                        productName: existingProduct.name,\n                        sku: existingProduct.sku,\n                        barcode: existingProduct.barcode,\n                        description: existingProduct.description,\n                        retailPrice: existingProduct.retailPrice,\n                        categoryId: existingProduct.categoryId\n                    }\n                });\n            } catch (auditError) {\n                console.error('Failed to create audit log for product deletion:', auditError);\n                // Do not fail the main operation if audit logging fails\n            }\n\n            // Invalidate product cache\n            await cacheService.invalidatePattern('products:*');\n            await cacheService.invalidateInventory();\n\n            // Revalidate Next.js cached pages\n            revalidateTag('products');\n            revalidateTag('inventory');\n            revalidateTag(`product-${paramId}`);\n            revalidatePath('/inventory');\n            revalidatePath('/products');\n\n            // Real-time updates now handled by polling system\n\n            return NextResponse.json({\n                success: true,\n                message: 'Product deleted successfully'\n            });\n        } catch (error) {\n            // Handle foreign key constraint violations\n            if (error instanceof Prisma.PrismaClientKnownRequestError) {\n                if (error.code === 'P2003') {\n                    // Foreign key constraint violation\n                    const constraintName = error.meta?.target as string || '';\n\n                    // Determine which relation is causing the constraint violation\n                    let relationMessage = 'it is referenced in other records';\n\n                    if (constraintName.includes('PurchaseInvoiceItem')) {\n                        relationMessage = 'it is referenced in purchase invoice records';\n                    } else if (constraintName.includes('SalesInvoiceItem')) {\n                        relationMessage = 'it is referenced in sales invoice records';\n                    } else if (constraintName.includes('InventoryTransaction')) {\n                        relationMessage = 'it is referenced in inventory transaction records';\n                    }\n\n                    return NextResponse.json({\n                        success: false,\n                        message: `Cannot delete this product because ${relationMessage}.`,\n                        error: 'FOREIGN_KEY_CONSTRAINT'\n                    }, { status: 409 });\n                }\n            }\n\n            throw error; // Re-throw for the outer catch block\n        }\n    } catch (error) {\n        console.error(`Error deleting product:`, error);\n        return NextResponse.json({\n            success: false,\n            message: 'Error deleting product',\n            error: error instanceof Error ? error.message : String(error)\n        }, { status: 500 });\n    }\n}"],"names":["DELETE","GET","PUT","getDefaultProduct","id","name","sku","description","price","weightedAverageCost","category_name","inventory","inventoryItems","category","barcode","categoryId","createdAt","Date","updatedAt","shopId","minStockLevel","req","params","paramId","parseInt","isNaN","NextResponse","json","success","message","status","product","safeQuery","productData","prisma","findUnique","where","include","shop","map","item","quantity","shop_id","shop_name","shop_location","location","shop_specific_cost","shopSpecificCost","data","error","console","existingProduct","dataToUpdate","undefined","basePrice","retailPrice","connect","disconnect","updatedProduct","update","token","extractToken","decoded","verifyToken","userId","changes","Object","keys","forEach","key","typedKey","old","new","length","auditService","log","action","entity","entityId","details","productName","auditError","cacheService","invalidateInventory","revalidateTag","revalidatePath","Error","String","relatedRecords","purchaseInvoiceItemsCount","purchaseInvoiceItem","count","productId","push","salesInvoiceItemsCount","invoiceItem","quotationItemsCount","quotationItem","join","purchaseInvoiceItems","salesInvoiceItems","quotationItems","$transaction","tx","inventoryItem","deleteMany","delete","invalidatePattern","Prisma","PrismaClientKnownRequestError","code","constraintName","meta","target","relationMessage","includes"],"mappings":"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"}