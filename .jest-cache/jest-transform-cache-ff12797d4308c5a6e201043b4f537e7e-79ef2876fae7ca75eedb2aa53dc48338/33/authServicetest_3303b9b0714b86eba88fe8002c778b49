21f7c9b99beb47ee51c10fbe7bb2410b
// Fixed Unit tests for AuthService
// This file tests the authentication service functionality
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _authService = require("../../src/services/authService");
const _cache = require("../../src/lib/cache");
const _jsonwebtoken = /*#__PURE__*/ _interop_require_wildcard(require("jsonwebtoken"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock dependencies BEFORE importing the service
const mockCacheService = {
    get: _globals.jest.fn(),
    set: _globals.jest.fn(),
    delete: _globals.jest.fn(),
    increment: _globals.jest.fn(),
    generateKey: _globals.jest.fn(),
    clear: _globals.jest.fn()
};
const mockPrisma = {
    user: {
        findUnique: _globals.jest.fn(),
        findFirst: _globals.jest.fn(),
        create: _globals.jest.fn(),
        update: _globals.jest.fn(),
        findMany: _globals.jest.fn(),
        delete: _globals.jest.fn()
    },
    permission: {
        findMany: _globals.jest.fn()
    },
    session: {
        create: _globals.jest.fn(),
        findUnique: _globals.jest.fn(),
        update: _globals.jest.fn(),
        deleteMany: _globals.jest.fn()
    },
    auditLog: {
        create: _globals.jest.fn()
    }
};
const mockBcrypt = {
    compare: _globals.jest.fn(),
    hash: _globals.jest.fn(),
    genSalt: _globals.jest.fn()
};
// Mock modules
_globals.jest.mock("@/lib/prisma", ()=>({
        __esModule: true,
        default: mockPrisma
    }));
_globals.jest.mock("@/lib/cache", ()=>({
        __esModule: true,
        cacheService: mockCacheService,
        cache: mockCacheService,
        CACHE_CONFIG: {
            KEYS: {
                USER_SESSION: "user_session",
                TOKEN_VALIDATION: "token_validation"
            },
            TTL: {
                USER_SESSION: 3600,
                TOKEN_VALIDATION: 1800
            }
        }
    }));
_globals.jest.mock("bcryptjs", ()=>mockBcrypt);
// Mock jsonwebtoken with a simple approach
const mockJwt = {
    sign: _globals.jest.fn(),
    verify: _globals.jest.fn(),
    decode: _globals.jest.fn(),
    TokenExpiredError: class extends Error {
        constructor(message, expiredAt){
            super(message);
            this.name = "TokenExpiredError";
            this.expiredAt = expiredAt || new Date();
        }
    },
    JsonWebTokenError: class extends Error {
        constructor(message){
            super(message);
            this.name = "JsonWebTokenError";
        }
    }
};
_globals.jest.mock("jsonwebtoken", ()=>mockJwt);
// Spy on the imported jwt to ensure our mocks work
const jwtVerifySpy = _globals.jest.spyOn(_jsonwebtoken, "verify");
const jwtSignSpy = _globals.jest.spyOn(_jsonwebtoken, "sign");
// Spy on the actual cacheService to verify mocking
const cacheServiceGenerateKeySpy = _globals.jest.spyOn(_cache.cacheService, "generateKey");
const cacheServiceGetSpy = _globals.jest.spyOn(_cache.cacheService, "get");
const cacheServiceSetSpy = _globals.jest.spyOn(_cache.cacheService, "set");
// Create proper mock types for easier access
const mockUserFindFirst = mockPrisma.user.findFirst;
const mockPermissionFindMany = mockPrisma.permission.findMany;
// mockJwt is already defined above
describe("AuthService", ()=>{
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        process.env.JWT_SECRET = "test-secret-key";
        process.env.JWT_ACCESS_TOKEN_EXPIRES_IN = "12h";
        // Setup default cache mocks
        mockCacheService.generateKey.mockReturnValue("mock-cache-key");
        mockCacheService.get.mockResolvedValue(null);
        mockCacheService.set.mockResolvedValue(true);
        mockCacheService.delete.mockResolvedValue(true);
        // Reset Prisma mocks
        mockUserFindFirst.mockResolvedValue(null);
        mockPermissionFindMany.mockResolvedValue([]);
        // Reset JWT mocks
        mockJwt.sign.mockReturnValue("mocked-jwt-token");
        mockJwt.verify.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
        mockJwt.decode.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
        jwtVerifySpy.mockClear();
        jwtSignSpy.mockClear();
    });
    describe("parseTimeStringToSeconds", ()=>{
        test("should parse seconds correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("30s")).toBe(30);
        });
        test("should parse minutes correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("5m")).toBe(300);
        });
        test("should parse hours correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("2h")).toBe(7200);
        });
        test("should parse days correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("1d")).toBe(86400);
        });
        test("should return 0 for invalid input", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("invalid")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("abc")).toBe(0);
        });
        test("should handle edge cases", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("0s")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("100x")).toBe(100); // Falls back to parsing the number part
        });
    });
    describe("authenticateUser", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            password: "hashedpassword",
            isActive: true,
            roleId: 1,
            shopId: 1,
            roleName: "admin",
            permissions: null,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should authenticate valid user credentials", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(true);
            mockJwt.sign.mockReturnValue("mock-jwt-token");
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(true);
            expect(result.token).toBe("mock-jwt-token");
            expect(result.user).toEqual({
                id: 1,
                email: "test@example.com",
                username: "testuser",
                fullName: "testuser",
                roleId: 1,
                roleName: "admin",
                shopId: 1,
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockUserFindFirst).toHaveBeenCalledWith({
                where: {
                    email: "test@example.com",
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            });
        });
        test("should reject invalid email", async ()=>{
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.authenticateUser)("invalid@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject invalid password", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(false);
            const result = await (0, _authService.authenticateUser)("test@example.com", "wrongpassword");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject inactive user", async ()=>{
            mockUserFindFirst.mockResolvedValue(null); // findFirst with isActive: true returns null
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should handle database errors gracefully", async ()=>{
            mockUserFindFirst.mockRejectedValue(new Error("Database connection failed"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
        test("should handle bcrypt errors gracefully", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockRejectedValue(new Error("Bcrypt error"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
    });
    describe("generateToken", ()=>{
        const mockPayload = {
            sub: 1,
            username: "testuser",
            email: "test@example.com",
            roleId: 1,
            shopId: 1,
            permissions: [
                "read_products",
                "write_products"
            ]
        };
        test("should generate JWT token", ()=>{
            const mockToken = "mock-jwt-token";
            mockJwt.sign.mockReturnValue(mockToken);
            const result = (0, _authService.generateToken)(mockPayload);
            expect(result).toBe(mockToken);
            expect(mockJwt.sign).toHaveBeenCalledWith(mockPayload, "test-secret-key", {
                expiresIn: "12h"
            });
        });
    });
    describe("verifyToken", ()=>{
        test("should verify valid token from cache", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should verify valid token and cache result", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockJwt.verify.mockReturnValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockJwt.verify).toHaveBeenCalledWith("valid-token", "test-secret-key");
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            const invalidError = new Error("Invalid token");
            mockJwt.verify.mockImplementation(()=>{
                throw invalidError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw invalidError;
            });
            await expect((0, _authService.verifyToken)("invalid-token")).rejects.toThrow("Invalid token");
        });
        test("should throw error for expired token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            const expiredError = new mockJwt.TokenExpiredError("Token expired", new Date());
            mockJwt.verify.mockImplementation(()=>{
                throw expiredError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw expiredError;
            });
            await expect((0, _authService.verifyToken)("expired-token")).rejects.toThrow("Token expired");
        });
    });
    describe("getUserFromDecodedPayload", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            isActive: true,
            roleId: 1,
            shopId: 1,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should return user from cache", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const cachedUser = {
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            };
            mockCacheService.get.mockResolvedValue(cachedUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual(cachedUser);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should return user from database and cache it", async ()=>{
            // Temporarily restore console.log for debugging
            const originalConsoleLog = console.log;
            console.log = originalConsoleLog;
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            // Clear any previous mock calls
            mockUserFindFirst.mockClear();
            // Reset and configure the global cache service mocks
            _globals.jest.clearAllMocks();
            // Configure the cache service to return null (not in cache)
            _cache.cacheService.get.mockResolvedValue(null);
            _cache.cacheService.generateKey.mockReturnValue("test-cache-key");
            _cache.cacheService.set.mockResolvedValue(undefined);
            // Mock the findFirst call to return the user when called with the correct parameters
            mockUserFindFirst.mockResolvedValue(mockUser);
            console.log("Test: About to call getUserFromDecodedPayload");
            console.log("Test: Payload:", payload);
            console.log("Test: mockUser:", mockUser);
            let result;
            let caughtError = null;
            try {
                result = await (0, _authService.getUserFromDecodedPayload)(payload);
            } catch (error) {
                caughtError = error;
                result = null;
            }
            // Debug information
            const debugInfo = {
                result,
                caughtError: caughtError ? caughtError.message : null,
                cacheGetCalls: _cache.cacheService.get.mock.calls.length,
                userFindFirstCalls: mockUserFindFirst.mock.calls.length,
                userFindFirstCallsDetails: mockUserFindFirst.mock.calls,
                cacheGetCallsDetails: _cache.cacheService.get.mock.calls,
                generateKeyCalls: _cache.cacheService.generateKey.mock.calls.length,
                payload,
                mockUser
            };
            // Write debug info to console in smaller chunks
            console.log("=== DEBUG INFO START ===");
            console.log("Result:", result);
            console.log("Caught Error:", caughtError ? caughtError.message : null);
            console.log("Cache Get Calls:", _cache.cacheService.get.mock.calls.length);
            console.log("User FindFirst Calls:", mockUserFindFirst.mock.calls.length);
            console.log("Generate Key Calls:", _cache.cacheService.generateKey.mock.calls.length);
            console.log("Cache Get Call Details:", _cache.cacheService.get.mock.calls);
            console.log("=== DEBUG INFO END ===");
            if (result === null) {
                throw new Error("getUserFromDecodedPayload returned null - see console logs above for debug info");
            }
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should return null for null payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)(null);
            expect(result).toBeNull();
        });
        test("should return null for invalid payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)({});
            expect(result).toBeNull();
        });
        test("should return null when user not found", async ()=>{
            const payload = {
                sub: 999,
                username: "nonexistent",
                email: "nonexistent@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null);
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toBeNull();
        });
    });
    describe("getUserFromToken", ()=>{
        test("should return user from valid token", async ()=>{
            const mockPayload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const mockUser = {
                id: 1,
                email: "test@example.com",
                name: "testuser",
                isActive: true,
                roleId: 1,
                shopId: 1,
                role: {
                    id: 1,
                    name: "admin",
                    permissions: [
                        {
                            name: "read_products"
                        }
                    ]
                }
            };
            // Mock verifyToken to return payload
            mockCacheService.get.mockResolvedValue(null); // Cache miss for user lookup
            mockCacheService.generateKey.mockReturnValue("test-cache-key");
            mockCacheService.set.mockResolvedValue(undefined);
            mockJwt.verify.mockReturnValue(mockPayload);
            jwtVerifySpy.mockReturnValue(mockPayload);
            // Mock the findFirst call to return the user
            mockUserFindFirst.mockResolvedValue(mockUser);
            // Set up spies to return expected values
            cacheServiceGenerateKeySpy.mockReturnValue("test-cache-key");
            cacheServiceGetSpy.mockResolvedValue(null);
            cacheServiceSetSpy.mockResolvedValue(undefined);
            // Reset cache mock to ensure it always returns null (cache miss)
            mockCacheService.get.mockResolvedValue(null);
            // Test verifyToken separately first
            const verifyResult = await (0, _authService.verifyToken)("valid-token");
            expect(verifyResult).toBeDefined();
            expect(verifyResult).toHaveProperty("sub", 1);
            // Test getUserFromDecodedPayload separately
            // First verify the function exists
            expect(typeof _authService.getUserFromDecodedPayload).toBe("function");
            // Test with null payload first to see if we get the expected error path
            const nullResult = await (0, _authService.getUserFromDecodedPayload)(null);
            expect(nullResult).toBeNull();
            // Test with payload missing sub
            const noSubResult = await (0, _authService.getUserFromDecodedPayload)({
                username: "test"
            });
            expect(noSubResult).toBeNull();
            // Test with mockPayload
            const decodedResult = await (0, _authService.getUserFromDecodedPayload)(mockPayload);
            // Check if the actual cacheService methods are being called
            expect(cacheServiceGenerateKeySpy).toHaveBeenCalledWith("user_session", {
                userId: 1
            });
            expect(cacheServiceGetSpy).toHaveBeenCalled();
            expect(decodedResult).toBeDefined();
            expect(decodedResult).not.toBeNull();
            // Now test the full flow
            const result = await (0, _authService.getUserFromToken)("valid-token");
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products"
                ]
            });
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockCacheService.generateKey.mockReturnValue("test-cache-key");
            // Mock both the direct mock and the spy
            const jwtError = new mockJwt.JsonWebTokenError("jwt malformed");
            mockJwt.verify.mockImplementation(()=>{
                throw jwtError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw jwtError;
            });
            await expect((0, _authService.getUserFromToken)("invalid")).rejects.toThrow("jwt malformed");
        });
    });
    describe("Error Handling", ()=>{
        test("should handle missing JWT_SECRET", async ()=>{
            const originalSecret = process.env.JWT_SECRET;
            delete process.env.JWT_SECRET;
            mockCacheService.get.mockResolvedValue(null);
            const secretError = new Error("secretOrPrivateKey must have a value");
            mockJwt.verify.mockImplementation(()=>{
                throw secretError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw secretError;
            });
            await expect((0, _authService.verifyToken)("any-token")).rejects.toThrow();
            // Restore the secret
            process.env.JWT_SECRET = originalSecret;
        });
        test("should handle malformed tokens gracefully", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            // Mock both the direct mock and the spy
            const jwtError = new mockJwt.JsonWebTokenError("jwt malformed");
            mockJwt.verify.mockImplementation(()=>{
                throw jwtError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw jwtError;
            });
            await expect((0, _authService.verifyToken)("malformed-token")).rejects.toThrow("jwt malformed");
        });
        test("should handle empty token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            await expect((0, _authService.verifyToken)("")).rejects.toThrow("jwt must be provided");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9hdXRoU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpeGVkIFVuaXQgdGVzdHMgZm9yIEF1dGhTZXJ2aWNlXG4vLyBUaGlzIGZpbGUgdGVzdHMgdGhlIGF1dGhlbnRpY2F0aW9uIHNlcnZpY2UgZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzIEJFRk9SRSBpbXBvcnRpbmcgdGhlIHNlcnZpY2VcbmNvbnN0IG1vY2tDYWNoZVNlcnZpY2UgPSB7XG4gIGdldDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgc2V0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBkZWxldGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGluY3JlbWVudDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgZ2VuZXJhdGVLZXk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGNsZWFyOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxufTtcblxuY29uc3QgbW9ja1ByaXNtYSA9IHtcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZEZpcnN0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICAgIGNyZWF0ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICB9LFxuICBwZXJtaXNzaW9uOiB7XG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG4gIHNlc3Npb246IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlTWFueTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgfSxcbiAgYXVkaXRMb2c6IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG59O1xuXG5jb25zdCBtb2NrQmNyeXB0ID0ge1xuICBjb21wYXJlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBoYXNoOiBqZXN0LmZuKCksXG4gIGdlblNhbHQ6IGplc3QuZm4oKSxcbn07XG5cbi8vIE1vY2sgbW9kdWxlc1xuamVzdC5tb2NrKCdAL2xpYi9wcmlzbWEnLCAoKSA9PiAoe1xuICBfX2VzTW9kdWxlOiB0cnVlLFxuICBkZWZhdWx0OiBtb2NrUHJpc21hLFxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvbGliL2NhY2hlJywgKCkgPT4gKHtcbiAgX19lc01vZHVsZTogdHJ1ZSxcbiAgY2FjaGVTZXJ2aWNlOiBtb2NrQ2FjaGVTZXJ2aWNlLFxuICBjYWNoZTogbW9ja0NhY2hlU2VydmljZSxcbiAgQ0FDSEVfQ09ORklHOiB7XG4gICAgS0VZUzoge1xuICAgICAgVVNFUl9TRVNTSU9OOiAndXNlcl9zZXNzaW9uJyxcbiAgICAgIFRPS0VOX1ZBTElEQVRJT046ICd0b2tlbl92YWxpZGF0aW9uJyxcbiAgICB9LFxuICAgIFRUTDoge1xuICAgICAgVVNFUl9TRVNTSU9OOiAzNjAwLFxuICAgICAgVE9LRU5fVkFMSURBVElPTjogMTgwMCxcbiAgICB9LFxuICB9LFxufSkpO1xuXG5qZXN0Lm1vY2soJ2JjcnlwdGpzJywgKCkgPT4gbW9ja0JjcnlwdCk7XG4vLyBNb2NrIGpzb253ZWJ0b2tlbiB3aXRoIGEgc2ltcGxlIGFwcHJvYWNoXG5jb25zdCBtb2NrSnd0ID0ge1xuICBzaWduOiBqZXN0LmZuKCksXG4gIHZlcmlmeTogamVzdC5mbigpLFxuICBkZWNvZGU6IGplc3QuZm4oKSxcbiAgVG9rZW5FeHBpcmVkRXJyb3I6IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgIGV4cGlyZWRBdDogRGF0ZTtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGV4cGlyZWRBdD86IERhdGUpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuRXhwaXJlZEVycm9yJztcbiAgICAgIHRoaXMuZXhwaXJlZEF0ID0gZXhwaXJlZEF0IHx8IG5ldyBEYXRlKCk7XG4gICAgfVxuICB9LFxuICBKc29uV2ViVG9rZW5FcnJvcjogY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIHRoaXMubmFtZSA9ICdKc29uV2ViVG9rZW5FcnJvcic7XG4gICAgfVxuICB9LFxufTtcblxuamVzdC5tb2NrKCdqc29ud2VidG9rZW4nLCAoKSA9PiBtb2NrSnd0KTtcblxuLy8gSW1wb3J0IGFmdGVyIG1vY2tpbmdcbmltcG9ydCB7IGF1dGhlbnRpY2F0ZVVzZXIsIGdlbmVyYXRlVG9rZW4sIHZlcmlmeVRva2VuLCBwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMsIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQsIGdldFVzZXJGcm9tVG9rZW4gfSBmcm9tICdAL3NlcnZpY2VzL2F1dGhTZXJ2aWNlJztcbmltcG9ydCB7IGNhY2hlU2VydmljZSB9IGZyb20gJ0AvbGliL2NhY2hlJztcbmltcG9ydCAqIGFzIGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuXG4vLyBTcHkgb24gdGhlIGltcG9ydGVkIGp3dCB0byBlbnN1cmUgb3VyIG1vY2tzIHdvcmtcbmNvbnN0IGp3dFZlcmlmeVNweSA9IGplc3Quc3B5T24oand0LCAndmVyaWZ5Jyk7XG5jb25zdCBqd3RTaWduU3B5ID0gamVzdC5zcHlPbihqd3QsICdzaWduJyk7XG5cbi8vIFNweSBvbiB0aGUgYWN0dWFsIGNhY2hlU2VydmljZSB0byB2ZXJpZnkgbW9ja2luZ1xuY29uc3QgY2FjaGVTZXJ2aWNlR2VuZXJhdGVLZXlTcHkgPSBqZXN0LnNweU9uKGNhY2hlU2VydmljZSwgJ2dlbmVyYXRlS2V5Jyk7XG5jb25zdCBjYWNoZVNlcnZpY2VHZXRTcHkgPSBqZXN0LnNweU9uKGNhY2hlU2VydmljZSwgJ2dldCcpO1xuY29uc3QgY2FjaGVTZXJ2aWNlU2V0U3B5ID0gamVzdC5zcHlPbihjYWNoZVNlcnZpY2UsICdzZXQnKTtcblxuLy8gQ3JlYXRlIHByb3BlciBtb2NrIHR5cGVzIGZvciBlYXNpZXIgYWNjZXNzXG5jb25zdCBtb2NrVXNlckZpbmRGaXJzdCA9IG1vY2tQcmlzbWEudXNlci5maW5kRmlyc3QgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuY29uc3QgbW9ja1Blcm1pc3Npb25GaW5kTWFueSA9IG1vY2tQcmlzbWEucGVybWlzc2lvbi5maW5kTWFueSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG4vLyBtb2NrSnd0IGlzIGFscmVhZHkgZGVmaW5lZCBhYm92ZVxuXG5kZXNjcmliZSgnQXV0aFNlcnZpY2UnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgPSAndGVzdC1zZWNyZXQta2V5JztcbiAgICBwcm9jZXNzLmVudi5KV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4gPSAnMTJoJztcbiAgICBcbiAgICAvLyBTZXR1cCBkZWZhdWx0IGNhY2hlIG1vY2tzXG4gICAgbW9ja0NhY2hlU2VydmljZS5nZW5lcmF0ZUtleS5tb2NrUmV0dXJuVmFsdWUoJ21vY2stY2FjaGUta2V5Jyk7XG4gICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgbW9ja0NhY2hlU2VydmljZS5zZXQubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG4gICAgbW9ja0NhY2hlU2VydmljZS5kZWxldGUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG4gICAgXG4gICAgLy8gUmVzZXQgUHJpc21hIG1vY2tzXG4gICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgbW9ja1Blcm1pc3Npb25GaW5kTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgXG4gICAgLy8gUmVzZXQgSldUIG1vY2tzXG4gICAgbW9ja0p3dC5zaWduLm1vY2tSZXR1cm5WYWx1ZSgnbW9ja2VkLWp3dC10b2tlbicpO1xuICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tSZXR1cm5WYWx1ZSh7IHVzZXJJZDogMSwgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9KTtcbiAgICBtb2NrSnd0LmRlY29kZS5tb2NrUmV0dXJuVmFsdWUoeyB1c2VySWQ6IDEsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSk7XG4gICAgand0VmVyaWZ5U3B5Lm1vY2tDbGVhcigpO1xuICAgIGp3dFNpZ25TcHkubW9ja0NsZWFyKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIHNlY29uZHMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMzBzJykpLnRvQmUoMzApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIG1pbnV0ZXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnNW0nKSkudG9CZSgzMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIGhvdXJzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzJoJykpLnRvQmUoNzIwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgZGF5cyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcxZCcpKS50b0JlKDg2NDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gMCBmb3IgaW52YWxpZCBpbnB1dCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJycpKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnaW52YWxpZCcpKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnYWJjJykpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZXMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcwcycpKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMTAweCcpKS50b0JlKDEwMCk7IC8vIEZhbGxzIGJhY2sgdG8gcGFyc2luZyB0aGUgbnVtYmVyIHBhcnRcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2F1dGhlbnRpY2F0ZVVzZXInLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICBuYW1lOiAndGVzdHVzZXInLFxuICAgICAgcGFzc3dvcmQ6ICdoYXNoZWRwYXNzd29yZCcsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIHJvbGVJZDogMSxcbiAgICAgIHNob3BJZDogMSxcbiAgICAgIHJvbGVOYW1lOiAnYWRtaW4nLFxuICAgICAgcGVybWlzc2lvbnM6IG51bGwsXG4gICAgICByb2xlOiB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBuYW1lOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczogW1xuICAgICAgICAgIHsgbmFtZTogJ3JlYWRfcHJvZHVjdHMnIH0sXG4gICAgICAgICAgeyBuYW1lOiAnd3JpdGVfcHJvZHVjdHMnIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0ZXN0KCdzaG91bGQgYXV0aGVudGljYXRlIHZhbGlkIHVzZXIgY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgICBtb2NrQmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSBhcyBhbnkpO1xuICAgICAgbW9ja0p3dC5zaWduLm1vY2tSZXR1cm5WYWx1ZSgnbW9jay1qd3QtdG9rZW4nIGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC50b2tlbikudG9CZSgnbW9jay1qd3QtdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcikudG9FcXVhbCh7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZnVsbE5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHNob3BJZDogMSxcbiAgICAgICAgcGVybWlzc2lvbnM6IFsncmVhZF9wcm9kdWN0cycsICd3cml0ZV9wcm9kdWN0cyddXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChtb2NrVXNlckZpbmRGaXJzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgaXNBY3RpdmU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ2ludmFsaWRAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIHBhc3N3b3JkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuICAgICAgbW9ja0JjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlIGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnd3JvbmdwYXNzd29yZCcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGluYWN0aXZlIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTsgLy8gZmluZEZpcnN0IHdpdGggaXNBY3RpdmU6IHRydWUgcmV0dXJucyBudWxsXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnQXV0aGVudGljYXRpb24gZmFpbGVkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGJjcnlwdCBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIG1vY2tCY3J5cHQuY29tcGFyZS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0JjcnlwdCBlcnJvcicpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdBdXRoZW50aWNhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dlbmVyYXRlVG9rZW4nLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICBzdWI6IDEsXG4gICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICByb2xlSWQ6IDEsXG4gICAgICBzaG9wSWQ6IDEsXG4gICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJywgJ3dyaXRlX3Byb2R1Y3RzJ11cbiAgICB9O1xuXG4gICAgdGVzdCgnc2hvdWxkIGdlbmVyYXRlIEpXVCB0b2tlbicsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tUb2tlbiA9ICdtb2NrLWp3dC10b2tlbic7XG4gICAgICBtb2NrSnd0LnNpZ24ubW9ja1JldHVyblZhbHVlKG1vY2tUb2tlbik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdlbmVyYXRlVG9rZW4obW9ja1BheWxvYWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKG1vY2tUb2tlbik7XG4gICAgICBleHBlY3QobW9ja0p3dC5zaWduKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBtb2NrUGF5bG9hZCxcbiAgICAgICAgICAndGVzdC1zZWNyZXQta2V5JyxcbiAgICAgICAgICB7IGV4cGlyZXNJbjogJzEyaCcgfVxuICAgICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmVyaWZ5VG9rZW4nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHZlcmlmeSB2YWxpZCB0b2tlbiBmcm9tIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICAgIHN1YjogJzEnLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxLFxuICAgICAgICBpYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICBleHA6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgMzYwMFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1BheWxvYWQpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbigndmFsaWQtdG9rZW4nKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUGF5bG9hZCk7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB2ZXJpZnkgdmFsaWQgdG9rZW4gYW5kIGNhY2hlIHJlc3VsdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgICBzdWI6ICcxJyxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgaWF0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDM2MDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBOb3QgaW4gY2FjaGVcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tSZXR1cm5WYWx1ZShtb2NrUGF5bG9hZCBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbigndmFsaWQtdG9rZW4nKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUGF5bG9hZCk7XG4gICAgICBleHBlY3QobW9ja0p3dC52ZXJpZnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd2YWxpZC10b2tlbicsICd0ZXN0LXNlY3JldC1rZXknKTtcbiAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLnNldCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBpbnZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBjb25zdCBpbnZhbGlkRXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4nKTtcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IGludmFsaWRFcnJvcjtcbiAgICAgIH0pO1xuICAgICAgand0VmVyaWZ5U3B5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgICB0aHJvdyBpbnZhbGlkRXJyb3I7XG4gICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbignaW52YWxpZC10b2tlbicpKS5yZWplY3RzLnRvVGhyb3coJ0ludmFsaWQgdG9rZW4nKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgZXhwaXJlZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgY29uc3QgZXhwaXJlZEVycm9yID0gbmV3IG1vY2tKd3QuVG9rZW5FeHBpcmVkRXJyb3IoJ1Rva2VuIGV4cGlyZWQnLCBuZXcgRGF0ZSgpKTtcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IGV4cGlyZWRFcnJvcjtcbiAgICAgIH0pO1xuICAgICAgand0VmVyaWZ5U3B5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgICB0aHJvdyBleHBpcmVkRXJyb3I7XG4gICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbignZXhwaXJlZC10b2tlbicpKS5yZWplY3RzLnRvVGhyb3coJ1Rva2VuIGV4cGlyZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICBuYW1lOiAndGVzdHVzZXInLFxuICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICByb2xlSWQ6IDEsXG4gICAgICBzaG9wSWQ6IDEsXG4gICAgICByb2xlOiB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBuYW1lOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczogW1xuICAgICAgICAgIHsgbmFtZTogJ3JlYWRfcHJvZHVjdHMnIH0sXG4gICAgICAgICAgeyBuYW1lOiAnd3JpdGVfcHJvZHVjdHMnIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIHVzZXIgZnJvbSBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgY2FjaGVkVXNlciA9IHtcbiAgICAgICAgLi4ubW9ja1VzZXIsXG4gICAgICAgIHJvbGVOYW1lOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJywgJ3dyaXRlX3Byb2R1Y3RzJ11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKGNhY2hlZFVzZXIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHBheWxvYWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGNhY2hlZFVzZXIpO1xuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2UuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIHVzZXIgZnJvbSBkYXRhYmFzZSBhbmQgY2FjaGUgaXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZW1wb3JhcmlseSByZXN0b3JlIGNvbnNvbGUubG9nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ29uc29sZUxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgY29uc29sZS5sb2cgPSBvcmlnaW5hbENvbnNvbGVMb2c7XG4gICAgICBcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcblxuICAgICAgLy8gQ2xlYXIgYW55IHByZXZpb3VzIG1vY2sgY2FsbHNcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tDbGVhcigpO1xuICAgICAgXG4gICAgICAvLyBSZXNldCBhbmQgY29uZmlndXJlIHRoZSBnbG9iYWwgY2FjaGUgc2VydmljZSBtb2Nrc1xuICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgICBcbiAgICAgIC8vIENvbmZpZ3VyZSB0aGUgY2FjaGUgc2VydmljZSB0byByZXR1cm4gbnVsbCAobm90IGluIGNhY2hlKVxuICAgICAgKGNhY2hlU2VydmljZS5nZXQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+KS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIChjYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+KS5tb2NrUmV0dXJuVmFsdWUoJ3Rlc3QtY2FjaGUta2V5Jyk7XG4gICAgICAoY2FjaGVTZXJ2aWNlLnNldCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4pLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgdGhlIGZpbmRGaXJzdCBjYWxsIHRvIHJldHVybiB0aGUgdXNlciB3aGVuIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IHBhcmFtZXRlcnNcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1Rlc3Q6IEFib3V0IHRvIGNhbGwgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCcpO1xuICAgICAgY29uc29sZS5sb2coJ1Rlc3Q6IFBheWxvYWQ6JywgcGF5bG9hZCk7XG4gICAgICBjb25zb2xlLmxvZygnVGVzdDogbW9ja1VzZXI6JywgbW9ja1VzZXIpO1xuXG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgbGV0IGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERlYnVnIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCBkZWJ1Z0luZm8gPSB7XG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgY2F1Z2h0RXJyb3I6IGNhdWdodEVycm9yID8gY2F1Z2h0RXJyb3IubWVzc2FnZSA6IG51bGwsXG4gICAgICAgIGNhY2hlR2V0Q2FsbHM6IChjYWNoZVNlcnZpY2UuZ2V0IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PikubW9jay5jYWxscy5sZW5ndGgsXG4gICAgICAgIHVzZXJGaW5kRmlyc3RDYWxsczogbW9ja1VzZXJGaW5kRmlyc3QubW9jay5jYWxscy5sZW5ndGgsXG4gICAgICAgIHVzZXJGaW5kRmlyc3RDYWxsc0RldGFpbHM6IG1vY2tVc2VyRmluZEZpcnN0Lm1vY2suY2FsbHMsXG4gICAgICAgIGNhY2hlR2V0Q2FsbHNEZXRhaWxzOiAoY2FjaGVTZXJ2aWNlLmdldCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4pLm1vY2suY2FsbHMsXG4gICAgICAgIGdlbmVyYXRlS2V5Q2FsbHM6IChjYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+KS5tb2NrLmNhbGxzLmxlbmd0aCxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgbW9ja1VzZXJcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFdyaXRlIGRlYnVnIGluZm8gdG8gY29uc29sZSBpbiBzbWFsbGVyIGNodW5rc1xuICAgICAgY29uc29sZS5sb2coJz09PSBERUJVRyBJTkZPIFNUQVJUID09PScpO1xuICAgICAgY29uc29sZS5sb2coJ1Jlc3VsdDonLCByZXN1bHQpO1xuICAgICAgY29uc29sZS5sb2coJ0NhdWdodCBFcnJvcjonLCBjYXVnaHRFcnJvciA/IGNhdWdodEVycm9yLm1lc3NhZ2UgOiBudWxsKTtcbiAgICAgIGNvbnNvbGUubG9nKCdDYWNoZSBHZXQgQ2FsbHM6JywgKGNhY2hlU2VydmljZS5nZXQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+KS5tb2NrLmNhbGxzLmxlbmd0aCk7XG4gICAgICBjb25zb2xlLmxvZygnVXNlciBGaW5kRmlyc3QgQ2FsbHM6JywgbW9ja1VzZXJGaW5kRmlyc3QubW9jay5jYWxscy5sZW5ndGgpO1xuICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRlIEtleSBDYWxsczonLCAoY2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PikubW9jay5jYWxscy5sZW5ndGgpO1xuICAgICAgY29uc29sZS5sb2coJ0NhY2hlIEdldCBDYWxsIERldGFpbHM6JywgKGNhY2hlU2VydmljZS5nZXQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+KS5tb2NrLmNhbGxzKTtcbiAgICAgIGNvbnNvbGUubG9nKCc9PT0gREVCVUcgSU5GTyBFTkQgPT09Jyk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkIHJldHVybmVkIG51bGwgLSBzZWUgY29uc29sZSBsb2dzIGFib3ZlIGZvciBkZWJ1ZyBpbmZvJyk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5zZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgbnVsbCBwYXlsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChudWxsKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGludmFsaWQgcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQoe30gYXMgYW55KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgd2hlbiB1c2VyIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogOTk5LFxuICAgICAgICB1c2VybmFtZTogJ25vbmV4aXN0ZW50JyxcbiAgICAgICAgZW1haWw6ICdub25leGlzdGVudEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRVc2VyRnJvbVRva2VuJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIHZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgcm9sZUlkOiAxLFxuICAgICAgICBzaG9wSWQ6IDEsXG4gICAgICAgIHJvbGU6IHtcbiAgICAgICAgICBpZDogMSxcbiAgICAgICAgICBuYW1lOiAnYWRtaW4nLFxuICAgICAgICAgIHBlcm1pc3Npb25zOiBbeyBuYW1lOiAncmVhZF9wcm9kdWN0cycgfV1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayB2ZXJpZnlUb2tlbiB0byByZXR1cm4gcGF5bG9hZFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIENhY2hlIG1pc3MgZm9yIHVzZXIgbG9va3VwXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5Lm1vY2tSZXR1cm5WYWx1ZSgndGVzdC1jYWNoZS1rZXknKTtcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2Uuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrUmV0dXJuVmFsdWUobW9ja1BheWxvYWQpO1xuICAgICAgand0VmVyaWZ5U3B5Lm1vY2tSZXR1cm5WYWx1ZShtb2NrUGF5bG9hZCBhcyBhbnkpO1xuICAgICAgXG4gICAgICAvLyBNb2NrIHRoZSBmaW5kRmlyc3QgY2FsbCB0byByZXR1cm4gdGhlIHVzZXJcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IHVwIHNwaWVzIHRvIHJldHVybiBleHBlY3RlZCB2YWx1ZXNcbiAgICAgIGNhY2hlU2VydmljZUdlbmVyYXRlS2V5U3B5Lm1vY2tSZXR1cm5WYWx1ZSgndGVzdC1jYWNoZS1rZXknKTtcbiAgICAgIGNhY2hlU2VydmljZUdldFNweS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGNhY2hlU2VydmljZVNldFNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgXG4gICAgICAvLyBSZXNldCBjYWNoZSBtb2NrIHRvIGVuc3VyZSBpdCBhbHdheXMgcmV0dXJucyBudWxsIChjYWNoZSBtaXNzKVxuICAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICAvLyBUZXN0IHZlcmlmeVRva2VuIHNlcGFyYXRlbHkgZmlyc3RcbiAgICAgICBjb25zdCB2ZXJpZnlSZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbigndmFsaWQtdG9rZW4nKTtcbiAgICAgICBleHBlY3QodmVyaWZ5UmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgIGV4cGVjdCh2ZXJpZnlSZXN1bHQpLnRvSGF2ZVByb3BlcnR5KCdzdWInLCAxKTtcbiAgICAgICBcbiAgICAgICAvLyBUZXN0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQgc2VwYXJhdGVseVxuICAgICAgIC8vIEZpcnN0IHZlcmlmeSB0aGUgZnVuY3Rpb24gZXhpc3RzXG4gICAgICAgZXhwZWN0KHR5cGVvZiBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKS50b0JlKCdmdW5jdGlvbicpO1xuICAgICAgIFxuICAgICAgIC8vIFRlc3Qgd2l0aCBudWxsIHBheWxvYWQgZmlyc3QgdG8gc2VlIGlmIHdlIGdldCB0aGUgZXhwZWN0ZWQgZXJyb3IgcGF0aFxuICAgICAgIGNvbnN0IG51bGxSZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKG51bGwpO1xuICAgICAgIGV4cGVjdChudWxsUmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgIFxuICAgICAgIC8vIFRlc3Qgd2l0aCBwYXlsb2FkIG1pc3Npbmcgc3ViXG4gICAgICAgY29uc3Qgbm9TdWJSZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHsgdXNlcm5hbWU6ICd0ZXN0JyB9IGFzIGFueSk7XG4gICAgICAgZXhwZWN0KG5vU3ViUmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgIFxuICAgICAgIC8vIFRlc3Qgd2l0aCBtb2NrUGF5bG9hZFxuICAgICAgIGNvbnN0IGRlY29kZWRSZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKG1vY2tQYXlsb2FkKTtcbiAgICAgICBcbiAgICAgICAvLyBDaGVjayBpZiB0aGUgYWN0dWFsIGNhY2hlU2VydmljZSBtZXRob2RzIGFyZSBiZWluZyBjYWxsZWRcbiAgICAgICBleHBlY3QoY2FjaGVTZXJ2aWNlR2VuZXJhdGVLZXlTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd1c2VyX3Nlc3Npb24nLCB7IHVzZXJJZDogMSB9KTtcbiAgICAgICBleHBlY3QoY2FjaGVTZXJ2aWNlR2V0U3B5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgXG4gICAgICAgZXhwZWN0KGRlY29kZWRSZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgZXhwZWN0KGRlY29kZWRSZXN1bHQpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgIFxuICAgICAgIC8vIE5vdyB0ZXN0IHRoZSBmdWxsIGZsb3dcbiAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbVRva2VuKCd2YWxpZC10b2tlbicpO1xuICAgICAgIFxuICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICAgLi4ubW9ja1VzZXIsXG4gICAgICAgICByb2xlTmFtZTogJ2FkbWluJyxcbiAgICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnXVxuICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBpbnZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5Lm1vY2tSZXR1cm5WYWx1ZSgndGVzdC1jYWNoZS1rZXknKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBib3RoIHRoZSBkaXJlY3QgbW9jayBhbmQgdGhlIHNweVxuICAgICAgY29uc3Qgand0RXJyb3IgPSBuZXcgbW9ja0p3dC5Kc29uV2ViVG9rZW5FcnJvcignand0IG1hbGZvcm1lZCcpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgand0RXJyb3I7XG4gICAgICB9KTtcbiAgICAgIGp3dFZlcmlmeVNweS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgdGhyb3cgand0RXJyb3I7XG4gICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChnZXRVc2VyRnJvbVRva2VuKCdpbnZhbGlkJykpLnJlamVjdHMudG9UaHJvdygnand0IG1hbGZvcm1lZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIEpXVF9TRUNSRVQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbFNlY3JldCA9IHByb2Nlc3MuZW52LkpXVF9TRUNSRVQ7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVDtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBjb25zdCBzZWNyZXRFcnJvciA9IG5ldyBFcnJvcignc2VjcmV0T3JQcml2YXRlS2V5IG11c3QgaGF2ZSBhIHZhbHVlJyk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBzZWNyZXRFcnJvcjtcbiAgICAgIH0pO1xuICAgICAgand0VmVyaWZ5U3B5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgICB0aHJvdyBzZWNyZXRFcnJvcjtcbiAgICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdhbnktdG9rZW4nKSkucmVqZWN0cy50b1Rocm93KCk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgdGhlIHNlY3JldFxuICAgICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCA9IG9yaWdpbmFsU2VjcmV0O1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtYWxmb3JtZWQgdG9rZW5zIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBib3RoIHRoZSBkaXJlY3QgbW9jayBhbmQgdGhlIHNweVxuICAgICAgY29uc3Qgand0RXJyb3IgPSBuZXcgbW9ja0p3dC5Kc29uV2ViVG9rZW5FcnJvcignand0IG1hbGZvcm1lZCcpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgand0RXJyb3I7XG4gICAgICB9KTtcbiAgICAgIGp3dFZlcmlmeVNweS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBqd3RFcnJvcjtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJ21hbGZvcm1lZC10b2tlbicpKS5yZWplY3RzLnRvVGhyb3coJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCcnKSkucmVqZWN0cy50b1Rocm93KCdqd3QgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJtb2NrQ2FjaGVTZXJ2aWNlIiwiZ2V0IiwiamVzdCIsImZuIiwic2V0IiwiZGVsZXRlIiwiaW5jcmVtZW50IiwiZ2VuZXJhdGVLZXkiLCJjbGVhciIsIm1vY2tQcmlzbWEiLCJ1c2VyIiwiZmluZFVuaXF1ZSIsImZpbmRGaXJzdCIsImNyZWF0ZSIsInVwZGF0ZSIsImZpbmRNYW55IiwicGVybWlzc2lvbiIsInNlc3Npb24iLCJkZWxldGVNYW55IiwiYXVkaXRMb2ciLCJtb2NrQmNyeXB0IiwiY29tcGFyZSIsImhhc2giLCJnZW5TYWx0IiwibW9jayIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiY2FjaGVTZXJ2aWNlIiwiY2FjaGUiLCJDQUNIRV9DT05GSUciLCJLRVlTIiwiVVNFUl9TRVNTSU9OIiwiVE9LRU5fVkFMSURBVElPTiIsIlRUTCIsIm1vY2tKd3QiLCJzaWduIiwidmVyaWZ5IiwiZGVjb2RlIiwiVG9rZW5FeHBpcmVkRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImV4cGlyZWRBdCIsIm5hbWUiLCJEYXRlIiwiSnNvbldlYlRva2VuRXJyb3IiLCJqd3RWZXJpZnlTcHkiLCJzcHlPbiIsImp3dCIsImp3dFNpZ25TcHkiLCJjYWNoZVNlcnZpY2VHZW5lcmF0ZUtleVNweSIsImNhY2hlU2VydmljZUdldFNweSIsImNhY2hlU2VydmljZVNldFNweSIsIm1vY2tVc2VyRmluZEZpcnN0IiwibW9ja1Blcm1pc3Npb25GaW5kTWFueSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJwcm9jZXNzIiwiZW52IiwiSldUX1NFQ1JFVCIsIkpXVF9BQ0NFU1NfVE9LRU5fRVhQSVJFU19JTiIsIm1vY2tSZXR1cm5WYWx1ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwidXNlcklkIiwiZW1haWwiLCJtb2NrQ2xlYXIiLCJ0ZXN0IiwiZXhwZWN0IiwicGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzIiwidG9CZSIsIm1vY2tVc2VyIiwiaWQiLCJwYXNzd29yZCIsImlzQWN0aXZlIiwicm9sZUlkIiwic2hvcElkIiwicm9sZU5hbWUiLCJwZXJtaXNzaW9ucyIsInJvbGUiLCJyZXN1bHQiLCJhdXRoZW50aWNhdGVVc2VyIiwic3VjY2VzcyIsInRva2VuIiwidG9FcXVhbCIsInVzZXJuYW1lIiwiZnVsbE5hbWUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIndoZXJlIiwiaW5jbHVkZSIsInNlbGVjdCIsIm1vY2tSZWplY3RlZFZhbHVlIiwibW9ja1BheWxvYWQiLCJzdWIiLCJtb2NrVG9rZW4iLCJnZW5lcmF0ZVRva2VuIiwiZXhwaXJlc0luIiwiaWF0IiwiTWF0aCIsImZsb29yIiwibm93IiwiZXhwIiwidmVyaWZ5VG9rZW4iLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiaW52YWxpZEVycm9yIiwibW9ja0ltcGxlbWVudGF0aW9uIiwicmVqZWN0cyIsInRvVGhyb3ciLCJleHBpcmVkRXJyb3IiLCJwYXlsb2FkIiwiY2FjaGVkVXNlciIsImdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQiLCJvcmlnaW5hbENvbnNvbGVMb2ciLCJjb25zb2xlIiwibG9nIiwidW5kZWZpbmVkIiwiY2F1Z2h0RXJyb3IiLCJlcnJvciIsImRlYnVnSW5mbyIsImNhY2hlR2V0Q2FsbHMiLCJjYWxscyIsImxlbmd0aCIsInVzZXJGaW5kRmlyc3RDYWxscyIsInVzZXJGaW5kRmlyc3RDYWxsc0RldGFpbHMiLCJjYWNoZUdldENhbGxzRGV0YWlscyIsImdlbmVyYXRlS2V5Q2FsbHMiLCJ0b0JlTnVsbCIsInZlcmlmeVJlc3VsdCIsInRvQmVEZWZpbmVkIiwidG9IYXZlUHJvcGVydHkiLCJudWxsUmVzdWx0Iiwibm9TdWJSZXN1bHQiLCJkZWNvZGVkUmVzdWx0Iiwibm90IiwiZ2V0VXNlckZyb21Ub2tlbiIsImp3dEVycm9yIiwib3JpZ2luYWxTZWNyZXQiLCJzZWNyZXRFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUEsbUNBQW1DO0FBQ25DLDJEQUEyRDs7Ozs7eUJBRXRDOzZCQXdGK0c7dUJBQ3ZHO3NFQUNSOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF4RnJCLGlEQUFpRDtBQUNqRCxNQUFNQSxtQkFBbUI7SUFDdkJDLEtBQUtDLGFBQUksQ0FBQ0MsRUFBRTtJQUNaQyxLQUFLRixhQUFJLENBQUNDLEVBQUU7SUFDWkUsUUFBUUgsYUFBSSxDQUFDQyxFQUFFO0lBQ2ZHLFdBQVdKLGFBQUksQ0FBQ0MsRUFBRTtJQUNsQkksYUFBYUwsYUFBSSxDQUFDQyxFQUFFO0lBQ3BCSyxPQUFPTixhQUFJLENBQUNDLEVBQUU7QUFDaEI7QUFFQSxNQUFNTSxhQUFhO0lBQ2pCQyxNQUFN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