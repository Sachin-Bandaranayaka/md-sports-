2cb481a451d0bc399037019e0d2596bc
"use strict";
// Mock ioredis
jest.mock("ioredis", ()=>{
    return {
        Redis: jest.fn().mockImplementation(()=>mockRedis)
    };
});
jest.mock("@/lib/inventoryCache", ()=>({
        inventoryCacheService: mockInventoryCache
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _cache = require("../../src/lib/cache");
const _ioredis = require("ioredis");
// Mock Redis
const mockRedis = {
    get: jest.fn(),
    set: jest.fn(),
    setex: jest.fn(),
    del: jest.fn(),
    keys: jest.fn(),
    flushall: jest.fn(),
    ping: jest.fn(),
    quit: jest.fn(),
    on: jest.fn(),
    connect: jest.fn(),
    disconnect: jest.fn()
};
// Mock the inventory cache service
const mockInventoryCache = {
    get: jest.fn(),
    set: jest.fn(),
    invalidateInventoryData: jest.fn(),
    generateKey: jest.fn(),
    warmPopularInventoryData: jest.fn(),
    trackFilterUsage: jest.fn(),
    getMetrics: jest.fn()
};
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Cache Management Tests", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("Basic Cache Operations", ()=>{
        describe("Memory Cache", ()=>{
            it("should store and retrieve data from memory cache", async ()=>{
                const testData = {
                    id: 1,
                    name: "Test Data"
                };
                const cacheKey = "test:key:1";
                // Mock memory cache behavior
                const memoryCache = new Map();
                memoryCache.set(cacheKey, JSON.stringify(testData));
                // Simulate cache set
                await _cache.cacheService.set(cacheKey, testData, 300);
                // Simulate cache get
                const cachedData = memoryCache.get(cacheKey);
                const result = cachedData ? JSON.parse(cachedData) : null;
                expect(result).toEqual(testData);
            });
            it("should handle cache expiration", async ()=>{
                const testData = {
                    id: 1,
                    name: "Expiring Data"
                };
                const cacheKey = "test:expiring:1";
                const ttl = 1; // 1 second
                await _cache.cacheService.set(cacheKey, testData, ttl);
                // Simulate time passing
                await new Promise((resolve)=>setTimeout(resolve, 1100));
                const result = await _cache.cacheService.get(cacheKey);
                expect(result).toBeNull();
            });
            it("should handle cache miss gracefully", async ()=>{
                const result = await _cache.cacheService.get("non:existent:key");
                expect(result).toBeNull();
            });
        });
        describe("Redis Cache", ()=>{
            it("should store data in Redis when available", async ()=>{
                const testData = {
                    id: 1,
                    name: "Redis Test"
                };
                const cacheKey = "redis:test:1";
                const ttl = 300;
                mockRedis.setex.mockResolvedValue("OK");
                await _cache.cacheService.set(cacheKey, testData, ttl);
                expect(mockRedis.setex).toHaveBeenCalledWith(cacheKey, ttl, JSON.stringify(testData));
            });
            it("should retrieve data from Redis", async ()=>{
                const testData = {
                    id: 1,
                    name: "Redis Test"
                };
                const cacheKey = "redis:test:1";
                mockRedis.get.mockResolvedValue(JSON.stringify(testData));
                const result = await _cache.cacheService.get(cacheKey);
                expect(mockRedis.get).toHaveBeenCalledWith(cacheKey);
                expect(result).toEqual(testData);
            });
            it("should handle Redis connection errors gracefully", async ()=>{
                const testData = {
                    id: 1,
                    name: "Error Test"
                };
                const cacheKey = "redis:error:1";
                mockRedis.setex.mockRejectedValue(new Error("Redis connection failed"));
                // Should not throw error, should fallback to memory cache
                await expect(_cache.cacheService.set(cacheKey, testData, 300)).resolves.not.toThrow();
                expect(consoleSpy.error).toHaveBeenCalledWith("Redis cache error:", expect.any(Error));
            });
            it("should handle Redis get errors gracefully", async ()=>{
                const cacheKey = "redis:error:get";
                mockRedis.get.mockRejectedValue(new Error("Redis get failed"));
                const result = await _cache.cacheService.get(cacheKey);
                expect(result).toBeNull();
                expect(consoleSpy.error).toHaveBeenCalledWith("Redis cache error:", expect.any(Error));
            });
        });
        describe("Cache Invalidation", ()=>{
            it("should delete specific cache keys", async ()=>{
                const cacheKey = "test:delete:1";
                mockRedis.del.mockResolvedValue(1);
                await _cache.cacheService.delete(cacheKey);
                expect(mockRedis.del).toHaveBeenCalledWith(cacheKey);
            });
            it("should delete multiple cache keys by pattern", async ()=>{
                const pattern = "test:pattern:*";
                const matchingKeys = [
                    "test:pattern:1",
                    "test:pattern:2",
                    "test:pattern:3"
                ];
                mockRedis.keys.mockResolvedValue(matchingKeys);
                mockRedis.del.mockResolvedValue(matchingKeys.length);
                await _cache.cacheService.deletePattern(pattern);
                expect(mockRedis.keys).toHaveBeenCalledWith(pattern);
                expect(mockRedis.del).toHaveBeenCalledWith(...matchingKeys);
            });
            it("should handle pattern deletion with no matches", async ()=>{
                const pattern = "test:nomatch:*";
                mockRedis.keys.mockResolvedValue([]);
                await _cache.cacheService.deletePattern(pattern);
                expect(mockRedis.keys).toHaveBeenCalledWith(pattern);
                expect(mockRedis.del).not.toHaveBeenCalled();
            });
            it("should clear all cache data", async ()=>{
                mockRedis.flushall.mockResolvedValue("OK");
                await _cache.cacheService.clear();
                expect(mockRedis.flushall).toHaveBeenCalled();
            });
        });
    });
    describe("Inventory Cache Service", ()=>{
        const mockInventoryData = {
            items: [
                {
                    id: 1,
                    productId: 1,
                    shopId: "shop1",
                    quantity: 100
                },
                {
                    id: 2,
                    productId: 2,
                    shopId: "shop1",
                    quantity: 50
                }
            ],
            total: 2,
            page: 1,
            limit: 20
        };
        const mockFilters = {
            shopId: "shop1",
            page: 1,
            limit: 20,
            status: "In Stock"
        };
        describe("Cache Key Generation", ()=>{
            it("should generate consistent cache keys", ()=>{
                const baseKey = "inventory:summary";
                const expectedKey = "inventory:summary:shop:shop1:status:In Stock:page:1:limit:20";
                mockInventoryCache.generateKey.mockReturnValue(expectedKey);
                const result = mockInventoryCache.generateKey(baseKey, mockFilters);
                expect(result).toBe(expectedKey);
                expect(mockInventoryCache.generateKey).toHaveBeenCalledWith(baseKey, mockFilters);
            });
            it("should handle filters with special characters", ()=>{
                const filtersWithSpecialChars = {
                    ...mockFilters,
                    search: "test product & more"
                };
                const expectedKey = "inventory:summary:shop:shop1:status:In Stock:search:test%20product%20%26%20more:page:1:limit:20";
                mockInventoryCache.generateKey.mockReturnValue(expectedKey);
                const result = mockInventoryCache.generateKey("inventory:summary", filtersWithSpecialChars);
                expect(result).toBe(expectedKey);
            });
        });
        describe("Cache Storage and Retrieval", ()=>{
            it("should store inventory data with TTL", async ()=>{
                const cacheKey = "inventory:summary:shop1";
                const ttl = 300;
                mockInventoryCache.set.mockResolvedValue(undefined);
                await mockInventoryCache.set(cacheKey, mockInventoryData, ttl);
                expect(mockInventoryCache.set).toHaveBeenCalledWith(cacheKey, mockInventoryData, ttl);
            });
            it("should retrieve cached inventory data", async ()=>{
                const cacheKey = "inventory:summary:shop1";
                mockInventoryCache.get.mockResolvedValue(mockInventoryData);
                const result = await mockInventoryCache.get(cacheKey);
                expect(mockInventoryCache.get).toHaveBeenCalledWith(cacheKey);
                expect(result).toEqual(mockInventoryData);
            });
            it("should return null for cache miss", async ()=>{
                const cacheKey = "inventory:summary:nonexistent";
                mockInventoryCache.get.mockResolvedValue(null);
                const result = await mockInventoryCache.get(cacheKey);
                expect(result).toBeNull();
            });
        });
        describe("Cache Invalidation Strategies", ()=>{
            it("should invalidate inventory data by product", async ()=>{
                const productId = 1;
                mockInventoryCache.invalidateInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.invalidateInventoryData(productId);
                expect(mockInventoryCache.invalidateInventoryData).toHaveBeenCalledWith(productId);
            });
            it("should invalidate inventory data by shop", async ()=>{
                const shopId = "shop1";
                mockInventoryCache.invalidateInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.invalidateInventoryData(undefined, shopId);
                expect(mockInventoryCache.invalidateInventoryData).toHaveBeenCalledWith(undefined, shopId);
            });
            it("should invalidate inventory data by category", async ()=>{
                const categoryId = 5;
                mockInventoryCache.invalidateInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.invalidateInventoryData(undefined, undefined, categoryId);
                expect(mockInventoryCache.invalidateInventoryData).toHaveBeenCalledWith(undefined, undefined, categoryId);
            });
            it("should invalidate all inventory data", async ()=>{
                mockInventoryCache.invalidateInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.invalidateInventoryData();
                expect(mockInventoryCache.invalidateInventoryData).toHaveBeenCalledWith();
            });
        });
        describe("Cache Warming", ()=>{
            it("should warm popular inventory data", async ()=>{
                mockInventoryCache.warmPopularInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.warmPopularInventoryData();
                expect(mockInventoryCache.warmPopularInventoryData).toHaveBeenCalled();
            });
            it("should track filter usage for warming strategy", ()=>{
                mockInventoryCache.trackFilterUsage.mockReturnValue(undefined);
                mockInventoryCache.trackFilterUsage(mockFilters);
                expect(mockInventoryCache.trackFilterUsage).toHaveBeenCalledWith(mockFilters);
            });
        });
        describe("Cache Metrics", ()=>{
            it("should collect cache performance metrics", ()=>{
                const mockMetrics = {
                    hits: 150,
                    misses: 25,
                    hitRate: 0.857,
                    avgResponseTime: 12.5,
                    totalRequests: 175
                };
                mockInventoryCache.getMetrics.mockReturnValue(mockMetrics);
                const metrics = mockInventoryCache.getMetrics();
                expect(metrics).toEqual(mockMetrics);
                expect(metrics.hitRate).toBeGreaterThan(0.8); // Good hit rate
                expect(metrics.avgResponseTime).toBeLessThan(50); // Fast response
            });
            it("should track cache performance over time", ()=>{
                const mockTimeSeriesMetrics = {
                    "2024-01-01T00:00:00Z": {
                        hits: 100,
                        misses: 10
                    },
                    "2024-01-01T01:00:00Z": {
                        hits: 120,
                        misses: 8
                    },
                    "2024-01-01T02:00:00Z": {
                        hits: 110,
                        misses: 12
                    }
                };
                mockInventoryCache.getMetrics.mockReturnValue(mockTimeSeriesMetrics);
                const metrics = mockInventoryCache.getMetrics("timeseries");
                expect(metrics).toEqual(mockTimeSeriesMetrics);
                expect(Object.keys(metrics)).toHaveLength(3);
            });
        });
    });
    describe("Cache Error Handling", ()=>{
        it("should handle cache service initialization errors", ()=>{
            const initError = new Error("Cache initialization failed");
            // Mock Redis constructor to throw error
            _ioredis.Redis.mockImplementationOnce(()=>{
                throw initError;
            });
            // Should not crash the application
            expect(()=>{
                new _ioredis.Redis();
            }).toThrow("Cache initialization failed");
        });
        it("should handle serialization errors", async ()=>{
            const circularData = {
                name: "test"
            };
            circularData.self = circularData; // Create circular reference
            const cacheKey = "test:circular";
            // Should handle JSON.stringify error gracefully
            await expect(_cache.cacheService.set(cacheKey, circularData, 300)).resolves.not.toThrow();
        });
        it("should handle deserialization errors", async ()=>{
            const cacheKey = "test:invalid:json";
            const invalidJson = "invalid json string";
            mockRedis.get.mockResolvedValue(invalidJson);
            const result = await _cache.cacheService.get(cacheKey);
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Cache deserialization error:", expect.any(Error));
        });
        it("should handle network timeouts gracefully", async ()=>{
            const timeoutError = new Error("Network timeout");
            timeoutError.name = "TimeoutError";
            mockRedis.get.mockRejectedValue(timeoutError);
            const result = await _cache.cacheService.get("test:timeout");
            expect(result).toBeNull();
            expect(consoleSpy.warn).toHaveBeenCalledWith("Cache timeout, falling back to database:", expect.any(Error));
        });
    });
    describe("Cache Performance Tests", ()=>{
        it("should handle high-frequency cache operations", async ()=>{
            const operations = [];
            const numOperations = 1000;
            // Simulate high-frequency cache operations
            for(let i = 0; i < numOperations; i++){
                operations.push(_cache.cacheService.set(`test:perf:${i}`, {
                    id: i,
                    data: `data-${i}`
                }, 300));
            }
            const startTime = Date.now();
            await Promise.all(operations);
            const endTime = Date.now();
            const duration = endTime - startTime;
            const opsPerSecond = numOperations / (duration / 1000);
            expect(opsPerSecond).toBeGreaterThan(100); // Should handle at least 100 ops/sec
        });
        it("should handle concurrent cache access", async ()=>{
            const cacheKey = "test:concurrent";
            const testData = {
                id: 1,
                name: "Concurrent Test"
            };
            mockRedis.get.mockResolvedValue(JSON.stringify(testData));
            mockRedis.setex.mockResolvedValue("OK");
            // Simulate concurrent reads and writes
            const concurrentOperations = [
                _cache.cacheService.get(cacheKey),
                _cache.cacheService.set(cacheKey, testData, 300),
                _cache.cacheService.get(cacheKey),
                _cache.cacheService.set(cacheKey, {
                    ...testData,
                    updated: true
                }, 300),
                _cache.cacheService.get(cacheKey)
            ];
            await expect(Promise.all(concurrentOperations)).resolves.not.toThrow();
        });
        it("should maintain cache consistency under load", async ()=>{
            const cacheKey = "test:consistency";
            let counter = 0;
            // Mock cache operations to simulate real behavior
            mockRedis.get.mockImplementation(async ()=>{
                return JSON.stringify({
                    counter
                });
            });
            mockRedis.setex.mockImplementation(async (key, ttl, value)=>{
                const data = JSON.parse(value);
                counter = data.counter;
                return "OK";
            });
            // Simulate multiple concurrent updates
            const updates = [];
            for(let i = 0; i < 10; i++){
                updates.push((async ()=>{
                    const current = await _cache.cacheService.get(cacheKey);
                    const newValue = {
                        counter: (current?.counter || 0) + 1
                    };
                    await _cache.cacheService.set(cacheKey, newValue, 300);
                })());
            }
            await Promise.all(updates);
            // Final counter should reflect all updates
            expect(counter).toBeGreaterThan(0);
        });
    });
    describe("Cache Configuration", ()=>{
        it("should respect TTL settings", async ()=>{
            const shortTTL = 1; // 1 second
            const longTTL = 3600; // 1 hour
            const testData = {
                id: 1,
                name: "TTL Test"
            };
            mockRedis.setex.mockResolvedValue("OK");
            await _cache.cacheService.set("test:short", testData, shortTTL);
            await _cache.cacheService.set("test:long", testData, longTTL);
            expect(mockRedis.setex).toHaveBeenCalledWith("test:short", shortTTL, JSON.stringify(testData));
            expect(mockRedis.setex).toHaveBeenCalledWith("test:long", longTTL, JSON.stringify(testData));
        });
        it("should use default TTL when not specified", async ()=>{
            const testData = {
                id: 1,
                name: "Default TTL Test"
            };
            const defaultTTL = 300; // 5 minutes
            mockRedis.setex.mockResolvedValue("OK");
            await _cache.cacheService.set("test:default", testData);
            expect(mockRedis.setex).toHaveBeenCalledWith("test:default", defaultTTL, JSON.stringify(testData));
        });
        it("should handle cache size limits", async ()=>{
            const largeData = {
                id: 1,
                data: "x".repeat(1024 * 1024)
            };
            mockRedis.setex.mockResolvedValue("OK");
            // Should handle large data without issues
            await expect(_cache.cacheService.set("test:large", largeData, 300)).resolves.not.toThrow();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9jYWNoZU1hbmFnZW1lbnQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWNoZVNlcnZpY2UgfSBmcm9tICdAL2xpYi9jYWNoZSc7XG5pbXBvcnQgeyBSZWRpcyB9IGZyb20gJ2lvcmVkaXMnO1xuXG4vLyBNb2NrIFJlZGlzXG5jb25zdCBtb2NrUmVkaXMgPSB7XG4gIGdldDogamVzdC5mbigpLFxuICBzZXQ6IGplc3QuZm4oKSxcbiAgc2V0ZXg6IGplc3QuZm4oKSxcbiAgZGVsOiBqZXN0LmZuKCksXG4gIGtleXM6IGplc3QuZm4oKSxcbiAgZmx1c2hhbGw6IGplc3QuZm4oKSxcbiAgcGluZzogamVzdC5mbigpLFxuICBxdWl0OiBqZXN0LmZuKCksXG4gIG9uOiBqZXN0LmZuKCksXG4gIGNvbm5lY3Q6IGplc3QuZm4oKSxcbiAgZGlzY29ubmVjdDogamVzdC5mbigpLFxufTtcblxuLy8gTW9jayBpb3JlZGlzXG5qZXN0Lm1vY2soJ2lvcmVkaXMnLCAoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgUmVkaXM6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja1JlZGlzKSxcbiAgfTtcbn0pO1xuXG4vLyBNb2NrIHRoZSBpbnZlbnRvcnkgY2FjaGUgc2VydmljZVxuY29uc3QgbW9ja0ludmVudG9yeUNhY2hlID0ge1xuICBnZXQ6IGplc3QuZm4oKSxcbiAgc2V0OiBqZXN0LmZuKCksXG4gIGludmFsaWRhdGVJbnZlbnRvcnlEYXRhOiBqZXN0LmZuKCksXG4gIGdlbmVyYXRlS2V5OiBqZXN0LmZuKCksXG4gIHdhcm1Qb3B1bGFySW52ZW50b3J5RGF0YTogamVzdC5mbigpLFxuICB0cmFja0ZpbHRlclVzYWdlOiBqZXN0LmZuKCksXG4gIGdldE1ldHJpY3M6IGplc3QuZm4oKSxcbn07XG5cbmplc3QubW9jaygnQC9saWIvaW52ZW50b3J5Q2FjaGUnLCAoKSA9PiAoe1xuICBpbnZlbnRvcnlDYWNoZVNlcnZpY2U6IG1vY2tJbnZlbnRvcnlDYWNoZSxcbn0pKTtcblxuLy8gTW9jayBjb25zb2xlIG1ldGhvZHNcbmNvbnN0IGNvbnNvbGVTcHkgPSB7XG4gIGxvZzogamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbiAgZXJyb3I6IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbiAgd2FybjogamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG59O1xuXG5kZXNjcmliZSgnQ2FjaGUgTWFuYWdlbWVudCBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgY29uc29sZVNweS5sb2cubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS5lcnJvci5tb2NrQ2xlYXIoKTtcbiAgICBjb25zb2xlU3B5Lndhcm4ubW9ja0NsZWFyKCk7XG4gIH0pO1xuXG4gIGFmdGVyQWxsKCgpID0+IHtcbiAgICBjb25zb2xlU3B5LmxvZy5tb2NrUmVzdG9yZSgpO1xuICAgIGNvbnNvbGVTcHkuZXJyb3IubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5Lndhcm4ubW9ja1Jlc3RvcmUoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Jhc2ljIENhY2hlIE9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoJ01lbW9yeSBDYWNoZScsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgc3RvcmUgYW5kIHJldHJpZXZlIGRhdGEgZnJvbSBtZW1vcnkgY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ1Rlc3QgRGF0YScgfTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAndGVzdDprZXk6MSc7XG5cbiAgICAgICAgLy8gTW9jayBtZW1vcnkgY2FjaGUgYmVoYXZpb3JcbiAgICAgICAgY29uc3QgbWVtb3J5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIG1lbW9yeUNhY2hlLnNldChjYWNoZUtleSwgSlNPTi5zdHJpbmdpZnkodGVzdERhdGEpKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBjYWNoZSBzZXRcbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdGVzdERhdGEsIDMwMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaW11bGF0ZSBjYWNoZSBnZXRcbiAgICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IG1lbW9yeUNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhY2hlZERhdGEgPyBKU09OLnBhcnNlKGNhY2hlZERhdGEpIDogbnVsbDtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHRlc3REYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBjYWNoZSBleHBpcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgaWQ6IDEsIG5hbWU6ICdFeHBpcmluZyBEYXRhJyB9O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICd0ZXN0OmV4cGlyaW5nOjEnO1xuICAgICAgICBjb25zdCB0dGwgPSAxOyAvLyAxIHNlY29uZFxuXG4gICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5zZXQoY2FjaGVLZXksIHRlc3REYXRhLCB0dGwpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIHRpbWUgcGFzc2luZ1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTEwMCkpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGNhY2hlIG1pc3MgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldCgnbm9uOmV4aXN0ZW50OmtleScpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnUmVkaXMgQ2FjaGUnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHN0b3JlIGRhdGEgaW4gUmVkaXMgd2hlbiBhdmFpbGFibGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ1JlZGlzIFRlc3QnIH07XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gJ3JlZGlzOnRlc3Q6MSc7XG4gICAgICAgIGNvbnN0IHR0bCA9IDMwMDtcblxuICAgICAgICBtb2NrUmVkaXMuc2V0ZXgubW9ja1Jlc29sdmVkVmFsdWUoJ09LJyk7XG5cbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdGVzdERhdGEsIHR0bCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tSZWRpcy5zZXRleCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgdHRsLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRlc3REYXRhKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0cmlldmUgZGF0YSBmcm9tIFJlZGlzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgaWQ6IDEsIG5hbWU6ICdSZWRpcyBUZXN0JyB9O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICdyZWRpczp0ZXN0OjEnO1xuXG4gICAgICAgIG1vY2tSZWRpcy5nZXQubW9ja1Jlc29sdmVkVmFsdWUoSlNPTi5zdHJpbmdpZnkodGVzdERhdGEpKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZVNlcnZpY2UuZ2V0KGNhY2hlS2V5KTtcblxuICAgICAgICBleHBlY3QobW9ja1JlZGlzLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoY2FjaGVLZXkpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHRlc3REYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBSZWRpcyBjb25uZWN0aW9uIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgaWQ6IDEsIG5hbWU6ICdFcnJvciBUZXN0JyB9O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICdyZWRpczplcnJvcjoxJztcblxuICAgICAgICBtb2NrUmVkaXMuc2V0ZXgubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdSZWRpcyBjb25uZWN0aW9uIGZhaWxlZCcpKTtcblxuICAgICAgICAvLyBTaG91bGQgbm90IHRocm93IGVycm9yLCBzaG91bGQgZmFsbGJhY2sgdG8gbWVtb3J5IGNhY2hlXG4gICAgICAgIGF3YWl0IGV4cGVjdChjYWNoZVNlcnZpY2Uuc2V0KGNhY2hlS2V5LCB0ZXN0RGF0YSwgMzAwKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICdSZWRpcyBjYWNoZSBlcnJvcjonLFxuICAgICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgUmVkaXMgZ2V0IGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICdyZWRpczplcnJvcjpnZXQnO1xuXG4gICAgICAgIG1vY2tSZWRpcy5nZXQubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdSZWRpcyBnZXQgZmFpbGVkJykpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnUmVkaXMgY2FjaGUgZXJyb3I6JyxcbiAgICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQ2FjaGUgSW52YWxpZGF0aW9uJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBkZWxldGUgc3BlY2lmaWMgY2FjaGUga2V5cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAndGVzdDpkZWxldGU6MSc7XG5cbiAgICAgICAgbW9ja1JlZGlzLmRlbC5tb2NrUmVzb2x2ZWRWYWx1ZSgxKTtcblxuICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2UuZGVsZXRlKGNhY2hlS2V5KTtcblxuICAgICAgICBleHBlY3QobW9ja1JlZGlzLmRlbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoY2FjaGVLZXkpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgZGVsZXRlIG11bHRpcGxlIGNhY2hlIGtleXMgYnkgcGF0dGVybicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9ICd0ZXN0OnBhdHRlcm46Kic7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nS2V5cyA9IFsndGVzdDpwYXR0ZXJuOjEnLCAndGVzdDpwYXR0ZXJuOjInLCAndGVzdDpwYXR0ZXJuOjMnXTtcblxuICAgICAgICBtb2NrUmVkaXMua2V5cy5tb2NrUmVzb2x2ZWRWYWx1ZShtYXRjaGluZ0tleXMpO1xuICAgICAgICBtb2NrUmVkaXMuZGVsLm1vY2tSZXNvbHZlZFZhbHVlKG1hdGNoaW5nS2V5cy5sZW5ndGgpO1xuXG4gICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5kZWxldGVQYXR0ZXJuKHBhdHRlcm4pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUmVkaXMua2V5cykudG9IYXZlQmVlbkNhbGxlZFdpdGgocGF0dGVybik7XG4gICAgICAgIGV4cGVjdChtb2NrUmVkaXMuZGVsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCguLi5tYXRjaGluZ0tleXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhdHRlcm4gZGVsZXRpb24gd2l0aCBubyBtYXRjaGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gJ3Rlc3Q6bm9tYXRjaDoqJztcblxuICAgICAgICBtb2NrUmVkaXMua2V5cy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLmRlbGV0ZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tSZWRpcy5rZXlzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwYXR0ZXJuKTtcbiAgICAgICAgZXhwZWN0KG1vY2tSZWRpcy5kZWwpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBjbGVhciBhbGwgY2FjaGUgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja1JlZGlzLmZsdXNoYWxsLm1vY2tSZXNvbHZlZFZhbHVlKCdPSycpO1xuXG4gICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5jbGVhcigpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUmVkaXMuZmx1c2hhbGwpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW52ZW50b3J5IENhY2hlIFNlcnZpY2UnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0ludmVudG9yeURhdGEgPSB7XG4gICAgICBpdGVtczogW1xuICAgICAgICB7IGlkOiAxLCBwcm9kdWN0SWQ6IDEsIHNob3BJZDogJ3Nob3AxJywgcXVhbnRpdHk6IDEwMCB9LFxuICAgICAgICB7IGlkOiAyLCBwcm9kdWN0SWQ6IDIsIHNob3BJZDogJ3Nob3AxJywgcXVhbnRpdHk6IDUwIH0sXG4gICAgICBdLFxuICAgICAgdG90YWw6IDIsXG4gICAgICBwYWdlOiAxLFxuICAgICAgbGltaXQ6IDIwLFxuICAgIH07XG5cbiAgICBjb25zdCBtb2NrRmlsdGVycyA9IHtcbiAgICAgIHNob3BJZDogJ3Nob3AxJyxcbiAgICAgIHBhZ2U6IDEsXG4gICAgICBsaW1pdDogMjAsXG4gICAgICBzdGF0dXM6ICdJbiBTdG9jaycsXG4gICAgfTtcblxuICAgIGRlc2NyaWJlKCdDYWNoZSBLZXkgR2VuZXJhdGlvbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgY29uc2lzdGVudCBjYWNoZSBrZXlzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlS2V5ID0gJ2ludmVudG9yeTpzdW1tYXJ5JztcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRLZXkgPSAnaW52ZW50b3J5OnN1bW1hcnk6c2hvcDpzaG9wMTpzdGF0dXM6SW4gU3RvY2s6cGFnZToxOmxpbWl0OjIwJztcblxuICAgICAgICBtb2NrSW52ZW50b3J5Q2FjaGUuZ2VuZXJhdGVLZXkubW9ja1JldHVyblZhbHVlKGV4cGVjdGVkS2V5KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBtb2NrSW52ZW50b3J5Q2FjaGUuZ2VuZXJhdGVLZXkoYmFzZUtleSwgbW9ja0ZpbHRlcnMpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZXhwZWN0ZWRLZXkpO1xuICAgICAgICBleHBlY3QobW9ja0ludmVudG9yeUNhY2hlLmdlbmVyYXRlS2V5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChiYXNlS2V5LCBtb2NrRmlsdGVycyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZmlsdGVycyB3aXRoIHNwZWNpYWwgY2hhcmFjdGVycycsICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyc1dpdGhTcGVjaWFsQ2hhcnMgPSB7XG4gICAgICAgICAgLi4ubW9ja0ZpbHRlcnMsXG4gICAgICAgICAgc2VhcmNoOiAndGVzdCBwcm9kdWN0ICYgbW9yZScsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkS2V5ID0gJ2ludmVudG9yeTpzdW1tYXJ5OnNob3A6c2hvcDE6c3RhdHVzOkluIFN0b2NrOnNlYXJjaDp0ZXN0JTIwcHJvZHVjdCUyMCUyNiUyMG1vcmU6cGFnZToxOmxpbWl0OjIwJztcblxuICAgICAgICBtb2NrSW52ZW50b3J5Q2FjaGUuZ2VuZXJhdGVLZXkubW9ja1JldHVyblZhbHVlKGV4cGVjdGVkS2V5KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBtb2NrSW52ZW50b3J5Q2FjaGUuZ2VuZXJhdGVLZXkoJ2ludmVudG9yeTpzdW1tYXJ5JywgZmlsdGVyc1dpdGhTcGVjaWFsQ2hhcnMpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZXhwZWN0ZWRLZXkpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQ2FjaGUgU3RvcmFnZSBhbmQgUmV0cmlldmFsJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBzdG9yZSBpbnZlbnRvcnkgZGF0YSB3aXRoIFRUTCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAnaW52ZW50b3J5OnN1bW1hcnk6c2hvcDEnO1xuICAgICAgICBjb25zdCB0dGwgPSAzMDA7XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICAgIGF3YWl0IG1vY2tJbnZlbnRvcnlDYWNoZS5zZXQoY2FjaGVLZXksIG1vY2tJbnZlbnRvcnlEYXRhLCB0dGwpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrSW52ZW50b3J5Q2FjaGUuc2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChjYWNoZUtleSwgbW9ja0ludmVudG9yeURhdGEsIHR0bCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBjYWNoZWQgaW52ZW50b3J5IGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gJ2ludmVudG9yeTpzdW1tYXJ5OnNob3AxJztcblxuICAgICAgICBtb2NrSW52ZW50b3J5Q2FjaGUuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tJbnZlbnRvcnlEYXRhKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrSW52ZW50b3J5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcblxuICAgICAgICBleHBlY3QobW9ja0ludmVudG9yeUNhY2hlLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoY2FjaGVLZXkpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tJbnZlbnRvcnlEYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBjYWNoZSBtaXNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICdpbnZlbnRvcnk6c3VtbWFyeTpub25leGlzdGVudCc7XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrSW52ZW50b3J5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQ2FjaGUgSW52YWxpZGF0aW9uIFN0cmF0ZWdpZXMnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGludmFsaWRhdGUgaW52ZW50b3J5IGRhdGEgYnkgcHJvZHVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcHJvZHVjdElkID0gMTtcblxuICAgICAgICBtb2NrSW52ZW50b3J5Q2FjaGUuaW52YWxpZGF0ZUludmVudG9yeURhdGEubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcblxuICAgICAgICBhd2FpdCBtb2NrSW52ZW50b3J5Q2FjaGUuaW52YWxpZGF0ZUludmVudG9yeURhdGEocHJvZHVjdElkKTtcblxuICAgICAgICBleHBlY3QobW9ja0ludmVudG9yeUNhY2hlLmludmFsaWRhdGVJbnZlbnRvcnlEYXRhKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwcm9kdWN0SWQpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaW52YWxpZGF0ZSBpbnZlbnRvcnkgZGF0YSBieSBzaG9wJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBzaG9wSWQgPSAnc2hvcDEnO1xuXG4gICAgICAgIG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICAgIGF3YWl0IG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YSh1bmRlZmluZWQsIHNob3BJZCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodW5kZWZpbmVkLCBzaG9wSWQpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaW52YWxpZGF0ZSBpbnZlbnRvcnkgZGF0YSBieSBjYXRlZ29yeScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlJZCA9IDU7XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLmludmFsaWRhdGVJbnZlbnRvcnlEYXRhLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgYXdhaXQgbW9ja0ludmVudG9yeUNhY2hlLmludmFsaWRhdGVJbnZlbnRvcnlEYXRhKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjYXRlZ29yeUlkKTtcblxuICAgICAgICBleHBlY3QobW9ja0ludmVudG9yeUNhY2hlLmludmFsaWRhdGVJbnZlbnRvcnlEYXRhKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2F0ZWdvcnlJZCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBpbnZhbGlkYXRlIGFsbCBpbnZlbnRvcnkgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLmludmFsaWRhdGVJbnZlbnRvcnlEYXRhLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgYXdhaXQgbW9ja0ludmVudG9yeUNhY2hlLmludmFsaWRhdGVJbnZlbnRvcnlEYXRhKCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0NhY2hlIFdhcm1pbmcnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHdhcm0gcG9wdWxhciBpbnZlbnRvcnkgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLndhcm1Qb3B1bGFySW52ZW50b3J5RGF0YS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICAgIGF3YWl0IG1vY2tJbnZlbnRvcnlDYWNoZS53YXJtUG9wdWxhckludmVudG9yeURhdGEoKTtcblxuICAgICAgICBleHBlY3QobW9ja0ludmVudG9yeUNhY2hlLndhcm1Qb3B1bGFySW52ZW50b3J5RGF0YSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdHJhY2sgZmlsdGVyIHVzYWdlIGZvciB3YXJtaW5nIHN0cmF0ZWd5JywgKCkgPT4ge1xuICAgICAgICBtb2NrSW52ZW50b3J5Q2FjaGUudHJhY2tGaWx0ZXJVc2FnZS5tb2NrUmV0dXJuVmFsdWUodW5kZWZpbmVkKTtcblxuICAgICAgICBtb2NrSW52ZW50b3J5Q2FjaGUudHJhY2tGaWx0ZXJVc2FnZShtb2NrRmlsdGVycyk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tJbnZlbnRvcnlDYWNoZS50cmFja0ZpbHRlclVzYWdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrRmlsdGVycyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdDYWNoZSBNZXRyaWNzJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjb2xsZWN0IGNhY2hlIHBlcmZvcm1hbmNlIG1ldHJpY3MnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tNZXRyaWNzID0ge1xuICAgICAgICAgIGhpdHM6IDE1MCxcbiAgICAgICAgICBtaXNzZXM6IDI1LFxuICAgICAgICAgIGhpdFJhdGU6IDAuODU3LFxuICAgICAgICAgIGF2Z1Jlc3BvbnNlVGltZTogMTIuNSxcbiAgICAgICAgICB0b3RhbFJlcXVlc3RzOiAxNzUsXG4gICAgICAgIH07XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLmdldE1ldHJpY3MubW9ja1JldHVyblZhbHVlKG1vY2tNZXRyaWNzKTtcblxuICAgICAgICBjb25zdCBtZXRyaWNzID0gbW9ja0ludmVudG9yeUNhY2hlLmdldE1ldHJpY3MoKTtcblxuICAgICAgICBleHBlY3QobWV0cmljcykudG9FcXVhbChtb2NrTWV0cmljcyk7XG4gICAgICAgIGV4cGVjdChtZXRyaWNzLmhpdFJhdGUpLnRvQmVHcmVhdGVyVGhhbigwLjgpOyAvLyBHb29kIGhpdCByYXRlXG4gICAgICAgIGV4cGVjdChtZXRyaWNzLmF2Z1Jlc3BvbnNlVGltZSkudG9CZUxlc3NUaGFuKDUwKTsgLy8gRmFzdCByZXNwb25zZVxuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdHJhY2sgY2FjaGUgcGVyZm9ybWFuY2Ugb3ZlciB0aW1lJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVGltZVNlcmllc01ldHJpY3MgPSB7XG4gICAgICAgICAgJzIwMjQtMDEtMDFUMDA6MDA6MDBaJzogeyBoaXRzOiAxMDAsIG1pc3NlczogMTAgfSxcbiAgICAgICAgICAnMjAyNC0wMS0wMVQwMTowMDowMFonOiB7IGhpdHM6IDEyMCwgbWlzc2VzOiA4IH0sXG4gICAgICAgICAgJzIwMjQtMDEtMDFUMDI6MDA6MDBaJzogeyBoaXRzOiAxMTAsIG1pc3NlczogMTIgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBtb2NrSW52ZW50b3J5Q2FjaGUuZ2V0TWV0cmljcy5tb2NrUmV0dXJuVmFsdWUobW9ja1RpbWVTZXJpZXNNZXRyaWNzKTtcblxuICAgICAgICBjb25zdCBtZXRyaWNzID0gbW9ja0ludmVudG9yeUNhY2hlLmdldE1ldHJpY3MoJ3RpbWVzZXJpZXMnKTtcblxuICAgICAgICBleHBlY3QobWV0cmljcykudG9FcXVhbChtb2NrVGltZVNlcmllc01ldHJpY3MpO1xuICAgICAgICBleHBlY3QoT2JqZWN0LmtleXMobWV0cmljcykpLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FjaGUgc2VydmljZSBpbml0aWFsaXphdGlvbiBlcnJvcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0RXJyb3IgPSBuZXcgRXJyb3IoJ0NhY2hlIGluaXRpYWxpemF0aW9uIGZhaWxlZCcpO1xuICAgICAgXG4gICAgICAvLyBNb2NrIFJlZGlzIGNvbnN0cnVjdG9yIHRvIHRocm93IGVycm9yXG4gICAgICAoUmVkaXMgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgUmVkaXM+KS5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHtcbiAgICAgICAgdGhyb3cgaW5pdEVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgY3Jhc2ggdGhlIGFwcGxpY2F0aW9uXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBuZXcgUmVkaXMoKTtcbiAgICAgIH0pLnRvVGhyb3coJ0NhY2hlIGluaXRpYWxpemF0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VyaWFsaXphdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjaXJjdWxhckRhdGEgPSB7IG5hbWU6ICd0ZXN0JyB9O1xuICAgICAgY2lyY3VsYXJEYXRhLnNlbGYgPSBjaXJjdWxhckRhdGE7IC8vIENyZWF0ZSBjaXJjdWxhciByZWZlcmVuY2VcblxuICAgICAgY29uc3QgY2FjaGVLZXkgPSAndGVzdDpjaXJjdWxhcic7XG5cbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgSlNPTi5zdHJpbmdpZnkgZXJyb3IgZ3JhY2VmdWxseVxuICAgICAgYXdhaXQgZXhwZWN0KGNhY2hlU2VydmljZS5zZXQoY2FjaGVLZXksIGNpcmN1bGFyRGF0YSwgMzAwKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRlc2VyaWFsaXphdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9ICd0ZXN0OmludmFsaWQ6anNvbic7XG4gICAgICBjb25zdCBpbnZhbGlkSnNvbiA9ICdpbnZhbGlkIGpzb24gc3RyaW5nJztcblxuICAgICAgbW9ja1JlZGlzLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShpbnZhbGlkSnNvbik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnQ2FjaGUgZGVzZXJpYWxpemF0aW9uIGVycm9yOicsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmV0d29yayB0aW1lb3V0cyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGltZW91dEVycm9yID0gbmV3IEVycm9yKCdOZXR3b3JrIHRpbWVvdXQnKTtcbiAgICAgIHRpbWVvdXRFcnJvci5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG5cbiAgICAgIG1vY2tSZWRpcy5nZXQubW9ja1JlamVjdGVkVmFsdWUodGltZW91dEVycm9yKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldCgndGVzdDp0aW1lb3V0Jyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0NhY2hlIHRpbWVvdXQsIGZhbGxpbmcgYmFjayB0byBkYXRhYmFzZTonLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhY2hlIFBlcmZvcm1hbmNlIFRlc3RzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGhpZ2gtZnJlcXVlbmN5IGNhY2hlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcGVyYXRpb25zID0gW107XG4gICAgICBjb25zdCBudW1PcGVyYXRpb25zID0gMTAwMDtcblxuICAgICAgLy8gU2ltdWxhdGUgaGlnaC1mcmVxdWVuY3kgY2FjaGUgb3BlcmF0aW9uc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PcGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKFxuICAgICAgICAgIGNhY2hlU2VydmljZS5zZXQoYHRlc3Q6cGVyZjoke2l9YCwgeyBpZDogaSwgZGF0YTogYGRhdGEtJHtpfWAgfSwgMzAwKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob3BlcmF0aW9ucyk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3Qgb3BzUGVyU2Vjb25kID0gbnVtT3BlcmF0aW9ucyAvIChkdXJhdGlvbiAvIDEwMDApO1xuXG4gICAgICBleHBlY3Qob3BzUGVyU2Vjb25kKS50b0JlR3JlYXRlclRoYW4oMTAwKTsgLy8gU2hvdWxkIGhhbmRsZSBhdCBsZWFzdCAxMDAgb3BzL3NlY1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCBjYWNoZSBhY2Nlc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9ICd0ZXN0OmNvbmN1cnJlbnQnO1xuICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGlkOiAxLCBuYW1lOiAnQ29uY3VycmVudCBUZXN0JyB9O1xuXG4gICAgICBtb2NrUmVkaXMuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKEpTT04uc3RyaW5naWZ5KHRlc3REYXRhKSk7XG4gICAgICBtb2NrUmVkaXMuc2V0ZXgubW9ja1Jlc29sdmVkVmFsdWUoJ09LJyk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGNvbmN1cnJlbnQgcmVhZHMgYW5kIHdyaXRlc1xuICAgICAgY29uc3QgY29uY3VycmVudE9wZXJhdGlvbnMgPSBbXG4gICAgICAgIGNhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpLFxuICAgICAgICBjYWNoZVNlcnZpY2Uuc2V0KGNhY2hlS2V5LCB0ZXN0RGF0YSwgMzAwKSxcbiAgICAgICAgY2FjaGVTZXJ2aWNlLmdldChjYWNoZUtleSksXG4gICAgICAgIGNhY2hlU2VydmljZS5zZXQoY2FjaGVLZXksIHsgLi4udGVzdERhdGEsIHVwZGF0ZWQ6IHRydWUgfSwgMzAwKSxcbiAgICAgICAgY2FjaGVTZXJ2aWNlLmdldChjYWNoZUtleSksXG4gICAgICBdO1xuXG4gICAgICBhd2FpdCBleHBlY3QoUHJvbWlzZS5hbGwoY29uY3VycmVudE9wZXJhdGlvbnMpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBtYWludGFpbiBjYWNoZSBjb25zaXN0ZW5jeSB1bmRlciBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSAndGVzdDpjb25zaXN0ZW5jeSc7XG4gICAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICAgIC8vIE1vY2sgY2FjaGUgb3BlcmF0aW9ucyB0byBzaW11bGF0ZSByZWFsIGJlaGF2aW9yXG4gICAgICBtb2NrUmVkaXMuZ2V0Lm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IGNvdW50ZXIgfSk7XG4gICAgICB9KTtcblxuICAgICAgbW9ja1JlZGlzLnNldGV4Lm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoa2V5LCB0dGwsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgY291bnRlciA9IGRhdGEuY291bnRlcjtcbiAgICAgICAgcmV0dXJuICdPSyc7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2ltdWxhdGUgbXVsdGlwbGUgY29uY3VycmVudCB1cGRhdGVzXG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgdXBkYXRlcy5wdXNoKFxuICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHsgY291bnRlcjogKGN1cnJlbnQ/LmNvdW50ZXIgfHwgMCkgKyAxIH07XG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KGNhY2hlS2V5LCBuZXdWYWx1ZSwgMzAwKTtcbiAgICAgICAgICB9KSgpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHVwZGF0ZXMpO1xuXG4gICAgICAvLyBGaW5hbCBjb3VudGVyIHNob3VsZCByZWZsZWN0IGFsbCB1cGRhdGVzXG4gICAgICBleHBlY3QoY291bnRlcikudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGUgQ29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlc3BlY3QgVFRMIHNldHRpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2hvcnRUVEwgPSAxOyAvLyAxIHNlY29uZFxuICAgICAgY29uc3QgbG9uZ1RUTCA9IDM2MDA7IC8vIDEgaG91clxuICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGlkOiAxLCBuYW1lOiAnVFRMIFRlc3QnIH07XG5cbiAgICAgIG1vY2tSZWRpcy5zZXRleC5tb2NrUmVzb2x2ZWRWYWx1ZSgnT0snKTtcblxuICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldCgndGVzdDpzaG9ydCcsIHRlc3REYXRhLCBzaG9ydFRUTCk7XG4gICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KCd0ZXN0OmxvbmcnLCB0ZXN0RGF0YSwgbG9uZ1RUTCk7XG5cbiAgICAgIGV4cGVjdChtb2NrUmVkaXMuc2V0ZXgpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAndGVzdDpzaG9ydCcsXG4gICAgICAgIHNob3J0VFRMLFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh0ZXN0RGF0YSlcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja1JlZGlzLnNldGV4KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ3Rlc3Q6bG9uZycsXG4gICAgICAgIGxvbmdUVEwsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHRlc3REYXRhKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgVFRMIHdoZW4gbm90IHNwZWNpZmllZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ0RlZmF1bHQgVFRMIFRlc3QnIH07XG4gICAgICBjb25zdCBkZWZhdWx0VFRMID0gMzAwOyAvLyA1IG1pbnV0ZXNcblxuICAgICAgbW9ja1JlZGlzLnNldGV4Lm1vY2tSZXNvbHZlZFZhbHVlKCdPSycpO1xuXG4gICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KCd0ZXN0OmRlZmF1bHQnLCB0ZXN0RGF0YSk7XG5cbiAgICAgIGV4cGVjdChtb2NrUmVkaXMuc2V0ZXgpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAndGVzdDpkZWZhdWx0JyxcbiAgICAgICAgZGVmYXVsdFRUTCxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkodGVzdERhdGEpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FjaGUgc2l6ZSBsaW1pdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZURhdGEgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBkYXRhOiAneCcucmVwZWF0KDEwMjQgKiAxMDI0KSwgLy8gMU1CIG9mIGRhdGFcbiAgICAgIH07XG5cbiAgICAgIG1vY2tSZWRpcy5zZXRleC5tb2NrUmVzb2x2ZWRWYWx1ZSgnT0snKTtcblxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBsYXJnZSBkYXRhIHdpdGhvdXQgaXNzdWVzXG4gICAgICBhd2FpdCBleHBlY3QoY2FjaGVTZXJ2aWNlLnNldCgndGVzdDpsYXJnZScsIGxhcmdlRGF0YSwgMzAwKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJSZWRpcyIsImZuIiwibW9ja0ltcGxlbWVudGF0aW9uIiwibW9ja1JlZGlzIiwiaW52ZW50b3J5Q2FjaGVTZXJ2aWNlIiwibW9ja0ludmVudG9yeUNhY2hlIiwiZ2V0Iiwic2V0Iiwic2V0ZXgiLCJkZWwiLCJrZXlzIiwiZmx1c2hhbGwiLCJwaW5nIiwicXVpdCIsIm9uIiwiY29ubmVjdCIsImRpc2Nvbm5lY3QiLCJpbnZhbGlkYXRlSW52ZW50b3J5RGF0YSIsImdlbmVyYXRlS2V5Iiwid2FybVBvcHVsYXJJbnZlbnRvcnlEYXRhIiwidHJhY2tGaWx0ZXJVc2FnZSIsImdldE1ldHJpY3MiLCJjb25zb2xlU3B5IiwibG9nIiwic3B5T24iLCJjb25zb2xlIiwiZXJyb3IiLCJ3YXJuIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsImFmdGVyQWxsIiwibW9ja1Jlc3RvcmUiLCJpdCIsInRlc3REYXRhIiwiaWQiLCJuYW1lIiwiY2FjaGVLZXkiLCJtZW1vcnlDYWNoZSIsIk1hcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjYWNoZVNlcnZpY2UiLCJjYWNoZWREYXRhIiwicmVzdWx0IiwicGFyc2UiLCJleHBlY3QiLCJ0b0VxdWFsIiwidHRsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwidG9CZU51bGwiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciIsInJlc29sdmVzIiwibm90IiwidG9UaHJvdyIsImFueSIsImRlbGV0ZSIsInBhdHRlcm4iLCJtYXRjaGluZ0tleXMiLCJsZW5ndGgiLCJkZWxldGVQYXR0ZXJuIiwidG9IYXZlQmVlbkNhbGxlZCIsImNsZWFyIiwibW9ja0ludmVudG9yeURhdGEiLCJpdGVtcyIsInByb2R1Y3RJZCIsInNob3BJZCIsInF1YW50aXR5IiwidG90YWwiLCJwYWdlIiwibGltaXQiLCJtb2NrRmlsdGVycyIsInN0YXR1cyIsImJhc2VLZXkiLCJleHBlY3RlZEtleSIsIm1vY2tSZXR1cm5WYWx1ZSIsInRvQmUiLCJmaWx0ZXJzV2l0aFNwZWNpYWxDaGFycyIsInNlYXJjaCIsInVuZGVmaW5lZCIsImNhdGVnb3J5SWQiLCJtb2NrTWV0cmljcyIsImhpdHMiLCJtaXNzZXMiLCJoaXRSYXRlIiwiYXZnUmVzcG9uc2VUaW1lIiwidG90YWxSZXF1ZXN0cyIsIm1ldHJpY3MiLCJ0b0JlR3JlYXRlclRoYW4iLCJ0b0JlTGVzc1RoYW4iLCJtb2NrVGltZVNlcmllc01ldHJpY3MiLCJPYmplY3QiLCJ0b0hhdmVMZW5ndGgiLCJpbml0RXJyb3IiLCJtb2NrSW1wbGVtZW50YXRpb25PbmNlIiwiY2lyY3VsYXJEYXRhIiwic2VsZiIsImludmFsaWRKc29uIiwidGltZW91dEVycm9yIiwib3BlcmF0aW9ucyIsIm51bU9wZXJhdGlvbnMiLCJpIiwicHVzaCIsImRhdGEiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiYWxsIiwiZW5kVGltZSIsImR1cmF0aW9uIiwib3BzUGVyU2Vjb25kIiwiY29uY3VycmVudE9wZXJhdGlvbnMiLCJ1cGRhdGVkIiwiY291bnRlciIsImtleSIsInZhbHVlIiwidXBkYXRlcyIsImN1cnJlbnQiLCJuZXdWYWx1ZSIsInNob3J0VFRMIiwibG9uZ1RUTCIsImRlZmF1bHRUVEwiLCJsYXJnZURhdGEiLCJyZXBlYXQiXSwibWFwcGluZ3MiOiI7QUFrQkEsZUFBZTtBQUNmQSxLQUFLQyxJQUFJLENBQUMsV0FBVztJQUNuQixPQUFPO1FBQ0xDLE9BQU9GLEtBQUtHLEVBQUUsR0FBR0Msa0JB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