{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/app/api/purchases/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport prisma from '@/lib/prisma';\n\n\nimport { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';\nimport { getToken } from 'next-auth/jwt';\nimport { cacheService } from '@/lib/cache';\n\n// GET /api/purchases - Get all purchase invoices\nexport async function GET(request: NextRequest) {\n    try {\n        const { searchParams } = new URL(request.url);\n        const search = searchParams.get('search') || '';\n        const status = searchParams.get('status');\n        const supplierId = searchParams.get('supplierId');\n        const startDate = searchParams.get('startDate');\n        const endDate = searchParams.get('endDate');\n        const page = parseInt(searchParams.get('page') || '1');\n        const limit = parseInt(searchParams.get('limit') || '10');\n        const skip = (page - 1) * limit;\n\n        // Build the where clause for Prisma\n        const whereClause: any = {};\n\n        if (search) {\n            // Search across multiple fields: invoiceNumber, supplier name, item product name\n            whereClause.OR = [\n                {\n                    invoiceNumber: {\n                        contains: search,\n                        mode: 'insensitive'\n                    }\n                },\n                {\n                    supplier: {\n                        name: {\n                            contains: search,\n                            mode: 'insensitive'\n                        }\n                    }\n                },\n                // Searching by item product name requires a more complex query if we want to keep it efficient.\n                // For simplicity now, we'll stick to invoiceNumber and supplier name for the main search.\n                // If product name search is critical, it might need a separate handling or different data structure.\n            ];\n        }\n\n        if (status) {\n            whereClause.status = status;\n        }\n\n        if (supplierId) {\n            whereClause.supplierId = parseInt(supplierId);\n        }\n\n        if (startDate && endDate) {\n            whereClause.date = { // Assuming filter by invoice date, not createdAt\n                gte: new Date(startDate),\n                lte: new Date(endDate)\n            };\n        } else if (startDate) {\n            whereClause.date = {\n                gte: new Date(startDate)\n            };\n        } else if (endDate) {\n            whereClause.date = {\n                lte: new Date(endDate)\n            };\n        }\n\n        const [purchases, totalCount] = await prisma.$transaction([\n            prisma.purchaseInvoice.findMany({\n                where: whereClause,\n                include: {\n                    supplier: {\n                        select: {\n                            id: true,\n                            name: true,\n                            email: true,\n                            phone: true\n                        }\n                    },\n                    items: {\n                        include: {\n                            product: {\n                                select: {\n                                    id: true,\n                                    name: true,\n                                    sku: true\n                                }\n                            }\n                        }\n                    }\n                },\n                orderBy: {\n                    date: 'desc' // More common to sort by invoice date\n                },\n                skip: skip,\n                take: limit\n            }),\n            prisma.purchaseInvoice.count({ where: whereClause })\n        ]);\n\n        return NextResponse.json({\n            data: purchases,\n            pagination: {\n                total: totalCount,\n                page,\n                limit,\n                totalPages: Math.ceil(totalCount / limit)\n            }\n        });\n    } catch (error) {\n        console.error('Error fetching purchase invoices:', error);\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return NextResponse.json(\n            { error: { message: 'Failed to fetch purchase invoices', details: message } },\n            { status: 500 }\n        );\n    }\n}\n\n// POST /api/purchases - Create a new purchase invoice\nexport async function POST(request: NextRequest) {\n    try {\n        const body = await request.json();\n\n        // Generate a more robust invoice number\n        if (!body.invoiceNumber) {\n            const today = new Date();\n            const year = today.getFullYear().toString().slice(-2); // Last 2 digits of year\n            const month = (today.getMonth() + 1).toString().padStart(2, '0'); // Month (01-12)\n            const day = today.getDate().toString().padStart(2, '0'); // Day (01-31)\n            // Get count of invoices for today to make it sequential, or use a random part\n            // For simplicity, using a timestamp fragment for uniqueness here.\n            // In a real app, a dedicated sequence generator per day/month is better.\n            const randomPart = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\n            body.invoiceNumber = `PI-${year}${month}${day}-${randomPart}`;\n        }\n\n        // Extract items and distributions from the request\n        const { items, distributions, totalAmount, paidAmount, date, dueDate, notes: _notes, ..._rest } = body;\n\n        // Only include fields that exist in the Prisma schema\n        const invoiceData: any = {\n            invoiceNumber: body.invoiceNumber,\n            supplierId: parseInt(body.supplierId as unknown as string) || 0,\n            total: totalAmount || 0,\n            status: body.status || 'unpaid',\n            date: date ? new Date(date) : null,\n            dueDate: dueDate ? new Date(dueDate) : null,\n            distributions: distributions\n        };\n\n        // Create the purchase invoice with items in a transaction\n        const purchase = await prisma.$transaction(\n            async (tx) => {\n                // Create the purchase invoice\n                const createdInvoice = await tx.purchaseInvoice.create({\n                    data: invoiceData\n                });\n\n                const inventoryUpdates: Array<{ productId: number, shopId: number, newQuantity: number }> = [];\n\n                // Create the purchase invoice items and update inventory\n                if (items && Array.isArray(items)) {\n                    for (let i = 0; i < items.length; i++) {\n                        const item = items[i];\n                        const itemDistribution = distributions && distributions[i] ? distributions[i] : null;\n\n                        // Create purchase invoice item\n                        await tx.purchaseInvoiceItem.create({\n                            data: {\n                                purchaseInvoiceId: createdInvoice.id,\n                                productId: parseInt(item.productId),\n                                quantity: item.quantity,\n                                price: item.price || 0,\n                                total: (item.quantity * item.price) || 0\n                            }\n                        });\n\n                        // Get current product data\n                        const product = await tx.product.findUnique({\n                            where: { id: parseInt(item.productId) },\n                            select: { id: true, weightedAverageCost: true }\n                        });\n\n                        // Get current inventory quantity for this product across all shops\n                        const inventoryItems = await tx.inventoryItem.findMany({\n                            where: { productId: parseInt(item.productId) }\n                        });\n\n                        const currentTotalQuantity = inventoryItems.reduce((sum, inv) => sum + inv.quantity, 0);\n                        const newQuantity = item.quantity;\n                        const currentCost = product?.weightedAverageCost || 0;\n                        const newCost = item.price;\n\n                        // Calculate new weighted average cost using proper formula\n                        // WAC = (Current Total Value + New Purchase Value) / (Current Quantity + New Quantity)\n                        let newWeightedAverageCost = newCost; // Default to new cost if there's no existing inventory\n\n                        if (currentTotalQuantity > 0 && currentCost > 0) {\n                            const currentTotalValue = currentTotalQuantity * currentCost;\n                            const newPurchaseValue = newQuantity * newCost;\n                            const totalValue = currentTotalValue + newPurchaseValue;\n                            const totalQuantity = currentTotalQuantity + newQuantity;\n\n                            newWeightedAverageCost = totalValue / totalQuantity;\n                        }\n\n                        // Ensure WAC is valid and positive\n                        if (newWeightedAverageCost <= 0 || isNaN(newWeightedAverageCost)) {\n                            newWeightedAverageCost = newCost;\n                        }\n\n                        // Update product with new weighted average cost\n                        await tx.product.update({\n                            where: { id: parseInt(item.productId) },\n                            data: { weightedAverageCost: newWeightedAverageCost }\n                        });\n\n                        // Handle distribution across shops\n                        if (itemDistribution && Object.keys(itemDistribution).length > 0) {\n                            // Process only the current item's distribution object\n                            const shopQuantities: Record<string, number> = {};\n                            \n                            // Process only the distribution object for this specific item (at index i)\n                            if (itemDistribution && typeof itemDistribution === 'object') {\n                                for (const [shopIdStr, quantity] of Object.entries(itemDistribution)) {\n                                    const qty = Number(quantity);\n                                    if (qty > 0 && !isNaN(qty)) {\n                                        shopQuantities[shopIdStr] = qty; // Use the exact quantity, not accumulated\n                                    }\n                                }\n                            }\n                            \n                            // Distribute to specific shops as aggregated\n                            for (const [shopIdStr, totalQty] of Object.entries(shopQuantities)) {\n                                const shopId = shopIdStr; // Keep shopId as string\n                                const qty = totalQty;\n\n                                if (qty <= 0) continue;\n\n                                const existingInventory = await tx.inventoryItem.findFirst({\n                                    where: {\n                                        productId: parseInt(item.productId),\n                                        shopId: shopId\n                                    }\n                                });\n\n                                let finalQuantity = 0;\n                                if (existingInventory) {\n                                    const currentQuantity = existingInventory.quantity;\n                                    const currentCost = existingInventory.shopSpecificCost || 0;\n                                    const newTotalQuantity = currentQuantity + qty;\n                                    let newShopSpecificCost = newCost; // item.price\n                                    if (currentQuantity > 0 && currentCost > 0) { // ensure currentCost is also positive\n                                        const currentTotalValue = currentQuantity * currentCost;\n                                        const newTotalValue = qty * newCost;\n                                        newShopSpecificCost = (currentTotalValue + newTotalValue) / newTotalQuantity;\n                                    } else if (currentQuantity === 0 && newTotalQuantity > 0) { // First stock for this item in this shop\n                                        newShopSpecificCost = newCost;\n                                    }\n\n\n                                    finalQuantity = newTotalQuantity;\n                                    await tx.inventoryItem.update({\n                                        where: { id: existingInventory.id },\n                                        data: {\n                                            quantity: finalQuantity,\n                                            shopSpecificCost: newShopSpecificCost >= 0 ? newShopSpecificCost : 0\n                                        }\n                                    });\n                                } else {\n                                    finalQuantity = qty;\n                                    await tx.inventoryItem.create({\n                                        data: {\n                                            productId: parseInt(item.productId),\n                                            shopId: shopId,\n                                            quantity: finalQuantity,\n                                            shopSpecificCost: newCost >= 0 ? newCost : 0\n                                        }\n                                    });\n                                }\n                                inventoryUpdates.push({ productId: parseInt(item.productId), shopId: parseInt(shopId), newQuantity: finalQuantity });\n                            }\n                        } else {\n                            // No explicit distribution: attempt to infer shop\n                            console.warn(`No distribution for product ${item.productId} in purchase. Attempting to infer shop.`);\n                            const existingInventoriesForProduct = await tx.inventoryItem.findMany({\n                                where: { productId: parseInt(item.productId) }\n                            });\n\n                            let inferredShopId: string | null = null;\n                            if (existingInventoriesForProduct.length === 1) {\n                                inferredShopId = existingInventoriesForProduct[0].shopId;\n                                console.log(`Product ${item.productId} found in single shop ${inferredShopId}. Will update there.`);\n                            } else if (existingInventoriesForProduct.length === 0) {\n                                console.error(`Product ${item.productId} is new to inventory and no shop distribution provided. Cannot automatically assign to a shop. Inventory not updated for this item.`);\n                            } else { // More than 1 shop\n                                console.error(`Product ${item.productId} exists in multiple shops and no specific distribution provided. Ambiguous. Inventory not updated for this item.`);\n                            }\n\n                            if (inferredShopId) {\n                                const qty = item.quantity;\n                                if (qty > 0) {\n                                    const inventoryInInferredShop = await tx.inventoryItem.findFirst({\n                                        where: {\n                                            productId: parseInt(item.productId),\n                                            shopId: inferredShopId\n                                        }\n                                    });\n\n                                    let finalQuantity = 0;\n                                    if (inventoryInInferredShop) {\n                                        const currentQuantity = inventoryInInferredShop.quantity;\n                                        const currentShopCost = inventoryInInferredShop.shopSpecificCost || 0;\n                                        const newTotalQuantity = currentQuantity + qty;\n                                        let newShopSpecificCost = newCost; // item.price\n\n                                        if (currentQuantity > 0 && currentShopCost > 0) {\n                                            const currentTotalValue = currentQuantity * currentShopCost;\n                                            const newTotalValue = qty * newCost;\n                                            newShopSpecificCost = (currentTotalValue + newTotalValue) / newTotalQuantity;\n                                        } else if (currentQuantity === 0 && newTotalQuantity > 0) {\n                                            newShopSpecificCost = newCost;\n                                        }\n\n                                        finalQuantity = newTotalQuantity;\n                                        await tx.inventoryItem.update({\n                                            where: { id: inventoryInInferredShop.id },\n                                            data: {\n                                                quantity: finalQuantity,\n                                                shopSpecificCost: newShopSpecificCost >= 0 ? newShopSpecificCost : 0\n                                            }\n                                        });\n                                    } else {\n                                        // This case should ideally not be hit if existingInventoriesForProduct.length === 1\n                                        // because it means we found it in that list. But for safety:\n                                        finalQuantity = qty;\n                                        await tx.inventoryItem.create({\n                                            data: {\n                                                productId: parseInt(item.productId),\n                                                shopId: inferredShopId,\n                                                quantity: finalQuantity,\n                                                shopSpecificCost: newCost >= 0 ? newCost : 0\n                                            }\n                                        });\n                                    }\n                                    inventoryUpdates.push({ productId: parseInt(item.productId), shopId: parseInt(inferredShopId), newQuantity: finalQuantity });\n                                } else {\n                                    console.warn(`Quantity for product ${item.productId} in inferred shop ${inferredShopId} is zero or negative. No inventory update.`);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // If there's a paidAmount, create a payment record\n                if (body.paidAmount && body.paidAmount > 0) {\n                    await tx.payment.create({\n                        data: {\n                            amount: parseFloat(body.paidAmount as unknown as string) || 0,\n                            paymentMethod: body.paymentMethod || 'cash', // Default or from body\n                            invoice: { connect: { id: newInvoice.id } }\n                        }\n                    });\n                }\n\n                // Fetch the complete invoice with items\n                const fullInvoice = await tx.purchaseInvoice.findUnique({\n                    where: { id: createdInvoice.id },\n                    include: {\n                        supplier: true,\n                        items: { include: { product: true } }\n                    }\n                });\n\n                return { invoice: fullInvoice, inventoryUpdates };\n            },\n            { timeout: 20000 } // 20 seconds timeout\n        );\n\n        // Real-time updates now handled by polling system\n\n        // After successful transaction, invalidate relevant caches\n        try {\n            await cacheService.invalidateInventory(); // Handles 'inventory:summary:*' and 'products:*'\n            await cacheService.del('dashboard:inventory');\n            await cacheService.del('dashboard:inventory-value');\n            await cacheService.del('dashboard:shops');\n            await cacheService.del('dashboard:all');\n            await cacheService.del('dashboard:summary'); // As per DASHBOARD_PERFORMANCE_OPTIMIZATIONS.md\n            // Invalidate purchases-specific caches\n            await cacheService.invalidatePattern('purchases-optimized*');\n            await cacheService.invalidatePattern('purchase-stats*');\n            console.log('Relevant caches invalidated after purchase creation.');\n        } catch (cacheError) {\n            console.error('Error invalidating caches after purchase creation:', cacheError);\n            // Do not let cache invalidation error fail the main operation\n        }\n\n        return NextResponse.json(\n            { success: true, message: 'Purchase invoice created successfully', data: purchase.invoice },\n            { status: 201 }\n        );\n    } catch (error) {\n        console.error('Error creating purchase invoice:', error);\n        const message = error instanceof Error ? error.message : 'An unknown error occurred';\n        return NextResponse.json(\n            { error: { message: 'Failed to create purchase invoice', details: message } },\n            { status: 500 }\n        );\n    }\n}"],"names":["GET","POST","request","searchParams","URL","url","search","get","status","supplierId","startDate","endDate","page","parseInt","limit","skip","whereClause","OR","invoiceNumber","contains","mode","supplier","name","date","gte","Date","lte","purchases","totalCount","prisma","$transaction","purchaseInvoice","findMany","where","include","select","id","email","phone","items","product","sku","orderBy","take","count","NextResponse","json","data","pagination","total","totalPages","Math","ceil","error","console","message","Error","details","body","today","year","getFullYear","toString","slice","month","getMonth","padStart","day","getDate","randomPart","floor","random","distributions","totalAmount","paidAmount","dueDate","notes","_notes","_rest","invoiceData","purchase","tx","createdInvoice","create","inventoryUpdates","Array","isArray","i","length","item","itemDistribution","purchaseInvoiceItem","purchaseInvoiceId","productId","quantity","price","findUnique","weightedAverageCost","inventoryItems","inventoryItem","currentTotalQuantity","reduce","sum","inv","newQuantity","currentCost","newCost","newWeightedAverageCost","currentTotalValue","newPurchaseValue","totalValue","totalQuantity","isNaN","update","Object","keys","shopQuantities","shopIdStr","entries","qty","Number","totalQty","shopId","existingInventory","findFirst","finalQuantity","currentQuantity","shopSpecificCost","newTotalQuantity","newShopSpecificCost","newTotalValue","push","warn","existingInventoriesForProduct","inferredShopId","log","inventoryInInferredShop","currentShopCost","payment","amount","parseFloat","paymentMethod","invoice","connect","newInvoice","fullInvoice","timeout","cacheService","invalidateInventory","del","invalidatePattern","cacheError","success"],"mappings":";;;;;;;;;;;IASsBA,GAAG;eAAHA;;IAkHAC,IAAI;eAAJA;;;wBA3HoB;+DACvB;uBAKU;;;;;;AAGtB,eAAeD,IAAIE,OAAoB;IAC1C,IAAI;QACA,MAAM,EAAEC,YAAY,EAAE,GAAG,IAAIC,IAAIF,QAAQG,GAAG;QAC5C,MAAMC,SAASH,aAAaI,GAAG,CAAC,aAAa;QAC7C,MAAMC,SAASL,aAAaI,GAAG,CAAC;QAChC,MAAME,aAAaN,aAAaI,GAAG,CAAC;QACpC,MAAMG,YAAYP,aAAaI,GAAG,CAAC;QACnC,MAAMI,UAAUR,aAAaI,GAAG,CAAC;QACjC,MAAMK,OAAOC,SAASV,aAAaI,GAAG,CAAC,WAAW;QAClD,MAAMO,QAAQD,SAASV,aAAaI,GAAG,CAAC,YAAY;QACpD,MAAMQ,OAAO,AAACH,CAAAA,OAAO,CAAA,IAAKE;QAE1B,oCAAoC;QACpC,MAAME,cAAmB,CAAC;QAE1B,IAAIV,QAAQ;YACR,iFAAiF;YACjFU,YAAYC,EAAE,GAAG;gBACb;oBACIC,eAAe;wBACXC,UAAUb;wBACVc,MAAM;oBACV;gBACJ;gBACA;oBACIC,UAAU;wBACNC,MAAM;4BACFH,UAAUb;4BACVc,MAAM;wBACV;oBACJ;gBACJ;aAIH;QACL;QAEA,IAAIZ,QAAQ;YACRQ,YAAYR,MAAM,GAAGA;QACzB;QAEA,IAAIC,YAAY;YACZO,YAAYP,UAAU,GAAGI,SAASJ;QACtC;QAEA,IAAIC,aAAaC,SAAS;YACtBK,YAAYO,IAAI,GAAG;gBACfC,KAAK,IAAIC,KAAKf;gBACdgB,KAAK,IAAID,KAAKd;YAClB;QACJ,OAAO,IAAID,WAAW;YAClBM,YAAYO,IAAI,GAAG;gBACfC,KAAK,IAAIC,KAAKf;YAClB;QACJ,OAAO,IAAIC,SAAS;YAChBK,YAAYO,IAAI,GAAG;gBACfG,KAAK,IAAID,KAAKd;YAClB;QACJ;QAEA,MAAM,CAACgB,WAAWC,WAAW,GAAG,MAAMC,eAAM,CAACC,YAAY,CAAC;YACtDD,eAAM,CAACE,eAAe,CAACC,QAAQ,CAAC;gBAC5BC,OAAOjB;gBACPkB,SAAS;oBACLb,UAAU;wBACNc,QAAQ;4BACJC,IAAI;4BACJd,MAAM;4BACNe,OAAO;4BACPC,OAAO;wBACX;oBACJ;oBACAC,OAAO;wBACHL,SAAS;4BACLM,SAAS;gCACLL,QAAQ;oCACJC,IAAI;oCACJd,MAAM;oCACNmB,KAAK;gCACT;4BACJ;wBACJ;oBACJ;gBACJ;gBACAC,SAAS;oBACLnB,MAAM,OAAO,sCAAsC;gBACvD;gBACAR,MAAMA;gBACN4B,MAAM7B;YACV;YACAe,eAAM,CAACE,eAAe,CAACa,KAAK,CAAC;gBAAEX,OAAOjB;YAAY;SACrD;QAED,OAAO6B,oBAAY,CAACC,IAAI,CAAC;YACrBC,MAAMpB;YACNqB,YAAY;gBACRC,OAAOrB;gBACPhB;gBACAE;gBACAoC,YAAYC,KAAKC,IAAI,CAACxB,aAAad;YACvC;QACJ;IACJ,EAAE,OAAOuC,OAAO;QACZC,QAAQD,KAAK,CAAC,qCAAqCA;QACnD,MAAME,UAAUF,iBAAiBG,QAAQH,MAAME,OAAO,GAAG;QACzD,OAAOV,oBAAY,CAACC,IAAI,CACpB;YAAEO,OAAO;gBAAEE,SAAS;gBAAqCE,SAASF;YAAQ;QAAE,GAC5E;YAAE/C,QAAQ;QAAI;IAEtB;AACJ;AAGO,eAAeP,KAAKC,OAAoB;IAC3C,IAAI;QACA,MAAMwD,OAAO,MAAMxD,QAAQ4C,IAAI;QAE/B,wCAAwC;QACxC,IAAI,CAACY,KAAKxC,aAAa,EAAE;YACrB,MAAMyC,QAAQ,IAAIlC;YAClB,MAAMmC,OAAOD,MAAME,WAAW,GAAGC,QAAQ,GAAGC,KAAK,CAAC,CAAC,IAAI,wBAAwB;YAC/E,MAAMC,QAAQ,AAACL,CAAAA,MAAMM,QAAQ,KAAK,CAAA,EAAGH,QAAQ,GAAGI,QAAQ,CAAC,GAAG,MAAM,gBAAgB;YAClF,MAAMC,MAAMR,MAAMS,OAAO,GAAGN,QAAQ,GAAGI,QAAQ,CAAC,GAAG,MAAM,cAAc;YACvE,8EAA8E;YAC9E,kEAAkE;YAClE,yEAAyE;YACzE,MAAMG,aAAalB,KAAKmB,KAAK,CAACnB,KAAKoB,MAAM,KAAK,MAAMT,QAAQ,GAAGI,QAAQ,CAAC,GAAG;YAC3ER,KAAKxC,aAAa,GAAG,CAAC,GAAG,EAAE0C,KAAK,EAAEI,MAAM,EAAEG,IAAI,CAAC,EAAEE,WAAW,CAAC;QACjE;QAEA,mDAAmD;QACnD,MAAM,EAAE9B,KAAK,EAAEiC,aAAa,EAAEC,WAAW,EAAEC,UAAU,EAAEnD,IAAI,EAAEoD,OAAO,EAAEC,OAAOC,MAAM,EAAE,GAAGC,OAAO,GAAGpB;QAElG,sDAAsD;QACtD,MAAMqB,cAAmB;YACrB7D,eAAewC,KAAKxC,aAAa;YACjCT,YAAYI,SAAS6C,KAAKjD,UAAU,KAA0B;YAC9DwC,OAAOwB,eAAe;YACtBjE,QAAQkD,KAAKlD,MAAM,IAAI;YACvBe,MAAMA,OAAO,IAAIE,KAAKF,QAAQ;YAC9BoD,SAASA,UAAU,IAAIlD,KAAKkD,WAAW;YACvCH,eAAeA;QACnB;QAEA,0DAA0D;QAC1D,MAAMQ,WAAW,MAAMnD,eAAM,CAACC,YAAY,CACtC,OAAOmD;YACH,8BAA8B;YAC9B,MAAMC,iBAAiB,MAAMD,GAAGlD,eAAe,CAACoD,MAAM,CAAC;gBACnDpC,MAAMgC;YACV;YAEA,MAAMK,mBAAsF,EAAE;YAE9F,yDAAyD;YACzD,IAAI7C,SAAS8C,MAAMC,OAAO,CAAC/C,QAAQ;gBAC/B,IAAK,IAAIgD,IAAI,GAAGA,IAAIhD,MAAMiD,MAAM,EAAED,IAAK;oBACnC,MAAME,OAAOlD,KAAK,CAACgD,EAAE;oBACrB,MAAMG,mBAAmBlB,iBAAiBA,aAAa,CAACe,EAAE,GAAGf,aAAa,CAACe,EAAE,GAAG;oBAEhF,+BAA+B;oBAC/B,MAAMN,GAAGU,mBAAmB,CAACR,MAAM,CAAC;wBAChCpC,MAAM;4BACF6C,mBAAmBV,eAAe9C,EAAE;4BACpCyD,WAAWhF,SAAS4E,KAAKI,SAAS;4BAClCC,UAAUL,KAAKK,QAAQ;4BACvBC,OAAON,KAAKM,KAAK,IAAI;4BACrB9C,OAAO,AAACwC,KAAKK,QAAQ,GAAGL,KAAKM,KAAK,IAAK;wBAC3C;oBACJ;oBAEA,2BAA2B;oBAC3B,MAAMvD,UAAU,MAAMyC,GAAGzC,OAAO,CAACwD,UAAU,CAAC;wBACxC/D,OAAO;4BAAEG,IAAIvB,SAAS4E,KAAKI,SAAS;wBAAE;wBACtC1D,QAAQ;4BAAEC,IAAI;4BAAM6D,qBAAqB;wBAAK;oBAClD;oBAEA,mEAAmE;oBACnE,MAAMC,iBAAiB,MAAMjB,GAAGkB,aAAa,CAACnE,QAAQ,CAAC;wBACnDC,OAAO;4BAAE4D,WAAWhF,SAAS4E,KAAKI,SAAS;wBAAE;oBACjD;oBAEA,MAAMO,uBAAuBF,eAAeG,MAAM,CAAC,CAACC,KAAKC,MAAQD,MAAMC,IAAIT,QAAQ,EAAE;oBACrF,MAAMU,cAAcf,KAAKK,QAAQ;oBACjC,MAAMW,cAAcjE,SAASyD,uBAAuB;oBACpD,MAAMS,UAAUjB,KAAKM,KAAK;oBAE1B,2DAA2D;oBAC3D,uFAAuF;oBACvF,IAAIY,yBAAyBD,SAAS,uDAAuD;oBAE7F,IAAIN,uBAAuB,KAAKK,cAAc,GAAG;wBAC7C,MAAMG,oBAAoBR,uBAAuBK;wBACjD,MAAMI,mBAAmBL,cAAcE;wBACvC,MAAMI,aAAaF,oBAAoBC;wBACvC,MAAME,gBAAgBX,uBAAuBI;wBAE7CG,yBAAyBG,aAAaC;oBAC1C;oBAEA,mCAAmC;oBACnC,IAAIJ,0BAA0B,KAAKK,MAAML,yBAAyB;wBAC9DA,yBAAyBD;oBAC7B;oBAEA,gDAAgD;oBAChD,MAAMzB,GAAGzC,OAAO,CAACyE,MAAM,CAAC;wBACpBhF,OAAO;4BAAEG,IAAIvB,SAAS4E,KAAKI,SAAS;wBAAE;wBACtC9C,MAAM;4BAAEkD,qBAAqBU;wBAAuB;oBACxD;oBAEA,mCAAmC;oBACnC,IAAIjB,oBAAoBwB,OAAOC,IAAI,CAACzB,kBAAkBF,MAAM,GAAG,GAAG;wBAC9D,sDAAsD;wBACtD,MAAM4B,iBAAyC,CAAC;wBAEhD,2EAA2E;wBAC3E,IAAI1B,oBAAoB,OAAOA,qBAAqB,UAAU;4BAC1D,KAAK,MAAM,CAAC2B,WAAWvB,SAAS,IAAIoB,OAAOI,OAAO,CAAC5B,kBAAmB;gCAClE,MAAM6B,MAAMC,OAAO1B;gCACnB,IAAIyB,MAAM,KAAK,CAACP,MAAMO,MAAM;oCACxBH,cAAc,CAACC,UAAU,GAAGE,KAAK,0CAA0C;gCAC/E;4BACJ;wBACJ;wBAEA,6CAA6C;wBAC7C,KAAK,MAAM,CAACF,WAAWI,SAAS,IAAIP,OAAOI,OAAO,CAACF,gBAAiB;4BAChE,MAAMM,SAASL,WAAW,wBAAwB;4BAClD,MAAME,MAAME;4BAEZ,IAAIF,OAAO,GAAG;4BAEd,MAAMI,oBAAoB,MAAM1C,GAAGkB,aAAa,CAACyB,SAAS,CAAC;gCACvD3F,OAAO;oCACH4D,WAAWhF,SAAS4E,KAAKI,SAAS;oCAClC6B,QAAQA;gCACZ;4BACJ;4BAEA,IAAIG,gBAAgB;4BACpB,IAAIF,mBAAmB;gCACnB,MAAMG,kBAAkBH,kBAAkB7B,QAAQ;gCAClD,MAAMW,cAAckB,kBAAkBI,gBAAgB,IAAI;gCAC1D,MAAMC,mBAAmBF,kBAAkBP;gCAC3C,IAAIU,sBAAsBvB,SAAS,aAAa;gCAChD,IAAIoB,kBAAkB,KAAKrB,cAAc,GAAG;oCACxC,MAAMG,oBAAoBkB,kBAAkBrB;oCAC5C,MAAMyB,gBAAgBX,MAAMb;oCAC5BuB,sBAAsB,AAACrB,CAAAA,oBAAoBsB,aAAY,IAAKF;gCAChE,OAAO,IAAIF,oBAAoB,KAAKE,mBAAmB,GAAG;oCACtDC,sBAAsBvB;gCAC1B;gCAGAmB,gBAAgBG;gCAChB,MAAM/C,GAAGkB,aAAa,CAACc,MAAM,CAAC;oCAC1BhF,OAAO;wCAAEG,IAAIuF,kBAAkBvF,EAAE;oCAAC;oCAClCW,MAAM;wCACF+C,UAAU+B;wCACVE,kBAAkBE,uBAAuB,IAAIA,sBAAsB;oCACvE;gCACJ;4BACJ,OAAO;gCACHJ,gBAAgBN;gCAChB,MAAMtC,GAAGkB,aAAa,CAAChB,MAAM,CAAC;oCAC1BpC,MAAM;wCACF8C,WAAWhF,SAAS4E,KAAKI,SAAS;wCAClC6B,QAAQA;wCACR5B,UAAU+B;wCACVE,kBAAkBrB,WAAW,IAAIA,UAAU;oCAC/C;gCACJ;4BACJ;4BACAtB,iBAAiB+C,IAAI,CAAC;gCAAEtC,WAAWhF,SAAS4E,KAAKI,SAAS;gCAAG6B,QAAQ7G,SAAS6G;gCAASlB,aAAaqB;4BAAc;wBACtH;oBACJ,OAAO;wBACH,kDAAkD;wBAClDvE,QAAQ8E,IAAI,CAAC,CAAC,4BAA4B,EAAE3C,KAAKI,SAAS,CAAC,uCAAuC,CAAC;wBACnG,MAAMwC,gCAAgC,MAAMpD,GAAGkB,aAAa,CAACnE,QAAQ,CAAC;4BAClEC,OAAO;gCAAE4D,WAAWhF,SAAS4E,KAAKI,SAAS;4BAAE;wBACjD;wBAEA,IAAIyC,iBAAgC;wBACpC,IAAID,8BAA8B7C,MAAM,KAAK,GAAG;4BAC5C8C,iBAAiBD,6BAA6B,CAAC,EAAE,CAACX,MAAM;4BACxDpE,QAAQiF,GAAG,CAAC,CAAC,QAAQ,EAAE9C,KAAKI,SAAS,CAAC,sBAAsB,EAAEyC,eAAe,oBAAoB,CAAC;wBACtG,OAAO,IAAID,8BAA8B7C,MAAM,KAAK,GAAG;4BACnDlC,QAAQD,KAAK,CAAC,CAAC,QAAQ,EAAEoC,KAAKI,SAAS,CAAC,mIAAmI,CAAC;wBAChL,OAAO;4BACHvC,QAAQD,KAAK,CAAC,CAAC,QAAQ,EAAEoC,KAAKI,SAAS,CAAC,gHAAgH,CAAC;wBAC7J;wBAEA,IAAIyC,gBAAgB;4BAChB,MAAMf,MAAM9B,KAAKK,QAAQ;4BACzB,IAAIyB,MAAM,GAAG;gCACT,MAAMiB,0BAA0B,MAAMvD,GAAGkB,aAAa,CAACyB,SAAS,CAAC;oCAC7D3F,OAAO;wCACH4D,WAAWhF,SAAS4E,KAAKI,SAAS;wCAClC6B,QAAQY;oCACZ;gCACJ;gCAEA,IAAIT,gBAAgB;gCACpB,IAAIW,yBAAyB;oCACzB,MAAMV,kBAAkBU,wBAAwB1C,QAAQ;oCACxD,MAAM2C,kBAAkBD,wBAAwBT,gBAAgB,IAAI;oCACpE,MAAMC,mBAAmBF,kBAAkBP;oCAC3C,IAAIU,sBAAsBvB,SAAS,aAAa;oCAEhD,IAAIoB,kBAAkB,KAAKW,kBAAkB,GAAG;wCAC5C,MAAM7B,oBAAoBkB,kBAAkBW;wCAC5C,MAAMP,gBAAgBX,MAAMb;wCAC5BuB,sBAAsB,AAACrB,CAAAA,oBAAoBsB,aAAY,IAAKF;oCAChE,OAAO,IAAIF,oBAAoB,KAAKE,mBAAmB,GAAG;wCACtDC,sBAAsBvB;oCAC1B;oCAEAmB,gBAAgBG;oCAChB,MAAM/C,GAAGkB,aAAa,CAACc,MAAM,CAAC;wCAC1BhF,OAAO;4CAAEG,IAAIoG,wBAAwBpG,EAAE;wCAAC;wCACxCW,MAAM;4CACF+C,UAAU+B;4CACVE,kBAAkBE,uBAAuB,IAAIA,sBAAsB;wCACvE;oCACJ;gCACJ,OAAO;oCACH,oFAAoF;oCACpF,6DAA6D;oCAC7DJ,gBAAgBN;oCAChB,MAAMtC,GAAGkB,aAAa,CAAChB,MAAM,CAAC;wCAC1BpC,MAAM;4CACF8C,WAAWhF,SAAS4E,KAAKI,SAAS;4CAClC6B,QAAQY;4CACRxC,UAAU+B;4CACVE,kBAAkBrB,WAAW,IAAIA,UAAU;wCAC/C;oCACJ;gCACJ;gCACAtB,iBAAiB+C,IAAI,CAAC;oCAAEtC,WAAWhF,SAAS4E,KAAKI,SAAS;oCAAG6B,QAAQ7G,SAASyH;oCAAiB9B,aAAaqB;gCAAc;4BAC9H,OAAO;gCACHvE,QAAQ8E,IAAI,CAAC,CAAC,qBAAqB,EAAE3C,KAAKI,SAAS,CAAC,kBAAkB,EAAEyC,eAAe,0CAA0C,CAAC;4BACtI;wBACJ;oBACJ;gBACJ;YACJ;YAEA,mDAAmD;YACnD,IAAI5E,KAAKgB,UAAU,IAAIhB,KAAKgB,UAAU,GAAG,GAAG;gBACxC,MAAMO,GAAGyD,OAAO,CAACvD,MAAM,CAAC;oBACpBpC,MAAM;wBACF4F,QAAQC,WAAWlF,KAAKgB,UAAU,KAA0B;wBAC5DmE,eAAenF,KAAKmF,aAAa,IAAI;wBACrCC,SAAS;4BAAEC,SAAS;gCAAE3G,IAAI4G,WAAW5G,EAAE;4BAAC;wBAAE;oBAC9C;gBACJ;YACJ;YAEA,wCAAwC;YACxC,MAAM6G,cAAc,MAAMhE,GAAGlD,eAAe,CAACiE,UAAU,CAAC;gBACpD/D,OAAO;oBAAEG,IAAI8C,eAAe9C,EAAE;gBAAC;gBAC/BF,SAAS;oBACLb,UAAU;oBACVkB,OAAO;wBAAEL,SAAS;4BAAEM,SAAS;wBAAK;oBAAE;gBACxC;YACJ;YAEA,OAAO;gBAAEsG,SAASG;gBAAa7D;YAAiB;QACpD,GACA;YAAE8D,SAAS;QAAM,EAAE,qBAAqB;;QAG5C,kDAAkD;QAElD,2DAA2D;QAC3D,IAAI;YACA,MAAMC,mBAAY,CAACC,mBAAmB,IAAI,iDAAiD;YAC3F,MAAMD,mBAAY,CAACE,GAAG,CAAC;YACvB,MAAMF,mBAAY,CAACE,GAAG,CAAC;YACvB,MAAMF,mBAAY,CAACE,GAAG,CAAC;YACvB,MAAMF,mBAAY,CAACE,GAAG,CAAC;YACvB,MAAMF,mBAAY,CAACE,GAAG,CAAC,sBAAsB,gDAAgD;YAC7F,uCAAuC;YACvC,MAAMF,mBAAY,CAACG,iBAAiB,CAAC;YACrC,MAAMH,mBAAY,CAACG,iBAAiB,CAAC;YACrChG,QAAQiF,GAAG,CAAC;QAChB,EAAE,OAAOgB,YAAY;YACjBjG,QAAQD,KAAK,CAAC,sDAAsDkG;QACpE,8DAA8D;QAClE;QAEA,OAAO1G,oBAAY,CAACC,IAAI,CACpB;YAAE0G,SAAS;YAAMjG,SAAS;YAAyCR,MAAMiC,SAAS8D,OAAO;QAAC,GAC1F;YAAEtI,QAAQ;QAAI;IAEtB,EAAE,OAAO6C,OAAO;QACZC,QAAQD,KAAK,CAAC,oCAAoCA;QAClD,MAAME,UAAUF,iBAAiBG,QAAQH,MAAME,OAAO,GAAG;QACzD,OAAOV,oBAAY,CAACC,IAAI,CACpB;YAAEO,OAAO;gBAAEE,SAAS;gBAAqCE,SAASF;YAAQ;QAAE,GAC5E;YAAE/C,QAAQ;QAAI;IAEtB;AACJ"}