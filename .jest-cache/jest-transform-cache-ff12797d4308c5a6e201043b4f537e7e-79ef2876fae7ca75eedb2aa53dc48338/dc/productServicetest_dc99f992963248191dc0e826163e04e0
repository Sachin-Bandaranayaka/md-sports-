cccf3e28c78c9f50dd726c8d1c6b19fa
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _productService = require("../../src/services/productService");
// Mock the Product model
const mockProduct = {
    findAll: _globals.jest.fn(),
    findOne: _globals.jest.fn(),
    findByPk: _globals.jest.fn(),
    create: _globals.jest.fn(),
    update: _globals.jest.fn()
};
// Mock the Product import
_globals.jest.mock("@/lib/models", ()=>({
        Product: mockProduct
    }));
(0, _globals.describe)("ProductService", ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.afterEach)(()=>{
        _globals.jest.resetAllMocks();
    });
    (0, _globals.describe)("getAllProducts", ()=>{
        (0, _globals.it)("should return all active products", async ()=>{
            const mockProducts = [
                {
                    id: 1,
                    name: "Product 1",
                    isActive: true
                },
                {
                    id: 2,
                    name: "Product 2",
                    isActive: true
                }
            ];
            mockProduct.findAll.mockResolvedValue(mockProducts);
            const result = await _productService.productService.getAllProducts();
            (0, _globals.expect)(result).toEqual(mockProducts);
            (0, _globals.expect)(mockProduct.findAll).toHaveBeenCalledWith({
                where: {
                    isActive: true
                }
            });
        });
        (0, _globals.it)("should handle database errors", async ()=>{
            const error = new Error("Database connection failed");
            mockProduct.findAll.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.getAllProducts()).rejects.toThrow("Database connection failed");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error fetching products:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should return empty array when no products found", async ()=>{
            mockProduct.findAll.mockResolvedValue([]);
            const result = await _productService.productService.getAllProducts();
            (0, _globals.expect)(result).toEqual([]);
            (0, _globals.expect)(mockProduct.findAll).toHaveBeenCalledWith({
                where: {
                    isActive: true
                }
            });
        });
    });
    (0, _globals.describe)("getProductById", ()=>{
        (0, _globals.it)("should return a product by ID", async ()=>{
            const mockProduct_data = {
                id: 1,
                name: "Test Product",
                isActive: true
            };
            mockProduct.findOne.mockResolvedValue(mockProduct_data);
            const result = await _productService.productService.getProductById(1);
            (0, _globals.expect)(result).toEqual(mockProduct_data);
            (0, _globals.expect)(mockProduct.findOne).toHaveBeenCalledWith({
                where: {
                    id: 1,
                    isActive: true
                }
            });
        });
        (0, _globals.it)("should return null when product not found", async ()=>{
            mockProduct.findOne.mockResolvedValue(null);
            const result = await _productService.productService.getProductById(999);
            (0, _globals.expect)(result).toBeNull();
            (0, _globals.expect)(mockProduct.findOne).toHaveBeenCalledWith({
                where: {
                    id: 999,
                    isActive: true
                }
            });
        });
        (0, _globals.it)("should handle database errors", async ()=>{
            const error = new Error("Database error");
            mockProduct.findOne.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.getProductById(1)).rejects.toThrow("Database error");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error fetching product with ID 1:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle invalid ID types", async ()=>{
            const error = new Error("Invalid ID");
            mockProduct.findOne.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.getProductById(NaN)).rejects.toThrow("Invalid ID");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error fetching product with ID NaN:", error);
            consoleSpy.mockRestore();
        });
    });
    (0, _globals.describe)("createProduct", ()=>{
        (0, _globals.it)("should create a new product successfully", async ()=>{
            const productData = {
                name: "New Product",
                price: 99.99,
                description: "A new product",
                isActive: true
            };
            const createdProduct = {
                id: 1,
                ...productData
            };
            mockProduct.create.mockResolvedValue(createdProduct);
            const result = await _productService.productService.createProduct(productData);
            (0, _globals.expect)(result).toEqual(createdProduct);
            (0, _globals.expect)(mockProduct.create).toHaveBeenCalledWith(productData);
        });
        (0, _globals.it)("should handle validation errors", async ()=>{
            const productData = {
                name: ""
            }; // Invalid data
            const error = new Error("Validation failed");
            mockProduct.create.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.createProduct(productData)).rejects.toThrow("Validation failed");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error creating product:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle database constraint errors", async ()=>{
            const productData = {
                name: "Duplicate Product"
            };
            const error = new Error("Unique constraint violation");
            mockProduct.create.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.createProduct(productData)).rejects.toThrow("Unique constraint violation");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error creating product:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should create product with minimal required fields", async ()=>{
            const productData = {
                name: "Minimal Product"
            };
            const createdProduct = {
                id: 1,
                ...productData
            };
            mockProduct.create.mockResolvedValue(createdProduct);
            const result = await _productService.productService.createProduct(productData);
            (0, _globals.expect)(result).toEqual(createdProduct);
            (0, _globals.expect)(mockProduct.create).toHaveBeenCalledWith(productData);
        });
    });
    (0, _globals.describe)("updateProduct", ()=>{
        (0, _globals.it)("should update an existing product successfully", async ()=>{
            const productData = {
                name: "Updated Product",
                price: 149.99
            };
            const existingProduct = {
                id: 1,
                name: "Old Product",
                price: 99.99,
                update: _globals.jest.fn().mockResolvedValue({
                    id: 1,
                    ...productData
                })
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const result = await _productService.productService.updateProduct(1, productData);
            (0, _globals.expect)(result).toEqual({
                id: 1,
                ...productData
            });
            (0, _globals.expect)(mockProduct.findByPk).toHaveBeenCalledWith(1);
            (0, _globals.expect)(existingProduct.update).toHaveBeenCalledWith(productData);
        });
        (0, _globals.it)("should throw error when product not found", async ()=>{
            const productData = {
                name: "Updated Product"
            };
            mockProduct.findByPk.mockResolvedValue(null);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.updateProduct(999, productData)).rejects.toThrow("Product with ID 999 not found");
            (0, _globals.expect)(mockProduct.findByPk).toHaveBeenCalledWith(999);
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error updating product with ID 999:", _globals.expect.any(Error));
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle update validation errors", async ()=>{
            const productData = {
                price: -10
            }; // Invalid price
            const existingProduct = {
                id: 1,
                update: _globals.jest.fn().mockRejectedValue(new Error("Invalid price"))
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.updateProduct(1, productData)).rejects.toThrow("Invalid price");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error updating product with ID 1:", _globals.expect.any(Error));
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle database errors during update", async ()=>{
            const productData = {
                name: "Updated Product"
            };
            const error = new Error("Database connection lost");
            mockProduct.findByPk.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.updateProduct(1, productData)).rejects.toThrow("Database connection lost");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error updating product with ID 1:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should update only provided fields", async ()=>{
            const productData = {
                name: "Updated Name Only"
            };
            const existingProduct = {
                id: 1,
                name: "Old Name",
                price: 99.99,
                description: "Old Description",
                update: _globals.jest.fn().mockResolvedValue({
                    id: 1,
                    name: "Updated Name Only",
                    price: 99.99,
                    description: "Old Description"
                })
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const result = await _productService.productService.updateProduct(1, productData);
            (0, _globals.expect)(existingProduct.update).toHaveBeenCalledWith(productData);
            (0, _globals.expect)(result.name).toBe("Updated Name Only");
            (0, _globals.expect)(result.price).toBe(99.99); // Should remain unchanged
        });
    });
    (0, _globals.describe)("deleteProduct", ()=>{
        (0, _globals.it)("should soft delete a product successfully", async ()=>{
            const existingProduct = {
                id: 1,
                name: "Product to Delete",
                isActive: true,
                update: _globals.jest.fn().mockResolvedValue({
                    id: 1,
                    name: "Product to Delete",
                    isActive: false
                })
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const result = await _productService.productService.deleteProduct(1);
            (0, _globals.expect)(result).toEqual({
                id: 1,
                name: "Product to Delete",
                isActive: false
            });
            (0, _globals.expect)(mockProduct.findByPk).toHaveBeenCalledWith(1);
            (0, _globals.expect)(existingProduct.update).toHaveBeenCalledWith({
                isActive: false
            });
        });
        (0, _globals.it)("should throw error when product not found for deletion", async ()=>{
            mockProduct.findByPk.mockResolvedValue(null);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.deleteProduct(999)).rejects.toThrow("Product with ID 999 not found");
            (0, _globals.expect)(mockProduct.findByPk).toHaveBeenCalledWith(999);
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error deleting product with ID 999:", _globals.expect.any(Error));
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle database errors during deletion", async ()=>{
            const error = new Error("Database error during deletion");
            mockProduct.findByPk.mockRejectedValue(error);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.deleteProduct(1)).rejects.toThrow("Database error during deletion");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error deleting product with ID 1:", error);
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should handle update errors during soft delete", async ()=>{
            const existingProduct = {
                id: 1,
                update: _globals.jest.fn().mockRejectedValue(new Error("Update failed"))
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const consoleSpy = _globals.jest.spyOn(console, "error").mockImplementation();
            await (0, _globals.expect)(_productService.productService.deleteProduct(1)).rejects.toThrow("Update failed");
            (0, _globals.expect)(consoleSpy).toHaveBeenCalledWith("Error deleting product with ID 1:", _globals.expect.any(Error));
            consoleSpy.mockRestore();
        });
        (0, _globals.it)("should not affect already deleted products", async ()=>{
            // Reset the mock explicitly
            mockProduct.findByPk.mockReset();
            const existingProduct = {
                id: 1,
                name: "Already Deleted Product",
                isActive: false,
                update: _globals.jest.fn().mockResolvedValue({
                    id: 1,
                    name: "Already Deleted Product",
                    isActive: false
                })
            };
            mockProduct.findByPk.mockResolvedValue(existingProduct);
            const result = await _productService.productService.deleteProduct(1);
            (0, _globals.expect)(result.isActive).toBe(false);
            (0, _globals.expect)(existingProduct.update).toHaveBeenCalledWith({
                isActive: false
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9wcm9kdWN0U2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IHByb2R1Y3RTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9wcm9kdWN0U2VydmljZSc7XG5cbi8vIE1vY2sgdGhlIFByb2R1Y3QgbW9kZWxcbmNvbnN0IG1vY2tQcm9kdWN0ID0ge1xuICBmaW5kQWxsOiBqZXN0LmZuKCksXG4gIGZpbmRPbmU6IGplc3QuZm4oKSxcbiAgZmluZEJ5UGs6IGplc3QuZm4oKSxcbiAgY3JlYXRlOiBqZXN0LmZuKCksXG4gIHVwZGF0ZTogamVzdC5mbigpLFxufTtcblxuLy8gTW9jayB0aGUgUHJvZHVjdCBpbXBvcnRcbmplc3QubW9jaygnQC9saWIvbW9kZWxzJywgKCkgPT4gKHtcbiAgUHJvZHVjdDogbW9ja1Byb2R1Y3Rcbn0pKTtcblxuZGVzY3JpYmUoJ1Byb2R1Y3RTZXJ2aWNlJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnJlc2V0QWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEFsbFByb2R1Y3RzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGFsbCBhY3RpdmUgcHJvZHVjdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUHJvZHVjdHMgPSBbXG4gICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdQcm9kdWN0IDEnLCBpc0FjdGl2ZTogdHJ1ZSB9LFxuICAgICAgICB7IGlkOiAyLCBuYW1lOiAnUHJvZHVjdCAyJywgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgIF07XG5cbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRBbGwubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2R1Y3RzKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZ2V0QWxsUHJvZHVjdHMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUHJvZHVjdHMpO1xuICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRBbGwpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHsgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICBtb2NrUHJvZHVjdC5maW5kQWxsLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuZ2V0QWxsUHJvZHVjdHMoKSkucmVqZWN0cy50b1Rocm93KCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBmZXRjaGluZyBwcm9kdWN0czonLCBlcnJvcik7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGVtcHR5IGFycmF5IHdoZW4gbm8gcHJvZHVjdHMgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJvZHVjdC5maW5kQWxsLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZ2V0QWxsUHJvZHVjdHMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QobW9ja1Byb2R1Y3QuZmluZEFsbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZTogeyBpc0FjdGl2ZTogdHJ1ZSB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRQcm9kdWN0QnlJZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBhIHByb2R1Y3QgYnkgSUQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUHJvZHVjdF9kYXRhID0geyBpZDogMSwgbmFtZTogJ1Rlc3QgUHJvZHVjdCcsIGlzQWN0aXZlOiB0cnVlIH07XG4gICAgICBtb2NrUHJvZHVjdC5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9kdWN0X2RhdGEpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5nZXRQcm9kdWN0QnlJZCgxKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUHJvZHVjdF9kYXRhKTtcbiAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5maW5kT25lKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiAxLCBpc0FjdGl2ZTogdHJ1ZSB9LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIHdoZW4gcHJvZHVjdCBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJvZHVjdC5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9kdWN0U2VydmljZS5nZXRQcm9kdWN0QnlJZCg5OTkpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRPbmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IDk5OSwgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGVycm9yJyk7XG4gICAgICBtb2NrUHJvZHVjdC5maW5kT25lLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuZ2V0UHJvZHVjdEJ5SWQoMSkpLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgZXJyb3InKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdCB3aXRoIElEIDE6JywgZXJyb3IpO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIElEIHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgSUQnKTtcbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRPbmUubW9ja1JlamVjdGVkVmFsdWUoZXJyb3IpO1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS5nZXRQcm9kdWN0QnlJZChOYU4pKS5yZWplY3RzLnRvVGhyb3coJ0ludmFsaWQgSUQnKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgZmV0Y2hpbmcgcHJvZHVjdCB3aXRoIElEIE5hTjonLCBlcnJvcik7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZVByb2R1Y3QnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBuZXcgcHJvZHVjdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHtcbiAgICAgICAgbmFtZTogJ05ldyBQcm9kdWN0JyxcbiAgICAgICAgcHJpY2U6IDk5Ljk5LFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0EgbmV3IHByb2R1Y3QnLFxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBjb25zdCBjcmVhdGVkUHJvZHVjdCA9IHsgaWQ6IDEsIC4uLnByb2R1Y3REYXRhIH07XG5cbiAgICAgIG1vY2tQcm9kdWN0LmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShjcmVhdGVkUHJvZHVjdCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3QocHJvZHVjdERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGNyZWF0ZWRQcm9kdWN0KTtcbiAgICAgIGV4cGVjdChtb2NrUHJvZHVjdC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHByb2R1Y3REYXRhKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvZHVjdERhdGEgPSB7IG5hbWU6ICcnIH07IC8vIEludmFsaWQgZGF0YVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1ZhbGlkYXRpb24gZmFpbGVkJyk7XG4gICAgICBtb2NrUHJvZHVjdC5jcmVhdGUubW9ja1JlamVjdGVkVmFsdWUoZXJyb3IpO1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS5jcmVhdGVQcm9kdWN0KHByb2R1Y3REYXRhKSkucmVqZWN0cy50b1Rocm93KCdWYWxpZGF0aW9uIGZhaWxlZCcpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBjcmVhdGluZyBwcm9kdWN0OicsIGVycm9yKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgY29uc3RyYWludCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHsgbmFtZTogJ0R1cGxpY2F0ZSBQcm9kdWN0JyB9O1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1VuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvbicpO1xuICAgICAgbW9ja1Byb2R1Y3QuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuY3JlYXRlUHJvZHVjdChwcm9kdWN0RGF0YSkpLnJlamVjdHMudG9UaHJvdygnVW5pcXVlIGNvbnN0cmFpbnQgdmlvbGF0aW9uJyk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIGNyZWF0aW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBwcm9kdWN0IHdpdGggbWluaW1hbCByZXF1aXJlZCBmaWVsZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHsgbmFtZTogJ01pbmltYWwgUHJvZHVjdCcgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRQcm9kdWN0ID0geyBpZDogMSwgLi4ucHJvZHVjdERhdGEgfTtcblxuICAgICAgbW9ja1Byb2R1Y3QuY3JlYXRlLm1vY2tSZXNvbHZlZFZhbHVlKGNyZWF0ZWRQcm9kdWN0KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuY3JlYXRlUHJvZHVjdChwcm9kdWN0RGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoY3JlYXRlZFByb2R1Y3QpO1xuICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgocHJvZHVjdERhdGEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndXBkYXRlUHJvZHVjdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSBhbiBleGlzdGluZyBwcm9kdWN0IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByb2R1Y3REYXRhID0geyBuYW1lOiAnVXBkYXRlZCBQcm9kdWN0JywgcHJpY2U6IDE0OS45OSB9O1xuICAgICAgY29uc3QgZXhpc3RpbmdQcm9kdWN0ID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ09sZCBQcm9kdWN0JyxcbiAgICAgICAgcHJpY2U6IDk5Ljk5LFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGlkOiAxLCAuLi5wcm9kdWN0RGF0YSB9KSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKGV4aXN0aW5nUHJvZHVjdCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLnVwZGF0ZVByb2R1Y3QoMSwgcHJvZHVjdERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgaWQ6IDEsIC4uLnByb2R1Y3REYXRhIH0pO1xuICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRCeVBrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxKTtcbiAgICAgIGV4cGVjdChleGlzdGluZ1Byb2R1Y3QudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwcm9kdWN0RGF0YSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIHdoZW4gcHJvZHVjdCBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHsgbmFtZTogJ1VwZGF0ZWQgUHJvZHVjdCcgfTtcbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDk5OSwgcHJvZHVjdERhdGEpKS5yZWplY3RzLnRvVGhyb3coJ1Byb2R1Y3Qgd2l0aCBJRCA5OTkgbm90IGZvdW5kJyk7XG4gICAgICBleHBlY3QobW9ja1Byb2R1Y3QuZmluZEJ5UGspLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDk5OSk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIHVwZGF0aW5nIHByb2R1Y3Qgd2l0aCBJRCA5OTk6JywgZXhwZWN0LmFueShFcnJvcikpO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1cGRhdGUgdmFsaWRhdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHsgcHJpY2U6IC0xMCB9OyAvLyBJbnZhbGlkIHByaWNlXG4gICAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3QgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0ludmFsaWQgcHJpY2UnKSksXG4gICAgICB9O1xuXG4gICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShleGlzdGluZ1Byb2R1Y3QpO1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDEsIHByb2R1Y3REYXRhKSkucmVqZWN0cy50b1Rocm93KCdJbnZhbGlkIHByaWNlJyk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIHVwZGF0aW5nIHByb2R1Y3Qgd2l0aCBJRCAxOicsIGV4cGVjdC5hbnkoRXJyb3IpKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIGR1cmluZyB1cGRhdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHsgbmFtZTogJ1VwZGF0ZWQgUHJvZHVjdCcgfTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGxvc3QnKTtcbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UudXBkYXRlUHJvZHVjdCgxLCBwcm9kdWN0RGF0YSkpLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgY29ubmVjdGlvbiBsb3N0Jyk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIHVwZGF0aW5nIHByb2R1Y3Qgd2l0aCBJRCAxOicsIGVycm9yKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgb25seSBwcm92aWRlZCBmaWVsZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHsgbmFtZTogJ1VwZGF0ZWQgTmFtZSBPbmx5JyB9O1xuICAgICAgY29uc3QgZXhpc3RpbmdQcm9kdWN0ID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ09sZCBOYW1lJyxcbiAgICAgICAgcHJpY2U6IDk5Ljk5LFxuICAgICAgICBkZXNjcmlwdGlvbjogJ09sZCBEZXNjcmlwdGlvbicsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgaWQ6IDEsIG5hbWU6ICdVcGRhdGVkIE5hbWUgT25seScsIHByaWNlOiA5OS45OSwgZGVzY3JpcHRpb246ICdPbGQgRGVzY3JpcHRpb24nIH0pLFxuICAgICAgfTtcblxuICAgICAgbW9ja1Byb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUoZXhpc3RpbmdQcm9kdWN0KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UudXBkYXRlUHJvZHVjdCgxLCBwcm9kdWN0RGF0YSk7XG5cbiAgICAgIGV4cGVjdChleGlzdGluZ1Byb2R1Y3QudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwcm9kdWN0RGF0YSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm5hbWUpLnRvQmUoJ1VwZGF0ZWQgTmFtZSBPbmx5Jyk7XG4gICAgICBleHBlY3QocmVzdWx0LnByaWNlKS50b0JlKDk5Ljk5KTsgLy8gU2hvdWxkIHJlbWFpbiB1bmNoYW5nZWRcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RlbGV0ZVByb2R1Y3QnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzb2Z0IGRlbGV0ZSBhIHByb2R1Y3Qgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdQcm9kdWN0ID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ1Byb2R1Y3QgdG8gRGVsZXRlJyxcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgaWQ6IDEsIG5hbWU6ICdQcm9kdWN0IHRvIERlbGV0ZScsIGlzQWN0aXZlOiBmYWxzZSB9KSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKGV4aXN0aW5nUHJvZHVjdCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmRlbGV0ZVByb2R1Y3QoMSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBpZDogMSwgbmFtZTogJ1Byb2R1Y3QgdG8gRGVsZXRlJywgaXNBY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgZXhwZWN0KG1vY2tQcm9kdWN0LmZpbmRCeVBrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxKTtcbiAgICAgIGV4cGVjdChleGlzdGluZ1Byb2R1Y3QudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IGlzQWN0aXZlOiBmYWxzZSB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3Igd2hlbiBwcm9kdWN0IG5vdCBmb3VuZCBmb3IgZGVsZXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuZGVsZXRlUHJvZHVjdCg5OTkpKS5yZWplY3RzLnRvVGhyb3coJ1Byb2R1Y3Qgd2l0aCBJRCA5OTkgbm90IGZvdW5kJyk7XG4gICAgICBleHBlY3QobW9ja1Byb2R1Y3QuZmluZEJ5UGspLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDk5OSk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIGRlbGV0aW5nIHByb2R1Y3Qgd2l0aCBJRCA5OTk6JywgZXhwZWN0LmFueShFcnJvcikpO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZHVyaW5nIGRlbGV0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGVycm9yIGR1cmluZyBkZWxldGlvbicpO1xuICAgICAgbW9ja1Byb2R1Y3QuZmluZEJ5UGsubW9ja1JlamVjdGVkVmFsdWUoZXJyb3IpO1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS5kZWxldGVQcm9kdWN0KDEpKS5yZWplY3RzLnRvVGhyb3coJ0RhdGFiYXNlIGVycm9yIGR1cmluZyBkZWxldGlvbicpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBkZWxldGluZyBwcm9kdWN0IHdpdGggSUQgMTonLCBlcnJvcik7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHVwZGF0ZSBlcnJvcnMgZHVyaW5nIHNvZnQgZGVsZXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdQcm9kdWN0ID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdVcGRhdGUgZmFpbGVkJykpLFxuICAgICAgfTtcblxuICAgICAgbW9ja1Byb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUoZXhpc3RpbmdQcm9kdWN0KTtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuZGVsZXRlUHJvZHVjdCgxKSkucmVqZWN0cy50b1Rocm93KCdVcGRhdGUgZmFpbGVkJyk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIGRlbGV0aW5nIHByb2R1Y3Qgd2l0aCBJRCAxOicsIGV4cGVjdC5hbnkoRXJyb3IpKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgYWZmZWN0IGFscmVhZHkgZGVsZXRlZCBwcm9kdWN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFJlc2V0IHRoZSBtb2NrIGV4cGxpY2l0bHlcbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNldCgpO1xuICAgICAgXG4gICAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3QgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBuYW1lOiAnQWxyZWFkeSBEZWxldGVkIFByb2R1Y3QnLFxuICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgaWQ6IDEsIG5hbWU6ICdBbHJlYWR5IERlbGV0ZWQgUHJvZHVjdCcsIGlzQWN0aXZlOiBmYWxzZSB9KSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKGV4aXN0aW5nUHJvZHVjdCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmRlbGV0ZVByb2R1Y3QoMSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuaXNBY3RpdmUpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGV4aXN0aW5nUHJvZHVjdC51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgaXNBY3RpdmU6IGZhbHNlIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJtb2NrUHJvZHVjdCIsImZpbmRBbGwiLCJqZXN0IiwiZm4iLCJmaW5kT25lIiwiZmluZEJ5UGsiLCJjcmVhdGUiLCJ1cGRhdGUiLCJtb2NrIiwiUHJvZHVjdCIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJhZnRlckVhY2giLCJyZXNldEFsbE1vY2tzIiwiaXQiLCJtb2NrUHJvZHVjdHMiLCJpZCIsIm5hbWUiLCJpc0FjdGl2ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwicmVzdWx0IiwicHJvZHVjdFNlcnZpY2UiLCJnZXRBbGxQcm9kdWN0cyIsImV4cGVjdCIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIndoZXJlIiwiZXJyb3IiLCJFcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlIiwiY29uc29sZVNweSIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsInJlamVjdHMiLCJ0b1Rocm93IiwibW9ja1Jlc3RvcmUiLCJtb2NrUHJvZHVjdF9kYXRhIiwiZ2V0UHJvZHVjdEJ5SWQiLCJ0b0JlTnVsbCIsIk5hTiIsInByb2R1Y3REYXRhIiwicHJpY2UiLCJkZXNjcmlwdGlvbiIsImNyZWF0ZWRQcm9kdWN0IiwiY3JlYXRlUHJvZHVjdCIsImV4aXN0aW5nUHJvZHVjdCIsInVwZGF0ZVByb2R1Y3QiLCJhbnkiLCJ0b0JlIiwiZGVsZXRlUHJvZHVjdCIsIm1vY2tSZXNldCJdLCJtYXBwaW5ncyI6Ijs7Ozt5QkFBa0U7Z0NBQ25DO0FBRS9CLHlCQUF5QjtBQUN6QixNQUFNQSxjQUFjO0lBQ2xCQyxTQUFTQyxhQUFJLENBQUNDLEVBQUU7SUFDaEJDLFNBQVNGLGFBQUksQ0FBQ0MsRUFBRTtJQUNoQkUsVUFBVUgsYUFBSSxDQUFDQyxFQUFFO0lBQ2pCRyxRQUFRSixhQUFJLENBQUNDLEVBQUU7SUFDZkksUUFBUUwsYUFBSSxDQUFDQyxFQUFFO0FBQ2pCO0FBRUEsMEJBQTBCO0FBQzFCRCxhQUFJLENBQUNNLElBQUksQ0FBQyxnQkFBZ0IsSUFBTyxDQUFBO1FBQy9CQyxTQUFTVDtJQUNYLENBQUE7QUFFQVUsSUFBQUEsaUJBQVEsRUFBQyxrQkFBa0I7SUFDekJDLElBQUFBLG1CQUFVLEVBQUM7UUFDVFQsYUFBSSxDQUFDVSxhQUFhO0lBQ3BCO0lBRUFDLElBQUFBLGtCQUFTLEVBQUM7UUFDUlgsYUFBSSxDQUFDWSxhQUFhO0lBQ3BCO0lBRUFKLElBQUFBLGlCQUFRLEVBQUMsa0JBQWtCO1FBQ3pCSyxJQUFBQSxXQUFFLEVBQUMscUNBQXFDO1lBQ3RDLE1BQU1DLGVBQWU7Z0JBQ25CO29CQUFFQyxJQUFJO29CQUFHQyxNQUFNO29CQUFhQyxVQUFVO2dCQUFLO2dCQUMzQztvQkFBRUYsSUFBSTtvQkFBR0MsTUFBTTtvQkFBYUMsVUFBVTtnQkFBSzthQUM1QztZQUVEbkIsWUFBWUMsT0FBTyxDQUFDbUIsaUJBQWlCLENBQUNKO1lBRXRDLE1BQU1LLFNBQVMsTUFBTUMsOEJBQWMs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