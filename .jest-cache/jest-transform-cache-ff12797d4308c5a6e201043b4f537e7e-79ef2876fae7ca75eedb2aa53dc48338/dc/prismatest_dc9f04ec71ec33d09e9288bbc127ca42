ce8916219468ab51689a68be5a093e93
// Unit tests for Prisma utilities
// Testing the safeQuery helper function and Prisma client configuration
"use strict";
// Mock the PrismaClient constructor
jest.mock("@prisma/client", ()=>({
        PrismaClient: jest.fn().mockImplementation(()=>mockPrismaClient)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _client = require("@prisma/client");
// Mock PrismaClient
const mockPrismaClient = {
    $connect: jest.fn(),
    $disconnect: jest.fn(),
    user: {
        findMany: jest.fn(),
        findUnique: jest.fn(),
        create: jest.fn(),
        update: jest.fn(),
        delete: jest.fn()
    },
    shop: {
        findMany: jest.fn(),
        findUnique: jest.fn(),
        create: jest.fn(),
        update: jest.fn(),
        delete: jest.fn()
    }
};
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Prisma Utilities", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("PrismaClient Configuration", ()=>{
        it("should create PrismaClient with correct configuration", ()=>{
            // Re-import to trigger constructor
            jest.resetModules();
            require("@/lib/prisma");
            expect(_client.PrismaClient).toHaveBeenCalledWith(expect.objectContaining({
                datasources: {
                    db: {
                        url: expect.stringContaining("postgresql")
                    }
                },
                log: expect.arrayContaining([
                    "error"
                ]),
                errorFormat: "minimal"
            }));
        });
    });
    describe("safeQuery function (isolated implementation)", ()=>{
        // Isolated implementation of safeQuery matching the actual implementation
        const safeQuery = async (queryFn, fallback, logMessage = "Database operation failed")=>{
            try {
                return await queryFn();
            } catch (error) {
                console.error(`${logMessage}:`, error);
                return fallback;
            }
        };
        it("should return result for successful operation", async ()=>{
            const mockOperation = jest.fn().mockResolvedValue({
                id: 1,
                name: "Test User"
            });
            const result = await safeQuery(mockOperation, null, "Find user");
            expect(result).toEqual({
                id: 1,
                name: "Test User"
            });
            expect(mockOperation).toHaveBeenCalledTimes(1);
            expect(consoleSpy.error).not.toHaveBeenCalled();
        });
        it("should return fallback and log error for failed operation", async ()=>{
            const mockError = new Error("Database connection failed");
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            const result = await safeQuery(mockOperation, null, "Find user failed");
            expect(result).toBeNull();
            expect(mockOperation).toHaveBeenCalledTimes(1);
            expect(consoleSpy.error).toHaveBeenCalledWith("Find user failed:", mockError);
        });
        it("should handle database errors with fallback", async ()=>{
            const mockError = {
                code: "P2002",
                message: "Unique constraint failed"
            };
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            const fallbackValue = {
                error: "Operation failed"
            };
            const result = await safeQuery(mockOperation, fallbackValue, "Create user failed");
            expect(result).toEqual(fallbackValue);
            expect(consoleSpy.error).toHaveBeenCalledWith("Create user failed:", mockError);
        });
        it("should use default log message when none provided", async ()=>{
            const mockError = new Error("Generic error");
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            const result = await safeQuery(mockOperation, "default");
            expect(result).toBe("default");
            expect(consoleSpy.error).toHaveBeenCalledWith("Database operation failed:", mockError);
        });
        it("should handle different fallback types", async ()=>{
            const mockError = new Error("Operation failed");
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            // Test with array fallback
            const result1 = await safeQuery(mockOperation, [], "Array operation failed");
            expect(result1).toEqual([]);
            // Test with object fallback
            const result2 = await safeQuery(mockOperation, {
                error: true
            }, "Object operation failed");
            expect(result2).toEqual({
                error: true
            });
            // Test with number fallback
            const result3 = await safeQuery(mockOperation, 0, "Number operation failed");
            expect(result3).toBe(0);
        });
        it("should handle async operations correctly", async ()=>{
            const mockData = {
                id: 1,
                name: "Async User"
            };
            const mockOperation = jest.fn().mockImplementation(()=>new Promise((resolve)=>setTimeout(()=>resolve(mockData), 10)));
            const result = await safeQuery(mockOperation, null, "Async operation");
            expect(result).toEqual(mockData);
            expect(mockOperation).toHaveBeenCalledTimes(1);
        });
        it("should preserve error objects in logs", async ()=>{
            const mockError = {
                code: "P2002",
                message: "Unique constraint failed",
                meta: {
                    target: [
                        "email"
                    ]
                }
            };
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            const result = await safeQuery(mockOperation, null, "Constraint error");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Constraint error:", mockError);
        });
    });
    describe("Database Operations with safeQuery", ()=>{
        // Use the actual safeQuery implementation for integration testing
        const safeQuery = async (queryFn, fallback, logMessage = "Database operation failed")=>{
            try {
                return await queryFn();
            } catch (error) {
                console.error(`${logMessage}:`, error);
                return fallback;
            }
        };
        it("should safely execute user findMany operation", async ()=>{
            const mockUsers = [
                {
                    id: 1,
                    name: "User 1"
                },
                {
                    id: 2,
                    name: "User 2"
                }
            ];
            mockPrismaClient.user.findMany.mockResolvedValue(mockUsers);
            const result = await safeQuery(()=>mockPrismaClient.user.findMany(), [], "Find all users");
            expect(result).toEqual(mockUsers);
            expect(mockPrismaClient.user.findMany).toHaveBeenCalledTimes(1);
        });
        it("should safely execute user create operation", async ()=>{
            const newUser = {
                id: 1,
                name: "New User",
                email: "new@example.com"
            };
            mockPrismaClient.user.create.mockResolvedValue(newUser);
            const result = await safeQuery(()=>mockPrismaClient.user.create({
                    data: {
                        name: "New User",
                        email: "new@example.com"
                    }
                }), null, "Create user");
            expect(result).toEqual(newUser);
            expect(mockPrismaClient.user.create).toHaveBeenCalledWith({
                data: {
                    name: "New User",
                    email: "new@example.com"
                }
            });
        });
        it("should safely execute shop operations", async ()=>{
            const mockShop = {
                id: "shop1",
                name: "Test Shop"
            };
            mockPrismaClient.shop.findUnique.mockResolvedValue(mockShop);
            const result = await safeQuery(()=>mockPrismaClient.shop.findUnique({
                    where: {
                        id: "shop1"
                    }
                }), null, "Find shop");
            expect(result).toEqual(mockShop);
            expect(mockPrismaClient.shop.findUnique).toHaveBeenCalledWith({
                where: {
                    id: "shop1"
                }
            });
        });
        it("should return fallback when operation fails", async ()=>{
            const mockError = new Error("Database error");
            mockPrismaClient.user.findUnique.mockRejectedValue(mockError);
            const result = await safeQuery(()=>mockPrismaClient.user.findUnique({
                    where: {
                        id: 999
                    }
                }), null, "Find non-existent user");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Find non-existent user:", mockError);
        });
    });
    describe("Prisma Client Lifecycle", ()=>{
        it("should handle connection operations", async ()=>{
            mockPrismaClient.$connect.mockResolvedValue(undefined);
            await mockPrismaClient.$connect();
            expect(mockPrismaClient.$connect).toHaveBeenCalledTimes(1);
        });
        it("should handle disconnection operations", async ()=>{
            mockPrismaClient.$disconnect.mockResolvedValue(undefined);
            await mockPrismaClient.$disconnect();
            expect(mockPrismaClient.$disconnect).toHaveBeenCalledTimes(1);
        });
        it("should handle connection errors", async ()=>{
            const connectionError = new Error("Connection failed");
            mockPrismaClient.$connect.mockRejectedValue(connectionError);
            await expect(mockPrismaClient.$connect()).rejects.toThrow("Connection failed");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9wcmlzbWEudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbml0IHRlc3RzIGZvciBQcmlzbWEgdXRpbGl0aWVzXG4vLyBUZXN0aW5nIHRoZSBzYWZlUXVlcnkgaGVscGVyIGZ1bmN0aW9uIGFuZCBQcmlzbWEgY2xpZW50IGNvbmZpZ3VyYXRpb25cblxuaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSAnQHByaXNtYS9jbGllbnQnO1xuXG4vLyBNb2NrIFByaXNtYUNsaWVudFxuY29uc3QgbW9ja1ByaXNtYUNsaWVudCA9IHtcbiAgJGNvbm5lY3Q6IGplc3QuZm4oKSxcbiAgJGRpc2Nvbm5lY3Q6IGplc3QuZm4oKSxcbiAgdXNlcjoge1xuICAgIGZpbmRNYW55OiBqZXN0LmZuKCksXG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpLFxuICAgIGNyZWF0ZTogamVzdC5mbigpLFxuICAgIHVwZGF0ZTogamVzdC5mbigpLFxuICAgIGRlbGV0ZTogamVzdC5mbigpLFxuICB9LFxuICBzaG9wOiB7XG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgICBmaW5kVW5pcXVlOiBqZXN0LmZuKCksXG4gICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gICAgdXBkYXRlOiBqZXN0LmZuKCksXG4gICAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIH0sXG59O1xuXG4vLyBNb2NrIHRoZSBQcmlzbWFDbGllbnQgY29uc3RydWN0b3Jcbmplc3QubW9jaygnQHByaXNtYS9jbGllbnQnLCAoKSA9PiAoe1xuICBQcmlzbWFDbGllbnQ6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja1ByaXNtYUNsaWVudCksXG59KSk7XG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBjb25zb2xlU3B5ID0ge1xuICBsb2c6IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIGVycm9yOiBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIHdhcm46IGplc3Quc3B5T24oY29uc29sZSwgJ3dhcm4nKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pLFxufTtcblxuZGVzY3JpYmUoJ1ByaXNtYSBVdGlsaXRpZXMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkuZXJyb3IubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgY29uc29sZVNweS5sb2cubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcmlzbWFDbGllbnQgQ29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBQcmlzbWFDbGllbnQgd2l0aCBjb3JyZWN0IGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgICAvLyBSZS1pbXBvcnQgdG8gdHJpZ2dlciBjb25zdHJ1Y3RvclxuICAgICAgamVzdC5yZXNldE1vZHVsZXMoKTtcbiAgICAgIHJlcXVpcmUoJ0AvbGliL3ByaXNtYScpO1xuICAgICAgXG4gICAgICBleHBlY3QoUHJpc21hQ2xpZW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGRhdGFzb3VyY2VzOiB7XG4gICAgICAgICAgICBkYjoge1xuICAgICAgICAgICAgICB1cmw6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdwb3N0Z3Jlc3FsJyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbG9nOiBleHBlY3QuYXJyYXlDb250YWluaW5nKFsnZXJyb3InXSksXG4gICAgICAgICAgZXJyb3JGb3JtYXQ6ICdtaW5pbWFsJyxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzYWZlUXVlcnkgZnVuY3Rpb24gKGlzb2xhdGVkIGltcGxlbWVudGF0aW9uKScsICgpID0+IHtcbiAgICAvLyBJc29sYXRlZCBpbXBsZW1lbnRhdGlvbiBvZiBzYWZlUXVlcnkgbWF0Y2hpbmcgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHNhZmVRdWVyeSA9IGFzeW5jIDxUPihcbiAgICAgIHF1ZXJ5Rm46ICgpID0+IFByb21pc2U8VD4sXG4gICAgICBmYWxsYmFjazogVCxcbiAgICAgIGxvZ01lc3NhZ2UgPSAnRGF0YWJhc2Ugb3BlcmF0aW9uIGZhaWxlZCdcbiAgICApOiBQcm9taXNlPFQ+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBxdWVyeUZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2xvZ01lc3NhZ2V9OmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiByZXN1bHQgZm9yIHN1Y2Nlc3NmdWwgb3BlcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGlkOiAxLCBuYW1lOiAnVGVzdCBVc2VyJyB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KG1vY2tPcGVyYXRpb24sIG51bGwsICdGaW5kIHVzZXInKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IGlkOiAxLCBuYW1lOiAnVGVzdCBVc2VyJyB9KTtcbiAgICAgIGV4cGVjdChtb2NrT3BlcmF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbGxiYWNrIGFuZCBsb2cgZXJyb3IgZm9yIGZhaWxlZCBvcGVyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG1vY2tFcnJvcik7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCBudWxsLCAnRmluZCB1c2VyIGZhaWxlZCcpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KG1vY2tPcGVyYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0ZpbmQgdXNlciBmYWlsZWQ6JyxcbiAgICAgICAgbW9ja0Vycm9yXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIHdpdGggZmFsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSB7IGNvZGU6ICdQMjAwMicsIG1lc3NhZ2U6ICdVbmlxdWUgY29uc3RyYWludCBmYWlsZWQnIH07XG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG1vY2tFcnJvcik7XG4gICAgICBjb25zdCBmYWxsYmFja1ZhbHVlID0geyBlcnJvcjogJ09wZXJhdGlvbiBmYWlsZWQnIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCBmYWxsYmFja1ZhbHVlLCAnQ3JlYXRlIHVzZXIgZmFpbGVkJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZmFsbGJhY2tWYWx1ZSk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdDcmVhdGUgdXNlciBmYWlsZWQ6JyxcbiAgICAgICAgbW9ja0Vycm9yXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgZGVmYXVsdCBsb2cgbWVzc2FnZSB3aGVuIG5vbmUgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSBuZXcgRXJyb3IoJ0dlbmVyaWMgZXJyb3InKTtcbiAgICAgIGNvbnN0IG1vY2tPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobW9ja0Vycm9yKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KG1vY2tPcGVyYXRpb24sICdkZWZhdWx0Jyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ2RlZmF1bHQnKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0RhdGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQ6JyxcbiAgICAgICAgbW9ja0Vycm9yXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGlmZmVyZW50IGZhbGxiYWNrIHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yID0gbmV3IEVycm9yKCdPcGVyYXRpb24gZmFpbGVkJyk7XG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG1vY2tFcnJvcik7XG4gICAgICBcbiAgICAgIC8vIFRlc3Qgd2l0aCBhcnJheSBmYWxsYmFja1xuICAgICAgY29uc3QgcmVzdWx0MSA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCBbXSwgJ0FycmF5IG9wZXJhdGlvbiBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQxKS50b0VxdWFsKFtdKTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCB3aXRoIG9iamVjdCBmYWxsYmFja1xuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCB7IGVycm9yOiB0cnVlIH0sICdPYmplY3Qgb3BlcmF0aW9uIGZhaWxlZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdDIpLnRvRXF1YWwoeyBlcnJvcjogdHJ1ZSB9KTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCB3aXRoIG51bWJlciBmYWxsYmFja1xuICAgICAgY29uc3QgcmVzdWx0MyA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCAwLCAnTnVtYmVyIG9wZXJhdGlvbiBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQzKS50b0JlKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXN5bmMgb3BlcmF0aW9ucyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGF0YSA9IHsgaWQ6IDEsIG5hbWU6ICdBc3luYyBVc2VyJyB9O1xuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gXG4gICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKG1vY2tEYXRhKSwgMTApKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KG1vY2tPcGVyYXRpb24sIG51bGwsICdBc3luYyBvcGVyYXRpb24nKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrRGF0YSk7XG4gICAgICBleHBlY3QobW9ja09wZXJhdGlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSBlcnJvciBvYmplY3RzIGluIGxvZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSB7XG4gICAgICAgIGNvZGU6ICdQMjAwMicsXG4gICAgICAgIG1lc3NhZ2U6ICdVbmlxdWUgY29uc3RyYWludCBmYWlsZWQnLFxuICAgICAgICBtZXRhOiB7IHRhcmdldDogWydlbWFpbCddIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG1vY2tFcnJvcik7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCBudWxsLCAnQ29uc3RyYWludCBlcnJvcicpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnQ29uc3RyYWludCBlcnJvcjonLFxuICAgICAgICBtb2NrRXJyb3JcbiAgICAgICk7XG4gICAgfSk7XG5cblxuXG5cblxuXG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEYXRhYmFzZSBPcGVyYXRpb25zIHdpdGggc2FmZVF1ZXJ5JywgKCkgPT4ge1xuICAgIC8vIFVzZSB0aGUgYWN0dWFsIHNhZmVRdWVyeSBpbXBsZW1lbnRhdGlvbiBmb3IgaW50ZWdyYXRpb24gdGVzdGluZ1xuICAgIGNvbnN0IHNhZmVRdWVyeSA9IGFzeW5jIDxUPihcbiAgICAgIHF1ZXJ5Rm46ICgpID0+IFByb21pc2U8VD4sXG4gICAgICBmYWxsYmFjazogVCxcbiAgICAgIGxvZ01lc3NhZ2UgPSAnRGF0YWJhc2Ugb3BlcmF0aW9uIGZhaWxlZCdcbiAgICApOiBQcm9taXNlPFQ+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBxdWVyeUZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2xvZ01lc3NhZ2V9OmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHNhZmVseSBleGVjdXRlIHVzZXIgZmluZE1hbnkgb3BlcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VzZXJzID0gW3sgaWQ6IDEsIG5hbWU6ICdVc2VyIDEnIH0sIHsgaWQ6IDIsIG5hbWU6ICdVc2VyIDInIH1dO1xuICAgICAgbW9ja1ByaXNtYUNsaWVudC51c2VyLmZpbmRNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2Vycyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShcbiAgICAgICAgKCkgPT4gbW9ja1ByaXNtYUNsaWVudC51c2VyLmZpbmRNYW55KCksXG4gICAgICAgIFtdLFxuICAgICAgICAnRmluZCBhbGwgdXNlcnMnXG4gICAgICApO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tVc2Vycyk7XG4gICAgICBleHBlY3QobW9ja1ByaXNtYUNsaWVudC51c2VyLmZpbmRNYW55KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNhZmVseSBleGVjdXRlIHVzZXIgY3JlYXRlIG9wZXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld1VzZXIgPSB7IGlkOiAxLCBuYW1lOiAnTmV3IFVzZXInLCBlbWFpbDogJ25ld0BleGFtcGxlLmNvbScgfTtcbiAgICAgIG1vY2tQcmlzbWFDbGllbnQudXNlci5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUobmV3VXNlcik7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShcbiAgICAgICAgKCkgPT4gbW9ja1ByaXNtYUNsaWVudC51c2VyLmNyZWF0ZSh7XG4gICAgICAgICAgZGF0YTogeyBuYW1lOiAnTmV3IFVzZXInLCBlbWFpbDogJ25ld0BleGFtcGxlLmNvbScgfVxuICAgICAgICB9KSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgJ0NyZWF0ZSB1c2VyJ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChuZXdVc2VyKTtcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hQ2xpZW50LnVzZXIuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIGRhdGE6IHsgbmFtZTogJ05ldyBVc2VyJywgZW1haWw6ICduZXdAZXhhbXBsZS5jb20nIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzYWZlbHkgZXhlY3V0ZSBzaG9wIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2hvcCA9IHsgaWQ6ICdzaG9wMScsIG5hbWU6ICdUZXN0IFNob3AnIH07XG4gICAgICBtb2NrUHJpc21hQ2xpZW50LnNob3AuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU2hvcCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShcbiAgICAgICAgKCkgPT4gbW9ja1ByaXNtYUNsaWVudC5zaG9wLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogJ3Nob3AxJyB9IH0pLFxuICAgICAgICBudWxsLFxuICAgICAgICAnRmluZCBzaG9wJ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrU2hvcCk7XG4gICAgICBleHBlY3QobW9ja1ByaXNtYUNsaWVudC5zaG9wLmZpbmRVbmlxdWUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgd2hlcmU6IHsgaWQ6ICdzaG9wMScgfSB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbGxiYWNrIHdoZW4gb3BlcmF0aW9uIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBlcnJvcicpO1xuICAgICAgbW9ja1ByaXNtYUNsaWVudC51c2VyLmZpbmRVbmlxdWUubW9ja1JlamVjdGVkVmFsdWUobW9ja0Vycm9yKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KFxuICAgICAgICAoKSA9PiBtb2NrUHJpc21hQ2xpZW50LnVzZXIuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiA5OTkgfSB9KSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgJ0ZpbmQgbm9uLWV4aXN0ZW50IHVzZXInXG4gICAgICApO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdGaW5kIG5vbi1leGlzdGVudCB1c2VyOicsIG1vY2tFcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcmlzbWEgQ2xpZW50IExpZmVjeWNsZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25uZWN0aW9uIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJpc21hQ2xpZW50LiRjb25uZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBcbiAgICAgIGF3YWl0IG1vY2tQcmlzbWFDbGllbnQuJGNvbm5lY3QoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tQcmlzbWFDbGllbnQuJGNvbm5lY3QpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRpc2Nvbm5lY3Rpb24gb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tQcmlzbWFDbGllbnQuJGRpc2Nvbm5lY3QubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgYXdhaXQgbW9ja1ByaXNtYUNsaWVudC4kZGlzY29ubmVjdCgpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja1ByaXNtYUNsaWVudC4kZGlzY29ubmVjdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29ubmVjdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICBtb2NrUHJpc21hQ2xpZW50LiRjb25uZWN0Lm1vY2tSZWplY3RlZFZhbHVlKGNvbm5lY3Rpb25FcnJvcik7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChtb2NrUHJpc21hQ2xpZW50LiRjb25uZWN0KCkpLnJlamVjdHMudG9UaHJvdygnQ29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJQcmlzbWFDbGllbnQiLCJmbiIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIm1vY2tQcmlzbWFDbGllbnQiLCIkY29ubmVjdCIsIiRkaXNjb25uZWN0IiwidXNlciIsImZpbmRNYW55IiwiZmluZFVuaXF1ZSIsImNyZWF0ZSIsInVwZGF0ZSIsImRlbGV0ZSIsInNob3AiLCJjb25zb2xlU3B5IiwibG9nIiwic3B5T24iLCJjb25zb2xlIiwiZXJyb3IiLCJ3YXJuIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsImFmdGVyQWxsIiwibW9ja1Jlc3RvcmUiLCJpdCIsInJlc2V0TW9kdWxlcyIsInJlcXVpcmUiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm9iamVjdENvbnRhaW5pbmciLCJkYXRhc291cmNlcyIsImRiIiwidXJsIiwic3RyaW5nQ29udGFpbmluZyIsImFycmF5Q29udGFpbmluZyIsImVycm9yRm9ybWF0Iiwic2FmZVF1ZXJ5IiwicXVlcnlGbiIsImZhbGxiYWNrIiwibG9nTWVzc2FnZSIsIm1vY2tPcGVyYXRpb24iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImlkIiwibmFtZSIsInJlc3VsdCIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibW9ja0Vycm9yIiwiRXJyb3IiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsInRvQmVOdWxsIiwiY29kZSIsIm1lc3NhZ2UiLCJmYWxsYmFja1ZhbHVlIiwidG9CZSIsInJlc3VsdDEiLCJyZXN1bHQyIiwicmVzdWx0MyIsIm1vY2tEYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibWV0YSIsInRhcmdldCIsIm1vY2tVc2VycyIsIm5ld1VzZXIiLCJlbWFpbCIsImRhdGEiLCJtb2NrU2hvcCIsIndoZXJlIiwidW5kZWZpbmVkIiwiY29ubmVjdGlvbkVycm9yIiwicmVqZWN0cyIsInRvVGhyb3ciXSwibWFwcGluZ3MiOiJBQUFBLGtDQUFrQztBQUNsQyx3RUFBd0U7O0FBd0J4RSxvQ0FBb0M7QUFDcENBLEtBQUtDLElBQUksQ0FBQyxrQkFBa0IsSUFBTyxDQUFBO1FBQ2pDQyxjQUFjRixLQUFLRyxFQUFFLEdBQUdDLGtCQUFrQixDQUFDLElBQU1DO0lBQ25ELENBQUE7Ozs7d0JBekI2QjtBQUU3QixvQkFBb0I7QUFDcEIsTUFBTUEsbUJBQW1CO0lBQ3ZCQyxVQUFVTixLQUFLRyxFQUFFO0lB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