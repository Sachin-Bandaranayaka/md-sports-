a5e8a6b79e2bc534fb974a9b3fa85ae0
/**
 * @jest-environment node
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _client = require("@prisma/client");
const _route = require("../../src/app/api/purchases/route");
const _route1 = require("../../src/app/api/purchases/[id]/route");
const _server = require("next/server");
const prisma = new _client.PrismaClient();
describe("Purchase Invoice API Integration Tests", ()=>{
    let createdShopId;
    let createdSupplierId;
    let createdProductId;
    beforeAll(async ()=>{
    // Seed initial data if necessary, e.g., a default supplier or shop
    // For now, we'll create them in beforeEach or specific tests
    });
    beforeEach(async ()=>{
        // Clean up database tables to ensure test isolation
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        // Create a shop for testing
        const shop = await prisma.shop.create({
            data: {
                name: "Test Shop Local",
                location: "Test Location"
            }
        });
        createdShopId = shop.id;
        // Create a supplier for testing
        const supplier = await prisma.supplier.create({
            data: {
                name: "Test Supplier Local"
            }
        });
        createdSupplierId = supplier.id;
        // Create a product for testing updates/deletes (not for create new product test)
        const product = await prisma.product.create({
            data: {
                name: "Existing Product",
                price: 100,
                sku: "EXISTING001",
                shopId: createdShopId
            }
        });
        createdProductId = product.id;
    });
    afterAll(async ()=>{
        // Clean up database after all tests
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        await prisma.$disconnect();
    });
    describe("POST /api/purchases (Create Purchase Invoice)", ()=>{
        it("should create a purchase invoice for a new product, update inventory, and set WAC", async ()=>{
            // 1. Define data for a new product
            const newProductName = "Brand New Racket";
            const newProductSku = "NEWB001";
            const purchasePrice = 150;
            const purchaseQuantity = 10;
            // Create product first (as API expects productId)
            // In a real scenario, the UI might create product then purchase, or purchase API handles product creation
            // For this test, assume product is created just before, or API implies its creation from purchase (not current API)
            // Let's assume for now product must exist, if API doesn't create it from purchase items.
            // The current API's POST /api/purchases expects item.productId, implying product exists.
            const newTestProduct = await prisma.product.create({
                data: {
                    name: newProductName,
                    sku: newProductSku,
                    price: 250,
                    shopId: createdShopId // Optional default shop association
                }
            });
            const newTestProductId = newTestProduct.id;
            // 2. Prepare the request body for POST /api/purchases
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // 3. Construct a NextRequest instance
            const req = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate the API call
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201); // Or 200 depending on your API's success response for POST
            expect(responseBody.data).toHaveProperty("id");
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice).not.toBeNull();
            expect(dbInvoice?.supplierId).toBe(createdSupplierId);
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(newTestProductId);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice);
            // Verify InventoryItem in DB
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newTestProductId,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem).not.toBeNull();
            expect(dbInventoryItem?.quantity).toBe(purchaseQuantity);
            // The POST route seems to calculate shopSpecificCost too.
            // WAC = (Current Total Value + New Purchase Value) / (Current Quantity + New Quantity)
            // For new item, existing shopSpecificCost is 0, currentQuantity is 0.
            // So newShopSpecificCost should be newCost (purchasePrice)
            expect(dbInventoryItem?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC in DB
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: newTestProductId
                }
            });
            expect(dbProduct).not.toBeNull();
            // For a new product, WAC should be equal to the purchase price of this first batch
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should create a purchase for an existing product, update inventory, and recalculate WACs", async ()=>{
            // 0. Initial state: Product exists, potentially with some inventory and WAC
            const initialPurchasePrice = 120;
            const initialPurchaseQuantity = 5;
            const existingProductId = createdProductId; // From beforeEach
            // Create an initial purchase to set up existing inventory and WAC
            const initialPayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const initialReq = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(initialPayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route.POST)(initialReq);
            const productBeforeNewPurchase = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            const inventoryBeforeNewPurchase = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            expect(productBeforeNewPurchase?.weightedAverageCost).toBe(initialPurchasePrice);
            expect(inventoryBeforeNewPurchase?.quantity).toBe(initialPurchaseQuantity);
            expect(inventoryBeforeNewPurchase?.shopSpecificCost).toBe(initialPurchasePrice);
            // 1. Define data for the new purchase of the existing product
            const newPurchasePrice = 100;
            const newPurchaseQuantity = 8;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: newPurchaseQuantity,
                        price: newPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newPurchaseQuantity
                    }
                ],
                totalAmount: newPurchaseQuantity * newPurchasePrice,
                status: "paid"
            };
            // 3. Simulate API call
            const req = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify InventoryItem
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            const expectedTotalQuantity = initialPurchaseQuantity + newPurchaseQuantity;
            expect(dbInventoryItem?.quantity).toBe(expectedTotalQuantity);
            // Verify shopSpecificCost recalculation
            // SSC = ((oldQty * oldSSC) + (newQty * newPrice)) / (oldQty + newQty)
            const expectedShopSpecificCost = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            expect(dbInventoryItem?.shopSpecificCost).toBeCloseTo(expectedShopSpecificCost);
            // Verify Product WAC recalculation
            // WAC = ((oldTotalQty * oldWAC) + (newPurchaseQty * newPurchasePrice)) / (newTotalQty + newPurchaseQty)
            // In this case, product WAC was initialPurchasePrice for initialPurchaseQuantity.
            const expectedProductWAC = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            expect(dbProduct?.weightedAverageCost).toBeCloseTo(expectedProductWAC);
        }, 15000); // Increased timeout
        it("should create a purchase with multiple items and update inventory/WAC for each", async ()=>{
            // 1. Create two distinct products for this test
            const product1Data = {
                name: "MultiItem Product A",
                sku: "MULTI001",
                price: 50,
                shopId: createdShopId
            };
            const product2Data = {
                name: "MultiItem Product B",
                sku: "MULTI002",
                price: 75,
                shopId: createdShopId
            };
            const product1 = await prisma.product.create({
                data: product1Data
            });
            const product2 = await prisma.product.create({
                data: product2Data
            });
            const purchasePrice1 = 40;
            const purchaseQuantity1 = 5;
            const purchasePrice2 = 60;
            const purchaseQuantity2 = 3;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product1.id.toString(),
                        quantity: purchaseQuantity1,
                        price: purchasePrice1
                    },
                    {
                        productId: product2.id.toString(),
                        quantity: purchaseQuantity2,
                        price: purchasePrice2
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity1
                    },
                    {
                        [createdShopId]: purchaseQuantity2
                    } // Distribution for item 2
                ],
                totalAmount: purchaseQuantity1 * purchasePrice1 + purchaseQuantity2 * purchasePrice2,
                status: "pending"
            };
            // 3. Simulate API call
            const req = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice and its items
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                } // Order to ensure consistent assertion
            });
            expect(dbInvoice?.items.length).toBe(2);
            // Assuming product1.id < product2.id due to creation order for consistent checks
            const sortedProducts = [
                product1,
                product2
            ].sort((a, b)=>a.id - b.id);
            expect(dbInvoice?.items[0].productId).toBe(sortedProducts[0].id);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity1);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice1);
            expect(dbInvoice?.items[1].productId).toBe(sortedProducts[1].id);
            expect(dbInvoice?.items[1].quantity).toBe(purchaseQuantity2);
            expect(dbInvoice?.items[1].price).toBe(purchasePrice2);
            // Verify InventoryItem and Product WAC for Product 1
            const dbInventoryItem1 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product1.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem1?.quantity).toBe(purchaseQuantity1);
            expect(dbInventoryItem1?.shopSpecificCost).toBe(purchasePrice1);
            const dbProduct1 = await prisma.product.findUnique({
                where: {
                    id: product1.id
                }
            });
            expect(dbProduct1?.weightedAverageCost).toBe(purchasePrice1);
            // Verify InventoryItem and Product WAC for Product 2
            const dbInventoryItem2 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product2.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem2?.quantity).toBe(purchaseQuantity2);
            expect(dbInventoryItem2?.shopSpecificCost).toBe(purchasePrice2);
            const dbProduct2 = await prisma.product.findUnique({
                where: {
                    id: product2.id
                }
            });
            expect(dbProduct2?.weightedAverageCost).toBe(purchasePrice2);
        }, 15000); // Increased timeout
        it("should distribute a single purchase item to multiple shops", async ()=>{
            // 1. Create two new shops for this test
            const shopA = await prisma.shop.create({
                data: {
                    name: "Test Shop A",
                    location: "Loc A"
                }
            });
            const shopB = await prisma.shop.create({
                data: {
                    name: "Test Shop B",
                    location: "Loc B"
                }
            });
            // 2. Create a new product
            const product = await prisma.product.create({
                data: {
                    name: "Split Product",
                    sku: "SPLIT001",
                    price: 200
                }
            });
            const purchasePrice = 180;
            const totalQuantity = 10;
            const quantityForShopA = 6;
            const quantityForShopB = 4;
            expect(quantityForShopA + quantityForShopB).toBe(totalQuantity); // Sanity check
            // 3. Prepare request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product.id.toString(),
                        quantity: totalQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [shopA.id]: quantityForShopA,
                        [shopB.id]: quantityForShopB
                    }
                ],
                totalAmount: totalQuantity * purchasePrice,
                status: "paid"
            };
            // 4. Simulate API call
            const req = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 5. Assertions
            expect(response.status).toBe(201);
            // Verify InventoryItem for Shop A
            const invItemA = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopA.id
                }
            });
            expect(invItemA).not.toBeNull();
            expect(invItemA?.quantity).toBe(quantityForShopA);
            expect(invItemA?.shopSpecificCost).toBe(purchasePrice);
            // Verify InventoryItem for Shop B
            const invItemB = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopB.id
                }
            });
            expect(invItemB).not.toBeNull();
            expect(invItemB?.quantity).toBe(quantityForShopB);
            expect(invItemB?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC (should be the purchase price as it's all new stock)
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: product.id
                }
            });
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a productId does not exist", async ()=>{
            const nonExistentProductId = 999999; // Assuming this ID won't exist
            const purchasePrice = 100;
            const purchaseQuantity = 5;
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: nonExistentProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            // Expect a client error (e.g., 400 or 404) or potentially 500 if not handled gracefully
            // For robust error handling, API should return specific error code.
            // Prisma will throw an error if a related record (product) is not found for foreign key.
            // This will likely result in a 500 if not caught and handled by the API route.
            // Let's aim for the API to catch this and return a more specific client error.
            // For now, we'll check if it's NOT a success (201).
            // A more precise check would be for 400/404/422 depending on planned error handling.
            expect(response.status).toBe(500); // Or 400/404 if you implement specific error handling
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        // Optionally, check for a specific error message or code if your API provides one.
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a supplierId does not exist", async ()=>{
            const newTestProduct = await prisma.product.create({
                data: {
                    name: "Product For Invalid Supplier Test",
                    sku: "INV SUP001",
                    price: 100
                }
            });
            const purchasePrice = 80;
            const purchaseQuantity = 5;
            const nonExistentSupplierId = 999999; // Assuming this ID won't exist
            const purchaseInvoicePayload = {
                supplierId: nonExistentSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            expect(response.status).toBe(500); // Expecting 500 as Prisma throws P2003
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        });
    });
    describe("PUT /api/purchases/:id (Update Purchase Invoice)", ()=>{
        let existingInvoiceId;
        let productForUpdateTestsId;
        const initialPurchasePrice = 50;
        const initialPurchaseQuantity = 10;
        beforeEach(async ()=>{
            // Create a product specifically for these update/delete tests if not already created
            // The global createdProductId can be used if it fits, or make a new one.
            // Let's use the global one for simplicity, assuming beforeEach cleans it up.
            productForUpdateTestsId = createdProductId;
            // Create an initial purchase invoice to be updated or deleted in tests
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const req = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(initialInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            existingInvoiceId = body.data.id;
            // Sanity check: verify initial state
            const initialProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(initialProduct?.weightedAverageCost).toBe(initialPurchasePrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(initialPurchasePrice);
        });
        it("should update item quantity (increase), recalculate stock and WACs", async ()=>{
            const quantityIncrease = 5;
            const newQuantity = initialPurchaseQuantity + quantityIncrease;
            // Price remains the same for this item in this update scenario
            const updatedPriceForItem = initialPurchasePrice;
            const updatePayload = {
                // We need to send the complete structure expected by the PUT route
                // This includes all items, even if only one is changing.
                // The PUT route logic might compare with existing items to see what changed.
                items: [
                    {
                        // If the item had an ID (PurchaseInvoiceItem id), it might be needed.
                        // Let's assume for now the PUT matches items based on productId if not item ID.
                        // Based on current PUT route, it expects productId.
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    // The distributions in PUT might need to reflect the *new total* for the item
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = new _server.NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate API call - updatePurchaseInvoice(req, { params: { id: existingInvoiceId } })
            // This is how you call it if you are testing the handler directly in Jest with context
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // WAC calculation: ((oldQty * oldSSC) + (addedQty * priceOfAddedQty)) / (newTotalQty)
            // In this specific update, the PUT route reverses the old item and adds the new one as if it's a new purchase line for WAC calcs.
            // So, the old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // However, the current PUT logic first reverses *all* old items based on their *original* recorded cost.
            // Then it adds *all* new items based on their *new* cost.
            // So for the product WAC: (TotalValueBefore - OldItemValue + NewItemValue) / (TotalStockBefore - OldItemQty + NewItemQty)
            // And for shop specific WAC: (ShopValueBefore - OldItemValueInShop + NewItemValueInShop) / (ShopStockBefore - OldItemQtyInShop + NewItemQtyInShop)
            // Let's check the logic from src/app/api/purchases/[id]/route.ts
            // 1. It fetches the old invoice.
            // 2. It reverses inventory adjustments for ALL old items (decrease stock, WAC updated).
            // 3. It processes ALL new/updated items as if they are new purchases (increase stock, WAC updated).
            // So, after reversal of initialPurchaseQuantity at initialPurchasePrice:
            // Product WAC and ShopSpecificCost would be effectively 0 if this were the only product/stock.
            // Then, adding newQuantity at updatedPriceForItem:
            // The new WACs should become updatedPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB reflects the change
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item quantity (decrease), recalculate stock and WACs", async ()=>{
            const quantityDecrease = 3;
            const newQuantity = initialPurchaseQuantity - quantityDecrease;
            expect(newQuantity).toBeGreaterThanOrEqual(0); // Ensure we don't go negative for this test logic
            const updatedPriceForItem = initialPurchasePrice; // Price remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = new _server.NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // Due to the reversal and re-addition logic of the PUT route:
            // The old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // So, new WACs should become updatedPriceForItem (which is initialPurchasePrice).
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item price, recalculate stock and WACs", async ()=>{
            const newPriceForItem = initialPurchasePrice + 25; // New price, e.g., 50 + 25 = 75
            const quantityUnchanged = initialPurchaseQuantity; // Quantity remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: quantityUnchanged,
                        price: newPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityUnchanged
                    }
                ]
            };
            const req = new _server.NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock (should be unchanged) and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(quantityUnchanged);
            // WAC logic in PUT: reverses old, adds new. So shopSpecificCost should reflect newPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(newPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(newPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(quantityUnchanged);
            expect(dbInvoice?.items[0].price).toBe(newPriceForItem);
            expect(dbInvoice?.total).toBe(quantityUnchanged * newPriceForItem);
        }, 15000); // Increased timeout
        it("should add a new item to an existing invoice, update stock and WACs", async ()=>{
            // 1. Define a new product for the new item
            const newItemProduct = await prisma.product.create({
                data: {
                    name: "Newly Added Product for PUT",
                    sku: "PUTNEW001",
                    price: 200
                }
            });
            const newItemProductId = newItemProduct.id;
            const newItemQuantity = 7;
            const newItemPrice = 120;
            // Original item details (from beforeEach setup)
            const originalItemProductId = productForUpdateTestsId;
            const originalItemQuantity = initialPurchaseQuantity;
            const originalItemPrice = initialPurchasePrice;
            // 2. Prepare the update payload with both original and new item
            const updatePayload = {
                items: [
                    {
                        productId: originalItemProductId.toString(),
                        quantity: originalItemQuantity,
                        price: originalItemPrice
                    },
                    {
                        productId: newItemProductId.toString(),
                        quantity: newItemQuantity,
                        price: newItemPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: originalItemQuantity
                    },
                    {
                        [createdShopId]: newItemQuantity
                    } // Distribution for new item
                ]
            };
            // 3. Simulate API call
            const req = new _server.NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                }
            });
            expect(dbInvoice?.items.length).toBe(2);
            const expectedTotal = originalItemQuantity * originalItemPrice + newItemQuantity * newItemPrice;
            expect(dbInvoice?.total).toBe(expectedTotal);
            // Find the items in the response (order might vary, so find by productId)
            const dbOriginalItem = dbInvoice?.items.find((item)=>item.productId === originalItemProductId);
            const dbNewItem = dbInvoice?.items.find((item)=>item.productId === newItemProductId);
            expect(dbOriginalItem).toBeDefined();
            expect(dbOriginalItem?.quantity).toBe(originalItemQuantity);
            expect(dbOriginalItem?.price).toBe(originalItemPrice);
            expect(dbNewItem).toBeDefined();
            expect(dbNewItem?.quantity).toBe(newItemQuantity);
            expect(dbNewItem?.price).toBe(newItemPrice);
            // Verify InventoryItem and Product WAC for the original item
            // (Due to PUT logic of reverse & re-add, WACs should reflect its current price)
            const originalInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: originalItemProductId,
                    shopId: createdShopId
                }
            });
            expect(originalInventory?.quantity).toBe(originalItemQuantity);
            expect(originalInventory?.shopSpecificCost).toBeCloseTo(originalItemPrice);
            const originalProduct = await prisma.product.findUnique({
                where: {
                    id: originalItemProductId
                }
            });
            expect(originalProduct?.weightedAverageCost).toBeCloseTo(originalItemPrice);
            // Verify InventoryItem and Product WAC for the NEW item
            const newInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newItemProductId,
                    shopId: createdShopId
                }
            });
            expect(newInventory?.quantity).toBe(newItemQuantity);
            expect(newInventory?.shopSpecificCost).toBeCloseTo(newItemPrice);
            const newProductDb = await prisma.product.findUnique({
                where: {
                    id: newItemProductId
                }
            });
            expect(newProductDb?.weightedAverageCost).toBeCloseTo(newItemPrice);
        }, 15000); // Increased timeout
        it("should remove an item from an existing invoice, update stock and WACs", async ()=>{
            // 1. Setup: Ensure an invoice with at least two items exists.
            // We'll use the existing `productForUpdateTestsId` and create one more product and item.
            const productToRemove = await prisma.product.create({
                data: {
                    name: "Product To Be Removed",
                    sku: "PUTRMV001",
                    price: 300
                }
            });
            const productToRemoveId = productToRemove.id;
            const productToRemoveQuantity = 4;
            const productToRemovePrice = 40;
            // Update the existing invoice (created in global beforeEach for PUT) to include this second item first.
            const addSecondItemPayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    },
                    {
                        productId: productToRemoveId.toString(),
                        quantity: productToRemoveQuantity,
                        price: productToRemovePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    },
                    {
                        [createdShopId]: productToRemoveQuantity
                    }
                ]
            };
            const addReq = new _server.NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(addSecondItemPayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route1.PUT)(addReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            // Sanity check: Invoice should have 2 items
            let invoiceWithTwoItems = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(invoiceWithTwoItems?.items.length).toBe(2);
            // 2. Prepare the update payload that only contains the item we want to keep.
            const updatePayloadToRemoveItem = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    } // Distribution for the kept item
                ]
            };
            // 3. Simulate API call to remove the item
            const removeReq = new _server.NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayloadToRemoveItem),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(removeReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB - should now have only 1 item
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(productForUpdateTestsId);
            expect(dbInvoice?.items[0].quantity).toBe(initialPurchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(initialPurchasePrice);
            expect(dbInvoice?.total).toBe(initialPurchaseQuantity * initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the KEPT item
            const keptInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(keptInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(keptInventory?.shopSpecificCost).toBeCloseTo(initialPurchasePrice);
            const keptProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(keptProduct?.weightedAverageCost).toBeCloseTo(initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the REMOVED item
            // Stock should be zero or the item might be gone from inventory if it was the only purchase
            // WAC on product should be 0 if no other purchases exist.
            const removedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productToRemoveId,
                    shopId: createdShopId
                }
            });
            // The PUT logic reverses stock. If this was the only stock, it becomes 0.
            expect(removedInventory?.quantity).toBe(0);
            // ShopSpecificCost might become 0 or NaN if quantity is 0. The API sets it to 0 for safety.
            expect(removedInventory?.shopSpecificCost).toBeCloseTo(0);
            const removedProductDb = await prisma.product.findUnique({
                where: {
                    id: productToRemoveId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfRemovedItem = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productToRemoveId
                }
            });
            if (otherPurchasesOfRemovedItem === 0) {
                expect(removedProductDb?.weightedAverageCost).toBeCloseTo(0);
            } // Else, it would be based on other purchases, which this test doesn't set up.
        }, 15000); // Increased timeout
    });
    describe("DELETE /api/purchases/:id (Delete Purchase Invoice)", ()=>{
        let invoiceToDeleteId;
        let productForDeleteTestId;
        const deleteTestInitialPrice = 60;
        const deleteTestInitialQuantity = 12;
        beforeEach(async ()=>{
            // Ensure product exists for the test
            const product = await prisma.product.create({
                data: {
                    name: "Product For Delete Test",
                    sku: "DELPROD001",
                    price: 100
                }
            });
            productForDeleteTestId = product.id;
            // Create an initial purchase invoice to be deleted
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productForDeleteTestId.toString(),
                        quantity: deleteTestInitialQuantity,
                        price: deleteTestInitialPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: deleteTestInitialQuantity
                    } // Explicit distribution
                ],
                totalAmount: deleteTestInitialQuantity * deleteTestInitialPrice,
                status: "paid"
            };
            const req = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(initialInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            invoiceToDeleteId = body.data.id;
            // Sanity check: verify initial state after creation
            const initialProductDB = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            expect(initialProductDB?.weightedAverageCost).toBe(deleteTestInitialPrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(deleteTestInitialQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(deleteTestInitialPrice);
        });
        it("should delete a purchase invoice and correctly reverse stock and WACs for a single-item invoice with explicit distribution", async ()=>{
            // 1. Call the DELETE endpoint
            const deleteReq = new _server.NextRequest(`http://localhost/api/purchases/${invoiceToDeleteId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceToDeleteId
                }
            });
            // 2. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 3. Verify PurchaseInvoice is deleted from DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceToDeleteId
                }
            });
            expect(dbInvoice).toBeNull();
            // 4. Verify PurchaseInvoiceItems are deleted
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceToDeleteId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock is reversed
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            // Assuming this was the only purchase, stock should be 0
            expect(updatedInventory?.quantity).toBe(0);
            // ShopSpecificCost should also be 0 if stock is 0
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated (should be 0 if this was the only purchase)
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfProduct = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productForDeleteTestId
                }
            });
            if (otherPurchasesOfProduct === 0) {
                expect(updatedProduct?.weightedAverageCost).toBeCloseTo(0);
            }
        });
        it("should delete a purchase and reverse stock/WAC when product is in a single inferred shop", async ()=>{
            // 1. Setup: Create dedicated entities for this test to ensure isolation.
            const testShop = await prisma.shop.create({
                data: {
                    name: "Inferred Delete Test Shop",
                    location: "Loc X"
                }
            });
            const testSupplier = await prisma.supplier.create({
                data: {
                    name: "Inferred Delete Test Supplier"
                }
            });
            const testProduct = await prisma.product.create({
                data: {
                    name: "Product for Inferred Delete",
                    sku: "INFDEL001",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            // Create an inventory item for this product in the test shop.
            // This makes it the "single inferred shop".
            await prisma.inventoryItem.create({
                data: {
                    productId: testProduct.id,
                    shopId: testShop.id,
                    quantity: 0,
                    shopSpecificCost: 0
                }
            });
            const purchaseQuantity = 12;
            const purchasePrice = 60;
            const inferredShopInvoicePayload = {
                supplierId: testSupplier.id.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: testProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                // NO distributions property here for inference to kick in on POST
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // Create the purchase invoice (this is where the failure was happening)
            const createReq = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(inferredShopInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201); // Assert successful creation
            const createBody = await createResponse.json();
            const invoiceIdForInferredDelete = createBody.data.id;
            // Sanity check: Verify stock and WAC after creation
            const inventoryAfterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(inventoryAfterCreate?.quantity).toBe(purchaseQuantity);
            expect(inventoryAfterCreate?.shopSpecificCost).toBeCloseTo(purchasePrice);
            const productAfterCreate = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(productAfterCreate?.weightedAverageCost).toBeCloseTo(purchasePrice);
            // 2. Call the DELETE endpoint
            const deleteReq = new _server.NextRequest(`http://localhost/api/purchases/${invoiceIdForInferredDelete}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceIdForInferredDelete
                }
            });
            // 3. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 4. Verify PurchaseInvoice and Items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock and shopSpecificCost are reversed in the inferred shop
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(updatedInventory?.quantity).toBe(0);
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated to 0
            const updatedProductDB = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(updatedProductDB?.weightedAverageCost).toBeCloseTo(0);
            // Cleanup dedicated entities for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: testProduct.id
                }
            });
            await prisma.product.delete({
                where: {
                    id: testProduct.id
                }
            });
            await prisma.supplier.delete({
                where: {
                    id: testSupplier.id
                }
            });
            await prisma.shop.delete({
                where: {
                    id: testShop.id
                }
            });
        }, 15000); // Added a longer timeout as a precaution
        it("should delete an invoice with multiple items, reversing stock/WAC for each", async ()=>{
            // 1. Setup: Create multiple products and an invoice with items from these products.
            // For simplicity, distribute each to the main createdShopId from global beforeEach.
            const productA = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod A",
                    sku: "MDEL00A",
                    price: 100,
                    weightedAverageCost: 0
                }
            });
            const productB = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod B",
                    sku: "MDEL00B",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            const quantityA = 5;
            const priceA = 50;
            const quantityB = 3;
            const priceB = 120;
            const multiItemInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productA.id.toString(),
                        quantity: quantityA,
                        price: priceA
                    },
                    {
                        productId: productB.id.toString(),
                        quantity: quantityB,
                        price: priceB
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityA
                    },
                    {
                        [createdShopId]: quantityB
                    } // Item B to main shop
                ],
                totalAmount: quantityA * priceA + quantityB * priceB,
                status: "paid"
            };
            const createReq = new _server.NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(multiItemInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201);
            const createBody = await createResponse.json();
            const multiItemInvoiceId = createBody.data.id;
            // Sanity check inventory and WAC after creation
            const invA_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterCreate?.quantity).toBe(quantityA);
            expect(invA_afterCreate?.shopSpecificCost).toBe(priceA);
            const prodA_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterCreate?.weightedAverageCost).toBe(priceA);
            const invB_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterCreate?.quantity).toBe(quantityB);
            expect(invB_afterCreate?.shopSpecificCost).toBe(priceB);
            const prodB_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterCreate?.weightedAverageCost).toBe(priceB);
            // 2. Call DELETE endpoint
            const deleteReq = new _server.NextRequest(`http://localhost/api/purchases/${multiItemInvoiceId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: multiItemInvoiceId
                }
            });
            expect(deleteResponse.status).toBe(200);
            // 3. Verify invoice and items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: multiItemInvoiceId
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: multiItemInvoiceId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 4. Verify stock and WAC for Product A are reversed
            const invA_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterDelete?.quantity).toBe(0);
            expect(invA_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodA_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // 5. Verify stock and WAC for Product B are reversed
            const invB_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterDelete?.quantity).toBe(0);
            expect(invB_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodB_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // Clean up products and their inventory items created for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
            await prisma.product.deleteMany({
                where: {
                    id: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
        }, 15000); // Timeout for safety
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvaW50ZWdyYXRpb24vcHVyY2hhc2VJbnZvaWNlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGplc3QtZW52aXJvbm1lbnQgbm9kZVxuICovXG5pbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tICdAcHJpc21hL2NsaWVudCc7XG5pbXBvcnQgeyBQT1NUIGFzIGNyZWF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvcm91dGUnOyAvLyBBZGp1c3QgaWYgZGlyZWN0IGltcG9ydCBpc24ndCBmZWFzaWJsZVxuaW1wb3J0IHsgUFVUIGFzIHVwZGF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuaW1wb3J0IHsgREVMRVRFIGFzIGRlbGV0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuaW1wb3J0IHsgTmV4dFJlcXVlc3QgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBjcmVhdGVNb2NrcyB9IGZyb20gJ25vZGUtbW9ja3MtaHR0cCc7IC8vIE9yIGFueSBvdGhlciB3YXkgdG8gbW9jayBOZXh0UmVxdWVzdC9SZXNwb25zZVxuXG5jb25zdCBwcmlzbWEgPSBuZXcgUHJpc21hQ2xpZW50KCk7XG5cbmRlc2NyaWJlKCdQdXJjaGFzZSBJbnZvaWNlIEFQSSBJbnRlZ3JhdGlvbiBUZXN0cycsICgpID0+IHtcbiAgICBsZXQgY3JlYXRlZFNob3BJZDogc3RyaW5nO1xuICAgIGxldCBjcmVhdGVkU3VwcGxpZXJJZDogbnVtYmVyO1xuICAgIGxldCBjcmVhdGVkUHJvZHVjdElkOiBudW1iZXI7XG5cbiAgICBiZWZvcmVBbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBTZWVkIGluaXRpYWwgZGF0YSBpZiBuZWNlc3NhcnksIGUuZy4sIGEgZGVmYXVsdCBzdXBwbGllciBvciBzaG9wXG4gICAgICAgIC8vIEZvciBub3csIHdlJ2xsIGNyZWF0ZSB0aGVtIGluIGJlZm9yZUVhY2ggb3Igc3BlY2lmaWMgdGVzdHNcbiAgICB9KTtcblxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBDbGVhbiB1cCBkYXRhYmFzZSB0YWJsZXMgdG8gZW5zdXJlIHRlc3QgaXNvbGF0aW9uXG4gICAgICAgIGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnByb2R1Y3QuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5zdXBwbGllci5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnNob3AuZGVsZXRlTWFueSh7fSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc2hvcCBmb3IgdGVzdGluZ1xuICAgICAgICBjb25zdCBzaG9wID0gYXdhaXQgcHJpc21hLnNob3AuY3JlYXRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnVGVzdCBTaG9wIExvY2FsJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1Rlc3QgTG9jYXRpb24nLFxuICAgICAgICAgICAgICAgIC8vIEFkZCBvdGhlciByZXF1aXJlZCBmaWVsZHMgaWYgYW55XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY3JlYXRlZFNob3BJZCA9IHNob3AuaWQ7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc3VwcGxpZXIgZm9yIHRlc3RpbmdcbiAgICAgICAgY29uc3Qgc3VwcGxpZXIgPSBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuY3JlYXRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnVGVzdCBTdXBwbGllciBMb2NhbCcsXG4gICAgICAgICAgICAgICAgLy8gQWRkIG90aGVyIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNyZWF0ZWRTdXBwbGllcklkID0gc3VwcGxpZXIuaWQ7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZHVjdCBmb3IgdGVzdGluZyB1cGRhdGVzL2RlbGV0ZXMgKG5vdCBmb3IgY3JlYXRlIG5ldyBwcm9kdWN0IHRlc3QpXG4gICAgICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdFeGlzdGluZyBQcm9kdWN0JyxcbiAgICAgICAgICAgICAgICBwcmljZTogMTAwLCAvLyByZXRhaWwgcHJpY2VcbiAgICAgICAgICAgICAgICBza3U6ICdFWElTVElORzAwMScsXG4gICAgICAgICAgICAgICAgc2hvcElkOiBjcmVhdGVkU2hvcElkLCAvLyBPcHRpb25hbDogYXNzb2NpYXRlIHdpdGggYSBzaG9wIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAvLyB3ZWlnaHRlZEF2ZXJhZ2VDb3N0IHdpbGwgYmUgc2V0IGJ5IHB1cmNoYXNlc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY3JlYXRlZFByb2R1Y3RJZCA9IHByb2R1Y3QuaWQ7XG4gICAgfSk7XG5cbiAgICBhZnRlckFsbChhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIENsZWFuIHVwIGRhdGFiYXNlIGFmdGVyIGFsbCB0ZXN0c1xuICAgICAgICBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5wcm9kdWN0LmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5zaG9wLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuJGRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdQT1NUIC9hcGkvcHVyY2hhc2VzIChDcmVhdGUgUHVyY2hhc2UgSW52b2ljZSknLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgcHVyY2hhc2UgaW52b2ljZSBmb3IgYSBuZXcgcHJvZHVjdCwgdXBkYXRlIGludmVudG9yeSwgYW5kIHNldCBXQUMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBEZWZpbmUgZGF0YSBmb3IgYSBuZXcgcHJvZHVjdFxuICAgICAgICAgICAgY29uc3QgbmV3UHJvZHVjdE5hbWUgPSAnQnJhbmQgTmV3IFJhY2tldCc7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9kdWN0U2t1ID0gJ05FV0IwMDEnO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZSA9IDE1MDtcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUXVhbnRpdHkgPSAxMDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHByb2R1Y3QgZmlyc3QgKGFzIEFQSSBleHBlY3RzIHByb2R1Y3RJZClcbiAgICAgICAgICAgIC8vIEluIGEgcmVhbCBzY2VuYXJpbywgdGhlIFVJIG1pZ2h0IGNyZWF0ZSBwcm9kdWN0IHRoZW4gcHVyY2hhc2UsIG9yIHB1cmNoYXNlIEFQSSBoYW5kbGVzIHByb2R1Y3QgY3JlYXRpb25cbiAgICAgICAgICAgIC8vIEZvciB0aGlzIHRlc3QsIGFzc3VtZSBwcm9kdWN0IGlzIGNyZWF0ZWQganVzdCBiZWZvcmUsIG9yIEFQSSBpbXBsaWVzIGl0cyBjcmVhdGlvbiBmcm9tIHB1cmNoYXNlIChub3QgY3VycmVudCBBUEkpXG4gICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgZm9yIG5vdyBwcm9kdWN0IG11c3QgZXhpc3QsIGlmIEFQSSBkb2Vzbid0IGNyZWF0ZSBpdCBmcm9tIHB1cmNoYXNlIGl0ZW1zLlxuICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgQVBJJ3MgUE9TVCAvYXBpL3B1cmNoYXNlcyBleHBlY3RzIGl0ZW0ucHJvZHVjdElkLCBpbXBseWluZyBwcm9kdWN0IGV4aXN0cy5cblxuICAgICAgICAgICAgY29uc3QgbmV3VGVzdFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmV3UHJvZHVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNrdTogbmV3UHJvZHVjdFNrdSxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDI1MCwgLy8gUmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgICAgIHNob3BJZDogY3JlYXRlZFNob3BJZCAvLyBPcHRpb25hbCBkZWZhdWx0IHNob3AgYXNzb2NpYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Rlc3RQcm9kdWN0SWQgPSBuZXdUZXN0UHJvZHVjdC5pZDtcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5IGZvciBQT1NUIC9hcGkvcHVyY2hhc2VzXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFsgLy8gRXhwbGljaXQgZGlzdHJpYnV0aW9uIGlzIGNydWNpYWwgYmFzZWQgb24gY3VycmVudCBQT1NUIEFQSVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IHB1cmNoYXNlUXVhbnRpdHkgKiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMy4gQ29uc3RydWN0IGEgTmV4dFJlcXVlc3QgaW5zdGFuY2VcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHB1cmNoYXNlSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHRoZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpOyAvLyBPciAyMDAgZGVwZW5kaW5nIG9uIHlvdXIgQVBJJ3Mgc3VjY2VzcyByZXNwb25zZSBmb3IgUE9TVFxuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogY3JlYXRlZEludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5zdXBwbGllcklkKS50b0JlKGNyZWF0ZWRTdXBwbGllcklkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShuZXdUZXN0UHJvZHVjdElkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGluIERCXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0gPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcElkOiBjcmVhdGVkU2hvcElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0pLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8ucXVhbnRpdHkpLnRvQmUocHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICAvLyBUaGUgUE9TVCByb3V0ZSBzZWVtcyB0byBjYWxjdWxhdGUgc2hvcFNwZWNpZmljQ29zdCB0b28uXG4gICAgICAgICAgICAvLyBXQUMgPSAoQ3VycmVudCBUb3RhbCBWYWx1ZSArIE5ldyBQdXJjaGFzZSBWYWx1ZSkgLyAoQ3VycmVudCBRdWFudGl0eSArIE5ldyBRdWFudGl0eSlcbiAgICAgICAgICAgIC8vIEZvciBuZXcgaXRlbSwgZXhpc3Rpbmcgc2hvcFNwZWNpZmljQ29zdCBpcyAwLCBjdXJyZW50UXVhbnRpdHkgaXMgMC5cbiAgICAgICAgICAgIC8vIFNvIG5ld1Nob3BTcGVjaWZpY0Nvc3Qgc2hvdWxkIGJlIG5ld0Nvc3QgKHB1cmNoYXNlUHJpY2UpXG4gICAgICAgICAgICBleHBlY3QoZGJJbnZlbnRvcnlJdGVtPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UpO1xuXG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQcm9kdWN0IFdBQyBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IG5ld1Rlc3RQcm9kdWN0SWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICAvLyBGb3IgYSBuZXcgcHJvZHVjdCwgV0FDIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgcHVyY2hhc2UgcHJpY2Ugb2YgdGhpcyBmaXJzdCBiYXRjaFxuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgcHVyY2hhc2UgZm9yIGFuIGV4aXN0aW5nIHByb2R1Y3QsIHVwZGF0ZSBpbnZlbnRvcnksIGFuZCByZWNhbGN1bGF0ZSBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMC4gSW5pdGlhbCBzdGF0ZTogUHJvZHVjdCBleGlzdHMsIHBvdGVudGlhbGx5IHdpdGggc29tZSBpbnZlbnRvcnkgYW5kIFdBQ1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFB1cmNoYXNlUHJpY2UgPSAxMjA7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDU7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3RJZCA9IGNyZWF0ZWRQcm9kdWN0SWQ7IC8vIEZyb20gYmVmb3JlRWFjaFxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gaW5pdGlhbCBwdXJjaGFzZSB0byBzZXQgdXAgZXhpc3RpbmcgaW52ZW50b3J5IGFuZCBXQUNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDg2NDAwMDAwKS50b0lTT1N0cmluZygpLCAvLyBZZXN0ZXJkYXlcbiAgICAgICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBleGlzdGluZ1Byb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiBpbml0aWFsUHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH1dLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAqIGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSZXEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbml0aWFsUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKGluaXRpYWxSZXEpO1xuXG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0QmVmb3JlTmV3UHVyY2hhc2UgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBjb25zdCBpbnZlbnRvcnlCZWZvcmVOZXdQdXJjaGFzZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogZXhpc3RpbmdQcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuXG4gICAgICAgICAgICBleHBlY3QocHJvZHVjdEJlZm9yZU5ld1B1cmNoYXNlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZlbnRvcnlCZWZvcmVOZXdQdXJjaGFzZT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGludmVudG9yeUJlZm9yZU5ld1B1cmNoYXNlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gMS4gRGVmaW5lIGRhdGEgZm9yIHRoZSBuZXcgcHVyY2hhc2Ugb2YgdGhlIGV4aXN0aW5nIHByb2R1Y3RcbiAgICAgICAgICAgIGNvbnN0IG5ld1B1cmNoYXNlUHJpY2UgPSAxMDA7XG4gICAgICAgICAgICBjb25zdCBuZXdQdXJjaGFzZVF1YW50aXR5ID0gODtcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogZXhpc3RpbmdQcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBuZXdQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld1B1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjcmVhdGVkU2hvcElkXTogbmV3UHVyY2hhc2VRdWFudGl0eVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogbmV3UHVyY2hhc2VRdWFudGl0eSAqIG5ld1B1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyAzLiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZEludm9pY2VJZCA9IHJlc3BvbnNlQm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbVxuICAgICAgICAgICAgY29uc3QgZGJJbnZlbnRvcnlJdGVtID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IGV4aXN0aW5nUHJvZHVjdElkLFxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbFF1YW50aXR5ID0gaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKyBuZXdQdXJjaGFzZVF1YW50aXR5O1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8ucXVhbnRpdHkpLnRvQmUoZXhwZWN0ZWRUb3RhbFF1YW50aXR5KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHNob3BTcGVjaWZpY0Nvc3QgcmVjYWxjdWxhdGlvblxuICAgICAgICAgICAgLy8gU1NDID0gKChvbGRRdHkgKiBvbGRTU0MpICsgKG5ld1F0eSAqIG5ld1ByaWNlKSkgLyAob2xkUXR5ICsgbmV3UXR5KVxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRTaG9wU3BlY2lmaWNDb3N0ID1cbiAgICAgICAgICAgICAgICAoKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UpICsgKG5ld1B1cmNoYXNlUXVhbnRpdHkgKiBuZXdQdXJjaGFzZVByaWNlKSkgL1xuICAgICAgICAgICAgICAgIChpbml0aWFsUHVyY2hhc2VRdWFudGl0eSArIG5ld1B1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oZXhwZWN0ZWRTaG9wU3BlY2lmaWNDb3N0KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDIHJlY2FsY3VsYXRpb25cbiAgICAgICAgICAgIC8vIFdBQyA9ICgob2xkVG90YWxRdHkgKiBvbGRXQUMpICsgKG5ld1B1cmNoYXNlUXR5ICogbmV3UHVyY2hhc2VQcmljZSkpIC8gKG5ld1RvdGFsUXR5ICsgbmV3UHVyY2hhc2VRdHkpXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHByb2R1Y3QgV0FDIHdhcyBpbml0aWFsUHVyY2hhc2VQcmljZSBmb3IgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkuXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFByb2R1Y3RXQUMgPVxuICAgICAgICAgICAgICAgICgoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKiBpbml0aWFsUHVyY2hhc2VQcmljZSkgKyAobmV3UHVyY2hhc2VRdWFudGl0eSAqIG5ld1B1cmNoYXNlUHJpY2UpKSAvXG4gICAgICAgICAgICAgICAgKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICsgbmV3UHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBjb25zdCBkYlByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhleHBlY3RlZFByb2R1Y3RXQUMpO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBwdXJjaGFzZSB3aXRoIG11bHRpcGxlIGl0ZW1zIGFuZCB1cGRhdGUgaW52ZW50b3J5L1dBQyBmb3IgZWFjaCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSB0d28gZGlzdGluY3QgcHJvZHVjdHMgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdDFEYXRhID0geyBuYW1lOiAnTXVsdGlJdGVtIFByb2R1Y3QgQScsIHNrdTogJ01VTFRJMDAxJywgcHJpY2U6IDUwLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QyRGF0YSA9IHsgbmFtZTogJ011bHRpSXRlbSBQcm9kdWN0IEInLCBza3U6ICdNVUxUSTAwMicsIHByaWNlOiA3NSwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH07XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0MSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7IGRhdGE6IHByb2R1Y3QxRGF0YSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QyID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHsgZGF0YTogcHJvZHVjdDJEYXRhIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlMSA9IDQwO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eTEgPSA1O1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZTIgPSA2MDtcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUXVhbnRpdHkyID0gMztcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdDEuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwdXJjaGFzZVByaWNlMSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Mi5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHkyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogWyAvLyBFeHBsaWNpdCBkaXN0cmlidXRpb24gZm9yIGVhY2ggaXRlbVxuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcHVyY2hhc2VRdWFudGl0eTEgfSwgLy8gRGlzdHJpYnV0aW9uIGZvciBpdGVtIDFcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHkyIH0gIC8vIERpc3RyaWJ1dGlvbiBmb3IgaXRlbSAyXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogKHB1cmNoYXNlUXVhbnRpdHkxICogcHVyY2hhc2VQcmljZTEpICsgKHB1cmNoYXNlUXVhbnRpdHkyICogcHVyY2hhc2VQcmljZTIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMy4gU2ltdWxhdGUgQVBJIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHB1cmNoYXNlSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIDQuIEFzc2VydGlvbnNcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBhbmQgaXRzIGl0ZW1zXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBjcmVhdGVkSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogeyBvcmRlckJ5OiB7IHByb2R1Y3RJZDogJ2FzYycgfSB9IH0gLy8gT3JkZXIgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYXNzZXJ0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcbiAgICAgICAgICAgIC8vIEFzc3VtaW5nIHByb2R1Y3QxLmlkIDwgcHJvZHVjdDIuaWQgZHVlIHRvIGNyZWF0aW9uIG9yZGVyIGZvciBjb25zaXN0ZW50IGNoZWNrc1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkUHJvZHVjdHMgPSBbcHJvZHVjdDEsIHByb2R1Y3QyXS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1swXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5MSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzFdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1sxXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5Mik7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMik7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAxXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0xID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QxLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTE/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0xPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UxKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDEgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QxLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0MT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAyXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0yID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QyLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTI/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkyKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0yPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UyKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QyLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Mj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMik7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIGRpc3RyaWJ1dGUgYSBzaW5nbGUgcHVyY2hhc2UgaXRlbSB0byBtdWx0aXBsZSBzaG9wcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSB0d28gbmV3IHNob3BzIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgIGNvbnN0IHNob3BBID0gYXdhaXQgcHJpc21hLnNob3AuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnVGVzdCBTaG9wIEEnLCBsb2NhdGlvbjogJ0xvYyBBJyB9IH0pO1xuICAgICAgICAgICAgY29uc3Qgc2hvcEIgPSBhd2FpdCBwcmlzbWEuc2hvcC5jcmVhdGUoeyBkYXRhOiB7IG5hbWU6ICdUZXN0IFNob3AgQicsIGxvY2F0aW9uOiAnTG9jIEInIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIDIuIENyZWF0ZSBhIG5ldyBwcm9kdWN0XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnU3BsaXQgUHJvZHVjdCcsIHNrdTogJ1NQTElUMDAxJywgcHJpY2U6IDIwMCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZSA9IDE4MDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsUXVhbnRpdHkgPSAxMDtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5Rm9yU2hvcEEgPSA2O1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlGb3JTaG9wQiA9IDQ7XG5cbiAgICAgICAgICAgIGV4cGVjdChxdWFudGl0eUZvclNob3BBICsgcXVhbnRpdHlGb3JTaG9wQikudG9CZSh0b3RhbFF1YW50aXR5KTsgLy8gU2FuaXR5IGNoZWNrXG5cbiAgICAgICAgICAgIC8vIDMuIFByZXBhcmUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHRvdGFsUXVhbnRpdHksIC8vIFRvdGFsIHF1YW50aXR5IGZvciB0aGUgaXRlbSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyAvLyBEaXN0cmlidXRpb24gZm9yIHRoZSBzaW5nbGUgaXRlbSwgc3BsaXQgaW50byB0d28gc2hvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzaG9wQS5pZF06IHF1YW50aXR5Rm9yU2hvcEEsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2hvcEIuaWRdOiBxdWFudGl0eUZvclNob3BCLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogdG90YWxRdWFudGl0eSAqIHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyA0LiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNS4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBmb3IgU2hvcCBBXG4gICAgICAgICAgICBjb25zdCBpbnZJdGVtQSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0LmlkLCBzaG9wSWQ6IHNob3BBLmlkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1BKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlGb3JTaG9wQSk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUE/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGZvciBTaG9wIEJcbiAgICAgICAgICAgIGNvbnN0IGludkl0ZW1CID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QuaWQsIHNob3BJZDogc2hvcEIuaWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUIpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1CPy5xdWFudGl0eSkudG9CZShxdWFudGl0eUZvclNob3BCKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQj8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDIChzaG91bGQgYmUgdGhlIHB1cmNoYXNlIHByaWNlIGFzIGl0J3MgYWxsIG5ldyBzdG9jaylcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgZmFpbCB0byBjcmVhdGUgYSBwdXJjaGFzZSBpZiBhIHByb2R1Y3RJZCBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vbkV4aXN0ZW50UHJvZHVjdElkID0gOTk5OTk5OyAvLyBBc3N1bWluZyB0aGlzIElEIHdvbid0IGV4aXN0XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gMTAwO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eSA9IDU7XG5cbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBub25FeGlzdGVudFByb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IHB1cmNoYXNlUXVhbnRpdHkgKiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcblxuICAgICAgICAgICAgLy8gRXhwZWN0IGEgY2xpZW50IGVycm9yIChlLmcuLCA0MDAgb3IgNDA0KSBvciBwb3RlbnRpYWxseSA1MDAgaWYgbm90IGhhbmRsZWQgZ3JhY2VmdWxseVxuICAgICAgICAgICAgLy8gRm9yIHJvYnVzdCBlcnJvciBoYW5kbGluZywgQVBJIHNob3VsZCByZXR1cm4gc3BlY2lmaWMgZXJyb3IgY29kZS5cbiAgICAgICAgICAgIC8vIFByaXNtYSB3aWxsIHRocm93IGFuIGVycm9yIGlmIGEgcmVsYXRlZCByZWNvcmQgKHByb2R1Y3QpIGlzIG5vdCBmb3VuZCBmb3IgZm9yZWlnbiBrZXkuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiBhIDUwMCBpZiBub3QgY2F1Z2h0IGFuZCBoYW5kbGVkIGJ5IHRoZSBBUEkgcm91dGUuXG4gICAgICAgICAgICAvLyBMZXQncyBhaW0gZm9yIHRoZSBBUEkgdG8gY2F0Y2ggdGhpcyBhbmQgcmV0dXJuIGEgbW9yZSBzcGVjaWZpYyBjbGllbnQgZXJyb3IuXG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBjaGVjayBpZiBpdCdzIE5PVCBhIHN1Y2Nlc3MgKDIwMSkuXG4gICAgICAgICAgICAvLyBBIG1vcmUgcHJlY2lzZSBjaGVjayB3b3VsZCBiZSBmb3IgNDAwLzQwNC80MjIgZGVwZW5kaW5nIG9uIHBsYW5uZWQgZXJyb3IgaGFuZGxpbmcuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7IC8vIE9yIDQwMC80MDQgaWYgeW91IGltcGxlbWVudCBzcGVjaWZpYyBlcnJvciBoYW5kbGluZ1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSwgY2hlY2sgZm9yIGEgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSBvciBjb2RlIGlmIHlvdXIgQVBJIHByb3ZpZGVzIG9uZS5cbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgZmFpbCB0byBjcmVhdGUgYSBwdXJjaGFzZSBpZiBhIHN1cHBsaWVySWQgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXN0UHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBGb3IgSW52YWxpZCBTdXBwbGllciBUZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnSU5WIFNVUDAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAxMDAsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gODA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gNTtcbiAgICAgICAgICAgIGNvbnN0IG5vbkV4aXN0ZW50U3VwcGxpZXJJZCA9IDk5OTk5OTsgLy8gQXNzdW1pbmcgdGhpcyBJRCB3b24ndCBleGlzdFxuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IG5vbkV4aXN0ZW50U3VwcGxpZXJJZC50b1N0cmluZygpLCAvLyBJbnZhbGlkIHN1cHBsaWVyXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3QuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBwdXJjaGFzZVF1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBwdXJjaGFzZVF1YW50aXR5ICogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHB1cmNoYXNlSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTsgLy8gRXhwZWN0aW5nIDUwMCBhcyBQcmlzbWEgdGhyb3dzIFAyMDAzXG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1BVVCAvYXBpL3B1cmNoYXNlcy86aWQgKFVwZGF0ZSBQdXJjaGFzZSBJbnZvaWNlKScsICgpID0+IHtcbiAgICAgICAgbGV0IGV4aXN0aW5nSW52b2ljZUlkOiBzdHJpbmc7XG4gICAgICAgIGxldCBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZDogbnVtYmVyO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VQcmljZSA9IDUwO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDEwO1xuXG4gICAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZHVjdCBzcGVjaWZpY2FsbHkgZm9yIHRoZXNlIHVwZGF0ZS9kZWxldGUgdGVzdHMgaWYgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gVGhlIGdsb2JhbCBjcmVhdGVkUHJvZHVjdElkIGNhbiBiZSB1c2VkIGlmIGl0IGZpdHMsIG9yIG1ha2UgYSBuZXcgb25lLlxuICAgICAgICAgICAgLy8gTGV0J3MgdXNlIHRoZSBnbG9iYWwgb25lIGZvciBzaW1wbGljaXR5LCBhc3N1bWluZyBiZWZvcmVFYWNoIGNsZWFucyBpdCB1cC5cbiAgICAgICAgICAgIHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkID0gY3JlYXRlZFByb2R1Y3RJZDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGluaXRpYWwgcHVyY2hhc2UgaW52b2ljZSB0byBiZSB1cGRhdGVkIG9yIGRlbGV0ZWQgaW4gdGVzdHNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSA4NjQwMDAwMCkudG9JU09TdHJpbmcoKSwgLy8gWWVzdGVyZGF5XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoaW5pdGlhbEludm9pY2VQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBleGlzdGluZ0ludm9pY2VJZCA9IGJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrOiB2ZXJpZnkgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbFByb2R1Y3Q/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGluaXRpYWxJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgaXRlbSBxdWFudGl0eSAoaW5jcmVhc2UpLCByZWNhbGN1bGF0ZSBzdG9jayBhbmQgV0FDcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5SW5jcmVhc2UgPSA1O1xuICAgICAgICAgICAgY29uc3QgbmV3UXVhbnRpdHkgPSBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSArIHF1YW50aXR5SW5jcmVhc2U7XG4gICAgICAgICAgICAvLyBQcmljZSByZW1haW5zIHRoZSBzYW1lIGZvciB0aGlzIGl0ZW0gaW4gdGhpcyB1cGRhdGUgc2NlbmFyaW9cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcmljZUZvckl0ZW0gPSBpbml0aWFsUHVyY2hhc2VQcmljZTtcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNlbmQgdGhlIGNvbXBsZXRlIHN0cnVjdHVyZSBleHBlY3RlZCBieSB0aGUgUFVUIHJvdXRlXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpbmNsdWRlcyBhbGwgaXRlbXMsIGV2ZW4gaWYgb25seSBvbmUgaXMgY2hhbmdpbmcuXG4gICAgICAgICAgICAgICAgLy8gVGhlIFBVVCByb3V0ZSBsb2dpYyBtaWdodCBjb21wYXJlIHdpdGggZXhpc3RpbmcgaXRlbXMgdG8gc2VlIHdoYXQgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaXRlbSBoYWQgYW4gSUQgKFB1cmNoYXNlSW52b2ljZUl0ZW0gaWQpLCBpdCBtaWdodCBiZSBuZWVkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgZm9yIG5vdyB0aGUgUFVUIG1hdGNoZXMgaXRlbXMgYmFzZWQgb24gcHJvZHVjdElkIGlmIG5vdCBpdGVtIElELlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFzZWQgb24gY3VycmVudCBQVVQgcm91dGUsIGl0IGV4cGVjdHMgcHJvZHVjdElkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IG5ld1F1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHVwZGF0ZWRQcmljZUZvckl0ZW0sIC8vIFNlbmQgdGhlIG9yaWdpbmFsIHByaWNlIGlmIGl0IGhhc24ndCBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRpc3RyaWJ1dGlvbnMgaW4gUFVUIG1pZ2h0IG5lZWQgdG8gcmVmbGVjdCB0aGUgKm5ldyB0b3RhbCogZm9yIHRoZSBpdGVtXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBuZXdRdWFudGl0eSB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyBPdGhlciBmaWVsZHMgbGlrZSBzdXBwbGllcklkLCBkYXRlLCB0b3RhbEFtb3VudCBtaWdodCBiZSB1cGRhdGFibGUgdG9vLlxuICAgICAgICAgICAgICAgIC8vIEZvciB0aGlzIHRlc3QsIGZvY3VzIG9uIGl0ZW0gcXVhbnRpdHkgY2hhbmdlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBQVVQgcm91dGUgcmVjYWxjdWxhdGVzIHRvdGFsQW1vdW50IGJhc2VkIG9uIGl0ZW1zIGlmIG5vdCBwcm92aWRlZCBvciBpZiBpdGVtcyBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgLy8gTGV0J3MgYXNzdW1lIHRvdGFsQW1vdW50IHdpbGwgYmUgcmVjYWxjdWxhdGVkIGJ5IHRoZSBBUEkuXG4gICAgICAgICAgICAgICAgLy8gc3VwcGxpZXJJZCBhbmQgZGF0ZSBjb3VsZCBiZSBwYXJ0IG9mIHRoZSBwYXlsb2FkIGlmIHRoZXkgYXJlIHVwZGF0YWJsZS5cbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCBrZWVwaW5nIGl0IG1pbmltYWwgdG8gdGVzdCBpdGVtIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgUFVUIGhhbmRsZXIgcmUtY2FsY3VsYXRlcyB0b3RhbCBhbW91bnQsIHNvIG5vdCBzZW5kaW5nIGl0LlxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtleGlzdGluZ0ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IE5lZWQgdG8gcGFzcyByb3V0ZSBwYXJhbXMgZm9yIFtpZF0gdG8gdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG5vdCBzdGFuZGFyZCBOZXh0UmVxdWVzdCBidXQgaG93IHRlc3Qgc2V0dXAgbWlnaHQgbmVlZCBpdCBvciBob3cgaGFuZGxlciBleHBlY3RzIGl0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBhY3R1YWwgaGFuZGxlciBgdXBkYXRlUHVyY2hhc2VJbnZvaWNlKHJlcXVlc3Q6IE5leHRSZXF1ZXN0LCB7IHBhcmFtcyB9OiB7IHBhcmFtczogeyBpZDogc3RyaW5nIH0gfSlgXG4gICAgICAgICAgICAgICAgLy8gbmVlZHMgYHBhcmFtc2AuIG5vZGUtbW9ja3MtaHR0cCBgY3JlYXRlTW9ja3NgIGhhbmRsZXMgdGhpcyB3ZWxsLlxuICAgICAgICAgICAgICAgIC8vIEZvciBkaXJlY3QgTmV4dFJlcXVlc3QsIHdlIHBhc3MgaXQgaW4gY29udGV4dCB0byB0aGUgaGFuZGxlciBjYWxsLlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIEFQSSBjYWxsIC0gdXBkYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSwgeyBwYXJhbXM6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0gfSlcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaG93IHlvdSBjYWxsIGl0IGlmIHlvdSBhcmUgdGVzdGluZyB0aGUgaGFuZGxlciBkaXJlY3RseSBpbiBKZXN0IHdpdGggY29udGV4dFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVxLCB7IHBhcmFtczogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnLCBleGlzdGluZ0ludm9pY2VJZCk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIHN0b2NrIGFuZCBzaG9wU3BlY2lmaWNDb3N0XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUobmV3UXVhbnRpdHkpO1xuXG4gICAgICAgICAgICAvLyBXQUMgY2FsY3VsYXRpb246ICgob2xkUXR5ICogb2xkU1NDKSArIChhZGRlZFF0eSAqIHByaWNlT2ZBZGRlZFF0eSkpIC8gKG5ld1RvdGFsUXR5KVxuICAgICAgICAgICAgLy8gSW4gdGhpcyBzcGVjaWZpYyB1cGRhdGUsIHRoZSBQVVQgcm91dGUgcmV2ZXJzZXMgdGhlIG9sZCBpdGVtIGFuZCBhZGRzIHRoZSBuZXcgb25lIGFzIGlmIGl0J3MgYSBuZXcgcHVyY2hhc2UgbGluZSBmb3IgV0FDIGNhbGNzLlxuICAgICAgICAgICAgLy8gU28sIHRoZSBvbGQgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgYXQgaW5pdGlhbFB1cmNoYXNlUHJpY2UgaXMgcmV2ZXJzZWQuXG4gICAgICAgICAgICAvLyBUaGVuLCBuZXdRdWFudGl0eSBhdCB1cGRhdGVkUHJpY2VGb3JJdGVtIGlzIGFkZGVkLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlIGN1cnJlbnQgUFVUIGxvZ2ljIGZpcnN0IHJldmVyc2VzICphbGwqIG9sZCBpdGVtcyBiYXNlZCBvbiB0aGVpciAqb3JpZ2luYWwqIHJlY29yZGVkIGNvc3QuXG4gICAgICAgICAgICAvLyBUaGVuIGl0IGFkZHMgKmFsbCogbmV3IGl0ZW1zIGJhc2VkIG9uIHRoZWlyICpuZXcqIGNvc3QuXG4gICAgICAgICAgICAvLyBTbyBmb3IgdGhlIHByb2R1Y3QgV0FDOiAoVG90YWxWYWx1ZUJlZm9yZSAtIE9sZEl0ZW1WYWx1ZSArIE5ld0l0ZW1WYWx1ZSkgLyAoVG90YWxTdG9ja0JlZm9yZSAtIE9sZEl0ZW1RdHkgKyBOZXdJdGVtUXR5KVxuICAgICAgICAgICAgLy8gQW5kIGZvciBzaG9wIHNwZWNpZmljIFdBQzogKFNob3BWYWx1ZUJlZm9yZSAtIE9sZEl0ZW1WYWx1ZUluU2hvcCArIE5ld0l0ZW1WYWx1ZUluU2hvcCkgLyAoU2hvcFN0b2NrQmVmb3JlIC0gT2xkSXRlbVF0eUluU2hvcCArIE5ld0l0ZW1RdHlJblNob3ApXG5cbiAgICAgICAgICAgIC8vIExldCdzIGNoZWNrIHRoZSBsb2dpYyBmcm9tIHNyYy9hcHAvYXBpL3B1cmNoYXNlcy9baWRdL3JvdXRlLnRzXG4gICAgICAgICAgICAvLyAxLiBJdCBmZXRjaGVzIHRoZSBvbGQgaW52b2ljZS5cbiAgICAgICAgICAgIC8vIDIuIEl0IHJldmVyc2VzIGludmVudG9yeSBhZGp1c3RtZW50cyBmb3IgQUxMIG9sZCBpdGVtcyAoZGVjcmVhc2Ugc3RvY2ssIFdBQyB1cGRhdGVkKS5cbiAgICAgICAgICAgIC8vIDMuIEl0IHByb2Nlc3NlcyBBTEwgbmV3L3VwZGF0ZWQgaXRlbXMgYXMgaWYgdGhleSBhcmUgbmV3IHB1cmNoYXNlcyAoaW5jcmVhc2Ugc3RvY2ssIFdBQyB1cGRhdGVkKS5cblxuICAgICAgICAgICAgLy8gU28sIGFmdGVyIHJldmVyc2FsIG9mIGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IGF0IGluaXRpYWxQdXJjaGFzZVByaWNlOlxuICAgICAgICAgICAgLy8gUHJvZHVjdCBXQUMgYW5kIFNob3BTcGVjaWZpY0Nvc3Qgd291bGQgYmUgZWZmZWN0aXZlbHkgMCBpZiB0aGlzIHdlcmUgdGhlIG9ubHkgcHJvZHVjdC9zdG9jay5cbiAgICAgICAgICAgIC8vIFRoZW4sIGFkZGluZyBuZXdRdWFudGl0eSBhdCB1cGRhdGVkUHJpY2VGb3JJdGVtOlxuICAgICAgICAgICAgLy8gVGhlIG5ldyBXQUNzIHNob3VsZCBiZWNvbWUgdXBkYXRlZFByaWNlRm9ySXRlbS5cbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8odXBkYXRlZFByaWNlRm9ySXRlbSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQdXJjaGFzZUludm9pY2VJdGVtIGluIERCIHJlZmxlY3RzIHRoZSBjaGFuZ2VcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShuZXdRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZSh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/LnRvdGFsKS50b0JlKG5ld1F1YW50aXR5ICogdXBkYXRlZFByaWNlRm9ySXRlbSk7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSBpdGVtIHF1YW50aXR5IChkZWNyZWFzZSksIHJlY2FsY3VsYXRlIHN0b2NrIGFuZCBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlEZWNyZWFzZSA9IDM7XG4gICAgICAgICAgICBjb25zdCBuZXdRdWFudGl0eSA9IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IC0gcXVhbnRpdHlEZWNyZWFzZTtcbiAgICAgICAgICAgIGV4cGVjdChuZXdRdWFudGl0eSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTsgLy8gRW5zdXJlIHdlIGRvbid0IGdvIG5lZ2F0aXZlIGZvciB0aGlzIHRlc3QgbG9naWNcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByaWNlRm9ySXRlbSA9IGluaXRpYWxQdXJjaGFzZVByaWNlOyAvLyBQcmljZSByZW1haW5zIHRoZSBzYW1lXG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IG5ld1F1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHVwZGF0ZWRQcmljZUZvckl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IG5ld1F1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtleGlzdGluZ0ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgYW5kIHNob3BTcGVjaWZpY0Nvc3RcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZShuZXdRdWFudGl0eSk7XG5cbiAgICAgICAgICAgIC8vIER1ZSB0byB0aGUgcmV2ZXJzYWwgYW5kIHJlLWFkZGl0aW9uIGxvZ2ljIG9mIHRoZSBQVVQgcm91dGU6XG4gICAgICAgICAgICAvLyBUaGUgb2xkIGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IGF0IGluaXRpYWxQdXJjaGFzZVByaWNlIGlzIHJldmVyc2VkLlxuICAgICAgICAgICAgLy8gVGhlbiwgbmV3UXVhbnRpdHkgYXQgdXBkYXRlZFByaWNlRm9ySXRlbSBpcyBhZGRlZC5cbiAgICAgICAgICAgIC8vIFNvLCBuZXcgV0FDcyBzaG91bGQgYmVjb21lIHVwZGF0ZWRQcmljZUZvckl0ZW0gKHdoaWNoIGlzIGluaXRpYWxQdXJjaGFzZVByaWNlKS5cbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8odXBkYXRlZFByaWNlRm9ySXRlbSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQdXJjaGFzZUludm9pY2VJdGVtIGluIERCXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXMubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucXVhbnRpdHkpLnRvQmUobmV3UXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUodXBkYXRlZFByaWNlRm9ySXRlbSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy50b3RhbCkudG9CZShuZXdRdWFudGl0eSAqIHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgaXRlbSBwcmljZSwgcmVjYWxjdWxhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdQcmljZUZvckl0ZW0gPSBpbml0aWFsUHVyY2hhc2VQcmljZSArIDI1OyAvLyBOZXcgcHJpY2UsIGUuZy4sIDUwICsgMjUgPSA3NVxuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlVbmNoYW5nZWQgPSBpbml0aWFsUHVyY2hhc2VRdWFudGl0eTsgLy8gUXVhbnRpdHkgcmVtYWlucyB0aGUgc2FtZVxuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBxdWFudGl0eVVuY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBuZXdQcmljZUZvckl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHF1YW50aXR5VW5jaGFuZ2VkIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIHRvdGFsQW1vdW50IHdpbGwgYmUgcmVjYWxjdWxhdGVkIGJ5IHRoZSBBUElcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7ZXhpc3RpbmdJbnZvaWNlSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVxLCB7IHBhcmFtczogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnLCBleGlzdGluZ0ludm9pY2VJZCk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIHN0b2NrIChzaG91bGQgYmUgdW5jaGFuZ2VkKSBhbmQgc2hvcFNwZWNpZmljQ29zdFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKHF1YW50aXR5VW5jaGFuZ2VkKTtcbiAgICAgICAgICAgIC8vIFdBQyBsb2dpYyBpbiBQVVQ6IHJldmVyc2VzIG9sZCwgYWRkcyBuZXcuIFNvIHNob3BTcGVjaWZpY0Nvc3Qgc2hvdWxkIHJlZmxlY3QgbmV3UHJpY2VGb3JJdGVtLlxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKG5ld1ByaWNlRm9ySXRlbSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQcm9kdWN0IFdBQ1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZFByb2R1Y3Q/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKG5ld1ByaWNlRm9ySXRlbSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQdXJjaGFzZUludm9pY2VJdGVtIGluIERCXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXMubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlVbmNoYW5nZWQpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUobmV3UHJpY2VGb3JJdGVtKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/LnRvdGFsKS50b0JlKHF1YW50aXR5VW5jaGFuZ2VkICogbmV3UHJpY2VGb3JJdGVtKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgYWRkIGEgbmV3IGl0ZW0gdG8gYW4gZXhpc3RpbmcgaW52b2ljZSwgdXBkYXRlIHN0b2NrIGFuZCBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gRGVmaW5lIGEgbmV3IHByb2R1Y3QgZm9yIHRoZSBuZXcgaXRlbVxuICAgICAgICAgICAgY29uc3QgbmV3SXRlbVByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ05ld2x5IEFkZGVkIFByb2R1Y3QgZm9yIFBVVCcsXG4gICAgICAgICAgICAgICAgICAgIHNrdTogJ1BVVE5FVzAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAyMDAsIC8vIFJldGFpbCBwcmljZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbVByb2R1Y3RJZCA9IG5ld0l0ZW1Qcm9kdWN0LmlkO1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbVF1YW50aXR5ID0gNztcbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1QcmljZSA9IDEyMDtcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgaXRlbSBkZXRhaWxzIChmcm9tIGJlZm9yZUVhY2ggc2V0dXApXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQgPSBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZDtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbVF1YW50aXR5ID0gaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEl0ZW1QcmljZSA9IGluaXRpYWxQdXJjaGFzZVByaWNlO1xuXG4gICAgICAgICAgICAvLyAyLiBQcmVwYXJlIHRoZSB1cGRhdGUgcGF5bG9hZCB3aXRoIGJvdGggb3JpZ2luYWwgYW5kIG5ldyBpdGVtXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogb3JpZ2luYWxJdGVtUHJvZHVjdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogb3JpZ2luYWxJdGVtUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogb3JpZ2luYWxJdGVtUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3SXRlbVByb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IG5ld0l0ZW1RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBuZXdJdGVtUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IG9yaWdpbmFsSXRlbVF1YW50aXR5IH0sIC8vIERpc3RyaWJ1dGlvbiBmb3Igb3JpZ2luYWwgaXRlbVxuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogbmV3SXRlbVF1YW50aXR5IH0gICAgICAvLyBEaXN0cmlidXRpb24gZm9yIG5ldyBpdGVtXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyB0b3RhbEFtb3VudCB3aWxsIGJlIHJlY2FsY3VsYXRlZCBieSB0aGUgQVBJXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyAzLiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtleGlzdGluZ0ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVxLCB7IHBhcmFtczogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnLCBleGlzdGluZ0ludm9pY2VJZCk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQdXJjaGFzZUludm9pY2UgaW4gREJcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogeyBvcmRlckJ5OiB7IHByb2R1Y3RJZDogJ2FzYycgfSB9IH0sIC8vIE9yZGVyIGZvciBjb25zaXN0ZW50IGNoZWNrc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMik7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVG90YWwgPSAob3JpZ2luYWxJdGVtUXVhbnRpdHkgKiBvcmlnaW5hbEl0ZW1QcmljZSkgKyAobmV3SXRlbVF1YW50aXR5ICogbmV3SXRlbVByaWNlKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/LnRvdGFsKS50b0JlKGV4cGVjdGVkVG90YWwpO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpdGVtcyBpbiB0aGUgcmVzcG9uc2UgKG9yZGVyIG1pZ2h0IHZhcnksIHNvIGZpbmQgYnkgcHJvZHVjdElkKVxuICAgICAgICAgICAgY29uc3QgZGJPcmlnaW5hbEl0ZW0gPSBkYkludm9pY2U/Lml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLnByb2R1Y3RJZCA9PT0gb3JpZ2luYWxJdGVtUHJvZHVjdElkKTtcbiAgICAgICAgICAgIGNvbnN0IGRiTmV3SXRlbSA9IGRiSW52b2ljZT8uaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ucHJvZHVjdElkID09PSBuZXdJdGVtUHJvZHVjdElkKTtcblxuICAgICAgICAgICAgZXhwZWN0KGRiT3JpZ2luYWxJdGVtKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGRiT3JpZ2luYWxJdGVtPy5xdWFudGl0eSkudG9CZShvcmlnaW5hbEl0ZW1RdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoZGJPcmlnaW5hbEl0ZW0/LnByaWNlKS50b0JlKG9yaWdpbmFsSXRlbVByaWNlKTtcblxuICAgICAgICAgICAgZXhwZWN0KGRiTmV3SXRlbSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChkYk5ld0l0ZW0/LnF1YW50aXR5KS50b0JlKG5ld0l0ZW1RdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoZGJOZXdJdGVtPy5wcmljZSkudG9CZShuZXdJdGVtUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBhbmQgUHJvZHVjdCBXQUMgZm9yIHRoZSBvcmlnaW5hbCBpdGVtXG4gICAgICAgICAgICAvLyAoRHVlIHRvIFBVVCBsb2dpYyBvZiByZXZlcnNlICYgcmUtYWRkLCBXQUNzIHNob3VsZCByZWZsZWN0IGl0cyBjdXJyZW50IHByaWNlKVxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogb3JpZ2luYWxJdGVtUHJvZHVjdElkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3Qob3JpZ2luYWxJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKG9yaWdpbmFsSXRlbVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChvcmlnaW5hbEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8ob3JpZ2luYWxJdGVtUHJpY2UpO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChvcmlnaW5hbFByb2R1Y3Q/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKG9yaWdpbmFsSXRlbVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gYW5kIFByb2R1Y3QgV0FDIGZvciB0aGUgTkVXIGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IG5ld0ludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBuZXdJdGVtUHJvZHVjdElkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QobmV3SW52ZW50b3J5Py5xdWFudGl0eSkudG9CZShuZXdJdGVtUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KG5ld0ludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8obmV3SXRlbVByaWNlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb2R1Y3REYiA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogbmV3SXRlbVByb2R1Y3RJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KG5ld1Byb2R1Y3REYj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8obmV3SXRlbVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgcmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBleGlzdGluZyBpbnZvaWNlLCB1cGRhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBTZXR1cDogRW5zdXJlIGFuIGludm9pY2Ugd2l0aCBhdCBsZWFzdCB0d28gaXRlbXMgZXhpc3RzLlxuICAgICAgICAgICAgLy8gV2UnbGwgdXNlIHRoZSBleGlzdGluZyBgcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWRgIGFuZCBjcmVhdGUgb25lIG1vcmUgcHJvZHVjdCBhbmQgaXRlbS5cbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RUb1JlbW92ZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBUbyBCZSBSZW1vdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnUFVUUk1WMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDMwMCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RUb1JlbW92ZUlkID0gcHJvZHVjdFRvUmVtb3ZlLmlkO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdFRvUmVtb3ZlUXVhbnRpdHkgPSA0O1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdFRvUmVtb3ZlUHJpY2UgPSA0MDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnZvaWNlIChjcmVhdGVkIGluIGdsb2JhbCBiZWZvcmVFYWNoIGZvciBQVVQpIHRvIGluY2x1ZGUgdGhpcyBzZWNvbmQgaXRlbSBmaXJzdC5cbiAgICAgICAgICAgIGNvbnN0IGFkZFNlY29uZEl0ZW1QYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBpbml0aWFsUHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0VG9SZW1vdmVJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHByb2R1Y3RUb1JlbW92ZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHByb2R1Y3RUb1JlbW92ZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSB9LFxuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcHJvZHVjdFRvUmVtb3ZlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWRkUmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtleGlzdGluZ0ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShhZGRTZWNvbmRJdGVtUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShhZGRSZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IEludm9pY2Ugc2hvdWxkIGhhdmUgMiBpdGVtc1xuICAgICAgICAgICAgbGV0IGludm9pY2VXaXRoVHdvSXRlbXMgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSwgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludm9pY2VXaXRoVHdvSXRlbXM/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgdXBkYXRlIHBheWxvYWQgdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBpdGVtIHdlIHdhbnQgdG8ga2VlcC5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWRUb1JlbW92ZUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLCAvLyBLZWVwIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogaW5pdGlhbFB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH0gLy8gRGlzdHJpYnV0aW9uIGZvciB0aGUga2VwdCBpdGVtXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIFNpbXVsYXRlIEFQSSBjYWxsIHRvIHJlbW92ZSB0aGUgaXRlbVxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlUmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtleGlzdGluZ0ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVQYXlsb2FkVG9SZW1vdmVJdGVtKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVtb3ZlUmVxLCB7IHBhcmFtczogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnLCBleGlzdGluZ0ludm9pY2VJZCk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQdXJjaGFzZUludm9pY2UgaW4gREIgLSBzaG91bGQgbm93IGhhdmUgb25seSAxIGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcm9kdWN0SWQpLnRvQmUocHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKiBpbml0aWFsUHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgdGhlIEtFUFQgaXRlbVxuICAgICAgICAgICAgY29uc3Qga2VwdEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGtlcHRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChrZXB0SW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhpbml0aWFsUHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBjb25zdCBrZXB0UHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChrZXB0UHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBhbmQgUHJvZHVjdCBXQUMgZm9yIHRoZSBSRU1PVkVEIGl0ZW1cbiAgICAgICAgICAgIC8vIFN0b2NrIHNob3VsZCBiZSB6ZXJvIG9yIHRoZSBpdGVtIG1pZ2h0IGJlIGdvbmUgZnJvbSBpbnZlbnRvcnkgaWYgaXQgd2FzIHRoZSBvbmx5IHB1cmNoYXNlXG4gICAgICAgICAgICAvLyBXQUMgb24gcHJvZHVjdCBzaG91bGQgYmUgMCBpZiBubyBvdGhlciBwdXJjaGFzZXMgZXhpc3QuXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RUb1JlbW92ZUlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUaGUgUFVUIGxvZ2ljIHJldmVyc2VzIHN0b2NrLiBJZiB0aGlzIHdhcyB0aGUgb25seSBzdG9jaywgaXQgYmVjb21lcyAwLlxuICAgICAgICAgICAgZXhwZWN0KHJlbW92ZWRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKDApO1xuICAgICAgICAgICAgLy8gU2hvcFNwZWNpZmljQ29zdCBtaWdodCBiZWNvbWUgMCBvciBOYU4gaWYgcXVhbnRpdHkgaXMgMC4gVGhlIEFQSSBzZXRzIGl0IHRvIDAgZm9yIHNhZmV0eS5cbiAgICAgICAgICAgIGV4cGVjdChyZW1vdmVkSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbygwKTtcblxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFByb2R1Y3REYiA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdFRvUmVtb3ZlSWQgfSB9KTtcbiAgICAgICAgICAgIC8vIElmIG5vIG90aGVyIHB1cmNoYXNlIGl0ZW1zIGZvciB0aGlzIHByb2R1Y3QsIFdBQyBzaG91bGQgYmVjb21lIDAuXG4gICAgICAgICAgICBjb25zdCBvdGhlclB1cmNoYXNlc09mUmVtb3ZlZEl0ZW0gPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5jb3VudCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0VG9SZW1vdmVJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvdGhlclB1cmNoYXNlc09mUmVtb3ZlZEl0ZW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBleHBlY3QocmVtb3ZlZFByb2R1Y3REYj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oMCk7XG4gICAgICAgICAgICB9IC8vIEVsc2UsIGl0IHdvdWxkIGJlIGJhc2VkIG9uIG90aGVyIHB1cmNoYXNlcywgd2hpY2ggdGhpcyB0ZXN0IGRvZXNuJ3Qgc2V0IHVwLlxuXG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdERUxFVEUgL2FwaS9wdXJjaGFzZXMvOmlkIChEZWxldGUgUHVyY2hhc2UgSW52b2ljZSknLCAoKSA9PiB7XG4gICAgICAgIGxldCBpbnZvaWNlVG9EZWxldGVJZDogc3RyaW5nO1xuICAgICAgICBsZXQgcHJvZHVjdEZvckRlbGV0ZVRlc3RJZDogbnVtYmVyO1xuICAgICAgICBjb25zdCBkZWxldGVUZXN0SW5pdGlhbFByaWNlID0gNjA7XG4gICAgICAgIGNvbnN0IGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHkgPSAxMjtcblxuICAgICAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBwcm9kdWN0IGV4aXN0cyBmb3IgdGhlIHRlc3RcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1Byb2R1Y3QgRm9yIERlbGV0ZSBUZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnREVMUFJPRDAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAxMDAsIC8vIHJldGFpbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCA9IHByb2R1Y3QuaWQ7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBpbml0aWFsIHB1cmNoYXNlIGludm9pY2UgdG8gYmUgZGVsZXRlZFxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbEludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogZGVsZXRlVGVzdEluaXRpYWxQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHkgfSAvLyBFeHBsaWNpdCBkaXN0cmlidXRpb25cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBkZWxldGVUZXN0SW5pdGlhbFF1YW50aXR5ICogZGVsZXRlVGVzdEluaXRpYWxQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbml0aWFsSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZVB1cmNoYXNlSW52b2ljZShyZXEpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGludm9pY2VUb0RlbGV0ZUlkID0gYm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IHZlcmlmeSBpbml0aWFsIHN0YXRlIGFmdGVyIGNyZWF0aW9uXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHJvZHVjdERCID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbFByb2R1Y3REQj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShkZWxldGVUZXN0SW5pdGlhbFByaWNlKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGluaXRpYWxJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGluaXRpYWxJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUoZGVsZXRlVGVzdEluaXRpYWxQcmljZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZGVsZXRlIGEgcHVyY2hhc2UgaW52b2ljZSBhbmQgY29ycmVjdGx5IHJldmVyc2Ugc3RvY2sgYW5kIFdBQ3MgZm9yIGEgc2luZ2xlLWl0ZW0gaW52b2ljZSB3aXRoIGV4cGxpY2l0IGRpc3RyaWJ1dGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENhbGwgdGhlIERFTEVURSBlbmRwb2ludFxuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtpbnZvaWNlVG9EZWxldGVJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzcG9uc2UgPSBhd2FpdCBkZWxldGVQdXJjaGFzZUludm9pY2UoZGVsZXRlUmVxLCB7IHBhcmFtczogeyBpZDogaW52b2ljZVRvRGVsZXRlSWQgfSB9KTtcblxuICAgICAgICAgICAgLy8gMi4gQXNzZXJ0aW9ucyBmb3IgREVMRVRFIHJlc3BvbnNlXG4gICAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXNwb25zZUJvZHkgPSBhd2FpdCBkZWxldGVSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzcG9uc2VCb2R5Lm1lc3NhZ2UpLnRvQmUoJ1B1cmNoYXNlIGludm9pY2UgZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcblxuICAgICAgICAgICAgLy8gMy4gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpcyBkZWxldGVkIGZyb20gREJcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGludm9pY2VUb0RlbGV0ZUlkIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2UpLnRvQmVOdWxsKCk7XG5cbiAgICAgICAgICAgIC8vIDQuIFZlcmlmeSBQdXJjaGFzZUludm9pY2VJdGVtcyBhcmUgZGVsZXRlZFxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlSXRlbXMgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5maW5kTWFueSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHVyY2hhc2VJbnZvaWNlSWQ6IGludm9pY2VUb0RlbGV0ZUlkIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2VJdGVtcy5sZW5ndGgpLnRvQmUoMCk7XG5cbiAgICAgICAgICAgIC8vIDUuIFZlcmlmeSBJbnZlbnRvcnlJdGVtIHN0b2NrIGlzIHJldmVyc2VkXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JEZWxldGVUZXN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFzc3VtaW5nIHRoaXMgd2FzIHRoZSBvbmx5IHB1cmNoYXNlLCBzdG9jayBzaG91bGQgYmUgMFxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKDApO1xuICAgICAgICAgICAgLy8gU2hvcFNwZWNpZmljQ29zdCBzaG91bGQgYWxzbyBiZSAwIGlmIHN0b2NrIGlzIDBcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbygwKTtcblxuXG4gICAgICAgICAgICAvLyA2LiBWZXJpZnkgUHJvZHVjdCBXQUMgaXMgcmVjYWxjdWxhdGVkIChzaG91bGQgYmUgMCBpZiB0aGlzIHdhcyB0aGUgb25seSBwdXJjaGFzZSlcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHByb2R1Y3RGb3JEZWxldGVUZXN0SWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSWYgbm8gb3RoZXIgcHVyY2hhc2UgaXRlbXMgZm9yIHRoaXMgcHJvZHVjdCwgV0FDIHNob3VsZCBiZWNvbWUgMC5cbiAgICAgICAgICAgIGNvbnN0IG90aGVyUHVyY2hhc2VzT2ZQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uY291bnQoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVyY2hhc2VJbnZvaWNlSWQ6IHsgbm90OiBpbnZvaWNlVG9EZWxldGVJZCB9IC8vIE5vdCBuZWVkZWQgYXMgb3JpZ2luYWwgaW52b2ljZSBpdGVtcyBhcmUgZ29uZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG90aGVyUHVyY2hhc2VzT2ZQcm9kdWN0ID09PSAwKSB7IC8vIFRoaXMgc2hvdWxkIGJlIHRydWUgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZGVsZXRlIGEgcHVyY2hhc2UgYW5kIHJldmVyc2Ugc3RvY2svV0FDIHdoZW4gcHJvZHVjdCBpcyBpbiBhIHNpbmdsZSBpbmZlcnJlZCBzaG9wJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gU2V0dXA6IENyZWF0ZSBkZWRpY2F0ZWQgZW50aXRpZXMgZm9yIHRoaXMgdGVzdCB0byBlbnN1cmUgaXNvbGF0aW9uLlxuICAgICAgICAgICAgY29uc3QgdGVzdFNob3AgPSBhd2FpdCBwcmlzbWEuc2hvcC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHsgbmFtZTogJ0luZmVycmVkIERlbGV0ZSBUZXN0IFNob3AnLCBsb2NhdGlvbjogJ0xvYyBYJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RTdXBwbGllciA9IGF3YWl0IHByaXNtYS5zdXBwbGllci5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHsgbmFtZTogJ0luZmVycmVkIERlbGV0ZSBUZXN0IFN1cHBsaWVyJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdQcm9kdWN0IGZvciBJbmZlcnJlZCBEZWxldGUnLFxuICAgICAgICAgICAgICAgICAgICBza3U6ICdJTkZERUwwMDEnLFxuICAgICAgICAgICAgICAgICAgICBwcmljZTogMjAwLCAvLyByZXRhaWwgcHJpY2VcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ZWRBdmVyYWdlQ29zdDogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gaW52ZW50b3J5IGl0ZW0gZm9yIHRoaXMgcHJvZHVjdCBpbiB0aGUgdGVzdCBzaG9wLlxuICAgICAgICAgICAgLy8gVGhpcyBtYWtlcyBpdCB0aGUgXCJzaW5nbGUgaW5mZXJyZWQgc2hvcFwiLlxuICAgICAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogdGVzdFByb2R1Y3QuaWQsXG4gICAgICAgICAgICAgICAgICAgIHNob3BJZDogdGVzdFNob3AuaWQsXG4gICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiAwLCAvLyBXaWxsIGJlIHVwZGF0ZWQgYnkgdGhlIHB1cmNoYXNlXG4gICAgICAgICAgICAgICAgICAgIHNob3BTcGVjaWZpY0Nvc3Q6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eSA9IDEyO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZSA9IDYwO1xuXG4gICAgICAgICAgICBjb25zdCBpbmZlcnJlZFNob3BJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiB0ZXN0U3VwcGxpZXIuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiB0ZXN0UHJvZHVjdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIE5PIGRpc3RyaWJ1dGlvbnMgcHJvcGVydHkgaGVyZSBmb3IgaW5mZXJlbmNlIHRvIGtpY2sgaW4gb24gUE9TVFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBwdXJjaGFzZVF1YW50aXR5ICogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcHVyY2hhc2UgaW52b2ljZSAodGhpcyBpcyB3aGVyZSB0aGUgZmFpbHVyZSB3YXMgaGFwcGVuaW5nKVxuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoaW5mZXJyZWRTaG9wSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZVB1cmNoYXNlSW52b2ljZShjcmVhdGVSZXEpO1xuICAgICAgICAgICAgZXhwZWN0KGNyZWF0ZVJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpOyAvLyBBc3NlcnQgc3VjY2Vzc2Z1bCBjcmVhdGlvblxuXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVCb2R5ID0gYXdhaXQgY3JlYXRlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgaW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGUgPSBjcmVhdGVCb2R5LmRhdGEuaWQ7XG5cbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjazogVmVyaWZ5IHN0b2NrIGFuZCBXQUMgYWZ0ZXIgY3JlYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGludmVudG9yeUFmdGVyQ3JlYXRlID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHRlc3RQcm9kdWN0LmlkLCBzaG9wSWQ6IHRlc3RTaG9wLmlkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludmVudG9yeUFmdGVyQ3JlYXRlPy5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZlbnRvcnlBZnRlckNyZWF0ZT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8ocHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0QWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHRlc3RQcm9kdWN0LmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QocHJvZHVjdEFmdGVyQ3JlYXRlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhwdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gMi4gQ2FsbCB0aGUgREVMRVRFIGVuZHBvaW50XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2ludm9pY2VJZEZvckluZmVycmVkRGVsZXRlfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXNwb25zZSA9IGF3YWl0IGRlbGV0ZVB1cmNoYXNlSW52b2ljZShkZWxldGVSZXEsIHsgcGFyYW1zOiB7IGlkOiBpbnZvaWNlSWRGb3JJbmZlcnJlZERlbGV0ZSB9IH0pO1xuXG4gICAgICAgICAgICAvLyAzLiBBc3NlcnRpb25zIGZvciBERUxFVEUgcmVzcG9uc2VcbiAgICAgICAgICAgIGV4cGVjdChkZWxldGVSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3BvbnNlQm9keSA9IGF3YWl0IGRlbGV0ZVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4cGVjdChkZWxldGVSZXNwb25zZUJvZHkubWVzc2FnZSkudG9CZSgnUHVyY2hhc2UgaW52b2ljZSBkZWxldGVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgICAgICAgICAvLyA0LiBWZXJpZnkgUHVyY2hhc2VJbnZvaWNlIGFuZCBJdGVtcyBhcmUgZGVsZXRlZFxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGludm9pY2VJZEZvckluZmVycmVkRGVsZXRlIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlKS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlSXRlbXMgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5maW5kTWFueSh7IHdoZXJlOiB7IHB1cmNoYXNlSW52b2ljZUlkOiBpbnZvaWNlSWRGb3JJbmZlcnJlZERlbGV0ZSB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZUl0ZW1zLmxlbmd0aCkudG9CZSgwKTtcblxuICAgICAgICAgICAgLy8gNS4gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgYW5kIHNob3BTcGVjaWZpY0Nvc3QgYXJlIHJldmVyc2VkIGluIHRoZSBpbmZlcnJlZCBzaG9wXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHRlc3RQcm9kdWN0LmlkLCBzaG9wSWQ6IHRlc3RTaG9wLmlkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKDApO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICAvLyA2LiBWZXJpZnkgUHJvZHVjdCBXQUMgaXMgcmVjYWxjdWxhdGVkIHRvIDBcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0REIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHRlc3RQcm9kdWN0LmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZFByb2R1Y3REQj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oMCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFudXAgZGVkaWNhdGVkIGVudGl0aWVzIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmRlbGV0ZU1hbnkoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IHRlc3RQcm9kdWN0LmlkIH0gfSk7XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEucHJvZHVjdC5kZWxldGUoeyB3aGVyZTogeyBpZDogdGVzdFByb2R1Y3QuaWQgfSB9KTtcbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5zdXBwbGllci5kZWxldGUoeyB3aGVyZTogeyBpZDogdGVzdFN1cHBsaWVyLmlkIH0gfSk7XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuc2hvcC5kZWxldGUoeyB3aGVyZTogeyBpZDogdGVzdFNob3AuaWQgfSB9KTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBBZGRlZCBhIGxvbmdlciB0aW1lb3V0IGFzIGEgcHJlY2F1dGlvblxuXG4gICAgICAgIGl0KCdzaG91bGQgZGVsZXRlIGFuIGludm9pY2Ugd2l0aCBtdWx0aXBsZSBpdGVtcywgcmV2ZXJzaW5nIHN0b2NrL1dBQyBmb3IgZWFjaCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIFNldHVwOiBDcmVhdGUgbXVsdGlwbGUgcHJvZHVjdHMgYW5kIGFuIGludm9pY2Ugd2l0aCBpdGVtcyBmcm9tIHRoZXNlIHByb2R1Y3RzLlxuICAgICAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIGRpc3RyaWJ1dGUgZWFjaCB0byB0aGUgbWFpbiBjcmVhdGVkU2hvcElkIGZyb20gZ2xvYmFsIGJlZm9yZUVhY2guXG5cbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3RBID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IG5hbWU6ICdNdWx0aS1EZWwgUHJvZCBBJywgc2t1OiAnTURFTDAwQScsIHByaWNlOiAxMDAsIHdlaWdodGVkQXZlcmFnZUNvc3Q6IDAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0QiA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBuYW1lOiAnTXVsdGktRGVsIFByb2QgQicsIHNrdTogJ01ERUwwMEInLCBwcmljZTogMjAwLCB3ZWlnaHRlZEF2ZXJhZ2VDb3N0OiAwIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBxdWFudGl0eUEgPSA1O1xuICAgICAgICAgICAgY29uc3QgcHJpY2VBID0gNTA7XG4gICAgICAgICAgICBjb25zdCBxdWFudGl0eUIgPSAzO1xuICAgICAgICAgICAgY29uc3QgcHJpY2VCID0gMTIwO1xuXG4gICAgICAgICAgICBjb25zdCBtdWx0aUl0ZW1JbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7IHByb2R1Y3RJZDogcHJvZHVjdEEuaWQudG9TdHJpbmcoKSwgcXVhbnRpdHk6IHF1YW50aXR5QSwgcHJpY2U6IHByaWNlQSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByb2R1Y3RJZDogcHJvZHVjdEIuaWQudG9TdHJpbmcoKSwgcXVhbnRpdHk6IHF1YW50aXR5QiwgcHJpY2U6IHByaWNlQiB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcXVhbnRpdHlBIH0sIC8vIEl0ZW0gQSB0byBtYWluIHNob3BcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHF1YW50aXR5QiB9ICAvLyBJdGVtIEIgdG8gbWFpbiBzaG9wXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogKHF1YW50aXR5QSAqIHByaWNlQSkgKyAocXVhbnRpdHlCICogcHJpY2VCKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG11bHRpSXRlbUludm9pY2VQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UoY3JlYXRlUmVxKTtcbiAgICAgICAgICAgIGV4cGVjdChjcmVhdGVSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJvZHkgPSBhd2FpdCBjcmVhdGVSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCBtdWx0aUl0ZW1JbnZvaWNlSWQgPSBjcmVhdGVCb2R5LmRhdGEuaWQ7XG5cbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjayBpbnZlbnRvcnkgYW5kIFdBQyBhZnRlciBjcmVhdGlvblxuICAgICAgICAgICAgY29uc3QgaW52QV9hZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEEuaWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkFfYWZ0ZXJDcmVhdGU/LnF1YW50aXR5KS50b0JlKHF1YW50aXR5QSk7XG4gICAgICAgICAgICBleHBlY3QoaW52QV9hZnRlckNyZWF0ZT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShwcmljZUEpO1xuICAgICAgICAgICAgY29uc3QgcHJvZEFfYWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RBLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QocHJvZEFfYWZ0ZXJDcmVhdGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmUocHJpY2VBKTtcblxuICAgICAgICAgICAgY29uc3QgaW52Ql9hZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEIuaWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkJfYWZ0ZXJDcmVhdGU/LnF1YW50aXR5KS50b0JlKHF1YW50aXR5Qik7XG4gICAgICAgICAgICBleHBlY3QoaW52Ql9hZnRlckNyZWF0ZT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShwcmljZUIpO1xuICAgICAgICAgICAgY29uc3QgcHJvZEJfYWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RCLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QocHJvZEJfYWZ0ZXJDcmVhdGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmUocHJpY2VCKTtcblxuICAgICAgICAgICAgLy8gMi4gQ2FsbCBERUxFVEUgZW5kcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcSA9IG5ldyBOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7bXVsdGlJdGVtSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXNwb25zZSA9IGF3YWl0IGRlbGV0ZVB1cmNoYXNlSW52b2ljZShkZWxldGVSZXEsIHsgcGFyYW1zOiB7IGlkOiBtdWx0aUl0ZW1JbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkZWxldGVSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcblxuICAgICAgICAgICAgLy8gMy4gVmVyaWZ5IGludm9pY2UgYW5kIGl0ZW1zIGFyZSBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogbXVsdGlJdGVtSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlKS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlSXRlbXMgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5maW5kTWFueSh7IHdoZXJlOiB7IHB1cmNoYXNlSW52b2ljZUlkOiBtdWx0aUl0ZW1JbnZvaWNlSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2VJdGVtcy5sZW5ndGgpLnRvQmUoMCk7XG5cbiAgICAgICAgICAgIC8vIDQuIFZlcmlmeSBzdG9jayBhbmQgV0FDIGZvciBQcm9kdWN0IEEgYXJlIHJldmVyc2VkXG4gICAgICAgICAgICBjb25zdCBpbnZBX2FmdGVyRGVsZXRlID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHsgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0QS5pZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52QV9hZnRlckRlbGV0ZT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICBleHBlY3QoaW52QV9hZnRlckRlbGV0ZT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oMCk7XG4gICAgICAgICAgICBjb25zdCBwcm9kQV9hZnRlckRlbGV0ZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEEuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChwcm9kQV9hZnRlckRlbGV0ZT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oMCk7XG5cbiAgICAgICAgICAgIC8vIDUuIFZlcmlmeSBzdG9jayBhbmQgV0FDIGZvciBQcm9kdWN0IEIgYXJlIHJldmVyc2VkXG4gICAgICAgICAgICBjb25zdCBpbnZCX2FmdGVyRGVsZXRlID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHsgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Qi5pZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52Ql9hZnRlckRlbGV0ZT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICBleHBlY3QoaW52Ql9hZnRlckRlbGV0ZT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oMCk7XG4gICAgICAgICAgICBjb25zdCBwcm9kQl9hZnRlckRlbGV0ZSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEIuaWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChwcm9kQl9hZnRlckRlbGV0ZT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8oMCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHByb2R1Y3RzIGFuZCB0aGVpciBpbnZlbnRvcnkgaXRlbXMgY3JlYXRlZCBmb3IgdGhpcyB0ZXN0XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5kZWxldGVNYW55KHsgd2hlcmU6IHsgcHJvZHVjdElkOiB7IGluOiBbcHJvZHVjdEEuaWQsIHByb2R1Y3RCLmlkXSB9IH0gfSk7XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEucHJvZHVjdC5kZWxldGVNYW55KHsgd2hlcmU6IHsgaWQ6IHsgaW46IFtwcm9kdWN0QS5pZCwgcHJvZHVjdEIuaWRdIH0gfSB9KTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBUaW1lb3V0IGZvciBzYWZldHlcbiAgICB9KTtcblxufSk7ICJdLCJuYW1lcyI6WyJwcmlzbWEiLCJQcmlzbWFDbGllbnQiLCJkZXNjcmliZSIsImNyZWF0ZWRTaG9wSWQiLCJjcmVhdGVkU3VwcGxpZXJJZCIsImNyZWF0ZWRQcm9kdWN0SWQiLCJiZWZvcmVBbGwiLCJiZWZvcmVFYWNoIiwicHVyY2hhc2VJbnZvaWNlSXRlbSIsImRlbGV0ZU1hbnkiLCJwdXJjaGFzZUludm9pY2UiLCJpbnZlbnRvcnlJdGVtIiwicHJvZHVjdCIsInN1cHBsaWVyIiwic2hvcCIsImNyZWF0ZSIsImRhdGEiLCJuYW1lIiwibG9jYXRpb24iLCJpZCIsInByaWNlIiwic2t1Iiwic2hvcElkIiwiYWZ0ZXJBbGwiLCIkZGlzY29ubmVjdCIsIml0IiwibmV3UHJvZHVjdE5hbWUiLCJuZXdQcm9kdWN0U2t1IiwicHVyY2hhc2VQcmljZSIsInB1cmNoYXNlUXVhbnRpdHkiLCJuZXdUZXN0UHJvZHVjdCIsIm5ld1Rlc3RQcm9kdWN0SWQiLCJwdXJjaGFzZUludm9pY2VQYXlsb2FkIiwic3VwcGxpZXJJZCIsInRvU3RyaW5nIiwiZGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIml0ZW1zIiwicHJvZHVjdElkIiwicXVhbnRpdHkiLCJkaXN0cmlidXRpb25zIiwidG90YWxBbW91bnQiLCJzdGF0dXMiLCJyZXEiLCJOZXh0UmVxdWVzdCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaGVhZGVycyIsInJlc3BvbnNlIiwiY3JlYXRlUHVyY2hhc2VJbnZvaWNlIiwicmVzcG9uc2VCb2R5IiwianNvbiIsImV4cGVjdCIsInRvQmUiLCJ0b0hhdmVQcm9wZXJ0eSIsImNyZWF0ZWRJbnZvaWNlSWQiLCJkYkludm9pY2UiLCJmaW5kVW5pcXVlIiwid2hlcmUiLCJpbmNsdWRlIiwibm90IiwidG9CZU51bGwiLCJsZW5ndGgiLCJkYkludmVudG9yeUl0ZW0iLCJmaW5kRmlyc3QiLCJzaG9wU3BlY2lmaWNDb3N0IiwiZGJQcm9kdWN0Iiwid2VpZ2h0ZWRBdmVyYWdlQ29zdCIsImluaXRpYWxQdXJjaGFzZVByaWNlIiwiaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkiLCJleGlzdGluZ1Byb2R1Y3RJZCIsImluaXRpYWxQYXlsb2FkIiwibm93IiwiaW5pdGlhbFJlcSIsInByb2R1Y3RCZWZvcmVOZXdQdXJjaGFzZSIsImludmVudG9yeUJlZm9yZU5ld1B1cmNoYXNlIiwibmV3UHVyY2hhc2VQcmljZSIsIm5ld1B1cmNoYXNlUXVhbnRpdHkiLCJleHBlY3RlZFRvdGFsUXVhbnRpdHkiLCJleHBlY3RlZFNob3BTcGVjaWZpY0Nvc3QiLCJ0b0JlQ2xvc2VUbyIsImV4cGVjdGVkUHJvZHVjdFdBQyIsInByb2R1Y3QxRGF0YSIsInByb2R1Y3QyRGF0YSIsInByb2R1Y3QxIiwicHJvZHVjdDIiLCJwdXJjaGFzZVByaWNlMSIsInB1cmNoYXNlUXVhbnRpdHkxIiwicHVyY2hhc2VQcmljZTIiLCJwdXJjaGFzZVF1YW50aXR5MiIsIm9yZGVyQnkiLCJzb3J0ZWRQcm9kdWN0cyIsInNvcnQiLCJhIiwiYiIsImRiSW52ZW50b3J5SXRlbTEiLCJkYlByb2R1Y3QxIiwiZGJJbnZlbnRvcnlJdGVtMiIsImRiUHJvZHVjdDIiLCJzaG9wQSIsInNob3BCIiwidG90YWxRdWFudGl0eSIsInF1YW50aXR5Rm9yU2hvcEEiLCJxdWFudGl0eUZvclNob3BCIiwiaW52SXRlbUEiLCJpbnZJdGVtQiIsIm5vbkV4aXN0ZW50UHJvZHVjdElkIiwiZXJyb3IiLCJ0b0JlRGVmaW5lZCIsIm5vbkV4aXN0ZW50U3VwcGxpZXJJZCIsImV4aXN0aW5nSW52b2ljZUlkIiwicHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQiLCJpbml0aWFsSW52b2ljZVBheWxvYWQiLCJpbml0aWFsUHJvZHVjdCIsImluaXRpYWxJbnZlbnRvcnkiLCJxdWFudGl0eUluY3JlYXNlIiwibmV3UXVhbnRpdHkiLCJ1cGRhdGVkUHJpY2VGb3JJdGVtIiwidXBkYXRlUGF5bG9hZCIsInVwZGF0ZVB1cmNoYXNlSW52b2ljZSIsInBhcmFtcyIsInVwZGF0ZWRJbnZlbnRvcnkiLCJ1cGRhdGVkUHJvZHVjdCIsInRvdGFsIiwicXVhbnRpdHlEZWNyZWFzZSIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiLCJuZXdQcmljZUZvckl0ZW0iLCJxdWFudGl0eVVuY2hhbmdlZCIsIm5ld0l0ZW1Qcm9kdWN0IiwibmV3SXRlbVByb2R1Y3RJZCIsIm5ld0l0ZW1RdWFudGl0eSIsIm5ld0l0ZW1QcmljZSIsIm9yaWdpbmFsSXRlbVByb2R1Y3RJZCIsIm9yaWdpbmFsSXRlbVF1YW50aXR5Iiwib3JpZ2luYWxJdGVtUHJpY2UiLCJleHBlY3RlZFRvdGFsIiwiZGJPcmlnaW5hbEl0ZW0iLCJmaW5kIiwiaXRlbSIsImRiTmV3SXRlbSIsIm9yaWdpbmFsSW52ZW50b3J5Iiwib3JpZ2luYWxQcm9kdWN0IiwibmV3SW52ZW50b3J5IiwibmV3UHJvZHVjdERiIiwicHJvZHVjdFRvUmVtb3ZlIiwicHJvZHVjdFRvUmVtb3ZlSWQiLCJwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSIsInByb2R1Y3RUb1JlbW92ZVByaWNlIiwiYWRkU2Vjb25kSXRlbVBheWxvYWQiLCJhZGRSZXEiLCJpbnZvaWNlV2l0aFR3b0l0ZW1zIiwidXBkYXRlUGF5bG9hZFRvUmVtb3ZlSXRlbSIsInJlbW92ZVJlcSIsImtlcHRJbnZlbnRvcnkiLCJrZXB0UHJvZHVjdCIsInJlbW92ZWRJbnZlbnRvcnkiLCJyZW1vdmVkUHJvZHVjdERiIiwib3RoZXJQdXJjaGFzZXNPZlJlbW92ZWRJdGVtIiwiY291bnQiLCJpbnZvaWNlVG9EZWxldGVJZCIsInByb2R1Y3RGb3JEZWxldGVUZXN0SWQiLCJkZWxldGVUZXN0SW5pdGlhbFByaWNlIiwiZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSIsImluaXRpYWxQcm9kdWN0REIiLCJkZWxldGVSZXEiLCJkZWxldGVSZXNwb25zZSIsImRlbGV0ZVB1cmNoYXNlSW52b2ljZSIsImRlbGV0ZVJlc3BvbnNlQm9keSIsIm1lc3NhZ2UiLCJkYkludm9pY2VJdGVtcyIsImZpbmRNYW55IiwicHVyY2hhc2VJbnZvaWNlSWQiLCJvdGhlclB1cmNoYXNlc09mUHJvZHVjdCIsInRlc3RTaG9wIiwidGVzdFN1cHBsaWVyIiwidGVzdFByb2R1Y3QiLCJpbmZlcnJlZFNob3BJbnZvaWNlUGF5bG9hZCIsImNyZWF0ZVJlcSIsImNyZWF0ZVJlc3BvbnNlIiwiY3JlYXRlQm9keSIsImludm9pY2VJZEZvckluZmVycmVkRGVsZXRlIiwiaW52ZW50b3J5QWZ0ZXJDcmVhdGUiLCJwcm9kdWN0QWZ0ZXJDcmVhdGUiLCJ1cGRhdGVkUHJvZHVjdERCIiwiZGVsZXRlIiwicHJvZHVjdEEiLCJwcm9kdWN0QiIsInF1YW50aXR5QSIsInByaWNlQSIsInF1YW50aXR5QiIsInByaWNlQiIsIm11bHRpSXRlbUludm9pY2VQYXlsb2FkIiwibXVsdGlJdGVtSW52b2ljZUlkIiwiaW52QV9hZnRlckNyZWF0ZSIsInByb2RBX2FmdGVyQ3JlYXRlIiwiaW52Ql9hZnRlckNyZWF0ZSIsInByb2RCX2FmdGVyQ3JlYXRlIiwiaW52QV9hZnRlckRlbGV0ZSIsInByb2RBX2FmdGVyRGVsZXRlIiwiaW52Ql9hZnRlckRlbGV0ZSIsInByb2RCX2FmdGVyRGVsZXRlIiwiaW4iXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDOzs7O3dCQUM0Qjt1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