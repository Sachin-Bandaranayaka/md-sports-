b82be8ddbb567dcdf4bd280ac4afb560
"use strict";
// Mock ioredis
jest.mock("ioredis", ()=>{
    return {
        Redis: jest.fn().mockImplementation(()=>mockRedis)
    };
});
jest.mock("@/lib/inventoryCache", ()=>({
        inventoryCacheService: mockInventoryCache
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _ioredis = require("ioredis");
// Mock cache service
const mockCacheService = {
    get: jest.fn(),
    set: jest.fn(),
    delete: jest.fn(),
    deletePattern: jest.fn(),
    clear: jest.fn()
};
// Mock Redis
const mockRedis = {
    get: jest.fn(),
    set: jest.fn(),
    setex: jest.fn(),
    del: jest.fn(),
    keys: jest.fn(),
    flushall: jest.fn(),
    ping: jest.fn(),
    quit: jest.fn(),
    on: jest.fn(),
    connect: jest.fn(),
    disconnect: jest.fn()
};
// Mock the inventory cache service
const mockInventoryCache = {
    get: jest.fn(),
    set: jest.fn(),
    invalidateInventoryData: jest.fn(),
    generateKey: jest.fn(),
    warmPopularInventoryData: jest.fn(),
    trackFilterUsage: jest.fn(),
    getMetrics: jest.fn()
};
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Cache Management Tests", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("Basic Cache Operations", ()=>{
        describe("Memory Cache", ()=>{
            it("should store and retrieve data from memory cache", async ()=>{
                const testData = {
                    id: 1,
                    name: "Test Data"
                };
                const cacheKey = "test:key:1";
                // Mock memory cache behavior
                const memoryCache = new Map();
                memoryCache.set(cacheKey, JSON.stringify(testData));
                // Simulate cache set
                mockCacheService.set.mockResolvedValue(undefined);
                await mockCacheService.set(cacheKey, testData, 300);
                // Simulate cache get
                mockCacheService.get.mockResolvedValue(testData);
                const result = await mockCacheService.get(cacheKey);
                expect(result).toEqual(testData);
            });
            it("should handle cache expiration", async ()=>{
                const testData = {
                    id: 1,
                    name: "Expiring Data"
                };
                const cacheKey = "test:expiring:1";
                const ttl = 1; // 1 second
                mockCacheService.set.mockResolvedValue(undefined);
                await mockCacheService.set(cacheKey, testData, ttl);
                // Simulate time passing and cache expiration
                mockCacheService.get.mockResolvedValue(null);
                const result = await mockCacheService.get(cacheKey);
                expect(result).toBeNull();
            });
            it("should handle cache miss gracefully", async ()=>{
                mockCacheService.get.mockResolvedValue(null);
                const result = await mockCacheService.get("non:existent:key");
                expect(result).toBeNull();
            });
        });
        describe("Redis Cache", ()=>{
            it("should store data in Redis when available", async ()=>{
                const testData = {
                    id: 1,
                    name: "Redis Test"
                };
                const cacheKey = "redis:test:1";
                const ttl = 300;
                mockRedis.setex.mockResolvedValue("OK");
                mockCacheService.set.mockResolvedValue(undefined);
                await mockCacheService.set(cacheKey, testData, ttl);
                expect(mockRedis.setex).toHaveBeenCalledWith(cacheKey, ttl, JSON.stringify(testData));
            });
            it("should retrieve data from Redis", async ()=>{
                const testData = {
                    id: 1,
                    name: "Redis Test"
                };
                const cacheKey = "redis:test:1";
                mockRedis.get.mockResolvedValue(JSON.stringify(testData));
                mockCacheService.get.mockResolvedValue(testData);
                const result = await mockCacheService.get(cacheKey);
                expect(mockCacheService.get).toHaveBeenCalledWith(cacheKey);
                expect(result).toEqual(testData);
            });
            it("should handle Redis connection errors gracefully", async ()=>{
                const testData = {
                    id: 1,
                    name: "Error Test"
                };
                const cacheKey = "redis:error:1";
                mockRedis.setex.mockRejectedValue(new Error("Redis connection failed"));
                // Should not throw error, should fallback to memory cache
                mockCacheService.set.mockResolvedValue(undefined);
                await expect(mockCacheService.set(cacheKey, testData, 300)).resolves.not.toThrow();
                expect(mockCacheService.set).toHaveBeenCalledWith(cacheKey, testData, 300);
            });
            it("should handle Redis get errors gracefully", async ()=>{
                const cacheKey = "redis:error:get";
                mockRedis.get.mockRejectedValue(new Error("Redis get failed"));
                mockCacheService.get.mockResolvedValue(null);
                const result = await mockCacheService.get(cacheKey);
                expect(result).toBeNull();
                expect(mockCacheService.get).toHaveBeenCalledWith(cacheKey);
            });
        });
        describe("Cache Invalidation", ()=>{
            it("should delete specific cache keys", async ()=>{
                const cacheKey = "test:delete:1";
                mockCacheService.delete.mockResolvedValue(undefined);
                await mockCacheService.delete(cacheKey);
                expect(mockCacheService.delete).toHaveBeenCalledWith(cacheKey);
            });
            it("should delete multiple cache keys by pattern", async ()=>{
                const pattern = "test:pattern:*";
                const matchingKeys = [
                    "test:pattern:1",
                    "test:pattern:2",
                    "test:pattern:3"
                ];
                mockCacheService.deletePattern.mockResolvedValue(undefined);
                await mockCacheService.deletePattern(pattern);
                expect(mockCacheService.deletePattern).toHaveBeenCalledWith(pattern);
            });
            it("should handle pattern deletion with no matches", async ()=>{
                const pattern = "test:nomatch:*";
                mockCacheService.deletePattern.mockResolvedValue(undefined);
                await mockCacheService.deletePattern(pattern);
                expect(mockCacheService.deletePattern).toHaveBeenCalledWith(pattern);
            });
            it("should clear all cache data", async ()=>{
                mockCacheService.clear.mockResolvedValue(undefined);
                await mockCacheService.clear();
                expect(mockCacheService.clear).toHaveBeenCalled();
            });
        });
    });
    describe("Inventory Cache Service", ()=>{
        const mockInventoryData = {
            items: [
                {
                    id: 1,
                    productId: 1,
                    shopId: "shop1",
                    quantity: 100
                },
                {
                    id: 2,
                    productId: 2,
                    shopId: "shop1",
                    quantity: 50
                }
            ],
            total: 2,
            page: 1,
            limit: 20
        };
        const mockFilters = {
            shopId: "shop1",
            page: 1,
            limit: 20,
            status: "In Stock"
        };
        describe("Cache Key Generation", ()=>{
            it("should generate consistent cache keys", ()=>{
                const baseKey = "inventory:summary";
                const expectedKey = "inventory:summary:shop:shop1:status:In Stock:page:1:limit:20";
                mockInventoryCache.generateKey.mockReturnValue(expectedKey);
                const result = mockInventoryCache.generateKey(baseKey, mockFilters);
                expect(result).toBe(expectedKey);
                expect(mockInventoryCache.generateKey).toHaveBeenCalledWith(baseKey, mockFilters);
            });
            it("should handle filters with special characters", ()=>{
                const filtersWithSpecialChars = {
                    ...mockFilters,
                    search: "test product & more"
                };
                const expectedKey = "inventory:summary:shop:shop1:status:In Stock:search:test%20product%20%26%20more:page:1:limit:20";
                mockInventoryCache.generateKey.mockReturnValue(expectedKey);
                const result = mockInventoryCache.generateKey("inventory:summary", filtersWithSpecialChars);
                expect(result).toBe(expectedKey);
            });
        });
        describe("Cache Storage and Retrieval", ()=>{
            it("should store inventory data with TTL", async ()=>{
                const cacheKey = "inventory:summary:shop1";
                const ttl = 300;
                mockInventoryCache.set.mockResolvedValue(undefined);
                await mockInventoryCache.set(cacheKey, mockInventoryData, ttl);
                expect(mockInventoryCache.set).toHaveBeenCalledWith(cacheKey, mockInventoryData, ttl);
            });
            it("should retrieve cached inventory data", async ()=>{
                const cacheKey = "inventory:summary:shop1";
                mockInventoryCache.get.mockResolvedValue(mockInventoryData);
                const result = await mockInventoryCache.get(cacheKey);
                expect(mockInventoryCache.get).toHaveBeenCalledWith(cacheKey);
                expect(result).toEqual(mockInventoryData);
            });
            it("should return null for cache miss", async ()=>{
                const cacheKey = "inventory:summary:nonexistent";
                mockInventoryCache.get.mockResolvedValue(null);
                const result = await mockInventoryCache.get(cacheKey);
                expect(result).toBeNull();
            });
        });
        describe("Cache Invalidation Strategies", ()=>{
            it("should invalidate inventory data by product", async ()=>{
                const productId = 1;
                mockInventoryCache.invalidateInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.invalidateInventoryData(productId);
                expect(mockInventoryCache.invalidateInventoryData).toHaveBeenCalledWith(productId);
            });
            it("should invalidate inventory data by shop", async ()=>{
                const shopId = "shop1";
                mockInventoryCache.invalidateInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.invalidateInventoryData(undefined, shopId);
                expect(mockInventoryCache.invalidateInventoryData).toHaveBeenCalledWith(undefined, shopId);
            });
            it("should invalidate inventory data by category", async ()=>{
                const categoryId = 5;
                mockInventoryCache.invalidateInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.invalidateInventoryData(undefined, undefined, categoryId);
                expect(mockInventoryCache.invalidateInventoryData).toHaveBeenCalledWith(undefined, undefined, categoryId);
            });
            it("should invalidate all inventory data", async ()=>{
                mockInventoryCache.invalidateInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.invalidateInventoryData();
                expect(mockInventoryCache.invalidateInventoryData).toHaveBeenCalledWith();
            });
        });
        describe("Cache Warming", ()=>{
            it("should warm popular inventory data", async ()=>{
                mockInventoryCache.warmPopularInventoryData.mockResolvedValue(undefined);
                await mockInventoryCache.warmPopularInventoryData();
                expect(mockInventoryCache.warmPopularInventoryData).toHaveBeenCalled();
            });
            it("should track filter usage for warming strategy", ()=>{
                mockInventoryCache.trackFilterUsage.mockReturnValue(undefined);
                mockInventoryCache.trackFilterUsage(mockFilters);
                expect(mockInventoryCache.trackFilterUsage).toHaveBeenCalledWith(mockFilters);
            });
        });
        describe("Cache Metrics", ()=>{
            it("should collect cache performance metrics", ()=>{
                const mockMetrics = {
                    hits: 150,
                    misses: 25,
                    hitRate: 0.857,
                    avgResponseTime: 12.5,
                    totalRequests: 175
                };
                mockInventoryCache.getMetrics.mockReturnValue(mockMetrics);
                const metrics = mockInventoryCache.getMetrics();
                expect(metrics).toEqual(mockMetrics);
                expect(metrics.hitRate).toBeGreaterThan(0.8); // Good hit rate
                expect(metrics.avgResponseTime).toBeLessThan(50); // Fast response
            });
            it("should track cache performance over time", ()=>{
                const mockTimeSeriesMetrics = {
                    "2024-01-01T00:00:00Z": {
                        hits: 100,
                        misses: 10
                    },
                    "2024-01-01T01:00:00Z": {
                        hits: 120,
                        misses: 8
                    },
                    "2024-01-01T02:00:00Z": {
                        hits: 110,
                        misses: 12
                    }
                };
                mockInventoryCache.getMetrics.mockReturnValue(mockTimeSeriesMetrics);
                const metrics = mockInventoryCache.getMetrics("timeseries");
                expect(metrics).toEqual(mockTimeSeriesMetrics);
                expect(Object.keys(metrics)).toHaveLength(3);
            });
        });
    });
    describe("Cache Error Handling", ()=>{
        it("should handle cache service initialization errors", ()=>{
            const initError = new Error("Cache initialization failed");
            // Mock Redis constructor to throw error
            _ioredis.Redis.mockImplementationOnce(()=>{
                throw initError;
            });
            // Should not crash the application
            expect(()=>{
                new _ioredis.Redis();
            }).toThrow("Cache initialization failed");
        });
        it("should handle serialization errors", async ()=>{
            const circularData = {
                name: "test"
            };
            circularData.self = circularData; // Create circular reference
            const cacheKey = "test:circular";
            // Should handle JSON.stringify error gracefully
            mockCacheService.set.mockResolvedValue(undefined);
            await expect(mockCacheService.set(cacheKey, circularData, 300)).resolves.not.toThrow();
        });
        it("should handle deserialization errors", async ()=>{
            const cacheKey = "test:invalid:json";
            mockCacheService.get.mockResolvedValue(null);
            const result = await mockCacheService.get(cacheKey);
            expect(result).toBeNull();
        });
        it("should handle network timeouts gracefully", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            const result = await mockCacheService.get("test:timeout");
            expect(result).toBeNull();
        });
    });
    describe("Cache Performance Tests", ()=>{
        it("should handle high-frequency cache operations", async ()=>{
            const operations = [];
            const numOperations = 1000;
            // Mock high-frequency cache operations
            mockCacheService.set.mockResolvedValue(undefined);
            for(let i = 0; i < numOperations; i++){
                operations.push(mockCacheService.set(`test:perf:${i}`, {
                    id: i,
                    data: `data-${i}`
                }, 300));
            }
            const startTime = Date.now();
            await Promise.all(operations);
            const endTime = Date.now();
            const duration = endTime - startTime;
            const opsPerSecond = numOperations / (duration / 1000);
            expect(opsPerSecond).toBeGreaterThan(100); // Should handle at least 100 ops/sec
        });
        it("should handle concurrent cache access", async ()=>{
            const cacheKey = "test:concurrent";
            const testData = {
                id: 1,
                name: "Concurrent Test"
            };
            // Mock concurrent operations
            mockCacheService.get.mockResolvedValue(testData);
            mockCacheService.set.mockResolvedValue(undefined);
            // Simulate concurrent reads and writes
            const concurrentOperations = [
                mockCacheService.get(cacheKey),
                mockCacheService.set(cacheKey, testData, 300),
                mockCacheService.get(cacheKey),
                mockCacheService.set(cacheKey, {
                    ...testData,
                    updated: true
                }, 300),
                mockCacheService.get(cacheKey)
            ];
            await expect(Promise.all(concurrentOperations)).resolves.not.toThrow();
        });
        it("should maintain cache consistency under load", async ()=>{
            const cacheKey = "test:consistency";
            let counter = 0;
            // Mock cache operations to simulate real behavior
            mockRedis.get.mockImplementation(async ()=>{
                return JSON.stringify({
                    counter
                });
            });
            mockRedis.setex.mockImplementation(async (key, ttl, value)=>{
                const data = JSON.parse(value);
                counter = data.counter;
                return "OK";
            });
            // Mock counter behavior for concurrent updates
            let testCounter = 0;
            mockCacheService.get.mockImplementation(()=>Promise.resolve({
                    counter: testCounter
                }));
            mockCacheService.set.mockImplementation((key, value)=>{
                testCounter = value.counter;
                return Promise.resolve(undefined);
            });
            // Simulate multiple concurrent updates
            const updates = [];
            for(let i = 0; i < 10; i++){
                updates.push((async ()=>{
                    const current = await mockCacheService.get(cacheKey);
                    const newValue = {
                        counter: (current?.counter || 0) + 1
                    };
                    await mockCacheService.set(cacheKey, newValue, 300);
                })());
            }
            await Promise.all(updates);
            const finalValue = await mockCacheService.get(cacheKey);
            expect(finalValue.counter).toBeGreaterThan(0);
        });
    });
    describe("Cache Configuration", ()=>{
        it("should respect TTL settings", async ()=>{
            const shortTTL = 1; // 1 second
            const longTTL = 3600; // 1 hour
            const testData = {
                id: 1,
                name: "TTL Test"
            };
            mockCacheService.set.mockResolvedValue(undefined);
            await mockCacheService.set("test:short", testData, shortTTL);
            await mockCacheService.set("test:long", testData, longTTL);
            expect(mockCacheService.set).toHaveBeenCalledWith("test:short", testData, shortTTL);
            expect(mockCacheService.set).toHaveBeenCalledWith("test:long", testData, longTTL);
        });
        it("should use default TTL when not specified", async ()=>{
            const testData = {
                id: 1,
                name: "Default TTL Test"
            };
            mockCacheService.set.mockResolvedValue(undefined);
            await mockCacheService.set("test:default", testData);
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        it("should handle cache size limits", async ()=>{
            const largeData = {
                id: 1,
                data: "x".repeat(1024 * 1024)
            };
            mockRedis.setex.mockResolvedValue("OK");
            // Should handle large data without issues
            mockCacheService.set.mockResolvedValue(undefined);
            await expect(mockCacheService.set("test:large", largeData, 300)).resolves.not.toThrow();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9jYWNoZU1hbmFnZW1lbnQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWRpcyB9IGZyb20gJ2lvcmVkaXMnO1xuXG4vLyBNb2NrIGNhY2hlIHNlcnZpY2VcbmNvbnN0IG1vY2tDYWNoZVNlcnZpY2UgPSB7XG4gIGdldDogamVzdC5mbigpLFxuICBzZXQ6IGplc3QuZm4oKSxcbiAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIGRlbGV0ZVBhdHRlcm46IGplc3QuZm4oKSxcbiAgY2xlYXI6IGplc3QuZm4oKSxcbn07XG5cbi8vIE1vY2sgUmVkaXNcbmNvbnN0IG1vY2tSZWRpcyA9IHtcbiAgZ2V0OiBqZXN0LmZuKCksXG4gIHNldDogamVzdC5mbigpLFxuICBzZXRleDogamVzdC5mbigpLFxuICBkZWw6IGplc3QuZm4oKSxcbiAga2V5czogamVzdC5mbigpLFxuICBmbHVzaGFsbDogamVzdC5mbigpLFxuICBwaW5nOiBqZXN0LmZuKCksXG4gIHF1aXQ6IGplc3QuZm4oKSxcbiAgb246IGplc3QuZm4oKSxcbiAgY29ubmVjdDogamVzdC5mbigpLFxuICBkaXNjb25uZWN0OiBqZXN0LmZuKCksXG59O1xuXG4vLyBNb2NrIGlvcmVkaXNcbmplc3QubW9jaygnaW9yZWRpcycsICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBSZWRpczogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrUmVkaXMpLFxuICB9O1xufSk7XG5cbi8vIE1vY2sgdGhlIGludmVudG9yeSBjYWNoZSBzZXJ2aWNlXG5jb25zdCBtb2NrSW52ZW50b3J5Q2FjaGUgPSB7XG4gIGdldDogamVzdC5mbigpLFxuICBzZXQ6IGplc3QuZm4oKSxcbiAgaW52YWxpZGF0ZUludmVudG9yeURhdGE6IGplc3QuZm4oKSxcbiAgZ2VuZXJhdGVLZXk6IGplc3QuZm4oKSxcbiAgd2FybVBvcHVsYXJJbnZlbnRvcnlEYXRhOiBqZXN0LmZuKCksXG4gIHRyYWNrRmlsdGVyVXNhZ2U6IGplc3QuZm4oKSxcbiAgZ2V0TWV0cmljczogamVzdC5mbigpLFxufTtcblxuamVzdC5tb2NrKCdAL2xpYi9pbnZlbnRvcnlDYWNoZScsICgpID0+ICh7XG4gIGludmVudG9yeUNhY2hlU2VydmljZTogbW9ja0ludmVudG9yeUNhY2hlLFxufSkpO1xuXG4vLyBNb2NrIGNvbnNvbGUgbWV0aG9kc1xuY29uc3QgY29uc29sZVNweSA9IHtcbiAgbG9nOiBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pLFxuICBlcnJvcjogamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pLFxuICB3YXJuOiBqZXN0LnNweU9uKGNvbnNvbGUsICd3YXJuJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbn07XG5cbmRlc2NyaWJlKCdDYWNoZSBNYW5hZ2VtZW50IFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBjb25zb2xlU3B5LmxvZy5tb2NrQ2xlYXIoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkud2Fybi5tb2NrQ2xlYXIoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJBbGwoKCkgPT4ge1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS5lcnJvci5tb2NrUmVzdG9yZSgpO1xuICAgIGNvbnNvbGVTcHkud2Fybi5tb2NrUmVzdG9yZSgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmFzaWMgQ2FjaGUgT3BlcmF0aW9ucycsICgpID0+IHtcbiAgICBkZXNjcmliZSgnTWVtb3J5IENhY2hlJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBzdG9yZSBhbmQgcmV0cmlldmUgZGF0YSBmcm9tIG1lbW9yeSBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGlkOiAxLCBuYW1lOiAnVGVzdCBEYXRhJyB9O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICd0ZXN0OmtleToxJztcblxuICAgICAgICAvLyBNb2NrIG1lbW9yeSBjYWNoZSBiZWhhdmlvclxuICAgICAgICBjb25zdCBtZW1vcnlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgbWVtb3J5Q2FjaGUuc2V0KGNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeSh0ZXN0RGF0YSkpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIGNhY2hlIHNldFxuICAgICAgICBtb2NrQ2FjaGVTZXJ2aWNlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICBhd2FpdCBtb2NrQ2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdGVzdERhdGEsIDMwMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaW11bGF0ZSBjYWNoZSBnZXRcbiAgICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUodGVzdERhdGEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrQ2FjaGVTZXJ2aWNlLmdldChjYWNoZUtleSk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh0ZXN0RGF0YSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FjaGUgZXhwaXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGlkOiAxLCBuYW1lOiAnRXhwaXJpbmcgRGF0YScgfTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAndGVzdDpleHBpcmluZzoxJztcbiAgICAgICAgY29uc3QgdHRsID0gMTsgLy8gMSBzZWNvbmRcblxuICAgICAgICBtb2NrQ2FjaGVTZXJ2aWNlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICBhd2FpdCBtb2NrQ2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdGVzdERhdGEsIHR0bCk7XG5cbiAgICAgICAgLy8gU2ltdWxhdGUgdGltZSBwYXNzaW5nIGFuZCBjYWNoZSBleHBpcmF0aW9uXG4gICAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrQ2FjaGVTZXJ2aWNlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FjaGUgbWlzcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja0NhY2hlU2VydmljZS5nZXQoJ25vbjpleGlzdGVudDprZXknKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1JlZGlzIENhY2hlJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBzdG9yZSBkYXRhIGluIFJlZGlzIHdoZW4gYXZhaWxhYmxlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgaWQ6IDEsIG5hbWU6ICdSZWRpcyBUZXN0JyB9O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICdyZWRpczp0ZXN0OjEnO1xuICAgICAgICBjb25zdCB0dGwgPSAzMDA7XG5cbiAgICAgICAgbW9ja1JlZGlzLnNldGV4Lm1vY2tSZXNvbHZlZFZhbHVlKCdPSycpO1xuXG4gICAgICAgIG1vY2tDYWNoZVNlcnZpY2Uuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgIGF3YWl0IG1vY2tDYWNoZVNlcnZpY2Uuc2V0KGNhY2hlS2V5LCB0ZXN0RGF0YSwgdHRsKTtcblxuICAgICAgICBleHBlY3QobW9ja1JlZGlzLnNldGV4KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICB0dGwsXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGVzdERhdGEpXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXRyaWV2ZSBkYXRhIGZyb20gUmVkaXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ1JlZGlzIFRlc3QnIH07XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gJ3JlZGlzOnRlc3Q6MSc7XG5cbiAgICAgICAgbW9ja1JlZGlzLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShKU09OLnN0cmluZ2lmeSh0ZXN0RGF0YSkpO1xuXG4gICAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHRlc3REYXRhKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja0NhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoY2FjaGVLZXkpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHRlc3REYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBSZWRpcyBjb25uZWN0aW9uIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgaWQ6IDEsIG5hbWU6ICdFcnJvciBUZXN0JyB9O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICdyZWRpczplcnJvcjoxJztcblxuICAgICAgICBtb2NrUmVkaXMuc2V0ZXgubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdSZWRpcyBjb25uZWN0aW9uIGZhaWxlZCcpKTtcblxuICAgICAgICAvLyBTaG91bGQgbm90IHRocm93IGVycm9yLCBzaG91bGQgZmFsbGJhY2sgdG8gbWVtb3J5IGNhY2hlXG4gICAgICAgIG1vY2tDYWNoZVNlcnZpY2Uuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgIGF3YWl0IGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdGVzdERhdGEsIDMwMCkpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoY2FjaGVLZXksIHRlc3REYXRhLCAzMDApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIFJlZGlzIGdldCBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAncmVkaXM6ZXJyb3I6Z2V0JztcblxuICAgICAgICBtb2NrUmVkaXMuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignUmVkaXMgZ2V0IGZhaWxlZCcpKTtcblxuICAgICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja0NhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoY2FjaGVLZXkpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQ2FjaGUgSW52YWxpZGF0aW9uJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBkZWxldGUgc3BlY2lmaWMgY2FjaGUga2V5cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAndGVzdDpkZWxldGU6MSc7XG5cbiAgICAgICAgbW9ja0NhY2hlU2VydmljZS5kZWxldGUubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgYXdhaXQgbW9ja0NhY2hlU2VydmljZS5kZWxldGUoY2FjaGVLZXkpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmRlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoY2FjaGVLZXkpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgZGVsZXRlIG11bHRpcGxlIGNhY2hlIGtleXMgYnkgcGF0dGVybicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9ICd0ZXN0OnBhdHRlcm46Kic7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nS2V5cyA9IFsndGVzdDpwYXR0ZXJuOjEnLCAndGVzdDpwYXR0ZXJuOjInLCAndGVzdDpwYXR0ZXJuOjMnXTtcblxuICAgICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmRlbGV0ZVBhdHRlcm4ubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgYXdhaXQgbW9ja0NhY2hlU2VydmljZS5kZWxldGVQYXR0ZXJuKHBhdHRlcm4pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmRlbGV0ZVBhdHRlcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBhdHRlcm4pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhdHRlcm4gZGVsZXRpb24gd2l0aCBubyBtYXRjaGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gJ3Rlc3Q6bm9tYXRjaDoqJztcblxuICAgICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmRlbGV0ZVBhdHRlcm4ubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgYXdhaXQgbW9ja0NhY2hlU2VydmljZS5kZWxldGVQYXR0ZXJuKHBhdHRlcm4pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmRlbGV0ZVBhdHRlcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBhdHRlcm4pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgY2xlYXIgYWxsIGNhY2hlIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tDYWNoZVNlcnZpY2UuY2xlYXIubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgYXdhaXQgbW9ja0NhY2hlU2VydmljZS5jbGVhcigpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmNsZWFyKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludmVudG9yeSBDYWNoZSBTZXJ2aWNlJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tJbnZlbnRvcnlEYXRhID0ge1xuICAgICAgaXRlbXM6IFtcbiAgICAgICAgeyBpZDogMSwgcHJvZHVjdElkOiAxLCBzaG9wSWQ6ICdzaG9wMScsIHF1YW50aXR5OiAxMDAgfSxcbiAgICAgICAgeyBpZDogMiwgcHJvZHVjdElkOiAyLCBzaG9wSWQ6ICdzaG9wMScsIHF1YW50aXR5OiA1MCB9LFxuICAgICAgXSxcbiAgICAgIHRvdGFsOiAyLFxuICAgICAgcGFnZTogMSxcbiAgICAgIGxpbWl0OiAyMCxcbiAgICB9O1xuXG4gICAgY29uc3QgbW9ja0ZpbHRlcnMgPSB7XG4gICAgICBzaG9wSWQ6ICdzaG9wMScsXG4gICAgICBwYWdlOiAxLFxuICAgICAgbGltaXQ6IDIwLFxuICAgICAgc3RhdHVzOiAnSW4gU3RvY2snLFxuICAgIH07XG5cbiAgICBkZXNjcmliZSgnQ2FjaGUgS2V5IEdlbmVyYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIGNvbnNpc3RlbnQgY2FjaGUga2V5cycsICgpID0+IHtcbiAgICAgICAgY29uc3QgYmFzZUtleSA9ICdpbnZlbnRvcnk6c3VtbWFyeSc7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkS2V5ID0gJ2ludmVudG9yeTpzdW1tYXJ5OnNob3A6c2hvcDE6c3RhdHVzOkluIFN0b2NrOnBhZ2U6MTpsaW1pdDoyMCc7XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLmdlbmVyYXRlS2V5Lm1vY2tSZXR1cm5WYWx1ZShleHBlY3RlZEtleSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9ja0ludmVudG9yeUNhY2hlLmdlbmVyYXRlS2V5KGJhc2VLZXksIG1vY2tGaWx0ZXJzKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKGV4cGVjdGVkS2V5KTtcbiAgICAgICAgZXhwZWN0KG1vY2tJbnZlbnRvcnlDYWNoZS5nZW5lcmF0ZUtleSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoYmFzZUtleSwgbW9ja0ZpbHRlcnMpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGZpbHRlcnMgd2l0aCBzcGVjaWFsIGNoYXJhY3RlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlcnNXaXRoU3BlY2lhbENoYXJzID0ge1xuICAgICAgICAgIC4uLm1vY2tGaWx0ZXJzLFxuICAgICAgICAgIHNlYXJjaDogJ3Rlc3QgcHJvZHVjdCAmIG1vcmUnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBleHBlY3RlZEtleSA9ICdpbnZlbnRvcnk6c3VtbWFyeTpzaG9wOnNob3AxOnN0YXR1czpJbiBTdG9jazpzZWFyY2g6dGVzdCUyMHByb2R1Y3QlMjAlMjYlMjBtb3JlOnBhZ2U6MTpsaW1pdDoyMCc7XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLmdlbmVyYXRlS2V5Lm1vY2tSZXR1cm5WYWx1ZShleHBlY3RlZEtleSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9ja0ludmVudG9yeUNhY2hlLmdlbmVyYXRlS2V5KCdpbnZlbnRvcnk6c3VtbWFyeScsIGZpbHRlcnNXaXRoU3BlY2lhbENoYXJzKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKGV4cGVjdGVkS2V5KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0NhY2hlIFN0b3JhZ2UgYW5kIFJldHJpZXZhbCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgc3RvcmUgaW52ZW50b3J5IGRhdGEgd2l0aCBUVEwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gJ2ludmVudG9yeTpzdW1tYXJ5OnNob3AxJztcbiAgICAgICAgY29uc3QgdHRsID0gMzAwO1xuXG4gICAgICAgIG1vY2tJbnZlbnRvcnlDYWNoZS5zZXQubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcblxuICAgICAgICBhd2FpdCBtb2NrSW52ZW50b3J5Q2FjaGUuc2V0KGNhY2hlS2V5LCBtb2NrSW52ZW50b3J5RGF0YSwgdHRsKTtcblxuICAgICAgICBleHBlY3QobW9ja0ludmVudG9yeUNhY2hlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoY2FjaGVLZXksIG1vY2tJbnZlbnRvcnlEYXRhLCB0dGwpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0cmlldmUgY2FjaGVkIGludmVudG9yeSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9ICdpbnZlbnRvcnk6c3VtbWFyeTpzaG9wMSc7XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrSW52ZW50b3J5RGF0YSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja0ludmVudG9yeUNhY2hlLmdldChjYWNoZUtleSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tJbnZlbnRvcnlDYWNoZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGNhY2hlS2V5KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrSW52ZW50b3J5RGF0YSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgY2FjaGUgbWlzcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAnaW52ZW50b3J5OnN1bW1hcnk6bm9uZXhpc3RlbnQnO1xuXG4gICAgICAgIG1vY2tJbnZlbnRvcnlDYWNoZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja0ludmVudG9yeUNhY2hlLmdldChjYWNoZUtleSk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0NhY2hlIEludmFsaWRhdGlvbiBTdHJhdGVnaWVzJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBpbnZhbGlkYXRlIGludmVudG9yeSBkYXRhIGJ5IHByb2R1Y3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2R1Y3RJZCA9IDE7XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLmludmFsaWRhdGVJbnZlbnRvcnlEYXRhLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgYXdhaXQgbW9ja0ludmVudG9yeUNhY2hlLmludmFsaWRhdGVJbnZlbnRvcnlEYXRhKHByb2R1Y3RJZCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YSkudG9IYXZlQmVlbkNhbGxlZFdpdGgocHJvZHVjdElkKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGludmFsaWRhdGUgaW52ZW50b3J5IGRhdGEgYnkgc2hvcCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2hvcElkID0gJ3Nob3AxJztcblxuICAgICAgICBtb2NrSW52ZW50b3J5Q2FjaGUuaW52YWxpZGF0ZUludmVudG9yeURhdGEubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcblxuICAgICAgICBhd2FpdCBtb2NrSW52ZW50b3J5Q2FjaGUuaW52YWxpZGF0ZUludmVudG9yeURhdGEodW5kZWZpbmVkLCBzaG9wSWQpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrSW52ZW50b3J5Q2FjaGUuaW52YWxpZGF0ZUludmVudG9yeURhdGEpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHVuZGVmaW5lZCwgc2hvcElkKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGludmFsaWRhdGUgaW52ZW50b3J5IGRhdGEgYnkgY2F0ZWdvcnknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5SWQgPSA1O1xuXG4gICAgICAgIG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICAgIGF3YWl0IG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2F0ZWdvcnlJZCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodW5kZWZpbmVkLCB1bmRlZmluZWQsIGNhdGVnb3J5SWQpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaW52YWxpZGF0ZSBhbGwgaW52ZW50b3J5IGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICAgIGF3YWl0IG1vY2tJbnZlbnRvcnlDYWNoZS5pbnZhbGlkYXRlSW52ZW50b3J5RGF0YSgpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrSW52ZW50b3J5Q2FjaGUuaW52YWxpZGF0ZUludmVudG9yeURhdGEpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdDYWNoZSBXYXJtaW5nJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB3YXJtIHBvcHVsYXIgaW52ZW50b3J5IGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIG1vY2tJbnZlbnRvcnlDYWNoZS53YXJtUG9wdWxhckludmVudG9yeURhdGEubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcblxuICAgICAgICBhd2FpdCBtb2NrSW52ZW50b3J5Q2FjaGUud2FybVBvcHVsYXJJbnZlbnRvcnlEYXRhKCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tJbnZlbnRvcnlDYWNoZS53YXJtUG9wdWxhckludmVudG9yeURhdGEpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHRyYWNrIGZpbHRlciB1c2FnZSBmb3Igd2FybWluZyBzdHJhdGVneScsICgpID0+IHtcbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLnRyYWNrRmlsdGVyVXNhZ2UubW9ja1JldHVyblZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLnRyYWNrRmlsdGVyVXNhZ2UobW9ja0ZpbHRlcnMpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrSW52ZW50b3J5Q2FjaGUudHJhY2tGaWx0ZXJVc2FnZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0ZpbHRlcnMpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQ2FjaGUgTWV0cmljcycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY29sbGVjdCBjYWNoZSBwZXJmb3JtYW5jZSBtZXRyaWNzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrTWV0cmljcyA9IHtcbiAgICAgICAgICBoaXRzOiAxNTAsXG4gICAgICAgICAgbWlzc2VzOiAyNSxcbiAgICAgICAgICBoaXRSYXRlOiAwLjg1NyxcbiAgICAgICAgICBhdmdSZXNwb25zZVRpbWU6IDEyLjUsXG4gICAgICAgICAgdG90YWxSZXF1ZXN0czogMTc1LFxuICAgICAgICB9O1xuXG4gICAgICAgIG1vY2tJbnZlbnRvcnlDYWNoZS5nZXRNZXRyaWNzLm1vY2tSZXR1cm5WYWx1ZShtb2NrTWV0cmljcyk7XG5cbiAgICAgICAgY29uc3QgbWV0cmljcyA9IG1vY2tJbnZlbnRvcnlDYWNoZS5nZXRNZXRyaWNzKCk7XG5cbiAgICAgICAgZXhwZWN0KG1ldHJpY3MpLnRvRXF1YWwobW9ja01ldHJpY3MpO1xuICAgICAgICBleHBlY3QobWV0cmljcy5oaXRSYXRlKS50b0JlR3JlYXRlclRoYW4oMC44KTsgLy8gR29vZCBoaXQgcmF0ZVxuICAgICAgICBleHBlY3QobWV0cmljcy5hdmdSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbig1MCk7IC8vIEZhc3QgcmVzcG9uc2VcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHRyYWNrIGNhY2hlIHBlcmZvcm1hbmNlIG92ZXIgdGltZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1RpbWVTZXJpZXNNZXRyaWNzID0ge1xuICAgICAgICAgICcyMDI0LTAxLTAxVDAwOjAwOjAwWic6IHsgaGl0czogMTAwLCBtaXNzZXM6IDEwIH0sXG4gICAgICAgICAgJzIwMjQtMDEtMDFUMDE6MDA6MDBaJzogeyBoaXRzOiAxMjAsIG1pc3NlczogOCB9LFxuICAgICAgICAgICcyMDI0LTAxLTAxVDAyOjAwOjAwWic6IHsgaGl0czogMTEwLCBtaXNzZXM6IDEyIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgbW9ja0ludmVudG9yeUNhY2hlLmdldE1ldHJpY3MubW9ja1JldHVyblZhbHVlKG1vY2tUaW1lU2VyaWVzTWV0cmljcyk7XG5cbiAgICAgICAgY29uc3QgbWV0cmljcyA9IG1vY2tJbnZlbnRvcnlDYWNoZS5nZXRNZXRyaWNzKCd0aW1lc2VyaWVzJyk7XG5cbiAgICAgICAgZXhwZWN0KG1ldHJpY3MpLnRvRXF1YWwobW9ja1RpbWVTZXJpZXNNZXRyaWNzKTtcbiAgICAgICAgZXhwZWN0KE9iamVjdC5rZXlzKG1ldHJpY3MpKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhY2hlIEVycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNhY2hlIHNlcnZpY2UgaW5pdGlhbGl6YXRpb24gZXJyb3JzJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdEVycm9yID0gbmV3IEVycm9yKCdDYWNoZSBpbml0aWFsaXphdGlvbiBmYWlsZWQnKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBSZWRpcyBjb25zdHJ1Y3RvciB0byB0aHJvdyBlcnJvclxuICAgICAgKFJlZGlzIGFzIGplc3QuTW9ja2VkQ2xhc3M8dHlwZW9mIFJlZGlzPikubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgIHRocm93IGluaXRFcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGQgbm90IGNyYXNoIHRoZSBhcHBsaWNhdGlvblxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgbmV3IFJlZGlzKCk7XG4gICAgICB9KS50b1Rocm93KCdDYWNoZSBpbml0aWFsaXphdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcmlhbGl6YXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2lyY3VsYXJEYXRhID0geyBuYW1lOiAndGVzdCcgfTtcbiAgICAgIGNpcmN1bGFyRGF0YS5zZWxmID0gY2lyY3VsYXJEYXRhOyAvLyBDcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlXG5cbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gJ3Rlc3Q6Y2lyY3VsYXInO1xuXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIEpTT04uc3RyaW5naWZ5IGVycm9yIGdyYWNlZnVsbHlcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2Uuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBhd2FpdCBleHBlY3QobW9ja0NhY2hlU2VydmljZS5zZXQoY2FjaGVLZXksIGNpcmN1bGFyRGF0YSwgMzAwKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRlc2VyaWFsaXphdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9ICd0ZXN0OmludmFsaWQ6anNvbic7XG5cbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja0NhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmV0d29yayB0aW1lb3V0cyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrQ2FjaGVTZXJ2aWNlLmdldCgndGVzdDp0aW1lb3V0Jyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDYWNoZSBQZXJmb3JtYW5jZSBUZXN0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBoaWdoLWZyZXF1ZW5jeSBjYWNoZSBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdO1xuICAgICAgY29uc3QgbnVtT3BlcmF0aW9ucyA9IDEwMDA7XG5cbiAgICAgIC8vIE1vY2sgaGlnaC1mcmVxdWVuY3kgY2FjaGUgb3BlcmF0aW9uc1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5zZXQubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT3BlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaChcbiAgICAgICAgICBtb2NrQ2FjaGVTZXJ2aWNlLnNldChgdGVzdDpwZXJmOiR7aX1gLCB7IGlkOiBpLCBkYXRhOiBgZGF0YS0ke2l9YCB9LCAzMDApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChvcGVyYXRpb25zKTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBjb25zdCBvcHNQZXJTZWNvbmQgPSBudW1PcGVyYXRpb25zIC8gKGR1cmF0aW9uIC8gMTAwMCk7XG5cbiAgICAgIGV4cGVjdChvcHNQZXJTZWNvbmQpLnRvQmVHcmVhdGVyVGhhbigxMDApOyAvLyBTaG91bGQgaGFuZGxlIGF0IGxlYXN0IDEwMCBvcHMvc2VjXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IGNhY2hlIGFjY2VzcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gJ3Rlc3Q6Y29uY3VycmVudCc7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgaWQ6IDEsIG5hbWU6ICdDb25jdXJyZW50IFRlc3QnIH07XG5cbiAgICAgIC8vIE1vY2sgY29uY3VycmVudCBvcGVyYXRpb25zXG4gICAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHRlc3REYXRhKTtcbiAgICAgICAgbW9ja0NhY2hlU2VydmljZS5zZXQubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgY29uY3VycmVudCByZWFkcyBhbmQgd3JpdGVzXG4gICAgICBjb25zdCBjb25jdXJyZW50T3BlcmF0aW9ucyA9IFtcbiAgICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpLFxuICAgICAgICBtb2NrQ2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdGVzdERhdGEsIDMwMCksXG4gICAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0KGNhY2hlS2V5KSxcbiAgICAgICAgbW9ja0NhY2hlU2VydmljZS5zZXQoY2FjaGVLZXksIHsgLi4udGVzdERhdGEsIHVwZGF0ZWQ6IHRydWUgfSwgMzAwKSxcbiAgICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpLFxuICAgICAgXTtcblxuICAgICAgYXdhaXQgZXhwZWN0KFByb21pc2UuYWxsKGNvbmN1cnJlbnRPcGVyYXRpb25zKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gY2FjaGUgY29uc2lzdGVuY3kgdW5kZXIgbG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gJ3Rlc3Q6Y29uc2lzdGVuY3knO1xuICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gICAgICAvLyBNb2NrIGNhY2hlIG9wZXJhdGlvbnMgdG8gc2ltdWxhdGUgcmVhbCBiZWhhdmlvclxuICAgICAgbW9ja1JlZGlzLmdldC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyBjb3VudGVyIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIG1vY2tSZWRpcy5zZXRleC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGtleSwgdHRsLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGNvdW50ZXIgPSBkYXRhLmNvdW50ZXI7XG4gICAgICAgIHJldHVybiAnT0snO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgY291bnRlciBiZWhhdmlvciBmb3IgY29uY3VycmVudCB1cGRhdGVzXG4gICAgICAgIGxldCB0ZXN0Q291bnRlciA9IDA7XG4gICAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBjb3VudGVyOiB0ZXN0Q291bnRlciB9KSk7XG4gICAgICAgIG1vY2tDYWNoZVNlcnZpY2Uuc2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRlc3RDb3VudGVyID0gdmFsdWUuY291bnRlcjtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBtdWx0aXBsZSBjb25jdXJyZW50IHVwZGF0ZXNcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICB1cGRhdGVzLnB1c2goXG4gICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FpdCBtb2NrQ2FjaGVTZXJ2aWNlLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHsgY291bnRlcjogKGN1cnJlbnQ/LmNvdW50ZXIgfHwgMCkgKyAxIH07XG4gICAgICAgICAgICBhd2FpdCBtb2NrQ2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgbmV3VmFsdWUsIDMwMCk7XG4gICAgICAgICAgfSkoKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh1cGRhdGVzKTtcblxuICAgICAgY29uc3QgZmluYWxWYWx1ZSA9IGF3YWl0IG1vY2tDYWNoZVNlcnZpY2UuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGV4cGVjdChmaW5hbFZhbHVlLmNvdW50ZXIpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhY2hlIENvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXNwZWN0IFRUTCBzZXR0aW5ncycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNob3J0VFRMID0gMTsgLy8gMSBzZWNvbmRcbiAgICAgIGNvbnN0IGxvbmdUVEwgPSAzNjAwOyAvLyAxIGhvdXJcbiAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ1RUTCBUZXN0JyB9O1xuXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICBhd2FpdCBtb2NrQ2FjaGVTZXJ2aWNlLnNldCgndGVzdDpzaG9ydCcsIHRlc3REYXRhLCBzaG9ydFRUTCk7XG4gICAgICAgIGF3YWl0IG1vY2tDYWNoZVNlcnZpY2Uuc2V0KCd0ZXN0OmxvbmcnLCB0ZXN0RGF0YSwgbG9uZ1RUTCk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2Uuc2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdDpzaG9ydCcsIHRlc3REYXRhLCBzaG9ydFRUTCk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Rlc3Q6bG9uZycsIHRlc3REYXRhLCBsb25nVFRMKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgVFRMIHdoZW4gbm90IHNwZWNpZmllZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ0RlZmF1bHQgVFRMIFRlc3QnIH07XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgYXdhaXQgbW9ja0NhY2hlU2VydmljZS5zZXQoJ3Rlc3Q6ZGVmYXVsdCcsIHRlc3REYXRhKTtcblxuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2Uuc2V0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjYWNoZSBzaXplIGxpbWl0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlRGF0YSA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGRhdGE6ICd4Jy5yZXBlYXQoMTAyNCAqIDEwMjQpLCAvLyAxTUIgb2YgZGF0YVxuICAgICAgfTtcblxuICAgICAgbW9ja1JlZGlzLnNldGV4Lm1vY2tSZXNvbHZlZFZhbHVlKCdPSycpO1xuXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIGxhcmdlIGRhdGEgd2l0aG91dCBpc3N1ZXNcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2Uuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBhd2FpdCBleHBlY3QobW9ja0NhY2hlU2VydmljZS5zZXQoJ3Rlc3Q6bGFyZ2UnLCBsYXJnZURhdGEsIDMwMCkpLnJlc29sdmVzLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiUmVkaXMiLCJmbiIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIm1vY2tSZWRpcyIsImludmVudG9yeUNhY2hlU2VydmljZSIsIm1vY2tJbnZlbnRvcnlDYWNoZSIsIm1vY2tDYWNoZVNlcnZpY2UiLCJnZXQiLCJzZXQiLCJkZWxldGUiLCJkZWxldGVQYXR0ZXJuIiwiY2xlYXIiLCJzZXRleCIsImRlbCIsImtleXMiLCJmbHVzaGFsbCIsInBpbmciLCJxdWl0Iiwib24iLCJjb25uZWN0IiwiZGlzY29ubmVjdCIsImludmFsaWRhdGVJbnZlbnRvcnlEYXRhIiwiZ2VuZXJhdGVLZXkiLCJ3YXJtUG9wdWxhckludmVudG9yeURhdGEiLCJ0cmFja0ZpbHRlclVzYWdlIiwiZ2V0TWV0cmljcyIsImNvbnNvbGVTcHkiLCJsb2ciLCJzcHlPbiIsImNvbnNvbGUiLCJlcnJvciIsIndhcm4iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja0NsZWFyIiwiYWZ0ZXJBbGwiLCJtb2NrUmVzdG9yZSIsIml0IiwidGVzdERhdGEiLCJpZCIsIm5hbWUiLCJjYWNoZUtleSIsIm1lbW9yeUNhY2hlIiwiTWFwIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwidW5kZWZpbmVkIiwicmVzdWx0IiwiZXhwZWN0IiwidG9FcXVhbCIsInR0bCIsInRvQmVOdWxsIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwicmVzb2x2ZXMiLCJub3QiLCJ0b1Rocm93IiwicGF0dGVybiIsIm1hdGNoaW5nS2V5cyIsInRvSGF2ZUJlZW5DYWxsZWQiLCJtb2NrSW52ZW50b3J5RGF0YSIsIml0ZW1zIiwicHJvZHVjdElkIiwic2hvcElkIiwicXVhbnRpdHkiLCJ0b3RhbCIsInBhZ2UiLCJsaW1pdCIsIm1vY2tGaWx0ZXJzIiwic3RhdHVzIiwiYmFzZUtleSIsImV4cGVjdGVkS2V5IiwibW9ja1JldHVyblZhbHVlIiwidG9CZSIsImZpbHRlcnNXaXRoU3BlY2lhbENoYXJzIiwic2VhcmNoIiwiY2F0ZWdvcnlJZCIsIm1vY2tNZXRyaWNzIiwiaGl0cyIsIm1pc3NlcyIsImhpdFJhdGUiLCJhdmdSZXNwb25zZVRpbWUiLCJ0b3RhbFJlcXVlc3RzIiwibWV0cmljcyIsInRvQmVHcmVhdGVyVGhhbiIsInRvQmVMZXNzVGhhbiIsIm1vY2tUaW1lU2VyaWVzTWV0cmljcyIsIk9iamVjdCIsInRvSGF2ZUxlbmd0aCIsImluaXRFcnJvciIsIm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UiLCJjaXJjdWxhckRhdGEiLCJzZWxmIiwib3BlcmF0aW9ucyIsIm51bU9wZXJhdGlvbnMiLCJpIiwicHVzaCIsImRhdGEiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiUHJvbWlzZSIsImFsbCIsImVuZFRpbWUiLCJkdXJhdGlvbiIsIm9wc1BlclNlY29uZCIsImNvbmN1cnJlbnRPcGVyYXRpb25zIiwidXBkYXRlZCIsImNvdW50ZXIiLCJrZXkiLCJ2YWx1ZSIsInBhcnNlIiwidGVzdENvdW50ZXIiLCJyZXNvbHZlIiwidXBkYXRlcyIsImN1cnJlbnQiLCJuZXdWYWx1ZSIsImZpbmFsVmFsdWUiLCJzaG9ydFRUTCIsImxvbmdUVEwiLCJsYXJnZURhdGEiLCJyZXBlYXQiXSwibWFwcGluZ3MiOiI7QUEwQkEsZUFBZTtBQUNmQSxLQUFLQyxJQUFJLENBQUMsV0FBVztJQUNuQixPQUFPO1FBQ0xDLE9BQU9GLEtBQUtHLEVBQUUsR0FBR0Msa0JBQWtCLENBQUMsSUFBTUM7SUFDNUM7QUFDRjtBQWFBTCxLQUFLQyxJQUFJLENBQUMsd0JBQXdCLElBQU8sQ0FBQTtRQUN2Q0ssdUJBQXVCQztJQUN6QixDQUFBOzs7O3lCQTlDc0I7QUFFdEIscUJBQXFCO0FBQ3JCLE1BQU1DLG1CQUFtQjtJQUN2QkMsS0FBS1QsS0FBS0csRUFBRTtJQUNaTyxLQUFLVixLQUFLRyxFQUFFO0lBQ1pRLFFBQVFYLEtBQUtHLEVBQUU7SUFDZlMsZUFBZVosS0FBS0csRUFBRTtJQUN0QlUsT0FBT2IsS0FBS0csRUFBRTtBQUNoQjtBQUVBLGFBQWE7QUFDYixNQUFNRSxZQUFZO0lBQ2hCSSxLQUFLVCxLQUFLRyxFQUFFO0lBQ1pPLEtBQUtWLEtBQUtHLEVBQUU7SUFDWlcsT0FBT2QsS0FBS0csRUFBRTtJQUNkWSxLQUFLZixLQUFLRyxFQUFFO0lBQ1phLE1BQU1oQixLQUFLRyxFQUFFO0lBQ2JjLFVBQVVqQixLQUFLRyxFQUFFO0lBQ2pCZSxNQUFNbEIsS0FBS0csRUFBRTtJQUNiZ0IsTUFBTW5CLEtBQUtHLEVBQUU7SUFDYmlCLElBQUlwQixLQUFLRyxFQUFFO0lBQ1hrQixTQUFTckIsS0FBS0csRUFBRTtJQUNo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