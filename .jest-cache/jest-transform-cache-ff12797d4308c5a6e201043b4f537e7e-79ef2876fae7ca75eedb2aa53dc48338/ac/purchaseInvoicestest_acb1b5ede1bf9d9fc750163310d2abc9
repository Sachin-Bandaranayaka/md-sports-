2b2ca06c5cc13b9bd5a362a227d7e39d
/**
 * @jest-environment node
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _client = require("@prisma/client");
const _route = require("../../src/app/api/purchases/route");
const _route1 = require("../../src/app/api/purchases/[id]/route");
// Helper function to create mock NextRequest
const createMockNextRequest = (url, options = {})=>{
    const { method = "GET", body, headers = {} } = options;
    return {
        method,
        url,
        headers: new Headers(headers),
        json: async ()=>body ? typeof body === "string" ? JSON.parse(body) : body : {},
        text: async ()=>body ? typeof body === "string" ? body : JSON.stringify(body) : ""
    };
};
const prisma = new _client.PrismaClient();
describe("Purchase Invoice API Integration Tests", ()=>{
    let createdShopId;
    let createdSupplierId;
    let createdProductId;
    beforeAll(async ()=>{
    // Seed initial data if necessary, e.g., a default supplier or shop
    // For now, we'll create them in beforeEach or specific tests
    });
    beforeEach(async ()=>{
        // Clean up database tables to ensure test isolation
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        // Create a shop for testing
        const shop = await prisma.shop.create({
            data: {
                name: "Test Shop Local",
                location: "Test Location"
            }
        });
        createdShopId = shop.id;
        // Create a supplier for testing
        const supplier = await prisma.supplier.create({
            data: {
                name: "Test Supplier Local"
            }
        });
        createdSupplierId = supplier.id;
        // Create a product for testing updates/deletes (not for create new product test)
        const product = await prisma.product.create({
            data: {
                name: "Existing Product",
                price: 100,
                sku: "EXISTING001",
                shopId: createdShopId
            }
        });
        createdProductId = product.id;
    });
    afterAll(async ()=>{
        // Clean up database after all tests
        await prisma.purchaseInvoiceItem.deleteMany({});
        await prisma.purchaseInvoice.deleteMany({});
        await prisma.inventoryItem.deleteMany({});
        await prisma.product.deleteMany({});
        await prisma.supplier.deleteMany({});
        await prisma.shop.deleteMany({});
        await prisma.$disconnect();
    });
    describe("POST /api/purchases (Create Purchase Invoice)", ()=>{
        it("should create a purchase invoice for a new product, update inventory, and set WAC", async ()=>{
            // 1. Define data for a new product
            const newProductName = "Brand New Racket";
            const newProductSku = "NEWB001";
            const purchasePrice = 150;
            const purchaseQuantity = 10;
            // Create product first (as API expects productId)
            // In a real scenario, the UI might create product then purchase, or purchase API handles product creation
            // For this test, assume product is created just before, or API implies its creation from purchase (not current API)
            // Let's assume for now product must exist, if API doesn't create it from purchase items.
            // The current API's POST /api/purchases expects item.productId, implying product exists.
            const newTestProduct = await prisma.product.create({
                data: {
                    name: newProductName,
                    sku: newProductSku,
                    price: 250,
                    shopId: createdShopId // Optional default shop association
                }
            });
            const newTestProductId = newTestProduct.id;
            // 2. Prepare the request body for POST /api/purchases
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // 3. Construct a NextRequest instance
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: purchaseInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate the API call
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201); // Or 200 depending on your API's success response for POST
            expect(responseBody.data).toHaveProperty("id");
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice).not.toBeNull();
            expect(dbInvoice?.supplierId).toBe(createdSupplierId);
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(newTestProductId);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice);
            // Verify InventoryItem in DB
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newTestProductId,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem).not.toBeNull();
            expect(dbInventoryItem?.quantity).toBe(purchaseQuantity);
            // The POST route seems to calculate shopSpecificCost too.
            // WAC = (Current Total Value + New Purchase Value) / (Current Quantity + New Quantity)
            // For new item, existing shopSpecificCost is 0, currentQuantity is 0.
            // So newShopSpecificCost should be newCost (purchasePrice)
            expect(dbInventoryItem?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC in DB
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: newTestProductId
                }
            });
            expect(dbProduct).not.toBeNull();
            // For a new product, WAC should be equal to the purchase price of this first batch
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should create a purchase for an existing product, update inventory, and recalculate WACs", async ()=>{
            // 0. Initial state: Product exists, potentially with some inventory and WAC
            const initialPurchasePrice = 120;
            const initialPurchaseQuantity = 5;
            const existingProductId = createdProductId; // From beforeEach
            // Create an initial purchase to set up existing inventory and WAC
            const initialPayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const initialReq = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(initialPayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route.POST)(initialReq);
            const productBeforeNewPurchase = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            const inventoryBeforeNewPurchase = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            expect(productBeforeNewPurchase?.weightedAverageCost).toBe(initialPurchasePrice);
            expect(inventoryBeforeNewPurchase?.quantity).toBe(initialPurchaseQuantity);
            expect(inventoryBeforeNewPurchase?.shopSpecificCost).toBe(initialPurchasePrice);
            // 1. Define data for the new purchase of the existing product
            const newPurchasePrice = 100;
            const newPurchaseQuantity = 8;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: existingProductId.toString(),
                        quantity: newPurchaseQuantity,
                        price: newPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newPurchaseQuantity
                    }
                ],
                totalAmount: newPurchaseQuantity * newPurchasePrice,
                status: "paid"
            };
            // 3. Simulate API call
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify InventoryItem
            const dbInventoryItem = await prisma.inventoryItem.findFirst({
                where: {
                    productId: existingProductId,
                    shopId: createdShopId
                }
            });
            const expectedTotalQuantity = initialPurchaseQuantity + newPurchaseQuantity;
            expect(dbInventoryItem?.quantity).toBe(expectedTotalQuantity);
            // Verify shopSpecificCost recalculation
            // SSC = ((oldQty * oldSSC) + (newQty * newPrice)) / (oldQty + newQty)
            const expectedShopSpecificCost = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            expect(dbInventoryItem?.shopSpecificCost).toBeCloseTo(expectedShopSpecificCost);
            // Verify Product WAC recalculation
            // WAC = ((oldTotalQty * oldWAC) + (newPurchaseQty * newPurchasePrice)) / (newTotalQty + newPurchaseQty)
            // In this case, product WAC was initialPurchasePrice for initialPurchaseQuantity.
            const expectedProductWAC = (initialPurchaseQuantity * initialPurchasePrice + newPurchaseQuantity * newPurchasePrice) / (initialPurchaseQuantity + newPurchaseQuantity);
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: existingProductId
                }
            });
            expect(dbProduct?.weightedAverageCost).toBeCloseTo(expectedProductWAC);
        }, 15000); // Increased timeout
        it("should create a purchase with multiple items and update inventory/WAC for each", async ()=>{
            // 1. Create two distinct products for this test
            const product1Data = {
                name: "MultiItem Product A",
                sku: "MULTI001",
                price: 50,
                shopId: createdShopId
            };
            const product2Data = {
                name: "MultiItem Product B",
                sku: "MULTI002",
                price: 75,
                shopId: createdShopId
            };
            const product1 = await prisma.product.create({
                data: product1Data
            });
            const product2 = await prisma.product.create({
                data: product2Data
            });
            const purchasePrice1 = 40;
            const purchaseQuantity1 = 5;
            const purchasePrice2 = 60;
            const purchaseQuantity2 = 3;
            // 2. Prepare the request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product1.id.toString(),
                        quantity: purchaseQuantity1,
                        price: purchasePrice1
                    },
                    {
                        productId: product2.id.toString(),
                        quantity: purchaseQuantity2,
                        price: purchasePrice2
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity1
                    },
                    {
                        [createdShopId]: purchaseQuantity2
                    } // Distribution for item 2
                ],
                totalAmount: purchaseQuantity1 * purchasePrice1 + purchaseQuantity2 * purchasePrice2,
                status: "pending"
            };
            // 3. Simulate API call
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(201);
            const createdInvoiceId = responseBody.data.id;
            // Verify PurchaseInvoice and its items
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: createdInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                } // Order to ensure consistent assertion
            });
            expect(dbInvoice?.items.length).toBe(2);
            // Assuming product1.id < product2.id due to creation order for consistent checks
            const sortedProducts = [
                product1,
                product2
            ].sort((a, b)=>a.id - b.id);
            expect(dbInvoice?.items[0].productId).toBe(sortedProducts[0].id);
            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity1);
            expect(dbInvoice?.items[0].price).toBe(purchasePrice1);
            expect(dbInvoice?.items[1].productId).toBe(sortedProducts[1].id);
            expect(dbInvoice?.items[1].quantity).toBe(purchaseQuantity2);
            expect(dbInvoice?.items[1].price).toBe(purchasePrice2);
            // Verify InventoryItem and Product WAC for Product 1
            const dbInventoryItem1 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product1.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem1?.quantity).toBe(purchaseQuantity1);
            expect(dbInventoryItem1?.shopSpecificCost).toBe(purchasePrice1);
            const dbProduct1 = await prisma.product.findUnique({
                where: {
                    id: product1.id
                }
            });
            expect(dbProduct1?.weightedAverageCost).toBe(purchasePrice1);
            // Verify InventoryItem and Product WAC for Product 2
            const dbInventoryItem2 = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product2.id,
                    shopId: createdShopId
                }
            });
            expect(dbInventoryItem2?.quantity).toBe(purchaseQuantity2);
            expect(dbInventoryItem2?.shopSpecificCost).toBe(purchasePrice2);
            const dbProduct2 = await prisma.product.findUnique({
                where: {
                    id: product2.id
                }
            });
            expect(dbProduct2?.weightedAverageCost).toBe(purchasePrice2);
        }, 15000); // Increased timeout
        it("should distribute a single purchase item to multiple shops", async ()=>{
            // 1. Create two new shops for this test
            const shopA = await prisma.shop.create({
                data: {
                    name: "Test Shop A",
                    location: "Loc A"
                }
            });
            const shopB = await prisma.shop.create({
                data: {
                    name: "Test Shop B",
                    location: "Loc B"
                }
            });
            // 2. Create a new product
            const product = await prisma.product.create({
                data: {
                    name: "Split Product",
                    sku: "SPLIT001",
                    price: 200
                }
            });
            const purchasePrice = 180;
            const totalQuantity = 10;
            const quantityForShopA = 6;
            const quantityForShopB = 4;
            expect(quantityForShopA + quantityForShopB).toBe(totalQuantity); // Sanity check
            // 3. Prepare request body
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: product.id.toString(),
                        quantity: totalQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [shopA.id]: quantityForShopA,
                        [shopB.id]: quantityForShopB
                    }
                ],
                totalAmount: totalQuantity * purchasePrice,
                status: "paid"
            };
            // 4. Simulate API call
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const responseBody = await response.json();
            // 5. Assertions
            expect(response.status).toBe(201);
            // Verify InventoryItem for Shop A
            const invItemA = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopA.id
                }
            });
            expect(invItemA).not.toBeNull();
            expect(invItemA?.quantity).toBe(quantityForShopA);
            expect(invItemA?.shopSpecificCost).toBe(purchasePrice);
            // Verify InventoryItem for Shop B
            const invItemB = await prisma.inventoryItem.findFirst({
                where: {
                    productId: product.id,
                    shopId: shopB.id
                }
            });
            expect(invItemB).not.toBeNull();
            expect(invItemB?.quantity).toBe(quantityForShopB);
            expect(invItemB?.shopSpecificCost).toBe(purchasePrice);
            // Verify Product WAC (should be the purchase price as it's all new stock)
            const dbProduct = await prisma.product.findUnique({
                where: {
                    id: product.id
                }
            });
            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a productId does not exist", async ()=>{
            const nonExistentProductId = 999999; // Assuming this ID won't exist
            const purchasePrice = 100;
            const purchaseQuantity = 5;
            const purchaseInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: nonExistentProductId.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            // Expect a client error (e.g., 400 or 404) or potentially 500 if not handled gracefully
            // For robust error handling, API should return specific error code.
            // Prisma will throw an error if a related record (product) is not found for foreign key.
            // This will likely result in a 500 if not caught and handled by the API route.
            // Let's aim for the API to catch this and return a more specific client error.
            // For now, we'll check if it's NOT a success (201).
            // A more precise check would be for 400/404/422 depending on planned error handling.
            expect(response.status).toBe(500); // Or 400/404 if you implement specific error handling
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        // Optionally, check for a specific error message or code if your API provides one.
        }, 15000); // Increased timeout
        it("should fail to create a purchase if a supplierId does not exist", async ()=>{
            const newTestProduct = await prisma.product.create({
                data: {
                    name: "Product For Invalid Supplier Test",
                    sku: "INV SUP001",
                    price: 100
                }
            });
            const purchasePrice = 80;
            const purchaseQuantity = 5;
            const nonExistentSupplierId = 999999; // Assuming this ID won't exist
            const purchaseInvoicePayload = {
                supplierId: nonExistentSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: newTestProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: purchaseQuantity
                    }
                ],
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            const req = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(purchaseInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            expect(response.status).toBe(500); // Expecting 500 as Prisma throws P2003
            const responseBody = await response.json();
            expect(responseBody.error).toBeDefined();
        });
    });
    describe("PUT /api/purchases/:id (Update Purchase Invoice)", ()=>{
        let existingInvoiceId;
        let productForUpdateTestsId;
        const initialPurchasePrice = 50;
        const initialPurchaseQuantity = 10;
        beforeEach(async ()=>{
            // Create a product specifically for these update/delete tests if not already created
            // The global createdProductId can be used if it fits, or make a new one.
            // Let's use the global one for simplicity, assuming beforeEach cleans it up.
            productForUpdateTestsId = createdProductId;
            // Create an initial purchase invoice to be updated or deleted in tests
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date(Date.now() - 86400000).toISOString(),
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    }
                ],
                totalAmount: initialPurchaseQuantity * initialPurchasePrice,
                status: "paid"
            };
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: initialInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            existingInvoiceId = body.data.id;
            // Sanity check: verify initial state
            const initialProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(initialProduct?.weightedAverageCost).toBe(initialPurchasePrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(initialPurchasePrice);
        });
        it("should update item quantity (increase), recalculate stock and WACs", async ()=>{
            const quantityIncrease = 5;
            const newQuantity = initialPurchaseQuantity + quantityIncrease;
            // Price remains the same for this item in this update scenario
            const updatedPriceForItem = initialPurchasePrice;
            const updatePayload = {
                // We need to send the complete structure expected by the PUT route
                // This includes all items, even if only one is changing.
                // The PUT route logic might compare with existing items to see what changed.
                items: [
                    {
                        // If the item had an ID (PurchaseInvoiceItem id), it might be needed.
                        // Let's assume for now the PUT matches items based on productId if not item ID.
                        // Based on current PUT route, it expects productId.
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    // The distributions in PUT might need to reflect the *new total* for the item
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Simulate API call - updatePurchaseInvoice(req, { params: { id: existingInvoiceId } })
            // This is how you call it if you are testing the handler directly in Jest with context
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // WAC calculation: ((oldQty * oldSSC) + (addedQty * priceOfAddedQty)) / (newTotalQty)
            // In this specific update, the PUT route reverses the old item and adds the new one as if it's a new purchase line for WAC calcs.
            // So, the old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // However, the current PUT logic first reverses *all* old items based on their *original* recorded cost.
            // Then it adds *all* new items based on their *new* cost.
            // So for the product WAC: (TotalValueBefore - OldItemValue + NewItemValue) / (TotalStockBefore - OldItemQty + NewItemQty)
            // And for shop specific WAC: (ShopValueBefore - OldItemValueInShop + NewItemValueInShop) / (ShopStockBefore - OldItemQtyInShop + NewItemQtyInShop)
            // Let's check the logic from src/app/api/purchases/[id]/route.ts
            // 1. It fetches the old invoice.
            // 2. It reverses inventory adjustments for ALL old items (decrease stock, WAC updated).
            // 3. It processes ALL new/updated items as if they are new purchases (increase stock, WAC updated).
            // So, after reversal of initialPurchaseQuantity at initialPurchasePrice:
            // Product WAC and ShopSpecificCost would be effectively 0 if this were the only product/stock.
            // Then, adding newQuantity at updatedPriceForItem:
            // The new WACs should become updatedPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB reflects the change
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item quantity (decrease), recalculate stock and WACs", async ()=>{
            const quantityDecrease = 3;
            const newQuantity = initialPurchaseQuantity - quantityDecrease;
            expect(newQuantity).toBeGreaterThanOrEqual(0); // Ensure we don't go negative for this test logic
            const updatedPriceForItem = initialPurchasePrice; // Price remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: newQuantity,
                        price: updatedPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: newQuantity
                    }
                ]
            };
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(newQuantity);
            // Due to the reversal and re-addition logic of the PUT route:
            // The old initialPurchaseQuantity at initialPurchasePrice is reversed.
            // Then, newQuantity at updatedPriceForItem is added.
            // So, new WACs should become updatedPriceForItem (which is initialPurchasePrice).
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);
            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);
            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);
        }, 15000); // Increased timeout
        it("should update item price, recalculate stock and WACs", async ()=>{
            const newPriceForItem = initialPurchasePrice + 25; // New price, e.g., 50 + 25 = 75
            const quantityUnchanged = initialPurchaseQuantity; // Quantity remains the same
            const updatePayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: quantityUnchanged,
                        price: newPriceForItem
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityUnchanged
                    }
                ]
            };
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify InventoryItem stock (should be unchanged) and shopSpecificCost
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(updatedInventory?.quantity).toBe(quantityUnchanged);
            // WAC logic in PUT: reverses old, adds new. So shopSpecificCost should reflect newPriceForItem.
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(newPriceForItem);
            // Verify Product WAC
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(newPriceForItem);
            // Verify PurchaseInvoiceItem in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].quantity).toBe(quantityUnchanged);
            expect(dbInvoice?.items[0].price).toBe(newPriceForItem);
            expect(dbInvoice?.total).toBe(quantityUnchanged * newPriceForItem);
        }, 15000); // Increased timeout
        it("should add a new item to an existing invoice, update stock and WACs", async ()=>{
            // 1. Define a new product for the new item
            const newItemProduct = await prisma.product.create({
                data: {
                    name: "Newly Added Product for PUT",
                    sku: "PUTNEW001",
                    price: 200
                }
            });
            const newItemProductId = newItemProduct.id;
            const newItemQuantity = 7;
            const newItemPrice = 120;
            // Original item details (from beforeEach setup)
            const originalItemProductId = productForUpdateTestsId;
            const originalItemQuantity = initialPurchaseQuantity;
            const originalItemPrice = initialPurchasePrice;
            // 2. Prepare the update payload with both original and new item
            const updatePayload = {
                items: [
                    {
                        productId: originalItemProductId.toString(),
                        quantity: originalItemQuantity,
                        price: originalItemPrice
                    },
                    {
                        productId: newItemProductId.toString(),
                        quantity: newItemQuantity,
                        price: newItemPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: originalItemQuantity
                    },
                    {
                        [createdShopId]: newItemQuantity
                    } // Distribution for new item
                ]
            };
            // 3. Simulate API call
            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(req, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: {
                        orderBy: {
                            productId: "asc"
                        }
                    }
                }
            });
            expect(dbInvoice?.items.length).toBe(2);
            const expectedTotal = originalItemQuantity * originalItemPrice + newItemQuantity * newItemPrice;
            expect(dbInvoice?.total).toBe(expectedTotal);
            // Find the items in the response (order might vary, so find by productId)
            const dbOriginalItem = dbInvoice?.items.find((item)=>item.productId === originalItemProductId);
            const dbNewItem = dbInvoice?.items.find((item)=>item.productId === newItemProductId);
            expect(dbOriginalItem).toBeDefined();
            expect(dbOriginalItem?.quantity).toBe(originalItemQuantity);
            expect(dbOriginalItem?.price).toBe(originalItemPrice);
            expect(dbNewItem).toBeDefined();
            expect(dbNewItem?.quantity).toBe(newItemQuantity);
            expect(dbNewItem?.price).toBe(newItemPrice);
            // Verify InventoryItem and Product WAC for the original item
            // (Due to PUT logic of reverse & re-add, WACs should reflect its current price)
            const originalInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: originalItemProductId,
                    shopId: createdShopId
                }
            });
            expect(originalInventory?.quantity).toBe(originalItemQuantity);
            expect(originalInventory?.shopSpecificCost).toBeCloseTo(originalItemPrice);
            const originalProduct = await prisma.product.findUnique({
                where: {
                    id: originalItemProductId
                }
            });
            expect(originalProduct?.weightedAverageCost).toBeCloseTo(originalItemPrice);
            // Verify InventoryItem and Product WAC for the NEW item
            const newInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: newItemProductId,
                    shopId: createdShopId
                }
            });
            expect(newInventory?.quantity).toBe(newItemQuantity);
            expect(newInventory?.shopSpecificCost).toBeCloseTo(newItemPrice);
            const newProductDb = await prisma.product.findUnique({
                where: {
                    id: newItemProductId
                }
            });
            expect(newProductDb?.weightedAverageCost).toBeCloseTo(newItemPrice);
        }, 15000); // Increased timeout
        it("should remove an item from an existing invoice, update stock and WACs", async ()=>{
            // 1. Setup: Ensure an invoice with at least two items exists.
            // We'll use the existing `productForUpdateTestsId` and create one more product and item.
            const productToRemove = await prisma.product.create({
                data: {
                    name: "Product To Be Removed",
                    sku: "PUTRMV001",
                    price: 300
                }
            });
            const productToRemoveId = productToRemove.id;
            const productToRemoveQuantity = 4;
            const productToRemovePrice = 40;
            // Update the existing invoice (created in global beforeEach for PUT) to include this second item first.
            const addSecondItemPayload = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    },
                    {
                        productId: productToRemoveId.toString(),
                        quantity: productToRemoveQuantity,
                        price: productToRemovePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    },
                    {
                        [createdShopId]: productToRemoveQuantity
                    }
                ]
            };
            const addReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(addSecondItemPayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            await (0, _route1.PUT)(addReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            // Sanity check: Invoice should have 2 items
            let invoiceWithTwoItems = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(invoiceWithTwoItems?.items.length).toBe(2);
            // 2. Prepare the update payload that only contains the item we want to keep.
            const updatePayloadToRemoveItem = {
                items: [
                    {
                        productId: productForUpdateTestsId.toString(),
                        quantity: initialPurchaseQuantity,
                        price: initialPurchasePrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: initialPurchaseQuantity
                    } // Distribution for the kept item
                ]
            };
            // 3. Simulate API call to remove the item
            const removeReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {
                method: "PUT",
                body: JSON.stringify(updatePayloadToRemoveItem),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route1.PUT)(removeReq, {
                params: {
                    id: existingInvoiceId
                }
            });
            const responseBody = await response.json();
            // 4. Assertions
            expect(response.status).toBe(200);
            expect(responseBody.data).toHaveProperty("id", existingInvoiceId);
            // Verify PurchaseInvoice in DB - should now have only 1 item
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: existingInvoiceId
                },
                include: {
                    items: true
                }
            });
            expect(dbInvoice?.items.length).toBe(1);
            expect(dbInvoice?.items[0].productId).toBe(productForUpdateTestsId);
            expect(dbInvoice?.items[0].quantity).toBe(initialPurchaseQuantity);
            expect(dbInvoice?.items[0].price).toBe(initialPurchasePrice);
            expect(dbInvoice?.total).toBe(initialPurchaseQuantity * initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the KEPT item
            const keptInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForUpdateTestsId,
                    shopId: createdShopId
                }
            });
            expect(keptInventory?.quantity).toBe(initialPurchaseQuantity);
            expect(keptInventory?.shopSpecificCost).toBeCloseTo(initialPurchasePrice);
            const keptProduct = await prisma.product.findUnique({
                where: {
                    id: productForUpdateTestsId
                }
            });
            expect(keptProduct?.weightedAverageCost).toBeCloseTo(initialPurchasePrice);
            // Verify InventoryItem and Product WAC for the REMOVED item
            // Stock should be zero or the item might be gone from inventory if it was the only purchase
            // WAC on product should be 0 if no other purchases exist.
            const removedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productToRemoveId,
                    shopId: createdShopId
                }
            });
            // The PUT logic reverses stock. If this was the only stock, it becomes 0.
            expect(removedInventory?.quantity).toBe(0);
            // ShopSpecificCost might become 0 or NaN if quantity is 0. The API sets it to 0 for safety.
            expect(removedInventory?.shopSpecificCost).toBeCloseTo(0);
            const removedProductDb = await prisma.product.findUnique({
                where: {
                    id: productToRemoveId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfRemovedItem = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productToRemoveId
                }
            });
            if (otherPurchasesOfRemovedItem === 0) {
                expect(removedProductDb?.weightedAverageCost).toBeCloseTo(0);
            } // Else, it would be based on other purchases, which this test doesn't set up.
        }, 15000); // Increased timeout
    });
    describe("DELETE /api/purchases/:id (Delete Purchase Invoice)", ()=>{
        let invoiceToDeleteId;
        let productForDeleteTestId;
        const deleteTestInitialPrice = 60;
        const deleteTestInitialQuantity = 12;
        beforeEach(async ()=>{
            // Ensure product exists for the test
            const product = await prisma.product.create({
                data: {
                    name: "Product For Delete Test",
                    sku: "DELPROD001",
                    price: 100
                }
            });
            productForDeleteTestId = product.id;
            // Create an initial purchase invoice to be deleted
            const initialInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productForDeleteTestId.toString(),
                        quantity: deleteTestInitialQuantity,
                        price: deleteTestInitialPrice
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: deleteTestInitialQuantity
                    } // Explicit distribution
                ],
                totalAmount: deleteTestInitialQuantity * deleteTestInitialPrice,
                status: "paid"
            };
            const req = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: initialInvoicePayload,
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await (0, _route.POST)(req);
            const body = await response.json();
            invoiceToDeleteId = body.data.id;
            // Sanity check: verify initial state after creation
            const initialProductDB = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            expect(initialProductDB?.weightedAverageCost).toBe(deleteTestInitialPrice);
            const initialInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            expect(initialInventory?.quantity).toBe(deleteTestInitialQuantity);
            expect(initialInventory?.shopSpecificCost).toBe(deleteTestInitialPrice);
        });
        it("should delete a purchase invoice and correctly reverse stock and WACs for a single-item invoice with explicit distribution", async ()=>{
            // 1. Call the DELETE endpoint
            const deleteReq = new NextRequest(`http://localhost/api/purchases/${invoiceToDeleteId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceToDeleteId
                }
            });
            // 2. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 3. Verify PurchaseInvoice is deleted from DB
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceToDeleteId
                }
            });
            expect(dbInvoice).toBeNull();
            // 4. Verify PurchaseInvoiceItems are deleted
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceToDeleteId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock is reversed
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productForDeleteTestId,
                    shopId: createdShopId
                }
            });
            // Assuming this was the only purchase, stock should be 0
            expect(updatedInventory?.quantity).toBe(0);
            // ShopSpecificCost should also be 0 if stock is 0
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated (should be 0 if this was the only purchase)
            const updatedProduct = await prisma.product.findUnique({
                where: {
                    id: productForDeleteTestId
                }
            });
            // If no other purchase items for this product, WAC should become 0.
            const otherPurchasesOfProduct = await prisma.purchaseInvoiceItem.count({
                where: {
                    productId: productForDeleteTestId
                }
            });
            if (otherPurchasesOfProduct === 0) {
                expect(updatedProduct?.weightedAverageCost).toBeCloseTo(0);
            }
        });
        it("should delete a purchase and reverse stock/WAC when product is in a single inferred shop", async ()=>{
            // 1. Setup: Create dedicated entities for this test to ensure isolation.
            const testShop = await prisma.shop.create({
                data: {
                    name: "Inferred Delete Test Shop",
                    location: "Loc X"
                }
            });
            const testSupplier = await prisma.supplier.create({
                data: {
                    name: "Inferred Delete Test Supplier"
                }
            });
            const testProduct = await prisma.product.create({
                data: {
                    name: "Product for Inferred Delete",
                    sku: "INFDEL001",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            // Create an inventory item for this product in the test shop.
            // This makes it the "single inferred shop".
            await prisma.inventoryItem.create({
                data: {
                    productId: testProduct.id,
                    shopId: testShop.id,
                    quantity: 0,
                    shopSpecificCost: 0
                }
            });
            const purchaseQuantity = 12;
            const purchasePrice = 60;
            const inferredShopInvoicePayload = {
                supplierId: testSupplier.id.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: testProduct.id.toString(),
                        quantity: purchaseQuantity,
                        price: purchasePrice
                    }
                ],
                // NO distributions property here for inference to kick in on POST
                totalAmount: purchaseQuantity * purchasePrice,
                status: "paid"
            };
            // Create the purchase invoice (this is where the failure was happening)
            const createReq = createMockNextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(inferredShopInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201); // Assert successful creation
            const createBody = await createResponse.json();
            const invoiceIdForInferredDelete = createBody.data.id;
            // Sanity check: Verify stock and WAC after creation
            const inventoryAfterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(inventoryAfterCreate?.quantity).toBe(purchaseQuantity);
            expect(inventoryAfterCreate?.shopSpecificCost).toBeCloseTo(purchasePrice);
            const productAfterCreate = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(productAfterCreate?.weightedAverageCost).toBeCloseTo(purchasePrice);
            // 2. Call the DELETE endpoint
            const deleteReq = new NextRequest(`http://localhost/api/purchases/${invoiceIdForInferredDelete}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: invoiceIdForInferredDelete
                }
            });
            // 3. Assertions for DELETE response
            expect(deleteResponse.status).toBe(200);
            const deleteResponseBody = await deleteResponse.json();
            expect(deleteResponseBody.message).toBe("Purchase invoice deleted successfully");
            // 4. Verify PurchaseInvoice and Items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: invoiceIdForInferredDelete
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 5. Verify InventoryItem stock and shopSpecificCost are reversed in the inferred shop
            const updatedInventory = await prisma.inventoryItem.findFirst({
                where: {
                    productId: testProduct.id,
                    shopId: testShop.id
                }
            });
            expect(updatedInventory?.quantity).toBe(0);
            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);
            // 6. Verify Product WAC is recalculated to 0
            const updatedProductDB = await prisma.product.findUnique({
                where: {
                    id: testProduct.id
                }
            });
            expect(updatedProductDB?.weightedAverageCost).toBeCloseTo(0);
            // Cleanup dedicated entities for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: testProduct.id
                }
            });
            await prisma.product.delete({
                where: {
                    id: testProduct.id
                }
            });
            await prisma.supplier.delete({
                where: {
                    id: testSupplier.id
                }
            });
            await prisma.shop.delete({
                where: {
                    id: testShop.id
                }
            });
        }, 15000); // Added a longer timeout as a precaution
        it("should delete an invoice with multiple items, reversing stock/WAC for each", async ()=>{
            // 1. Setup: Create multiple products and an invoice with items from these products.
            // For simplicity, distribute each to the main createdShopId from global beforeEach.
            const productA = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod A",
                    sku: "MDEL00A",
                    price: 100,
                    weightedAverageCost: 0
                }
            });
            const productB = await prisma.product.create({
                data: {
                    name: "Multi-Del Prod B",
                    sku: "MDEL00B",
                    price: 200,
                    weightedAverageCost: 0
                }
            });
            const quantityA = 5;
            const priceA = 50;
            const quantityB = 3;
            const priceB = 120;
            const multiItemInvoicePayload = {
                supplierId: createdSupplierId.toString(),
                date: new Date().toISOString(),
                items: [
                    {
                        productId: productA.id.toString(),
                        quantity: quantityA,
                        price: priceA
                    },
                    {
                        productId: productB.id.toString(),
                        quantity: quantityB,
                        price: priceB
                    }
                ],
                distributions: [
                    {
                        [createdShopId]: quantityA
                    },
                    {
                        [createdShopId]: quantityB
                    } // Item B to main shop
                ],
                totalAmount: quantityA * priceA + quantityB * priceB,
                status: "paid"
            };
            const createReq = new NextRequest("http://localhost/api/purchases", {
                method: "POST",
                body: JSON.stringify(multiItemInvoicePayload),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const createResponse = await (0, _route.POST)(createReq);
            expect(createResponse.status).toBe(201);
            const createBody = await createResponse.json();
            const multiItemInvoiceId = createBody.data.id;
            // Sanity check inventory and WAC after creation
            const invA_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterCreate?.quantity).toBe(quantityA);
            expect(invA_afterCreate?.shopSpecificCost).toBe(priceA);
            const prodA_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterCreate?.weightedAverageCost).toBe(priceA);
            const invB_afterCreate = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterCreate?.quantity).toBe(quantityB);
            expect(invB_afterCreate?.shopSpecificCost).toBe(priceB);
            const prodB_afterCreate = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterCreate?.weightedAverageCost).toBe(priceB);
            // 2. Call DELETE endpoint
            const deleteReq = createMockNextRequest(`http://localhost/api/purchases/${multiItemInvoiceId}`, {
                method: "DELETE"
            });
            const deleteResponse = await (0, _route1.DELETE)(deleteReq, {
                params: {
                    id: multiItemInvoiceId
                }
            });
            expect(deleteResponse.status).toBe(200);
            // 3. Verify invoice and items are deleted
            const dbInvoice = await prisma.purchaseInvoice.findUnique({
                where: {
                    id: multiItemInvoiceId
                }
            });
            expect(dbInvoice).toBeNull();
            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({
                where: {
                    purchaseInvoiceId: multiItemInvoiceId
                }
            });
            expect(dbInvoiceItems.length).toBe(0);
            // 4. Verify stock and WAC for Product A are reversed
            const invA_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productA.id,
                    shopId: createdShopId
                }
            });
            expect(invA_afterDelete?.quantity).toBe(0);
            expect(invA_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodA_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productA.id
                }
            });
            expect(prodA_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // 5. Verify stock and WAC for Product B are reversed
            const invB_afterDelete = await prisma.inventoryItem.findFirst({
                where: {
                    productId: productB.id,
                    shopId: createdShopId
                }
            });
            expect(invB_afterDelete?.quantity).toBe(0);
            expect(invB_afterDelete?.shopSpecificCost).toBeCloseTo(0);
            const prodB_afterDelete = await prisma.product.findUnique({
                where: {
                    id: productB.id
                }
            });
            expect(prodB_afterDelete?.weightedAverageCost).toBeCloseTo(0);
            // Clean up products and their inventory items created for this test
            await prisma.inventoryItem.deleteMany({
                where: {
                    productId: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
            await prisma.product.deleteMany({
                where: {
                    id: {
                        in: [
                            productA.id,
                            productB.id
                        ]
                    }
                }
            });
        }, 15000); // Timeout for safety
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvaW50ZWdyYXRpb24vcHVyY2hhc2VJbnZvaWNlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGplc3QtZW52aXJvbm1lbnQgbm9kZVxuICovXG5pbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tICdAcHJpc21hL2NsaWVudCc7XG5pbXBvcnQgeyBQT1NUIGFzIGNyZWF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvcm91dGUnOyAvLyBBZGp1c3QgaWYgZGlyZWN0IGltcG9ydCBpc24ndCBmZWFzaWJsZVxuaW1wb3J0IHsgUFVUIGFzIHVwZGF0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuaW1wb3J0IHsgREVMRVRFIGFzIGRlbGV0ZVB1cmNoYXNlSW52b2ljZSB9IGZyb20gJ0AvYXBwL2FwaS9wdXJjaGFzZXMvW2lkXS9yb3V0ZSc7IC8vIEFkanVzdFxuLy8gTW9jayBOZXh0UmVxdWVzdCBpbnRlcmZhY2VcbmludGVyZmFjZSBOZXh0UmVxdWVzdCB7XG4gIG1ldGhvZDogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgaGVhZGVyczogSGVhZGVycztcbiAganNvbigpOiBQcm9taXNlPGFueT47XG4gIHRleHQoKTogUHJvbWlzZTxzdHJpbmc+O1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2sgTmV4dFJlcXVlc3RcbmNvbnN0IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCA9ICh1cmw6IHN0cmluZywgb3B0aW9uczoge1xuICBtZXRob2Q/OiBzdHJpbmc7XG4gIGJvZHk/OiBhbnk7XG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSA9IHt9KTogTmV4dFJlcXVlc3QgPT4ge1xuICBjb25zdCB7IG1ldGhvZCA9ICdHRVQnLCBib2R5LCBoZWFkZXJzID0ge30gfSA9IG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIHVybCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICBqc29uOiBhc3luYyAoKSA9PiBib2R5ID8gKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoYm9keSkgOiBib2R5KSA6IHt9LFxuICAgIHRleHQ6IGFzeW5jICgpID0+IGJvZHkgPyAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnID8gYm9keSA6IEpTT04uc3RyaW5naWZ5KGJvZHkpKSA6ICcnLFxuICB9IGFzIE5leHRSZXF1ZXN0O1xufTtcblxuaW1wb3J0IHsgY3JlYXRlTW9ja3MgfSBmcm9tICdub2RlLW1vY2tzLWh0dHAnOyAvLyBPciBhbnkgb3RoZXIgd2F5IHRvIG1vY2sgTmV4dFJlcXVlc3QvUmVzcG9uc2VcblxuY29uc3QgcHJpc21hID0gbmV3IFByaXNtYUNsaWVudCgpO1xuXG5kZXNjcmliZSgnUHVyY2hhc2UgSW52b2ljZSBBUEkgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gICAgbGV0IGNyZWF0ZWRTaG9wSWQ6IHN0cmluZztcbiAgICBsZXQgY3JlYXRlZFN1cHBsaWVySWQ6IG51bWJlcjtcbiAgICBsZXQgY3JlYXRlZFByb2R1Y3RJZDogbnVtYmVyO1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gU2VlZCBpbml0aWFsIGRhdGEgaWYgbmVjZXNzYXJ5LCBlLmcuLCBhIGRlZmF1bHQgc3VwcGxpZXIgb3Igc2hvcFxuICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBjcmVhdGUgdGhlbSBpbiBiZWZvcmVFYWNoIG9yIHNwZWNpZmljIHRlc3RzXG4gICAgfSk7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgZGF0YWJhc2UgdGFibGVzIHRvIGVuc3VyZSB0ZXN0IGlzb2xhdGlvblxuICAgICAgICBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlSXRlbS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5wcm9kdWN0LmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5zaG9wLmRlbGV0ZU1hbnkoe30pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHNob3AgZm9yIHRlc3RpbmdcbiAgICAgICAgY29uc3Qgc2hvcCA9IGF3YWl0IHByaXNtYS5zaG9wLmNyZWF0ZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgU2hvcCBMb2NhbCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdUZXN0IExvY2F0aW9uJyxcbiAgICAgICAgICAgICAgICAvLyBBZGQgb3RoZXIgcmVxdWlyZWQgZmllbGRzIGlmIGFueVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNyZWF0ZWRTaG9wSWQgPSBzaG9wLmlkO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHN1cHBsaWVyIGZvciB0ZXN0aW5nXG4gICAgICAgIGNvbnN0IHN1cHBsaWVyID0gYXdhaXQgcHJpc21hLnN1cHBsaWVyLmNyZWF0ZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgU3VwcGxpZXIgTG9jYWwnLFxuICAgICAgICAgICAgICAgIC8vIEFkZCBvdGhlciByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjcmVhdGVkU3VwcGxpZXJJZCA9IHN1cHBsaWVyLmlkO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHByb2R1Y3QgZm9yIHRlc3RpbmcgdXBkYXRlcy9kZWxldGVzIChub3QgZm9yIGNyZWF0ZSBuZXcgcHJvZHVjdCB0ZXN0KVxuICAgICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXhpc3RpbmcgUHJvZHVjdCcsXG4gICAgICAgICAgICAgICAgcHJpY2U6IDEwMCwgLy8gcmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgc2t1OiAnRVhJU1RJTkcwMDEnLFxuICAgICAgICAgICAgICAgIHNob3BJZDogY3JlYXRlZFNob3BJZCwgLy8gT3B0aW9uYWw6IGFzc29jaWF0ZSB3aXRoIGEgc2hvcCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gd2VpZ2h0ZWRBdmVyYWdlQ29zdCB3aWxsIGJlIHNldCBieSBwdXJjaGFzZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNyZWF0ZWRQcm9kdWN0SWQgPSBwcm9kdWN0LmlkO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBDbGVhbiB1cCBkYXRhYmFzZSBhZnRlciBhbGwgdGVzdHNcbiAgICAgICAgYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZGVsZXRlTWFueSh7fSk7XG4gICAgICAgIGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEucHJvZHVjdC5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLnN1cHBsaWVyLmRlbGV0ZU1hbnkoe30pO1xuICAgICAgICBhd2FpdCBwcmlzbWEuc2hvcC5kZWxldGVNYW55KHt9KTtcbiAgICAgICAgYXdhaXQgcHJpc21hLiRkaXNjb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnUE9TVCAvYXBpL3B1cmNoYXNlcyAoQ3JlYXRlIFB1cmNoYXNlIEludm9pY2UpJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhIHB1cmNoYXNlIGludm9pY2UgZm9yIGEgbmV3IHByb2R1Y3QsIHVwZGF0ZSBpbnZlbnRvcnksIGFuZCBzZXQgV0FDJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMS4gRGVmaW5lIGRhdGEgZm9yIGEgbmV3IHByb2R1Y3RcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb2R1Y3ROYW1lID0gJ0JyYW5kIE5ldyBSYWNrZXQnO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvZHVjdFNrdSA9ICdORVdCMDAxJztcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUHJpY2UgPSAxNTA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gMTA7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcm9kdWN0IGZpcnN0IChhcyBBUEkgZXhwZWN0cyBwcm9kdWN0SWQpXG4gICAgICAgICAgICAvLyBJbiBhIHJlYWwgc2NlbmFyaW8sIHRoZSBVSSBtaWdodCBjcmVhdGUgcHJvZHVjdCB0aGVuIHB1cmNoYXNlLCBvciBwdXJjaGFzZSBBUEkgaGFuZGxlcyBwcm9kdWN0IGNyZWF0aW9uXG4gICAgICAgICAgICAvLyBGb3IgdGhpcyB0ZXN0LCBhc3N1bWUgcHJvZHVjdCBpcyBjcmVhdGVkIGp1c3QgYmVmb3JlLCBvciBBUEkgaW1wbGllcyBpdHMgY3JlYXRpb24gZnJvbSBwdXJjaGFzZSAobm90IGN1cnJlbnQgQVBJKVxuICAgICAgICAgICAgLy8gTGV0J3MgYXNzdW1lIGZvciBub3cgcHJvZHVjdCBtdXN0IGV4aXN0LCBpZiBBUEkgZG9lc24ndCBjcmVhdGUgaXQgZnJvbSBwdXJjaGFzZSBpdGVtcy5cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IEFQSSdzIFBPU1QgL2FwaS9wdXJjaGFzZXMgZXhwZWN0cyBpdGVtLnByb2R1Y3RJZCwgaW1wbHlpbmcgcHJvZHVjdCBleGlzdHMuXG5cbiAgICAgICAgICAgIGNvbnN0IG5ld1Rlc3RQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5ld1Byb2R1Y3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBza3U6IG5ld1Byb2R1Y3RTa3UsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAyNTAsIC8vIFJldGFpbCBwcmljZVxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgLy8gT3B0aW9uYWwgZGVmYXVsdCBzaG9wIGFzc29jaWF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXN0UHJvZHVjdElkID0gbmV3VGVzdFByb2R1Y3QuaWQ7XG5cbiAgICAgICAgICAgIC8vIDIuIFByZXBhcmUgdGhlIHJlcXVlc3QgYm9keSBmb3IgUE9TVCAvYXBpL3B1cmNoYXNlc1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IG5ld1Rlc3RQcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbIC8vIEV4cGxpY2l0IGRpc3RyaWJ1dGlvbiBpcyBjcnVjaWFsIGJhc2VkIG9uIGN1cnJlbnQgUE9TVCBBUElcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2NyZWF0ZWRTaG9wSWRdOiBwdXJjaGFzZVF1YW50aXR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBwdXJjaGFzZVF1YW50aXR5ICogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIENvbnN0cnVjdCBhIE5leHRSZXF1ZXN0IGluc3RhbmNlXG4gICAgICAgICAgICBjb25zdCByZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBwdXJjaGFzZUludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHRoZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpOyAvLyBPciAyMDAgZGVwZW5kaW5nIG9uIHlvdXIgQVBJJ3Mgc3VjY2VzcyByZXNwb25zZSBmb3IgUE9TVFxuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlQm9keS5kYXRhKS50b0hhdmVQcm9wZXJ0eSgnaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogY3JlYXRlZEludm9pY2VJZCB9LFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IHsgaXRlbXM6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5zdXBwbGllcklkKS50b0JlKGNyZWF0ZWRTdXBwbGllcklkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShuZXdUZXN0UHJvZHVjdElkKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8uaXRlbXNbMF0ucHJpY2UpLnRvQmUocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGluIERCXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0gPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvcElkOiBjcmVhdGVkU2hvcElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0pLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8ucXVhbnRpdHkpLnRvQmUocHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICAvLyBUaGUgUE9TVCByb3V0ZSBzZWVtcyB0byBjYWxjdWxhdGUgc2hvcFNwZWNpZmljQ29zdCB0b28uXG4gICAgICAgICAgICAvLyBXQUMgPSAoQ3VycmVudCBUb3RhbCBWYWx1ZSArIE5ldyBQdXJjaGFzZSBWYWx1ZSkgLyAoQ3VycmVudCBRdWFudGl0eSArIE5ldyBRdWFudGl0eSlcbiAgICAgICAgICAgIC8vIEZvciBuZXcgaXRlbSwgZXhpc3Rpbmcgc2hvcFNwZWNpZmljQ29zdCBpcyAwLCBjdXJyZW50UXVhbnRpdHkgaXMgMC5cbiAgICAgICAgICAgIC8vIFNvIG5ld1Nob3BTcGVjaWZpY0Nvc3Qgc2hvdWxkIGJlIG5ld0Nvc3QgKHB1cmNoYXNlUHJpY2UpXG4gICAgICAgICAgICBleHBlY3QoZGJJbnZlbnRvcnlJdGVtPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UpO1xuXG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBQcm9kdWN0IFdBQyBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IG5ld1Rlc3RQcm9kdWN0SWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICAvLyBGb3IgYSBuZXcgcHJvZHVjdCwgV0FDIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgcHVyY2hhc2UgcHJpY2Ugb2YgdGhpcyBmaXJzdCBiYXRjaFxuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgcHVyY2hhc2UgZm9yIGFuIGV4aXN0aW5nIHByb2R1Y3QsIHVwZGF0ZSBpbnZlbnRvcnksIGFuZCByZWNhbGN1bGF0ZSBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gMC4gSW5pdGlhbCBzdGF0ZTogUHJvZHVjdCBleGlzdHMsIHBvdGVudGlhbGx5IHdpdGggc29tZSBpbnZlbnRvcnkgYW5kIFdBQ1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFB1cmNoYXNlUHJpY2UgPSAxMjA7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDU7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3RJZCA9IGNyZWF0ZWRQcm9kdWN0SWQ7IC8vIEZyb20gYmVmb3JlRWFjaFxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gaW5pdGlhbCBwdXJjaGFzZSB0byBzZXQgdXAgZXhpc3RpbmcgaW52ZW50b3J5IGFuZCBXQUNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDg2NDAwMDAwKS50b0lTT1N0cmluZygpLCAvLyBZZXN0ZXJkYXlcbiAgICAgICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBleGlzdGluZ1Byb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiBpbml0aWFsUHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH1dLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAqIGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSZXEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbml0aWFsUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKGluaXRpYWxSZXEpO1xuXG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0QmVmb3JlTmV3UHVyY2hhc2UgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBjb25zdCBpbnZlbnRvcnlCZWZvcmVOZXdQdXJjaGFzZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogZXhpc3RpbmdQcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuXG4gICAgICAgICAgICBleHBlY3QocHJvZHVjdEJlZm9yZU5ld1B1cmNoYXNlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZlbnRvcnlCZWZvcmVOZXdQdXJjaGFzZT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGludmVudG9yeUJlZm9yZU5ld1B1cmNoYXNlPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gMS4gRGVmaW5lIGRhdGEgZm9yIHRoZSBuZXcgcHVyY2hhc2Ugb2YgdGhlIGV4aXN0aW5nIHByb2R1Y3RcbiAgICAgICAgICAgIGNvbnN0IG5ld1B1cmNoYXNlUHJpY2UgPSAxMDA7XG4gICAgICAgICAgICBjb25zdCBuZXdQdXJjaGFzZVF1YW50aXR5ID0gODtcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogZXhpc3RpbmdQcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBuZXdQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld1B1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjcmVhdGVkU2hvcElkXTogbmV3UHVyY2hhc2VRdWFudGl0eVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogbmV3UHVyY2hhc2VRdWFudGl0eSAqIG5ld1B1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyAzLiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNC4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZEludm9pY2VJZCA9IHJlc3BvbnNlQm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbVxuICAgICAgICAgICAgY29uc3QgZGJJbnZlbnRvcnlJdGVtID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IGV4aXN0aW5nUHJvZHVjdElkLFxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbFF1YW50aXR5ID0gaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKyBuZXdQdXJjaGFzZVF1YW50aXR5O1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8ucXVhbnRpdHkpLnRvQmUoZXhwZWN0ZWRUb3RhbFF1YW50aXR5KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHNob3BTcGVjaWZpY0Nvc3QgcmVjYWxjdWxhdGlvblxuICAgICAgICAgICAgLy8gU1NDID0gKChvbGRRdHkgKiBvbGRTU0MpICsgKG5ld1F0eSAqIG5ld1ByaWNlKSkgLyAob2xkUXR5ICsgbmV3UXR5KVxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRTaG9wU3BlY2lmaWNDb3N0ID1cbiAgICAgICAgICAgICAgICAoKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UpICsgKG5ld1B1cmNoYXNlUXVhbnRpdHkgKiBuZXdQdXJjaGFzZVByaWNlKSkgL1xuICAgICAgICAgICAgICAgIChpbml0aWFsUHVyY2hhc2VRdWFudGl0eSArIG5ld1B1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oZXhwZWN0ZWRTaG9wU3BlY2lmaWNDb3N0KTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDIHJlY2FsY3VsYXRpb25cbiAgICAgICAgICAgIC8vIFdBQyA9ICgob2xkVG90YWxRdHkgKiBvbGRXQUMpICsgKG5ld1B1cmNoYXNlUXR5ICogbmV3UHVyY2hhc2VQcmljZSkpIC8gKG5ld1RvdGFsUXR5ICsgbmV3UHVyY2hhc2VRdHkpXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHByb2R1Y3QgV0FDIHdhcyBpbml0aWFsUHVyY2hhc2VQcmljZSBmb3IgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkuXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFByb2R1Y3RXQUMgPVxuICAgICAgICAgICAgICAgICgoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgKiBpbml0aWFsUHVyY2hhc2VQcmljZSkgKyAobmV3UHVyY2hhc2VRdWFudGl0eSAqIG5ld1B1cmNoYXNlUHJpY2UpKSAvXG4gICAgICAgICAgICAgICAgKGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICsgbmV3UHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBjb25zdCBkYlByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhleHBlY3RlZFByb2R1Y3RXQUMpO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBwdXJjaGFzZSB3aXRoIG11bHRpcGxlIGl0ZW1zIGFuZCB1cGRhdGUgaW52ZW50b3J5L1dBQyBmb3IgZWFjaCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSB0d28gZGlzdGluY3QgcHJvZHVjdHMgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdDFEYXRhID0geyBuYW1lOiAnTXVsdGlJdGVtIFByb2R1Y3QgQScsIHNrdTogJ01VTFRJMDAxJywgcHJpY2U6IDUwLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QyRGF0YSA9IHsgbmFtZTogJ011bHRpSXRlbSBQcm9kdWN0IEInLCBza3U6ICdNVUxUSTAwMicsIHByaWNlOiA3NSwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH07XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0MSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7IGRhdGE6IHByb2R1Y3QxRGF0YSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QyID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHsgZGF0YTogcHJvZHVjdDJEYXRhIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlMSA9IDQwO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eTEgPSA1O1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZTIgPSA2MDtcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUXVhbnRpdHkyID0gMztcblxuICAgICAgICAgICAgLy8gMi4gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdDEuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwdXJjaGFzZVByaWNlMSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Mi5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHkyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogWyAvLyBFeHBsaWNpdCBkaXN0cmlidXRpb24gZm9yIGVhY2ggaXRlbVxuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcHVyY2hhc2VRdWFudGl0eTEgfSwgLy8gRGlzdHJpYnV0aW9uIGZvciBpdGVtIDFcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHkyIH0gIC8vIERpc3RyaWJ1dGlvbiBmb3IgaXRlbSAyXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogKHB1cmNoYXNlUXVhbnRpdHkxICogcHVyY2hhc2VQcmljZTEpICsgKHB1cmNoYXNlUXVhbnRpdHkyICogcHVyY2hhc2VQcmljZTIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMy4gU2ltdWxhdGUgQVBJIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHB1cmNoYXNlSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIC8vIDQuIEFzc2VydGlvbnNcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRJbnZvaWNlSWQgPSByZXNwb25zZUJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBhbmQgaXRzIGl0ZW1zXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBjcmVhdGVkSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogeyBvcmRlckJ5OiB7IHByb2R1Y3RJZDogJ2FzYycgfSB9IH0gLy8gT3JkZXIgdG8gZW5zdXJlIGNvbnNpc3RlbnQgYXNzZXJ0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcbiAgICAgICAgICAgIC8vIEFzc3VtaW5nIHByb2R1Y3QxLmlkIDwgcHJvZHVjdDIuaWQgZHVlIHRvIGNyZWF0aW9uIG9yZGVyIGZvciBjb25zaXN0ZW50IGNoZWNrc1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkUHJvZHVjdHMgPSBbcHJvZHVjdDEsIHByb2R1Y3QyXS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1swXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5MSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzFdLnByb2R1Y3RJZCkudG9CZShzb3J0ZWRQcm9kdWN0c1sxXS5pZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5xdWFudGl0eSkudG9CZShwdXJjaGFzZVF1YW50aXR5Mik7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1sxXS5wcmljZSkudG9CZShwdXJjaGFzZVByaWNlMik7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAxXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0xID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QxLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTE/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0xPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UxKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDEgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QxLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0MT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgUHJvZHVjdCAyXG4gICAgICAgICAgICBjb25zdCBkYkludmVudG9yeUl0ZW0yID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QyLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52ZW50b3J5SXRlbTI/LnF1YW50aXR5KS50b0JlKHB1cmNoYXNlUXVhbnRpdHkyKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludmVudG9yeUl0ZW0yPy5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKHB1cmNoYXNlUHJpY2UyKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdDIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3QyLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJQcm9kdWN0Mj8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlMik7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIGRpc3RyaWJ1dGUgYSBzaW5nbGUgcHVyY2hhc2UgaXRlbSB0byBtdWx0aXBsZSBzaG9wcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIENyZWF0ZSB0d28gbmV3IHNob3BzIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgIGNvbnN0IHNob3BBID0gYXdhaXQgcHJpc21hLnNob3AuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnVGVzdCBTaG9wIEEnLCBsb2NhdGlvbjogJ0xvYyBBJyB9IH0pO1xuICAgICAgICAgICAgY29uc3Qgc2hvcEIgPSBhd2FpdCBwcmlzbWEuc2hvcC5jcmVhdGUoeyBkYXRhOiB7IG5hbWU6ICdUZXN0IFNob3AgQicsIGxvY2F0aW9uOiAnTG9jIEInIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIDIuIENyZWF0ZSBhIG5ldyBwcm9kdWN0XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnU3BsaXQgUHJvZHVjdCcsIHNrdTogJ1NQTElUMDAxJywgcHJpY2U6IDIwMCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VQcmljZSA9IDE4MDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsUXVhbnRpdHkgPSAxMDtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5Rm9yU2hvcEEgPSA2O1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlGb3JTaG9wQiA9IDQ7XG5cbiAgICAgICAgICAgIGV4cGVjdChxdWFudGl0eUZvclNob3BBICsgcXVhbnRpdHlGb3JTaG9wQikudG9CZSh0b3RhbFF1YW50aXR5KTsgLy8gU2FuaXR5IGNoZWNrXG5cbiAgICAgICAgICAgIC8vIDMuIFByZXBhcmUgcmVxdWVzdCBib2R5XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IGNyZWF0ZWRTdXBwbGllcklkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogcHJvZHVjdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHRvdGFsUXVhbnRpdHksIC8vIFRvdGFsIHF1YW50aXR5IGZvciB0aGUgaXRlbSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyAvLyBEaXN0cmlidXRpb24gZm9yIHRoZSBzaW5nbGUgaXRlbSwgc3BsaXQgaW50byB0d28gc2hvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzaG9wQS5pZF06IHF1YW50aXR5Rm9yU2hvcEEsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2hvcEIuaWRdOiBxdWFudGl0eUZvclNob3BCLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogdG90YWxRdWFudGl0eSAqIHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyA0LiBTaW11bGF0ZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gNS4gQXNzZXJ0aW9uc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBmb3IgU2hvcCBBXG4gICAgICAgICAgICBjb25zdCBpbnZJdGVtQSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0LmlkLCBzaG9wSWQ6IHNob3BBLmlkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1BKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlGb3JTaG9wQSk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUE/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGZvciBTaG9wIEJcbiAgICAgICAgICAgIGNvbnN0IGludkl0ZW1CID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3QuaWQsIHNob3BJZDogc2hvcEIuaWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52SXRlbUIpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KGludkl0ZW1CPy5xdWFudGl0eSkudG9CZShxdWFudGl0eUZvclNob3BCKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZJdGVtQj8uc2hvcFNwZWNpZmljQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDIChzaG91bGQgYmUgdGhlIHB1cmNoYXNlIHByaWNlIGFzIGl0J3MgYWxsIG5ldyBzdG9jaylcbiAgICAgICAgICAgIGNvbnN0IGRiUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShwdXJjaGFzZVByaWNlKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgZmFpbCB0byBjcmVhdGUgYSBwdXJjaGFzZSBpZiBhIHByb2R1Y3RJZCBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vbkV4aXN0ZW50UHJvZHVjdElkID0gOTk5OTk5OyAvLyBBc3N1bWluZyB0aGlzIElEIHdvbid0IGV4aXN0XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gMTAwO1xuICAgICAgICAgICAgY29uc3QgcHVyY2hhc2VRdWFudGl0eSA9IDU7XG5cbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBub25FeGlzdGVudFByb2R1Y3RJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHB1cmNoYXNlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHB1cmNoYXNlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IHB1cmNoYXNlUXVhbnRpdHkgKiBwdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHVyY2hhc2VJbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcblxuICAgICAgICAgICAgLy8gRXhwZWN0IGEgY2xpZW50IGVycm9yIChlLmcuLCA0MDAgb3IgNDA0KSBvciBwb3RlbnRpYWxseSA1MDAgaWYgbm90IGhhbmRsZWQgZ3JhY2VmdWxseVxuICAgICAgICAgICAgLy8gRm9yIHJvYnVzdCBlcnJvciBoYW5kbGluZywgQVBJIHNob3VsZCByZXR1cm4gc3BlY2lmaWMgZXJyb3IgY29kZS5cbiAgICAgICAgICAgIC8vIFByaXNtYSB3aWxsIHRocm93IGFuIGVycm9yIGlmIGEgcmVsYXRlZCByZWNvcmQgKHByb2R1Y3QpIGlzIG5vdCBmb3VuZCBmb3IgZm9yZWlnbiBrZXkuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiBhIDUwMCBpZiBub3QgY2F1Z2h0IGFuZCBoYW5kbGVkIGJ5IHRoZSBBUEkgcm91dGUuXG4gICAgICAgICAgICAvLyBMZXQncyBhaW0gZm9yIHRoZSBBUEkgdG8gY2F0Y2ggdGhpcyBhbmQgcmV0dXJuIGEgbW9yZSBzcGVjaWZpYyBjbGllbnQgZXJyb3IuXG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBjaGVjayBpZiBpdCdzIE5PVCBhIHN1Y2Nlc3MgKDIwMSkuXG4gICAgICAgICAgICAvLyBBIG1vcmUgcHJlY2lzZSBjaGVjayB3b3VsZCBiZSBmb3IgNDAwLzQwNC80MjIgZGVwZW5kaW5nIG9uIHBsYW5uZWQgZXJyb3IgaGFuZGxpbmcuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7IC8vIE9yIDQwMC80MDQgaWYgeW91IGltcGxlbWVudCBzcGVjaWZpYyBlcnJvciBoYW5kbGluZ1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSwgY2hlY2sgZm9yIGEgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSBvciBjb2RlIGlmIHlvdXIgQVBJIHByb3ZpZGVzIG9uZS5cbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgZmFpbCB0byBjcmVhdGUgYSBwdXJjaGFzZSBpZiBhIHN1cHBsaWVySWQgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXN0UHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBGb3IgSW52YWxpZCBTdXBwbGllciBUZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnSU5WIFNVUDAwMScsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiAxMDAsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVByaWNlID0gODA7XG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZVF1YW50aXR5ID0gNTtcbiAgICAgICAgICAgIGNvbnN0IG5vbkV4aXN0ZW50U3VwcGxpZXJJZCA9IDk5OTk5OTsgLy8gQXNzdW1pbmcgdGhpcyBJRCB3b24ndCBleGlzdFxuXG4gICAgICAgICAgICBjb25zdCBwdXJjaGFzZUludm9pY2VQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsaWVySWQ6IG5vbkV4aXN0ZW50U3VwcGxpZXJJZC50b1N0cmluZygpLCAvLyBJbnZhbGlkIHN1cHBsaWVyXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogbmV3VGVzdFByb2R1Y3QuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBwdXJjaGFzZVF1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBwdXJjaGFzZVF1YW50aXR5ICogcHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwYWlkJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHB1cmNoYXNlSW52b2ljZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTsgLy8gRXhwZWN0aW5nIDUwMCBhcyBQcmlzbWEgdGhyb3dzIFAyMDAzXG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1BVVCAvYXBpL3B1cmNoYXNlcy86aWQgKFVwZGF0ZSBQdXJjaGFzZSBJbnZvaWNlKScsICgpID0+IHtcbiAgICAgICAgbGV0IGV4aXN0aW5nSW52b2ljZUlkOiBzdHJpbmc7XG4gICAgICAgIGxldCBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZDogbnVtYmVyO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VQcmljZSA9IDUwO1xuICAgICAgICBjb25zdCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSA9IDEwO1xuXG4gICAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvZHVjdCBzcGVjaWZpY2FsbHkgZm9yIHRoZXNlIHVwZGF0ZS9kZWxldGUgdGVzdHMgaWYgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gVGhlIGdsb2JhbCBjcmVhdGVkUHJvZHVjdElkIGNhbiBiZSB1c2VkIGlmIGl0IGZpdHMsIG9yIG1ha2UgYSBuZXcgb25lLlxuICAgICAgICAgICAgLy8gTGV0J3MgdXNlIHRoZSBnbG9iYWwgb25lIGZvciBzaW1wbGljaXR5LCBhc3N1bWluZyBiZWZvcmVFYWNoIGNsZWFucyBpdCB1cC5cbiAgICAgICAgICAgIHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkID0gY3JlYXRlZFByb2R1Y3RJZDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGluaXRpYWwgcHVyY2hhc2UgaW52b2ljZSB0byBiZSB1cGRhdGVkIG9yIGRlbGV0ZWQgaW4gdGVzdHNcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxJbnZvaWNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGllcklkOiBjcmVhdGVkU3VwcGxpZXJJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSA4NjQwMDAwMCkudG9JU09TdHJpbmcoKSwgLy8gWWVzdGVyZGF5XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICogaW5pdGlhbFB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVxID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMnLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogaW5pdGlhbEludm9pY2VQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNyZWF0ZVB1cmNoYXNlSW52b2ljZShyZXEpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGV4aXN0aW5nSW52b2ljZUlkID0gYm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IHZlcmlmeSBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZShpbml0aWFsUHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoaW5pdGlhbEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGluaXRpYWxJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUHJpY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSBpdGVtIHF1YW50aXR5IChpbmNyZWFzZSksIHJlY2FsY3VsYXRlIHN0b2NrIGFuZCBXQUNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlJbmNyZWFzZSA9IDU7XG4gICAgICAgICAgICBjb25zdCBuZXdRdWFudGl0eSA9IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5ICsgcXVhbnRpdHlJbmNyZWFzZTtcbiAgICAgICAgICAgIC8vIFByaWNlIHJlbWFpbnMgdGhlIHNhbWUgZm9yIHRoaXMgaXRlbSBpbiB0aGlzIHVwZGF0ZSBzY2VuYXJpb1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByaWNlRm9ySXRlbSA9IGluaXRpYWxQdXJjaGFzZVByaWNlO1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc2VuZCB0aGUgY29tcGxldGUgc3RydWN0dXJlIGV4cGVjdGVkIGJ5IHRoZSBQVVQgcm91dGVcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIGFsbCBpdGVtcywgZXZlbiBpZiBvbmx5IG9uZSBpcyBjaGFuZ2luZy5cbiAgICAgICAgICAgICAgICAvLyBUaGUgUFVUIHJvdXRlIGxvZ2ljIG1pZ2h0IGNvbXBhcmUgd2l0aCBleGlzdGluZyBpdGVtcyB0byBzZWUgd2hhdCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtIGhhZCBhbiBJRCAoUHVyY2hhc2VJbnZvaWNlSXRlbSBpZCksIGl0IG1pZ2h0IGJlIG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGFzc3VtZSBmb3Igbm93IHRoZSBQVVQgbWF0Y2hlcyBpdGVtcyBiYXNlZCBvbiBwcm9kdWN0SWQgaWYgbm90IGl0ZW0gSUQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlZCBvbiBjdXJyZW50IFBVVCByb3V0ZSwgaXQgZXhwZWN0cyBwcm9kdWN0SWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3UXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogdXBkYXRlZFByaWNlRm9ySXRlbSwgLy8gU2VuZCB0aGUgb3JpZ2luYWwgcHJpY2UgaWYgaXQgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGlzdHJpYnV0aW9ucyBpbiBQVVQgbWlnaHQgbmVlZCB0byByZWZsZWN0IHRoZSAqbmV3IHRvdGFsKiBmb3IgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IG5ld1F1YW50aXR5IH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIE90aGVyIGZpZWxkcyBsaWtlIHN1cHBsaWVySWQsIGRhdGUsIHRvdGFsQW1vdW50IG1pZ2h0IGJlIHVwZGF0YWJsZSB0b28uXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoaXMgdGVzdCwgZm9jdXMgb24gaXRlbSBxdWFudGl0eSBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgLy8gVGhlIFBVVCByb3V0ZSByZWNhbGN1bGF0ZXMgdG90YWxBbW91bnQgYmFzZWQgb24gaXRlbXMgaWYgbm90IHByb3ZpZGVkIG9yIGlmIGl0ZW1zIGNoYW5nZS5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgdG90YWxBbW91bnQgd2lsbCBiZSByZWNhbGN1bGF0ZWQgYnkgdGhlIEFQSS5cbiAgICAgICAgICAgICAgICAvLyBzdXBwbGllcklkIGFuZCBkYXRlIGNvdWxkIGJlIHBhcnQgb2YgdGhlIHBheWxvYWQgaWYgdGhleSBhcmUgdXBkYXRhYmxlLlxuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIGtlZXBpbmcgaXQgbWluaW1hbCB0byB0ZXN0IGl0ZW0gdXBkYXRlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBQVVQgaGFuZGxlciByZS1jYWxjdWxhdGVzIHRvdGFsIGFtb3VudCwgc28gbm90IHNlbmRpbmcgaXQuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIC8vIElNUE9SVEFOVDogTmVlZCB0byBwYXNzIHJvdXRlIHBhcmFtcyBmb3IgW2lkXSB0byB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IHN0YW5kYXJkIE5leHRSZXF1ZXN0IGJ1dCBob3cgdGVzdCBzZXR1cCBtaWdodCBuZWVkIGl0IG9yIGhvdyBoYW5kbGVyIGV4cGVjdHMgaXQuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCBoYW5kbGVyIGB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVxdWVzdDogTmV4dFJlcXVlc3QsIHsgcGFyYW1zIH06IHsgcGFyYW1zOiB7IGlkOiBzdHJpbmcgfSB9KWBcbiAgICAgICAgICAgICAgICAvLyBuZWVkcyBgcGFyYW1zYC4gbm9kZS1tb2Nrcy1odHRwIGBjcmVhdGVNb2Nrc2AgaGFuZGxlcyB0aGlzIHdlbGwuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGRpcmVjdCBOZXh0UmVxdWVzdCwgd2UgcGFzcyBpdCBpbiBjb250ZXh0IHRvIHRoZSBoYW5kbGVyIGNhbGwuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2ltdWxhdGUgQVBJIGNhbGwgLSB1cGRhdGVQdXJjaGFzZUludm9pY2UocmVxLCB7IHBhcmFtczogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSB9KVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBob3cgeW91IGNhbGwgaXQgaWYgeW91IGFyZSB0ZXN0aW5nIHRoZSBoYW5kbGVyIGRpcmVjdGx5IGluIEplc3Qgd2l0aCBjb250ZXh0XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgYW5kIHNob3BTcGVjaWZpY0Nvc3RcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZShuZXdRdWFudGl0eSk7XG5cbiAgICAgICAgICAgIC8vIFdBQyBjYWxjdWxhdGlvbjogKChvbGRRdHkgKiBvbGRTU0MpICsgKGFkZGVkUXR5ICogcHJpY2VPZkFkZGVkUXR5KSkgLyAobmV3VG90YWxRdHkpXG4gICAgICAgICAgICAvLyBJbiB0aGlzIHNwZWNpZmljIHVwZGF0ZSwgdGhlIFBVVCByb3V0ZSByZXZlcnNlcyB0aGUgb2xkIGl0ZW0gYW5kIGFkZHMgdGhlIG5ldyBvbmUgYXMgaWYgaXQncyBhIG5ldyBwdXJjaGFzZSBsaW5lIGZvciBXQUMgY2FsY3MuXG4gICAgICAgICAgICAvLyBTbywgdGhlIG9sZCBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSBhdCBpbml0aWFsUHVyY2hhc2VQcmljZSBpcyByZXZlcnNlZC5cbiAgICAgICAgICAgIC8vIFRoZW4sIG5ld1F1YW50aXR5IGF0IHVwZGF0ZWRQcmljZUZvckl0ZW0gaXMgYWRkZWQuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGUgY3VycmVudCBQVVQgbG9naWMgZmlyc3QgcmV2ZXJzZXMgKmFsbCogb2xkIGl0ZW1zIGJhc2VkIG9uIHRoZWlyICpvcmlnaW5hbCogcmVjb3JkZWQgY29zdC5cbiAgICAgICAgICAgIC8vIFRoZW4gaXQgYWRkcyAqYWxsKiBuZXcgaXRlbXMgYmFzZWQgb24gdGhlaXIgKm5ldyogY29zdC5cbiAgICAgICAgICAgIC8vIFNvIGZvciB0aGUgcHJvZHVjdCBXQUM6IChUb3RhbFZhbHVlQmVmb3JlIC0gT2xkSXRlbVZhbHVlICsgTmV3SXRlbVZhbHVlKSAvIChUb3RhbFN0b2NrQmVmb3JlIC0gT2xkSXRlbVF0eSArIE5ld0l0ZW1RdHkpXG4gICAgICAgICAgICAvLyBBbmQgZm9yIHNob3Agc3BlY2lmaWMgV0FDOiAoU2hvcFZhbHVlQmVmb3JlIC0gT2xkSXRlbVZhbHVlSW5TaG9wICsgTmV3SXRlbVZhbHVlSW5TaG9wKSAvIChTaG9wU3RvY2tCZWZvcmUgLSBPbGRJdGVtUXR5SW5TaG9wICsgTmV3SXRlbVF0eUluU2hvcClcblxuICAgICAgICAgICAgLy8gTGV0J3MgY2hlY2sgdGhlIGxvZ2ljIGZyb20gc3JjL2FwcC9hcGkvcHVyY2hhc2VzL1tpZF0vcm91dGUudHNcbiAgICAgICAgICAgIC8vIDEuIEl0IGZldGNoZXMgdGhlIG9sZCBpbnZvaWNlLlxuICAgICAgICAgICAgLy8gMi4gSXQgcmV2ZXJzZXMgaW52ZW50b3J5IGFkanVzdG1lbnRzIGZvciBBTEwgb2xkIGl0ZW1zIChkZWNyZWFzZSBzdG9jaywgV0FDIHVwZGF0ZWQpLlxuICAgICAgICAgICAgLy8gMy4gSXQgcHJvY2Vzc2VzIEFMTCBuZXcvdXBkYXRlZCBpdGVtcyBhcyBpZiB0aGV5IGFyZSBuZXcgcHVyY2hhc2VzIChpbmNyZWFzZSBzdG9jaywgV0FDIHVwZGF0ZWQpLlxuXG4gICAgICAgICAgICAvLyBTbywgYWZ0ZXIgcmV2ZXJzYWwgb2YgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgYXQgaW5pdGlhbFB1cmNoYXNlUHJpY2U6XG4gICAgICAgICAgICAvLyBQcm9kdWN0IFdBQyBhbmQgU2hvcFNwZWNpZmljQ29zdCB3b3VsZCBiZSBlZmZlY3RpdmVseSAwIGlmIHRoaXMgd2VyZSB0aGUgb25seSBwcm9kdWN0L3N0b2NrLlxuICAgICAgICAgICAgLy8gVGhlbiwgYWRkaW5nIG5ld1F1YW50aXR5IGF0IHVwZGF0ZWRQcmljZUZvckl0ZW06XG4gICAgICAgICAgICAvLyBUaGUgbmV3IFdBQ3Mgc2hvdWxkIGJlY29tZSB1cGRhdGVkUHJpY2VGb3JJdGVtLlxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgUHJvZHVjdCBXQUNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREIgcmVmbGVjdHMgdGhlIGNoYW5nZVxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7IGl0ZW1zOiB0cnVlIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnF1YW50aXR5KS50b0JlKG5ld1F1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByaWNlKS50b0JlKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUobmV3UXVhbnRpdHkgKiB1cGRhdGVkUHJpY2VGb3JJdGVtKTtcbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuXG4gICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIGl0ZW0gcXVhbnRpdHkgKGRlY3JlYXNlKSwgcmVjYWxjdWxhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWFudGl0eURlY3JlYXNlID0gMztcbiAgICAgICAgICAgIGNvbnN0IG5ld1F1YW50aXR5ID0gaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgLSBxdWFudGl0eURlY3JlYXNlO1xuICAgICAgICAgICAgZXhwZWN0KG5ld1F1YW50aXR5KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApOyAvLyBFbnN1cmUgd2UgZG9uJ3QgZ28gbmVnYXRpdmUgZm9yIHRoaXMgdGVzdCBsb2dpY1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJpY2VGb3JJdGVtID0gaW5pdGlhbFB1cmNoYXNlUHJpY2U7IC8vIFByaWNlIHJlbWFpbnMgdGhlIHNhbWVcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3UXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogdXBkYXRlZFByaWNlRm9ySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogbmV3UXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdXBkYXRlUHVyY2hhc2VJbnZvaWNlKHJlcSwgeyBwYXJhbXM6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZUJvZHkuZGF0YSkudG9IYXZlUHJvcGVydHkoJ2lkJywgZXhpc3RpbmdJbnZvaWNlSWQpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBzdG9jayBhbmQgc2hvcFNwZWNpZmljQ29zdFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCwgc2hvcElkOiBjcmVhdGVkU2hvcElkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKG5ld1F1YW50aXR5KTtcblxuICAgICAgICAgICAgLy8gRHVlIHRvIHRoZSByZXZlcnNhbCBhbmQgcmUtYWRkaXRpb24gbG9naWMgb2YgdGhlIFBVVCByb3V0ZTpcbiAgICAgICAgICAgIC8vIFRoZSBvbGQgaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgYXQgaW5pdGlhbFB1cmNoYXNlUHJpY2UgaXMgcmV2ZXJzZWQuXG4gICAgICAgICAgICAvLyBUaGVuLCBuZXdRdWFudGl0eSBhdCB1cGRhdGVkUHJpY2VGb3JJdGVtIGlzIGFkZGVkLlxuICAgICAgICAgICAgLy8gU28sIG5ldyBXQUNzIHNob3VsZCBiZWNvbWUgdXBkYXRlZFByaWNlRm9ySXRlbSAod2hpY2ggaXMgaW5pdGlhbFB1cmNoYXNlUHJpY2UpLlxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKHVwZGF0ZWRQcmljZUZvckl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgUHJvZHVjdCBXQUNcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREJcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShuZXdRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZSh1cGRhdGVkUHJpY2VGb3JJdGVtKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/LnRvdGFsKS50b0JlKG5ld1F1YW50aXR5ICogdXBkYXRlZFByaWNlRm9ySXRlbSk7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gSW5jcmVhc2VkIHRpbWVvdXRcblxuICAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSBpdGVtIHByaWNlLCByZWNhbGN1bGF0ZSBzdG9jayBhbmQgV0FDcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ByaWNlRm9ySXRlbSA9IGluaXRpYWxQdXJjaGFzZVByaWNlICsgMjU7IC8vIE5ldyBwcmljZSwgZS5nLiwgNTAgKyAyNSA9IDc1XG4gICAgICAgICAgICBjb25zdCBxdWFudGl0eVVuY2hhbmdlZCA9IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5OyAvLyBRdWFudGl0eSByZW1haW5zIHRoZSBzYW1lXG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IHF1YW50aXR5VW5jaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld1ByaWNlRm9ySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogcXVhbnRpdHlVbmNoYW5nZWQgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgLy8gdG90YWxBbW91bnQgd2lsbCBiZSByZWNhbGN1bGF0ZWQgYnkgdGhlIEFQSVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtleGlzdGluZ0ludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gc3RvY2sgKHNob3VsZCBiZSB1bmNoYW5nZWQpIGFuZCBzaG9wU3BlY2lmaWNDb3N0XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUocXVhbnRpdHlVbmNoYW5nZWQpO1xuICAgICAgICAgICAgLy8gV0FDIGxvZ2ljIGluIFBVVDogcmV2ZXJzZXMgb2xkLCBhZGRzIG5ldy4gU28gc2hvcFNwZWNpZmljQ29zdCBzaG91bGQgcmVmbGVjdCBuZXdQcmljZUZvckl0ZW0uXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8obmV3UHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFByb2R1Y3QgV0FDXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvclVwZGF0ZVRlc3RzSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8obmV3UHJpY2VGb3JJdGVtKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZUl0ZW0gaW4gREJcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogeyBpdGVtczogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShxdWFudGl0eVVuY2hhbmdlZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShuZXdQcmljZUZvckl0ZW0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUocXVhbnRpdHlVbmNoYW5nZWQgKiBuZXdQcmljZUZvckl0ZW0pO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBhZGQgYSBuZXcgaXRlbSB0byBhbiBleGlzdGluZyBpbnZvaWNlLCB1cGRhdGUgc3RvY2sgYW5kIFdBQ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBEZWZpbmUgYSBuZXcgcHJvZHVjdCBmb3IgdGhlIG5ldyBpdGVtXG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTmV3bHkgQWRkZWQgUHJvZHVjdCBmb3IgUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnUFVUTkVXMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDIwMCwgLy8gUmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUHJvZHVjdElkID0gbmV3SXRlbVByb2R1Y3QuaWQ7XG4gICAgICAgICAgICBjb25zdCBuZXdJdGVtUXVhbnRpdHkgPSA3O1xuICAgICAgICAgICAgY29uc3QgbmV3SXRlbVByaWNlID0gMTIwO1xuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBpdGVtIGRldGFpbHMgKGZyb20gYmVmb3JlRWFjaCBzZXR1cClcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbVByb2R1Y3RJZCA9IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxJdGVtUXVhbnRpdHkgPSBpbml0aWFsUHVyY2hhc2VRdWFudGl0eTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSXRlbVByaWNlID0gaW5pdGlhbFB1cmNoYXNlUHJpY2U7XG5cbiAgICAgICAgICAgIC8vIDIuIFByZXBhcmUgdGhlIHVwZGF0ZSBwYXlsb2FkIHdpdGggYm90aCBvcmlnaW5hbCBhbmQgbmV3IGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBvcmlnaW5hbEl0ZW1RdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBvcmlnaW5hbEl0ZW1QcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBuZXdJdGVtUHJvZHVjdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogbmV3SXRlbVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IG5ld0l0ZW1QcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogb3JpZ2luYWxJdGVtUXVhbnRpdHkgfSwgLy8gRGlzdHJpYnV0aW9uIGZvciBvcmlnaW5hbCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBuZXdJdGVtUXVhbnRpdHkgfSAgICAgIC8vIERpc3RyaWJ1dGlvbiBmb3IgbmV3IGl0ZW1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIHRvdGFsQW1vdW50IHdpbGwgYmUgcmVjYWxjdWxhdGVkIGJ5IHRoZSBBUElcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIDMuIFNpbXVsYXRlIEFQSSBjYWxsXG4gICAgICAgICAgICBjb25zdCByZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAvLyA0LiBBc3NlcnRpb25zXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQlxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7IGl0ZW1zOiB7IG9yZGVyQnk6IHsgcHJvZHVjdElkOiAnYXNjJyB9IH0gfSwgLy8gT3JkZXIgZm9yIGNvbnNpc3RlbnQgY2hlY2tzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgyKTtcblxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbCA9IChvcmlnaW5hbEl0ZW1RdWFudGl0eSAqIG9yaWdpbmFsSXRlbVByaWNlKSArIChuZXdJdGVtUXVhbnRpdHkgKiBuZXdJdGVtUHJpY2UpO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZT8udG90YWwpLnRvQmUoZXhwZWN0ZWRUb3RhbCk7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGl0ZW1zIGluIHRoZSByZXNwb25zZSAob3JkZXIgbWlnaHQgdmFyeSwgc28gZmluZCBieSBwcm9kdWN0SWQpXG4gICAgICAgICAgICBjb25zdCBkYk9yaWdpbmFsSXRlbSA9IGRiSW52b2ljZT8uaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ucHJvZHVjdElkID09PSBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQpO1xuICAgICAgICAgICAgY29uc3QgZGJOZXdJdGVtID0gZGJJbnZvaWNlPy5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5wcm9kdWN0SWQgPT09IG5ld0l0ZW1Qcm9kdWN0SWQpO1xuXG4gICAgICAgICAgICBleHBlY3QoZGJPcmlnaW5hbEl0ZW0pLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZGJPcmlnaW5hbEl0ZW0/LnF1YW50aXR5KS50b0JlKG9yaWdpbmFsSXRlbVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYk9yaWdpbmFsSXRlbT8ucHJpY2UpLnRvQmUob3JpZ2luYWxJdGVtUHJpY2UpO1xuXG4gICAgICAgICAgICBleHBlY3QoZGJOZXdJdGVtKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGRiTmV3SXRlbT8ucXVhbnRpdHkpLnRvQmUobmV3SXRlbVF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChkYk5ld0l0ZW0/LnByaWNlKS50b0JlKG5ld0l0ZW1QcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgdGhlIG9yaWdpbmFsIGl0ZW1cbiAgICAgICAgICAgIC8vIChEdWUgdG8gUFVUIGxvZ2ljIG9mIHJldmVyc2UgJiByZS1hZGQsIFdBQ3Mgc2hvdWxkIHJlZmxlY3QgaXRzIGN1cnJlbnQgcHJpY2UpXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBvcmlnaW5hbEl0ZW1Qcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChvcmlnaW5hbEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUob3JpZ2luYWxJdGVtUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhvcmlnaW5hbEl0ZW1QcmljZSk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFByb2R1Y3QgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IG9yaWdpbmFsSXRlbVByb2R1Y3RJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsUHJvZHVjdD8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8ob3JpZ2luYWxJdGVtUHJpY2UpO1xuXG4gICAgICAgICAgICAvLyBWZXJpZnkgSW52ZW50b3J5SXRlbSBhbmQgUHJvZHVjdCBXQUMgZm9yIHRoZSBORVcgaXRlbVxuICAgICAgICAgICAgY29uc3QgbmV3SW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IG5ld0l0ZW1Qcm9kdWN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChuZXdJbnZlbnRvcnk/LnF1YW50aXR5KS50b0JlKG5ld0l0ZW1RdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QobmV3SW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbyhuZXdJdGVtUHJpY2UpO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvZHVjdERiID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBuZXdJdGVtUHJvZHVjdElkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QobmV3UHJvZHVjdERiPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhuZXdJdGVtUHJpY2UpO1xuICAgICAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGV4aXN0aW5nIGludm9pY2UsIHVwZGF0ZSBzdG9jayBhbmQgV0FDcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIFNldHVwOiBFbnN1cmUgYW4gaW52b2ljZSB3aXRoIGF0IGxlYXN0IHR3byBpdGVtcyBleGlzdHMuXG4gICAgICAgICAgICAvLyBXZSdsbCB1c2UgdGhlIGV4aXN0aW5nIGBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZGAgYW5kIGNyZWF0ZSBvbmUgbW9yZSBwcm9kdWN0IGFuZCBpdGVtLlxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdFRvUmVtb3ZlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdQcm9kdWN0IFRvIEJlIFJlbW92ZWQnLFxuICAgICAgICAgICAgICAgICAgICBza3U6ICdQVVRSTVYwMDEnLFxuICAgICAgICAgICAgICAgICAgICBwcmljZTogMzAwLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdFRvUmVtb3ZlSWQgPSBwcm9kdWN0VG9SZW1vdmUuaWQ7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSA9IDQ7XG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0VG9SZW1vdmVQcmljZSA9IDQwO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGludm9pY2UgKGNyZWF0ZWQgaW4gZ2xvYmFsIGJlZm9yZUVhY2ggZm9yIFBVVCkgdG8gaW5jbHVkZSB0aGlzIHNlY29uZCBpdGVtIGZpcnN0LlxuICAgICAgICAgICAgY29uc3QgYWRkU2Vjb25kSXRlbVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGluaXRpYWxQdXJjaGFzZVByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RUb1JlbW92ZUlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogcHJvZHVjdFRvUmVtb3ZlUXVhbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcHJvZHVjdFRvUmVtb3ZlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IGluaXRpYWxQdXJjaGFzZVF1YW50aXR5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBwcm9kdWN0VG9SZW1vdmVRdWFudGl0eSB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhZGRSZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGFkZFNlY29uZEl0ZW1QYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdXBkYXRlUHVyY2hhc2VJbnZvaWNlKGFkZFJlcSwgeyBwYXJhbXM6IHsgaWQ6IGV4aXN0aW5nSW52b2ljZUlkIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjazogSW52b2ljZSBzaG91bGQgaGF2ZSAyIGl0ZW1zXG4gICAgICAgICAgICBsZXQgaW52b2ljZVdpdGhUd29JdGVtcyA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9LCBpbmNsdWRlOiB7IGl0ZW1zOiB0cnVlIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoaW52b2ljZVdpdGhUd29JdGVtcz8uaXRlbXMubGVuZ3RoKS50b0JlKDIpO1xuXG4gICAgICAgICAgICAvLyAyLiBQcmVwYXJlIHRoZSB1cGRhdGUgcGF5bG9hZCB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGl0ZW0gd2Ugd2FudCB0byBrZWVwLlxuICAgICAgICAgICAgY29uc3QgdXBkYXRlUGF5bG9hZFRvUmVtb3ZlSXRlbSA9IHtcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLnRvU3RyaW5nKCksIC8vIEtlZXAgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpbml0aWFsUHVyY2hhc2VRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBpbml0aWFsUHVyY2hhc2VQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkgfSAvLyBEaXN0cmlidXRpb24gZm9yIHRoZSBrZXB0IGl0ZW1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMy4gU2ltdWxhdGUgQVBJIGNhbGwgdG8gcmVtb3ZlIHRoZSBpdGVtXG4gICAgICAgICAgICBjb25zdCByZW1vdmVSZXEgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke2V4aXN0aW5nSW52b2ljZUlkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZVBheWxvYWRUb1JlbW92ZUl0ZW0pLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwZGF0ZVB1cmNoYXNlSW52b2ljZShyZW1vdmVSZXEsIHsgcGFyYW1zOiB7IGlkOiBleGlzdGluZ0ludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAvLyA0LiBBc3NlcnRpb25zXG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2VCb2R5LmRhdGEpLnRvSGF2ZVByb3BlcnR5KCdpZCcsIGV4aXN0aW5nSW52b2ljZUlkKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBpbiBEQiAtIHNob3VsZCBub3cgaGF2ZSBvbmx5IDEgaXRlbVxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdJbnZvaWNlSWQgfSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlOiB7IGl0ZW1zOiB0cnVlIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2U/Lml0ZW1zWzBdLnByb2R1Y3RJZCkudG9CZShwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5xdWFudGl0eSkudG9CZShpbml0aWFsUHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy5pdGVtc1swXS5wcmljZSkudG9CZShpbml0aWFsUHVyY2hhc2VQcmljZSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlPy50b3RhbCkudG9CZShpbml0aWFsUHVyY2hhc2VRdWFudGl0eSAqIGluaXRpYWxQdXJjaGFzZVByaWNlKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IEludmVudG9yeUl0ZW0gYW5kIFByb2R1Y3QgV0FDIGZvciB0aGUgS0VQVCBpdGVtXG4gICAgICAgICAgICBjb25zdCBrZXB0SW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JVcGRhdGVUZXN0c0lkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3Qoa2VwdEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGtlcHRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKGluaXRpYWxQdXJjaGFzZVByaWNlKTtcbiAgICAgICAgICAgIGNvbnN0IGtlcHRQcm9kdWN0ID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGtlcHRQcm9kdWN0Py53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbyhpbml0aWFsUHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIFZlcmlmeSBJbnZlbnRvcnlJdGVtIGFuZCBQcm9kdWN0IFdBQyBmb3IgdGhlIFJFTU9WRUQgaXRlbVxuICAgICAgICAgICAgLy8gU3RvY2sgc2hvdWxkIGJlIHplcm8gb3IgdGhlIGl0ZW0gbWlnaHQgYmUgZ29uZSBmcm9tIGludmVudG9yeSBpZiBpdCB3YXMgdGhlIG9ubHkgcHVyY2hhc2VcbiAgICAgICAgICAgIC8vIFdBQyBvbiBwcm9kdWN0IHNob3VsZCBiZSAwIGlmIG5vIG90aGVyIHB1cmNoYXNlcyBleGlzdC5cbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRJbnZlbnRvcnkgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdFRvUmVtb3ZlSWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRoZSBQVVQgbG9naWMgcmV2ZXJzZXMgc3RvY2suIElmIHRoaXMgd2FzIHRoZSBvbmx5IHN0b2NrLCBpdCBiZWNvbWVzIDAuXG4gICAgICAgICAgICBleHBlY3QocmVtb3ZlZEludmVudG9yeT8ucXVhbnRpdHkpLnRvQmUoMCk7XG4gICAgICAgICAgICAvLyBTaG9wU3BlY2lmaWNDb3N0IG1pZ2h0IGJlY29tZSAwIG9yIE5hTiBpZiBxdWFudGl0eSBpcyAwLiBUaGUgQVBJIHNldHMgaXQgdG8gMCBmb3Igc2FmZXR5LlxuICAgICAgICAgICAgZXhwZWN0KHJlbW92ZWRJbnZlbnRvcnk/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUHJvZHVjdERiID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0VG9SZW1vdmVJZCB9IH0pO1xuICAgICAgICAgICAgLy8gSWYgbm8gb3RoZXIgcHVyY2hhc2UgaXRlbXMgZm9yIHRoaXMgcHJvZHVjdCwgV0FDIHNob3VsZCBiZWNvbWUgMC5cbiAgICAgICAgICAgIGNvbnN0IG90aGVyUHVyY2hhc2VzT2ZSZW1vdmVkSXRlbSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmNvdW50KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RUb1JlbW92ZUlkIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG90aGVyUHVyY2hhc2VzT2ZSZW1vdmVkSXRlbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChyZW1vdmVkUHJvZHVjdERiPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlQ2xvc2VUbygwKTtcbiAgICAgICAgICAgIH0gLy8gRWxzZSwgaXQgd291bGQgYmUgYmFzZWQgb24gb3RoZXIgcHVyY2hhc2VzLCB3aGljaCB0aGlzIHRlc3QgZG9lc24ndCBzZXQgdXAuXG5cbiAgICAgICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0RFTEVURSAvYXBpL3B1cmNoYXNlcy86aWQgKERlbGV0ZSBQdXJjaGFzZSBJbnZvaWNlKScsICgpID0+IHtcbiAgICAgICAgbGV0IGludm9pY2VUb0RlbGV0ZUlkOiBzdHJpbmc7XG4gICAgICAgIGxldCBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkOiBudW1iZXI7XG4gICAgICAgIGNvbnN0IGRlbGV0ZVRlc3RJbml0aWFsUHJpY2UgPSA2MDtcbiAgICAgICAgY29uc3QgZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSA9IDEyO1xuXG4gICAgICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHByb2R1Y3QgZXhpc3RzIGZvciB0aGUgdGVzdFxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBGb3IgRGVsZXRlIFRlc3QnLFxuICAgICAgICAgICAgICAgICAgICBza3U6ICdERUxQUk9EMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDEwMCwgLy8gcmV0YWlsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkID0gcHJvZHVjdC5pZDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGluaXRpYWwgcHVyY2hhc2UgaW52b2ljZSB0byBiZSBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBkZWxldGVUZXN0SW5pdGlhbFByaWNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB7IFtjcmVhdGVkU2hvcElkXTogZGVsZXRlVGVzdEluaXRpYWxRdWFudGl0eSB9IC8vIEV4cGxpY2l0IGRpc3RyaWJ1dGlvblxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IGRlbGV0ZVRlc3RJbml0aWFsUXVhbnRpdHkgKiBkZWxldGVUZXN0SW5pdGlhbFByaWNlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IGluaXRpYWxJbnZvaWNlUGF5bG9hZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpbnZvaWNlVG9EZWxldGVJZCA9IGJvZHkuZGF0YS5pZDtcblxuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrOiB2ZXJpZnkgaW5pdGlhbCBzdGF0ZSBhZnRlciBjcmVhdGlvblxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFByb2R1Y3REQiA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogcHJvZHVjdEZvckRlbGV0ZVRlc3RJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGluaXRpYWxQcm9kdWN0REI/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmUoZGVsZXRlVGVzdEluaXRpYWxQcmljZSk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsSW52ZW50b3J5ID0gYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JEZWxldGVUZXN0SWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZShkZWxldGVUZXN0SW5pdGlhbFF1YW50aXR5KTtcbiAgICAgICAgICAgIGV4cGVjdChpbml0aWFsSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlKGRlbGV0ZVRlc3RJbml0aWFsUHJpY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhIHB1cmNoYXNlIGludm9pY2UgYW5kIGNvcnJlY3RseSByZXZlcnNlIHN0b2NrIGFuZCBXQUNzIGZvciBhIHNpbmdsZS1pdGVtIGludm9pY2Ugd2l0aCBleHBsaWNpdCBkaXN0cmlidXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBDYWxsIHRoZSBERUxFVEUgZW5kcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlcSA9IG5ldyBOZXh0UmVxdWVzdChgaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzLyR7aW52b2ljZVRvRGVsZXRlSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3BvbnNlID0gYXdhaXQgZGVsZXRlUHVyY2hhc2VJbnZvaWNlKGRlbGV0ZVJlcSwgeyBwYXJhbXM6IHsgaWQ6IGludm9pY2VUb0RlbGV0ZUlkIH0gfSk7XG5cbiAgICAgICAgICAgIC8vIDIuIEFzc2VydGlvbnMgZm9yIERFTEVURSByZXNwb25zZVxuICAgICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzcG9uc2VCb2R5ID0gYXdhaXQgZGVsZXRlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3BvbnNlQm9keS5tZXNzYWdlKS50b0JlKCdQdXJjaGFzZSBpbnZvaWNlIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICAgICAgICAgIC8vIDMuIFZlcmlmeSBQdXJjaGFzZUludm9pY2UgaXMgZGVsZXRlZCBmcm9tIERCXG4gICAgICAgICAgICBjb25zdCBkYkludm9pY2UgPSBhd2FpdCBwcmlzbWEucHVyY2hhc2VJbnZvaWNlLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBpbnZvaWNlVG9EZWxldGVJZCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlKS50b0JlTnVsbCgpO1xuXG4gICAgICAgICAgICAvLyA0LiBWZXJpZnkgUHVyY2hhc2VJbnZvaWNlSXRlbXMgYXJlIGRlbGV0ZWRcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZUl0ZW1zID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZmluZE1hbnkoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHB1cmNoYXNlSW52b2ljZUlkOiBpbnZvaWNlVG9EZWxldGVJZCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlSXRlbXMubGVuZ3RoKS50b0JlKDApO1xuXG4gICAgICAgICAgICAvLyA1LiBWZXJpZnkgSW52ZW50b3J5SXRlbSBzdG9jayBpcyByZXZlcnNlZFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBc3N1bWluZyB0aGlzIHdhcyB0aGUgb25seSBwdXJjaGFzZSwgc3RvY2sgc2hvdWxkIGJlIDBcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZSgwKTtcbiAgICAgICAgICAgIC8vIFNob3BTcGVjaWZpY0Nvc3Qgc2hvdWxkIGFsc28gYmUgMCBpZiBzdG9jayBpcyAwXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEludmVudG9yeT8uc2hvcFNwZWNpZmljQ29zdCkudG9CZUNsb3NlVG8oMCk7XG5cblxuICAgICAgICAgICAgLy8gNi4gVmVyaWZ5IFByb2R1Y3QgV0FDIGlzIHJlY2FsY3VsYXRlZCAoc2hvdWxkIGJlIDAgaWYgdGhpcyB3YXMgdGhlIG9ubHkgcHVyY2hhc2UpXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBwcm9kdWN0Rm9yRGVsZXRlVGVzdElkIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElmIG5vIG90aGVyIHB1cmNoYXNlIGl0ZW1zIGZvciB0aGlzIHByb2R1Y3QsIFdBQyBzaG91bGQgYmVjb21lIDAuXG4gICAgICAgICAgICBjb25zdCBvdGhlclB1cmNoYXNlc09mUHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2VJdGVtLmNvdW50KHtcbiAgICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHByb2R1Y3RGb3JEZWxldGVUZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1cmNoYXNlSW52b2ljZUlkOiB7IG5vdDogaW52b2ljZVRvRGVsZXRlSWQgfSAvLyBOb3QgbmVlZGVkIGFzIG9yaWdpbmFsIGludm9pY2UgaXRlbXMgYXJlIGdvbmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvdGhlclB1cmNoYXNlc09mUHJvZHVjdCA9PT0gMCkgeyAvLyBUaGlzIHNob3VsZCBiZSB0cnVlIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICAgICAgICBleHBlY3QodXBkYXRlZFByb2R1Y3Q/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhIHB1cmNoYXNlIGFuZCByZXZlcnNlIHN0b2NrL1dBQyB3aGVuIHByb2R1Y3QgaXMgaW4gYSBzaW5nbGUgaW5mZXJyZWQgc2hvcCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIFNldHVwOiBDcmVhdGUgZGVkaWNhdGVkIGVudGl0aWVzIGZvciB0aGlzIHRlc3QgdG8gZW5zdXJlIGlzb2xhdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHRlc3RTaG9wID0gYXdhaXQgcHJpc21hLnNob3AuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IG5hbWU6ICdJbmZlcnJlZCBEZWxldGUgVGVzdCBTaG9wJywgbG9jYXRpb246ICdMb2MgWCcgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0ZXN0U3VwcGxpZXIgPSBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IG5hbWU6ICdJbmZlcnJlZCBEZWxldGUgVGVzdCBTdXBwbGllcicgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0ZXN0UHJvZHVjdCA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvZHVjdCBmb3IgSW5mZXJyZWQgRGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgc2t1OiAnSU5GREVMMDAxJyxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IDIwMCwgLy8gcmV0YWlsIHByaWNlXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodGVkQXZlcmFnZUNvc3Q6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGludmVudG9yeSBpdGVtIGZvciB0aGlzIHByb2R1Y3QgaW4gdGhlIHRlc3Qgc2hvcC5cbiAgICAgICAgICAgIC8vIFRoaXMgbWFrZXMgaXQgdGhlIFwic2luZ2xlIGluZmVycmVkIHNob3BcIi5cbiAgICAgICAgICAgIGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWQ6IHRlc3RQcm9kdWN0LmlkLFxuICAgICAgICAgICAgICAgICAgICBzaG9wSWQ6IHRlc3RTaG9wLmlkLFxuICAgICAgICAgICAgICAgICAgICBxdWFudGl0eTogMCwgLy8gV2lsbCBiZSB1cGRhdGVkIGJ5IHRoZSBwdXJjaGFzZVxuICAgICAgICAgICAgICAgICAgICBzaG9wU3BlY2lmaWNDb3N0OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUXVhbnRpdHkgPSAxMjtcbiAgICAgICAgICAgIGNvbnN0IHB1cmNoYXNlUHJpY2UgPSA2MDtcblxuICAgICAgICAgICAgY29uc3QgaW5mZXJyZWRTaG9wSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogdGVzdFN1cHBsaWVyLmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RJZDogdGVzdFByb2R1Y3QuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBwdXJjaGFzZVF1YW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyBOTyBkaXN0cmlidXRpb25zIHByb3BlcnR5IGhlcmUgZm9yIGluZmVyZW5jZSB0byBraWNrIGluIG9uIFBPU1RcbiAgICAgICAgICAgICAgICB0b3RhbEFtb3VudDogcHVyY2hhc2VRdWFudGl0eSAqIHB1cmNoYXNlUHJpY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHB1cmNoYXNlIGludm9pY2UgKHRoaXMgaXMgd2hlcmUgdGhlIGZhaWx1cmUgd2FzIGhhcHBlbmluZylcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlcSA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvcHVyY2hhc2VzJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGluZmVycmVkU2hvcEludm9pY2VQYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVQdXJjaGFzZUludm9pY2UoY3JlYXRlUmVxKTtcbiAgICAgICAgICAgIGV4cGVjdChjcmVhdGVSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAxKTsgLy8gQXNzZXJ0IHN1Y2Nlc3NmdWwgY3JlYXRpb25cblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlQm9keSA9IGF3YWl0IGNyZWF0ZVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGludm9pY2VJZEZvckluZmVycmVkRGVsZXRlID0gY3JlYXRlQm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2s6IFZlcmlmeSBzdG9jayBhbmQgV0FDIGFmdGVyIGNyZWF0aW9uXG4gICAgICAgICAgICBjb25zdCBpbnZlbnRvcnlBZnRlckNyZWF0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiB0ZXN0UHJvZHVjdC5pZCwgc2hvcElkOiB0ZXN0U2hvcC5pZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZlbnRvcnlBZnRlckNyZWF0ZT8ucXVhbnRpdHkpLnRvQmUocHVyY2hhc2VRdWFudGl0eSk7XG4gICAgICAgICAgICBleHBlY3QoaW52ZW50b3J5QWZ0ZXJDcmVhdGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKHB1cmNoYXNlUHJpY2UpO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdEFmdGVyQ3JlYXRlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0UHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHByb2R1Y3RBZnRlckNyZWF0ZT8ud2VpZ2h0ZWRBdmVyYWdlQ29zdCkudG9CZUNsb3NlVG8ocHVyY2hhc2VQcmljZSk7XG5cbiAgICAgICAgICAgIC8vIDIuIENhbGwgdGhlIERFTEVURSBlbmRwb2ludFxuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVxID0gbmV3IE5leHRSZXF1ZXN0KGBodHRwOi8vbG9jYWxob3N0L2FwaS9wdXJjaGFzZXMvJHtpbnZvaWNlSWRGb3JJbmZlcnJlZERlbGV0ZX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzcG9uc2UgPSBhd2FpdCBkZWxldGVQdXJjaGFzZUludm9pY2UoZGVsZXRlUmVxLCB7IHBhcmFtczogeyBpZDogaW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGUgfSB9KTtcblxuICAgICAgICAgICAgLy8gMy4gQXNzZXJ0aW9ucyBmb3IgREVMRVRFIHJlc3BvbnNlXG4gICAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXNwb25zZUJvZHkgPSBhd2FpdCBkZWxldGVSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzcG9uc2VCb2R5Lm1lc3NhZ2UpLnRvQmUoJ1B1cmNoYXNlIGludm9pY2UgZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcblxuICAgICAgICAgICAgLy8gNC4gVmVyaWZ5IFB1cmNoYXNlSW52b2ljZSBhbmQgSXRlbXMgYXJlIGRlbGV0ZWRcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZSA9IGF3YWl0IHByaXNtYS5wdXJjaGFzZUludm9pY2UuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBpbnZvaWNlSWRGb3JJbmZlcnJlZERlbGV0ZSB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZUl0ZW1zID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZmluZE1hbnkoeyB3aGVyZTogeyBwdXJjaGFzZUludm9pY2VJZDogaW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGUgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChkYkludm9pY2VJdGVtcy5sZW5ndGgpLnRvQmUoMCk7XG5cbiAgICAgICAgICAgIC8vIDUuIFZlcmlmeSBJbnZlbnRvcnlJdGVtIHN0b2NrIGFuZCBzaG9wU3BlY2lmaWNDb3N0IGFyZSByZXZlcnNlZCBpbiB0aGUgaW5mZXJyZWQgc2hvcFxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZEludmVudG9yeSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgcHJvZHVjdElkOiB0ZXN0UHJvZHVjdC5pZCwgc2hvcElkOiB0ZXN0U2hvcC5pZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5xdWFudGl0eSkudG9CZSgwKTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkSW52ZW50b3J5Py5zaG9wU3BlY2lmaWNDb3N0KS50b0JlQ2xvc2VUbygwKTtcblxuICAgICAgICAgICAgLy8gNi4gVmVyaWZ5IFByb2R1Y3QgV0FDIGlzIHJlY2FsY3VsYXRlZCB0byAwXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZHVjdERCID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiB0ZXN0UHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRQcm9kdWN0REI/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICAvLyBDbGVhbnVwIGRlZGljYXRlZCBlbnRpdGllcyBmb3IgdGhpcyB0ZXN0XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5kZWxldGVNYW55KHsgd2hlcmU6IHsgcHJvZHVjdElkOiB0ZXN0UHJvZHVjdC5pZCB9IH0pO1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnByb2R1Y3QuZGVsZXRlKHsgd2hlcmU6IHsgaWQ6IHRlc3RQcm9kdWN0LmlkIH0gfSk7XG4gICAgICAgICAgICBhd2FpdCBwcmlzbWEuc3VwcGxpZXIuZGVsZXRlKHsgd2hlcmU6IHsgaWQ6IHRlc3RTdXBwbGllci5pZCB9IH0pO1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnNob3AuZGVsZXRlKHsgd2hlcmU6IHsgaWQ6IHRlc3RTaG9wLmlkIH0gfSk7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gQWRkZWQgYSBsb25nZXIgdGltZW91dCBhcyBhIHByZWNhdXRpb25cblxuICAgICAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhbiBpbnZvaWNlIHdpdGggbXVsdGlwbGUgaXRlbXMsIHJldmVyc2luZyBzdG9jay9XQUMgZm9yIGVhY2gnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBTZXR1cDogQ3JlYXRlIG11bHRpcGxlIHByb2R1Y3RzIGFuZCBhbiBpbnZvaWNlIHdpdGggaXRlbXMgZnJvbSB0aGVzZSBwcm9kdWN0cy5cbiAgICAgICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCBkaXN0cmlidXRlIGVhY2ggdG8gdGhlIG1haW4gY3JlYXRlZFNob3BJZCBmcm9tIGdsb2JhbCBiZWZvcmVFYWNoLlxuXG4gICAgICAgICAgICBjb25zdCBwcm9kdWN0QSA9IGF3YWl0IHByaXNtYS5wcm9kdWN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBuYW1lOiAnTXVsdGktRGVsIFByb2QgQScsIHNrdTogJ01ERUwwMEEnLCBwcmljZTogMTAwLCB3ZWlnaHRlZEF2ZXJhZ2VDb3N0OiAwIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdEIgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHsgbmFtZTogJ011bHRpLURlbCBQcm9kIEInLCBza3U6ICdNREVMMDBCJywgcHJpY2U6IDIwMCwgd2VpZ2h0ZWRBdmVyYWdlQ29zdDogMCB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlBID0gNTtcbiAgICAgICAgICAgIGNvbnN0IHByaWNlQSA9IDUwO1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpdHlCID0gMztcbiAgICAgICAgICAgIGNvbnN0IHByaWNlQiA9IDEyMDtcblxuICAgICAgICAgICAgY29uc3QgbXVsdGlJdGVtSW52b2ljZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxpZXJJZDogY3JlYXRlZFN1cHBsaWVySWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcm9kdWN0SWQ6IHByb2R1Y3RBLmlkLnRvU3RyaW5nKCksIHF1YW50aXR5OiBxdWFudGl0eUEsIHByaWNlOiBwcmljZUEgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcm9kdWN0SWQ6IHByb2R1Y3RCLmlkLnRvU3RyaW5nKCksIHF1YW50aXR5OiBxdWFudGl0eUIsIHByaWNlOiBwcmljZUIgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBbY3JlYXRlZFNob3BJZF06IHF1YW50aXR5QSB9LCAvLyBJdGVtIEEgdG8gbWFpbiBzaG9wXG4gICAgICAgICAgICAgICAgICAgIHsgW2NyZWF0ZWRTaG9wSWRdOiBxdWFudGl0eUIgfSAgLy8gSXRlbSBCIHRvIG1haW4gc2hvcFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IChxdWFudGl0eUEgKiBwcmljZUEpICsgKHF1YW50aXR5QiAqIHByaWNlQiksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVSZXEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcycsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtdWx0aUl0ZW1JbnZvaWNlUGF5bG9hZCksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJlc3BvbnNlID0gYXdhaXQgY3JlYXRlUHVyY2hhc2VJbnZvaWNlKGNyZWF0ZVJlcSk7XG4gICAgICAgICAgICBleHBlY3QoY3JlYXRlUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVCb2R5ID0gYXdhaXQgY3JlYXRlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlJdGVtSW52b2ljZUlkID0gY3JlYXRlQm9keS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2sgaW52ZW50b3J5IGFuZCBXQUMgYWZ0ZXIgY3JlYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGludkFfYWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3QoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RBLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZBX2FmdGVyQ3JlYXRlPy5xdWFudGl0eSkudG9CZShxdWFudGl0eUEpO1xuICAgICAgICAgICAgZXhwZWN0KGludkFfYWZ0ZXJDcmVhdGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUocHJpY2VBKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2RBX2FmdGVyQ3JlYXRlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0QS5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHByb2RBX2FmdGVyQ3JlYXRlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKHByaWNlQSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGludkJfYWZ0ZXJDcmVhdGUgPSBhd2FpdCBwcmlzbWEuaW52ZW50b3J5SXRlbS5maW5kRmlyc3QoeyB3aGVyZTogeyBwcm9kdWN0SWQ6IHByb2R1Y3RCLmlkLCBzaG9wSWQ6IGNyZWF0ZWRTaG9wSWQgfSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChpbnZCX2FmdGVyQ3JlYXRlPy5xdWFudGl0eSkudG9CZShxdWFudGl0eUIpO1xuICAgICAgICAgICAgZXhwZWN0KGludkJfYWZ0ZXJDcmVhdGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmUocHJpY2VCKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2RCX2FmdGVyQ3JlYXRlID0gYXdhaXQgcHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiBwcm9kdWN0Qi5pZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KHByb2RCX2FmdGVyQ3JlYXRlPy53ZWlnaHRlZEF2ZXJhZ2VDb3N0KS50b0JlKHByaWNlQik7XG5cbiAgICAgICAgICAgIC8vIDIuIENhbGwgREVMRVRFIGVuZHBvaW50XG4gICAgICAgICAgICBjb25zdCBkZWxldGVSZXEgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3QvYXBpL3B1cmNoYXNlcy8ke211bHRpSXRlbUludm9pY2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVzcG9uc2UgPSBhd2FpdCBkZWxldGVQdXJjaGFzZUludm9pY2UoZGVsZXRlUmVxLCB7IHBhcmFtczogeyBpZDogbXVsdGlJdGVtSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG5cbiAgICAgICAgICAgIC8vIDMuIFZlcmlmeSBpbnZvaWNlIGFuZCBpdGVtcyBhcmUgZGVsZXRlZFxuICAgICAgICAgICAgY29uc3QgZGJJbnZvaWNlID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZS5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IG11bHRpSXRlbUludm9pY2VJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGRiSW52b2ljZSkudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGNvbnN0IGRiSW52b2ljZUl0ZW1zID0gYXdhaXQgcHJpc21hLnB1cmNoYXNlSW52b2ljZUl0ZW0uZmluZE1hbnkoeyB3aGVyZTogeyBwdXJjaGFzZUludm9pY2VJZDogbXVsdGlJdGVtSW52b2ljZUlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QoZGJJbnZvaWNlSXRlbXMubGVuZ3RoKS50b0JlKDApO1xuXG4gICAgICAgICAgICAvLyA0LiBWZXJpZnkgc3RvY2sgYW5kIFdBQyBmb3IgUHJvZHVjdCBBIGFyZSByZXZlcnNlZFxuICAgICAgICAgICAgY29uc3QgaW52QV9hZnRlckRlbGV0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEEuaWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkFfYWZ0ZXJEZWxldGU/LnF1YW50aXR5KS50b0JlKDApO1xuICAgICAgICAgICAgZXhwZWN0KGludkFfYWZ0ZXJEZWxldGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuICAgICAgICAgICAgY29uc3QgcHJvZEFfYWZ0ZXJEZWxldGUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RBLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QocHJvZEFfYWZ0ZXJEZWxldGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICAvLyA1LiBWZXJpZnkgc3RvY2sgYW5kIFdBQyBmb3IgUHJvZHVjdCBCIGFyZSByZXZlcnNlZFxuICAgICAgICAgICAgY29uc3QgaW52Ql9hZnRlckRlbGV0ZSA9IGF3YWl0IHByaXNtYS5pbnZlbnRvcnlJdGVtLmZpbmRGaXJzdCh7IHdoZXJlOiB7IHByb2R1Y3RJZDogcHJvZHVjdEIuaWQsIHNob3BJZDogY3JlYXRlZFNob3BJZCB9IH0pO1xuICAgICAgICAgICAgZXhwZWN0KGludkJfYWZ0ZXJEZWxldGU/LnF1YW50aXR5KS50b0JlKDApO1xuICAgICAgICAgICAgZXhwZWN0KGludkJfYWZ0ZXJEZWxldGU/LnNob3BTcGVjaWZpY0Nvc3QpLnRvQmVDbG9zZVRvKDApO1xuICAgICAgICAgICAgY29uc3QgcHJvZEJfYWZ0ZXJEZWxldGUgPSBhd2FpdCBwcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHByb2R1Y3RCLmlkIH0gfSk7XG4gICAgICAgICAgICBleHBlY3QocHJvZEJfYWZ0ZXJEZWxldGU/LndlaWdodGVkQXZlcmFnZUNvc3QpLnRvQmVDbG9zZVRvKDApO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBwcm9kdWN0cyBhbmQgdGhlaXIgaW52ZW50b3J5IGl0ZW1zIGNyZWF0ZWQgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgICAgYXdhaXQgcHJpc21hLmludmVudG9yeUl0ZW0uZGVsZXRlTWFueSh7IHdoZXJlOiB7IHByb2R1Y3RJZDogeyBpbjogW3Byb2R1Y3RBLmlkLCBwcm9kdWN0Qi5pZF0gfSB9IH0pO1xuICAgICAgICAgICAgYXdhaXQgcHJpc21hLnByb2R1Y3QuZGVsZXRlTWFueSh7IHdoZXJlOiB7IGlkOiB7IGluOiBbcHJvZHVjdEEuaWQsIHByb2R1Y3RCLmlkXSB9IH0gfSk7XG4gICAgICAgIH0sIDE1MDAwKTsgLy8gVGltZW91dCBmb3Igc2FmZXR5XG4gICAgfSk7XG5cbn0pOyJdLCJuYW1lcyI6WyJjcmVhdGVNb2NrTmV4dFJlcXVlc3QiLCJ1cmwiLCJvcHRpb25zIiwibWV0aG9kIiwiYm9keSIsImhlYWRlcnMiLCJIZWFkZXJzIiwianNvbiIsIkpTT04iLCJwYXJzZSIsInRleHQiLCJzdHJpbmdpZnkiLCJwcmlzbWEiLCJQcmlzbWFDbGllbnQiLCJkZXNjcmliZSIsImNyZWF0ZWRTaG9wSWQiLCJjcmVhdGVkU3VwcGxpZXJJZCIsImNyZWF0ZWRQcm9kdWN0SWQiLCJiZWZvcmVBbGwiLCJiZWZvcmVFYWNoIiwicHVyY2hhc2VJbnZvaWNlSXRlbSIsImRlbGV0ZU1hbnkiLCJwdXJjaGFzZUludm9pY2UiLCJpbnZlbnRvcnlJdGVtIiwicHJvZHVjdCIsInN1cHBsaWVyIiwic2hvcCIsImNyZWF0ZSIsImRhdGEiLCJuYW1lIiwibG9jYXRpb24iLCJpZCIsInByaWNlIiwic2t1Iiwic2hvcElkIiwiYWZ0ZXJBbGwiLCIkZGlzY29ubmVjdCIsIml0IiwibmV3UHJvZHVjdE5hbWUiLCJuZXdQcm9kdWN0U2t1IiwicHVyY2hhc2VQcmljZSIsInB1cmNoYXNlUXVhbnRpdHkiLCJuZXdUZXN0UHJvZHVjdCIsIm5ld1Rlc3RQcm9kdWN0SWQiLCJwdXJjaGFzZUludm9pY2VQYXlsb2FkIiwic3VwcGxpZXJJZCIsInRvU3RyaW5nIiwiZGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIml0ZW1zIiwicHJvZHVjdElkIiwicXVhbnRpdHkiLCJkaXN0cmlidXRpb25zIiwidG90YWxBbW91bnQiLCJzdGF0dXMiLCJyZXEiLCJyZXNwb25zZSIsImNyZWF0ZVB1cmNoYXNlSW52b2ljZSIsInJlc3BvbnNlQm9keSIsImV4cGVjdCIsInRvQmUiLCJ0b0hhdmVQcm9wZXJ0eSIsImNyZWF0ZWRJbnZvaWNlSWQiLCJkYkludm9pY2UiLCJmaW5kVW5pcXVlIiwid2hlcmUiLCJpbmNsdWRlIiwibm90IiwidG9CZU51bGwiLCJsZW5ndGgiLCJkYkludmVudG9yeUl0ZW0iLCJmaW5kRmlyc3QiLCJzaG9wU3BlY2lmaWNDb3N0IiwiZGJQcm9kdWN0Iiwid2VpZ2h0ZWRBdmVyYWdlQ29zdCIsImluaXRpYWxQdXJjaGFzZVByaWNlIiwiaW5pdGlhbFB1cmNoYXNlUXVhbnRpdHkiLCJleGlzdGluZ1Byb2R1Y3RJZCIsImluaXRpYWxQYXlsb2FkIiwibm93IiwiaW5pdGlhbFJlcSIsIk5leHRSZXF1ZXN0IiwicHJvZHVjdEJlZm9yZU5ld1B1cmNoYXNlIiwiaW52ZW50b3J5QmVmb3JlTmV3UHVyY2hhc2UiLCJuZXdQdXJjaGFzZVByaWNlIiwibmV3UHVyY2hhc2VRdWFudGl0eSIsImV4cGVjdGVkVG90YWxRdWFudGl0eSIsImV4cGVjdGVkU2hvcFNwZWNpZmljQ29zdCIsInRvQmVDbG9zZVRvIiwiZXhwZWN0ZWRQcm9kdWN0V0FDIiwicHJvZHVjdDFEYXRhIiwicHJvZHVjdDJEYXRhIiwicHJvZHVjdDEiLCJwcm9kdWN0MiIsInB1cmNoYXNlUHJpY2UxIiwicHVyY2hhc2VRdWFudGl0eTEiLCJwdXJjaGFzZVByaWNlMiIsInB1cmNoYXNlUXVhbnRpdHkyIiwib3JkZXJCeSIsInNvcnRlZFByb2R1Y3RzIiwic29ydCIsImEiLCJiIiwiZGJJbnZlbnRvcnlJdGVtMSIsImRiUHJvZHVjdDEiLCJkYkludmVudG9yeUl0ZW0yIiwiZGJQcm9kdWN0MiIsInNob3BBIiwic2hvcEIiLCJ0b3RhbFF1YW50aXR5IiwicXVhbnRpdHlGb3JTaG9wQSIsInF1YW50aXR5Rm9yU2hvcEIiLCJpbnZJdGVtQSIsImludkl0ZW1CIiwibm9uRXhpc3RlbnRQcm9kdWN0SWQiLCJlcnJvciIsInRvQmVEZWZpbmVkIiwibm9uRXhpc3RlbnRTdXBwbGllcklkIiwiZXhpc3RpbmdJbnZvaWNlSWQiLCJwcm9kdWN0Rm9yVXBkYXRlVGVzdHNJZCIsImluaXRpYWxJbnZvaWNlUGF5bG9hZCIsImluaXRpYWxQcm9kdWN0IiwiaW5pdGlhbEludmVudG9yeSIsInF1YW50aXR5SW5jcmVhc2UiLCJuZXdRdWFudGl0eSIsInVwZGF0ZWRQcmljZUZvckl0ZW0iLCJ1cGRhdGVQYXlsb2FkIiwidXBkYXRlUHVyY2hhc2VJbnZvaWNlIiwicGFyYW1zIiwidXBkYXRlZEludmVudG9yeSIsInVwZGF0ZWRQcm9kdWN0IiwidG90YWwiLCJxdWFudGl0eURlY3JlYXNlIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsIm5ld1ByaWNlRm9ySXRlbSIsInF1YW50aXR5VW5jaGFuZ2VkIiwibmV3SXRlbVByb2R1Y3QiLCJuZXdJdGVtUHJvZHVjdElkIiwibmV3SXRlbVF1YW50aXR5IiwibmV3SXRlbVByaWNlIiwib3JpZ2luYWxJdGVtUHJvZHVjdElkIiwib3JpZ2luYWxJdGVtUXVhbnRpdHkiLCJvcmlnaW5hbEl0ZW1QcmljZSIsImV4cGVjdGVkVG90YWwiLCJkYk9yaWdpbmFsSXRlbSIsImZpbmQiLCJpdGVtIiwiZGJOZXdJdGVtIiwib3JpZ2luYWxJbnZlbnRvcnkiLCJvcmlnaW5hbFByb2R1Y3QiLCJuZXdJbnZlbnRvcnkiLCJuZXdQcm9kdWN0RGIiLCJwcm9kdWN0VG9SZW1vdmUiLCJwcm9kdWN0VG9SZW1vdmVJZCIsInByb2R1Y3RUb1JlbW92ZVF1YW50aXR5IiwicHJvZHVjdFRvUmVtb3ZlUHJpY2UiLCJhZGRTZWNvbmRJdGVtUGF5bG9hZCIsImFkZFJlcSIsImludm9pY2VXaXRoVHdvSXRlbXMiLCJ1cGRhdGVQYXlsb2FkVG9SZW1vdmVJdGVtIiwicmVtb3ZlUmVxIiwia2VwdEludmVudG9yeSIsImtlcHRQcm9kdWN0IiwicmVtb3ZlZEludmVudG9yeSIsInJlbW92ZWRQcm9kdWN0RGIiLCJvdGhlclB1cmNoYXNlc09mUmVtb3ZlZEl0ZW0iLCJjb3VudCIsImludm9pY2VUb0RlbGV0ZUlkIiwicHJvZHVjdEZvckRlbGV0ZVRlc3RJZCIsImRlbGV0ZVRlc3RJbml0aWFsUHJpY2UiLCJkZWxldGVUZXN0SW5pdGlhbFF1YW50aXR5IiwiaW5pdGlhbFByb2R1Y3REQiIsImRlbGV0ZVJlcSIsImRlbGV0ZVJlc3BvbnNlIiwiZGVsZXRlUHVyY2hhc2VJbnZvaWNlIiwiZGVsZXRlUmVzcG9uc2VCb2R5IiwibWVzc2FnZSIsImRiSW52b2ljZUl0ZW1zIiwiZmluZE1hbnkiLCJwdXJjaGFzZUludm9pY2VJZCIsIm90aGVyUHVyY2hhc2VzT2ZQcm9kdWN0IiwidGVzdFNob3AiLCJ0ZXN0U3VwcGxpZXIiLCJ0ZXN0UHJvZHVjdCIsImluZmVycmVkU2hvcEludm9pY2VQYXlsb2FkIiwiY3JlYXRlUmVxIiwiY3JlYXRlUmVzcG9uc2UiLCJjcmVhdGVCb2R5IiwiaW52b2ljZUlkRm9ySW5mZXJyZWREZWxldGUiLCJpbnZlbnRvcnlBZnRlckNyZWF0ZSIsInByb2R1Y3RBZnRlckNyZWF0ZSIsInVwZGF0ZWRQcm9kdWN0REIiLCJkZWxldGUiLCJwcm9kdWN0QSIsInByb2R1Y3RCIiwicXVhbnRpdHlBIiwicHJpY2VBIiwicXVhbnRpdHlCIiwicHJpY2VCIiwibXVsdGlJdGVtSW52b2ljZVBheWxvYWQiLCJtdWx0aUl0ZW1JbnZvaWNlSWQiLCJpbnZBX2FmdGVyQ3JlYXRlIiwicHJvZEFfYWZ0ZXJDcmVhdGUiLCJpbnZCX2FmdGVyQ3JlYXRlIiwicHJvZEJfYWZ0ZXJDcmVhdGUiLCJpbnZBX2FmdGVyRGVsZXRlIiwicHJvZEFfYWZ0ZXJEZWxldGUiLCJpbnZCX2FmdGVyRGVsZXRlIiwicHJvZEJfYWZ0ZXJEZWxldGUiLCJpbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7Ozs7d0JBQzRCO3VCQUNpQjt3QkFDRDtBQVc3Qyw2Q0FBNkM7QUFDN0MsTUFBTUEsd0JBQXdCLENBQUNDLEtBQWFDLFVBSXhDLENBQUMsQ0FBQztJQUNKLE1BQU0sRUFBRUMsU0FBUyxLQUFLLEVBQUVDLElBQUksRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRSxHQUFHSDtJQUMvQyxPQUFPO1FBQ0xDO1FBQ0FGO1FBQ0FJLFNBQVMsSUFBSUMsUUFBUUQ7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