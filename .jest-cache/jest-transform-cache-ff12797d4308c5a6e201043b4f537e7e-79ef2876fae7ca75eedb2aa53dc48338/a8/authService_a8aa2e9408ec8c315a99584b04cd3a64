dc51b38955416cf9b8bde0590f2e47ef
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    authenticateUser: function() {
        return authenticateUser;
    },
    generateToken: function() {
        return generateToken;
    },
    getUserFromDecodedPayload: function() {
        return getUserFromDecodedPayload;
    },
    getUserFromToken: function() {
        return getUserFromToken;
    },
    hasPermission: function() {
        return hasPermission;
    },
    parseTimeStringToSeconds: function() {
        return parseTimeStringToSeconds;
    },
    verifyToken: function() {
        return verifyToken;
    }
});
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
const _prisma = /*#__PURE__*/ _interop_require_default(require("../lib/prisma"));
const _cache = require("../lib/cache");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Secret key for JWT - should be moved to environment variables in production
const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
// Changed token expiration to 12h (from 24h) for better security
const JWT_EXPIRES_IN = process.env.JWT_ACCESS_TOKEN_EXPIRES_IN || "12h";
const parseTimeStringToSeconds = (timeStr)=>{
    if (!timeStr) return 0;
    const lastChar = timeStr.slice(-1);
    const num = parseInt(timeStr.slice(0, -1));
    if (isNaN(num)) return 0;
    switch(lastChar){
        case "s":
            return num;
        case "m":
            return num * 60;
        case "h":
            return num * 60 * 60;
        case "d":
            return num * 60 * 60 * 24;
        default:
            if (!isNaN(parseInt(timeStr))) return parseInt(timeStr);
            return 0;
    }
};
const authenticateUser = async (email, password)=>{
    try {
        console.time("user authentication query");
        // Optimized single query using the new composite index
        const user = await _prisma.default.user.findFirst({
            where: {
                email: email,
                isActive: true
            },
            include: {
                role: {
                    include: {
                        permissions: {
                            select: {
                                name: true
                            }
                        }
                    }
                }
            }
        });
        console.timeEnd("user authentication query");
        // If user not found
        if (!user) {
            return {
                success: false,
                message: "Invalid email or password"
            };
        }
        // Verify password
        const isPasswordValid = await _bcryptjs.default.compare(password, user.password);
        if (!isPasswordValid) {
            return {
                success: false,
                message: "Invalid email or password"
            };
        }
        // Get permissions from role (handle case where user has no role)
        let permissions = [];
        if (user.role?.permissions) {
            permissions = user.role.permissions.map((p)=>p.name);
        } else if (user.permissions && Array.isArray(user.permissions)) {
            // Convert permission IDs to names
            const permissionRecords = await _prisma.default.permission.findMany({
                where: {
                    id: {
                        in: user.permissions.map((id)=>parseInt(id.toString()))
                    }
                },
                select: {
                    name: true
                }
            });
            permissions = permissionRecords.map((p)=>p.name);
        }
        // Generate JWT token
        const token = generateToken({
            sub: user.id,
            username: user.name,
            email: user.email,
            roleId: user.roleId,
            shopId: user.shopId,
            permissions
        });
        const userSession = {
            id: user.id,
            username: user.name,
            fullName: user.name,
            email: user.email,
            roleId: user.roleId,
            roleName: user.role?.name || user.roleName || null,
            shopId: user.shopId,
            permissions,
            role: user.role
        };
        // Cache user session for faster subsequent requests
        const cacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_SESSION, {
            userId: user.id
        });
        await _cache.cacheService.set(cacheKey, userSession, _cache.CACHE_CONFIG.TTL.USER_SESSION);
        return {
            success: true,
            token,
            user: {
                id: user.id,
                username: user.name,
                fullName: user.name,
                email: user.email,
                roleId: user.roleId,
                roleName: user.role?.name || user.roleName || null,
                shopId: user.shopId,
                permissions
            }
        };
    } catch (error) {
        console.error("Authentication error:", error);
        return {
            success: false,
            message: "Authentication failed"
        };
    }
};
const generateToken = (payload)=>{
    return _jsonwebtoken.default.sign(payload, JWT_SECRET, {
        expiresIn: JWT_EXPIRES_IN
    });
};
const verifyToken = async (token)=>{
    const tokenKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.TOKEN_VALIDATION, {
        token: token.substring(0, 20)
    });
    try {
        // Check cache first for token validation result
        const cachedResult = await _cache.cacheService.get(tokenKey);
        if (cachedResult) {
            return cachedResult;
        }
        // Verify token
        const payload = _jsonwebtoken.default.verify(token, JWT_SECRET);
        // Cache the valid token payload (shorter TTL for security)
        await _cache.cacheService.set(tokenKey, payload, _cache.CACHE_CONFIG.TTL.TOKEN_VALIDATION);
        return payload;
    } catch (error) {
        // Log the error here if desired
        if (error instanceof _jsonwebtoken.default.TokenExpiredError) {
            console.error("Token expired during verification:", error.expiredAt);
        } else if (error instanceof _jsonwebtoken.default.JsonWebTokenError) {
            console.error("Invalid token during verification:", error.message);
        } else {
            console.error("Unknown token verification error:", error);
        }
        throw error; // Re-throw the error
    }
};
const hasPermission = async (tokenPayload, permission)=>{
    // Import the proper permission checking utility
    const { hasPermission: checkPermission } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../lib/utils/permissions")));
    // Quick check from token payload first
    if (tokenPayload.permissions) {
        if (checkPermission(tokenPayload.permissions, permission)) {
            return true;
        }
    }
    // If not in token, check cached user permissions
    const permissionsCacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_PERMISSIONS, {
        userId: tokenPayload.sub
    });
    try {
        const cachedPermissions = await _cache.cacheService.get(permissionsCacheKey);
        if (cachedPermissions) {
            return checkPermission(cachedPermissions, permission);
        }
        // Fallback to database query if not cached
        const user = await _prisma.default.user.findFirst({
            where: {
                id: tokenPayload.sub,
                isActive: true
            },
            include: {
                role: {
                    include: {
                        permissions: {
                            select: {
                                name: true
                            }
                        }
                    }
                }
            }
        });
        if (user) {
            const permissions = user.role.permissions.map((p)=>p.name);
            // Cache permissions for future checks
            await _cache.cacheService.set(permissionsCacheKey, permissions, _cache.CACHE_CONFIG.TTL.USER_PERMISSIONS);
            return checkPermission(permissions, permission);
        }
    } catch (error) {
        console.error("Error checking permissions:", error);
    }
    return false;
};
const getUserFromDecodedPayload = async (payload)=>{
    console.log("getUserFromDecodedPayload received payload:", payload);
    if (!payload) {
        console.error("Invalid token payload provided to getUserFromDecodedPayload");
        return null;
    }
    if (!payload.sub) {
        console.error("Token payload missing user ID (sub claim)");
        return null;
    }
    const userId = Number(payload.sub);
    const cacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_SESSION, {
        userId
    });
    try {
        // Try to get user from cache first
        const cachedUser = await _cache.cacheService.get(cacheKey);
        if (cachedUser) {
            console.log("User found in cache:", userId);
            return cachedUser;
        }
        console.log("Looking up user with ID:", userId);
        console.time("prisma.user.findFirst for auth"); // Start timer
        const user = await _prisma.default.user.findFirst({
            where: {
                id: userId,
                isActive: true
            },
            include: {
                role: {
                    include: {
                        permissions: {
                            select: {
                                name: true
                            }
                        }
                    }
                }
            }
        });
        console.timeEnd("prisma.user.findFirst for auth"); // End timer
        if (!user) {
            console.error("User not found for ID:", userId);
            return null;
        }
        const userWithPermissions = {
            ...user,
            roleName: user.role.name,
            permissions: user.role.permissions.map((p)=>p.name)
        };
        // Cache the user session
        await _cache.cacheService.set(cacheKey, userWithPermissions, _cache.CACHE_CONFIG.TTL.USER_SESSION);
        console.log("User found and cached:", user.id, user.name);
        return userWithPermissions;
    } catch (error) {
        console.error("Error getting user from decoded payload:", error);
        return null;
    }
};
const getUserFromToken = async (token)=>{
    const payload = await verifyToken(token);
    return getUserFromDecodedPayload(payload);
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vc3JjL3NlcnZpY2VzL2F1dGhTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJztcbmltcG9ydCBiY3J5cHQgZnJvbSAnYmNyeXB0anMnO1xuaW1wb3J0IHByaXNtYSBmcm9tICdAL2xpYi9wcmlzbWEnO1xuaW1wb3J0IHsgY2FjaGVTZXJ2aWNlLCBDQUNIRV9DT05GSUcgfSBmcm9tICdAL2xpYi9jYWNoZSc7XG5cbi8vIFNlY3JldCBrZXkgZm9yIEpXVCAtIHNob3VsZCBiZSBtb3ZlZCB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW4gcHJvZHVjdGlvblxuY29uc3QgSldUX1NFQ1JFVCA9IHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgfHwgJ3lvdXItc2VjcmV0LWtleSc7XG4vLyBDaGFuZ2VkIHRva2VuIGV4cGlyYXRpb24gdG8gMTJoIChmcm9tIDI0aCkgZm9yIGJldHRlciBzZWN1cml0eVxuY29uc3QgSldUX0VYUElSRVNfSU4gPSBwcm9jZXNzLmVudi5KV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4gfHwgJzEyaCc7XG5cbi8qKlxuICogUGFyc2VzIGEgdGltZSBzdHJpbmcgbGlrZSBcIjE1bVwiLCBcIjJoXCIsIFwiMWRcIiBpbnRvIHNlY29uZHMuXG4gKiBAcGFyYW0gdGltZVN0ciBUaGUgdGltZSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHNlY29uZHMsIG9yIDAgaWYgcGFyc2luZyBmYWlscy5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcyA9ICh0aW1lU3RyOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGlmICghdGltZVN0cikgcmV0dXJuIDA7XG4gICAgY29uc3QgbGFzdENoYXIgPSB0aW1lU3RyLnNsaWNlKC0xKTtcbiAgICBjb25zdCBudW0gPSBwYXJzZUludCh0aW1lU3RyLnNsaWNlKDAsIC0xKSk7XG5cbiAgICBpZiAoaXNOYU4obnVtKSkgcmV0dXJuIDA7XG5cbiAgICBzd2l0Y2ggKGxhc3RDaGFyKSB7XG4gICAgICAgIGNhc2UgJ3MnOiByZXR1cm4gbnVtO1xuICAgICAgICBjYXNlICdtJzogcmV0dXJuIG51bSAqIDYwO1xuICAgICAgICBjYXNlICdoJzogcmV0dXJuIG51bSAqIDYwICogNjA7XG4gICAgICAgIGNhc2UgJ2QnOiByZXR1cm4gbnVtICogNjAgKiA2MCAqIDI0O1xuICAgICAgICBkZWZhdWx0OiAvLyBJZiBubyB1bml0LCBhc3N1bWUgc2Vjb25kcyBpZiBpdCdzIGp1c3QgYSBudW1iZXIgc3RyaW5nXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHRpbWVTdHIpKSkgcmV0dXJuIHBhcnNlSW50KHRpbWVTdHIpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuaW50ZXJmYWNlIFRva2VuUGF5bG9hZCB7XG4gICAgc3ViOiBudW1iZXI7IC8vIFVzZXIgSUQgYXMgJ3N1YicgY2xhaW1cbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgcm9sZUlkOiBudW1iZXI7XG4gICAgc2hvcElkPzogbnVtYmVyIHwgbnVsbDtcbiAgICBwZXJtaXNzaW9ucz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZSBhIHVzZXIgd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgKG9wdGltaXplZCB3aXRoIHNpbmdsZSBxdWVyeSlcbiAqL1xuZXhwb3J0IGNvbnN0IGF1dGhlbnRpY2F0ZVVzZXIgPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUudGltZSgndXNlciBhdXRoZW50aWNhdGlvbiBxdWVyeScpO1xuICAgICAgICAvLyBPcHRpbWl6ZWQgc2luZ2xlIHF1ZXJ5IHVzaW5nIHRoZSBuZXcgY29tcG9zaXRlIGluZGV4XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgcm9sZToge1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDogeyBuYW1lOiB0cnVlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgndXNlciBhdXRoZW50aWNhdGlvbiBxdWVyeScpO1xuXG4gICAgICAgIC8vIElmIHVzZXIgbm90IGZvdW5kXG4gICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgcGFzc3dvcmRcbiAgICAgICAgY29uc3QgaXNQYXNzd29yZFZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUocGFzc3dvcmQsIHVzZXIucGFzc3dvcmQpO1xuICAgICAgICBpZiAoIWlzUGFzc3dvcmRWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgcGVybWlzc2lvbnMgZnJvbSByb2xlIChoYW5kbGUgY2FzZSB3aGVyZSB1c2VyIGhhcyBubyByb2xlKVxuICAgICAgICBsZXQgcGVybWlzc2lvbnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmICh1c2VyLnJvbGU/LnBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgICBwZXJtaXNzaW9ucyA9IHVzZXIucm9sZS5wZXJtaXNzaW9ucy5tYXAocCA9PiBwLm5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHVzZXIucGVybWlzc2lvbnMgJiYgQXJyYXkuaXNBcnJheSh1c2VyLnBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBwZXJtaXNzaW9uIElEcyB0byBuYW1lc1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvblJlY29yZHMgPSBhd2FpdCBwcmlzbWEucGVybWlzc2lvbi5maW5kTWFueSh7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluOiB1c2VyLnBlcm1pc3Npb25zLm1hcChpZCA9PiBwYXJzZUludChpZC50b1N0cmluZygpKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VsZWN0OiB7IG5hbWU6IHRydWUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25SZWNvcmRzLm1hcChwID0+IHAubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBKV1QgdG9rZW5cbiAgICAgICAgY29uc3QgdG9rZW4gPSBnZW5lcmF0ZVRva2VuKHtcbiAgICAgICAgICAgIHN1YjogdXNlci5pZCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VyLm5hbWUsXG4gICAgICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgICAgIHJvbGVJZDogdXNlci5yb2xlSWQsXG4gICAgICAgICAgICBzaG9wSWQ6IHVzZXIuc2hvcElkLFxuICAgICAgICAgICAgcGVybWlzc2lvbnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdXNlclNlc3Npb24gPSB7XG4gICAgICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VyLm5hbWUsXG4gICAgICAgICAgICBmdWxsTmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgICAgICByb2xlSWQ6IHVzZXIucm9sZUlkLFxuICAgICAgICAgICAgcm9sZU5hbWU6IHVzZXIucm9sZT8ubmFtZSB8fCB1c2VyLnJvbGVOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBzaG9wSWQ6IHVzZXIuc2hvcElkLFxuICAgICAgICAgICAgcGVybWlzc2lvbnMsXG4gICAgICAgICAgICByb2xlOiB1c2VyLnJvbGVcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWNoZSB1c2VyIHNlc3Npb24gZm9yIGZhc3RlciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5KENBQ0hFX0NPTkZJRy5LRVlTLlVTRVJfU0VTU0lPTiwgeyB1c2VySWQ6IHVzZXIuaWQgfSk7XG4gICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5zZXQoY2FjaGVLZXksIHVzZXJTZXNzaW9uLCBDQUNIRV9DT05GSUcuVFRMLlVTRVJfU0VTU0lPTik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgICAgIGZ1bGxOYW1lOiB1c2VyLm5hbWUsXG4gICAgICAgICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgICAgICAgICAgcm9sZUlkOiB1c2VyLnJvbGVJZCxcbiAgICAgICAgICAgICAgICByb2xlTmFtZTogdXNlci5yb2xlPy5uYW1lIHx8IHVzZXIucm9sZU5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzaG9wSWQ6IHVzZXIuc2hvcElkLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXV0aGVudGljYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQXV0aGVudGljYXRpb24gZmFpbGVkJ1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBKV1QgdG9rZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlVG9rZW4gPSAocGF5bG9hZDogVG9rZW5QYXlsb2FkKSA9PiB7XG4gICAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIEpXVF9TRUNSRVQsIHsgZXhwaXJlc0luOiBKV1RfRVhQSVJFU19JTiB9KTtcbn07XG5cbi8qKlxuICogVmVyaWZ5IGEgSldUIHRva2VuIHdpdGggY2FjaGluZ1xuICovXG5leHBvcnQgY29uc3QgdmVyaWZ5VG9rZW4gPSBhc3luYyAodG9rZW46IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHRva2VuS2V5ID0gY2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5KENBQ0hFX0NPTkZJRy5LRVlTLlRPS0VOX1ZBTElEQVRJT04sIHsgdG9rZW46IHRva2VuLnN1YnN0cmluZygwLCAyMCkgfSk7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdCBmb3IgdG9rZW4gdmFsaWRhdGlvbiByZXN1bHRcbiAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0ID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldCh0b2tlbktleSk7XG4gICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQgYXMgVG9rZW5QYXlsb2FkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRva2VuXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBqd3QudmVyaWZ5KHRva2VuLCBKV1RfU0VDUkVUKSBhcyBUb2tlblBheWxvYWQ7XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIHZhbGlkIHRva2VuIHBheWxvYWQgKHNob3J0ZXIgVFRMIGZvciBzZWN1cml0eSlcbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldCh0b2tlbktleSwgcGF5bG9hZCwgQ0FDSEVfQ09ORklHLlRUTC5UT0tFTl9WQUxJREFUSU9OKTtcblxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBMb2cgdGhlIGVycm9yIGhlcmUgaWYgZGVzaXJlZFxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBqd3QuVG9rZW5FeHBpcmVkRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIGV4cGlyZWQgZHVyaW5nIHZlcmlmaWNhdGlvbjonLCBlcnJvci5leHBpcmVkQXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2Ygand0Lkpzb25XZWJUb2tlbkVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHRva2VuIGR1cmluZyB2ZXJpZmljYXRpb246JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIHRva2VuIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRoZSBlcnJvclxuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0b2tlbiBoYXMgYSBzcGVjaWZpYyBwZXJtaXNzaW9uIHdpdGggY2FjaGluZ1xuICovXG5leHBvcnQgY29uc3QgaGFzUGVybWlzc2lvbiA9IGFzeW5jICh0b2tlblBheWxvYWQ6IFRva2VuUGF5bG9hZCwgcGVybWlzc2lvbjogc3RyaW5nKSA9PiB7XG4gICAgLy8gSW1wb3J0IHRoZSBwcm9wZXIgcGVybWlzc2lvbiBjaGVja2luZyB1dGlsaXR5XG4gICAgY29uc3QgeyBoYXNQZXJtaXNzaW9uOiBjaGVja1Blcm1pc3Npb24gfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvdXRpbHMvcGVybWlzc2lvbnMnKTtcbiAgICBcbiAgICAvLyBRdWljayBjaGVjayBmcm9tIHRva2VuIHBheWxvYWQgZmlyc3RcbiAgICBpZiAodG9rZW5QYXlsb2FkLnBlcm1pc3Npb25zKSB7XG4gICAgICAgIGlmIChjaGVja1Blcm1pc3Npb24odG9rZW5QYXlsb2FkLnBlcm1pc3Npb25zLCBwZXJtaXNzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgaW4gdG9rZW4sIGNoZWNrIGNhY2hlZCB1c2VyIHBlcm1pc3Npb25zXG4gICAgY29uc3QgcGVybWlzc2lvbnNDYWNoZUtleSA9IGNhY2hlU2VydmljZS5nZW5lcmF0ZUtleShDQUNIRV9DT05GSUcuS0VZUy5VU0VSX1BFUk1JU1NJT05TLCB7IHVzZXJJZDogdG9rZW5QYXlsb2FkLnN1YiB9KTtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZFBlcm1pc3Npb25zID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldChwZXJtaXNzaW9uc0NhY2hlS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJtaXNzaW9uKGNhY2hlZFBlcm1pc3Npb25zLCBwZXJtaXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGRhdGFiYXNlIHF1ZXJ5IGlmIG5vdCBjYWNoZWRcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHByaXNtYS51c2VyLmZpbmRGaXJzdCh7XG4gICAgICAgICAgICB3aGVyZTogeyBpZDogdG9rZW5QYXlsb2FkLnN1YiwgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICByb2xlOiB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiB7IHNlbGVjdDogeyBuYW1lOiB0cnVlIH0gfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSB1c2VyLnJvbGUucGVybWlzc2lvbnMubWFwKHAgPT4gcC5uYW1lKTtcbiAgICAgICAgICAgIC8vIENhY2hlIHBlcm1pc3Npb25zIGZvciBmdXR1cmUgY2hlY2tzXG4gICAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KHBlcm1pc3Npb25zQ2FjaGVLZXksIHBlcm1pc3Npb25zLCBDQUNIRV9DT05GSUcuVFRMLlVTRVJfUEVSTUlTU0lPTlMpO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVybWlzc2lvbihwZXJtaXNzaW9ucywgcGVybWlzc2lvbik7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBwZXJtaXNzaW9uczonLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdXNlciBkZXRhaWxzIGZyb20gYSBkZWNvZGVkIHRva2VuIHBheWxvYWQgd2l0aCBjYWNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkID0gYXN5bmMgKHBheWxvYWQ6IFRva2VuUGF5bG9hZCB8IG51bGwpID0+IHtcbiAgICBjb25zb2xlLmxvZygnZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCByZWNlaXZlZCBwYXlsb2FkOicsIHBheWxvYWQpO1xuXG4gICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdG9rZW4gcGF5bG9hZCBwcm92aWRlZCB0byBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gcGF5bG9hZCBtaXNzaW5nIHVzZXIgSUQgKHN1YiBjbGFpbSknKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlcklkID0gTnVtYmVyKHBheWxvYWQuc3ViKTtcbiAgICBjb25zdCBjYWNoZUtleSA9IGNhY2hlU2VydmljZS5nZW5lcmF0ZUtleShDQUNIRV9DT05GSUcuS0VZUy5VU0VSX1NFU1NJT04sIHsgdXNlcklkIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCB1c2VyIGZyb20gY2FjaGUgZmlyc3RcbiAgICAgICAgY29uc3QgY2FjaGVkVXNlciA9IGF3YWl0IGNhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoY2FjaGVkVXNlcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgZm91bmQgaW4gY2FjaGU6JywgdXNlcklkKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0xvb2tpbmcgdXAgdXNlciB3aXRoIElEOicsIHVzZXJJZCk7XG4gICAgICAgIGNvbnNvbGUudGltZSgncHJpc21hLnVzZXIuZmluZEZpcnN0IGZvciBhdXRoJyk7IC8vIFN0YXJ0IHRpbWVyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICBpZDogdXNlcklkLFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ3ByaXNtYS51c2VyLmZpbmRGaXJzdCBmb3IgYXV0aCcpOyAvLyBFbmQgdGltZXJcblxuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZXIgbm90IGZvdW5kIGZvciBJRDonLCB1c2VySWQpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1c2VyV2l0aFBlcm1pc3Npb25zID0ge1xuICAgICAgICAgICAgLi4udXNlcixcbiAgICAgICAgICAgIHJvbGVOYW1lOiB1c2VyLnJvbGUubmFtZSxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zOiB1c2VyLnJvbGUucGVybWlzc2lvbnMubWFwKHAgPT4gcC5uYW1lKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSB1c2VyIHNlc3Npb25cbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdXNlcldpdGhQZXJtaXNzaW9ucywgQ0FDSEVfQ09ORklHLlRUTC5VU0VSX1NFU1NJT04pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGZvdW5kIGFuZCBjYWNoZWQ6JywgdXNlci5pZCwgdXNlci5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHVzZXJXaXRoUGVybWlzc2lvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGZyb20gZGVjb2RlZCBwYXlsb2FkOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgdXNlciBkZXRhaWxzIGZyb20gdG9rZW4gKExlZ2FjeSAtIGNvbnNpZGVyIHBoYXNpbmcgb3V0IG9yIHJlZmFjdG9yaW5nKVxuICogVGhpcyBmdW5jdGlvbiBub3cgY2FsbHMgdmVyaWZ5VG9rZW4gYW5kIHRoZW4gZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVzZXJGcm9tVG9rZW4gPSBhc3luYyAodG9rZW46IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB2ZXJpZnlUb2tlbih0b2tlbik7XG4gICAgcmV0dXJuIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG59OyJdLCJuYW1lcyI6WyJhdXRoZW50aWNhdGVVc2VyIiwiZ2VuZXJhdGVUb2tlbiIsImdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQiLCJnZXRVc2VyRnJvbVRva2VuIiwiaGFzUGVybWlzc2lvbiIsInBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcyIsInZlcmlmeVRva2VuIiwiSldUX1NFQ1JFVCIsInByb2Nlc3MiLCJlbnYiLCJKV1RfRVhQSVJFU19JTiIsIkpXVF9BQ0NFU1NfVE9LRU5fRVhQSVJFU19JTiIsInRpbWVTdHIiLCJsYXN0Q2hhciIsInNsaWNlIiwibnVtIiwicGFyc2VJbnQiLCJpc05hTiIsImVtYWlsIiwicGFzc3dvcmQiLCJjb25zb2xlIiwidGltZSIsInVzZXIiLCJwcmlzbWEiLCJmaW5kRmlyc3QiLCJ3aGVyZSIsImlzQWN0aXZlIiwiaW5jbHVkZSIsInJvbGUiLCJwZXJtaXNzaW9ucyIsInNlbGVjdCIsIm5hbWUiLCJ0aW1lRW5kIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJpc1Bhc3N3b3JkVmFsaWQiLCJiY3J5cHQiLCJjb21wYXJlIiwibWFwIiwicCIsIkFycmF5IiwiaXNBcnJheSIsInBlcm1pc3Npb25SZWNvcmRzIiwicGVybWlzc2lvbiIsImZpbmRNYW55IiwiaWQiLCJpbiIsInRvU3RyaW5nIiwidG9rZW4iLCJzdWIiLCJ1c2VybmFtZSIsInJvbGVJZCIsInNob3BJZCIsInVzZXJTZXNzaW9uIiwiZnVsbE5hbWUiLCJyb2xlTmFtZSIsImNhY2hlS2V5IiwiY2FjaGVTZXJ2aWNlIiwiZ2VuZXJhdGVLZXkiLCJDQUNIRV9DT05GSUciLCJLRVlTIiwiVVNFUl9TRVNTSU9OIiwidXNlcklkIiwic2V0IiwiVFRMIiwiZXJyb3IiLCJwYXlsb2FkIiwiand0Iiwic2lnbiIsImV4cGlyZXNJbiIsInRva2VuS2V5IiwiVE9LRU5fVkFMSURBVElPTiIsInN1YnN0cmluZyIsImNhY2hlZFJlc3VsdCIsImdldCIsInZlcmlmeSIsIlRva2VuRXhwaXJlZEVycm9yIiwiZXhwaXJlZEF0IiwiSnNvbldlYlRva2VuRXJyb3IiLCJ0b2tlblBheWxvYWQiLCJjaGVja1Blcm1pc3Npb24iLCJwZXJtaXNzaW9uc0NhY2hlS2V5IiwiVVNFUl9QRVJNSVNTSU9OUyIsImNhY2hlZFBlcm1pc3Npb25zIiwibG9nIiwiTnVtYmVyIiwiY2FjaGVkVXNlciIsInVzZXJXaXRoUGVybWlzc2lvbnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBNkNhQSxnQkFBZ0I7ZUFBaEJBOztJQTJHQUMsYUFBYTtlQUFiQTs7SUF3RkFDLHlCQUF5QjtlQUF6QkE7O0lBcUVBQyxnQkFBZ0I7ZUFBaEJBOztJQXJIQUMsYUFBYTtlQUFiQTs7SUFqTEFDLHdCQUF3QjtlQUF4QkE7O0lBZ0pBQyxXQUFXO2VBQVhBOzs7cUVBL0pHO2lFQUNHOytEQUNBO3VCQUN3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFM0MsOEVBQThFO0FBQzlFLE1BQU1DLGFBQWFDLFFBQVFDLEdBQUcsQ0FBQ0YsVUFBVSxJQUFJO0FBQzdDLGlFQUFpRTtBQUNqRSxNQUFNRyxpQkFBaUJGLFFBQVFDLEdBQUcsQ0FBQ0UsMkJBQTJCLElBQUk7QUFPM0QsTUFBTU4sMkJBQTJCLENBQUNPO0lBQ3JDLElBQUksQ0FBQ0EsU0FBUyxPQUFPO0lBQ3JCLE1BQU1DLFdBQVdELFFBQVFFLEtBQUssQ0FBQyxDQUFDO0lBQ2hDLE1BQU1DLE1BQU1DLFNBQVNKLFFBQVFFLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFFdkMsSUFBSUcsTUFBTUYsTUFBTSxPQUFPO0lBRXZCLE9BQVFGO1FBQ0osS0FBSztZQUFLLE9BQU9FO1FBQ2pCLEtBQUs7WUFBSyxPQUFPQSxNQUFNO1FBQ3ZCLEtBQUs7WUFBSyxPQUFPQSxNQUFNLEtBQUs7UUFDNUIsS0FBSztZQUFLLE9BQU9BLE1BQU0sS0FBSyxLQUFLO1FBQ2pDO1lBQ0ksSUFBSSxDQUFDRSxNQUFNRCxTQUFTSixXQUFXLE9BQU9JLFNBQVNKO1lBQy9DLE9BQU87SUFDZjtBQUNKO0FBY08sTUFBTVosbUJBQW1CLE9BQU9rQixPQUFlQztJQUNsRCxJQUFJO1FBQ0FDLFFBQVFDLElBQUksQ0FBQztRQUNiLHVEQUF1RDtRQUN2RCxNQUFNQyxPQUFPLE1BQU1DLGVBQU0sQ0FBQ0QsSUFBSSxDQUFDRSxTQUFTLENBQUM7WUFDckNDLE9BQU87Z0JBQ0hQLE9BQU9BO2dCQUNQUSxVQUFVO1lBQ2Q7WUFDQUMsU0FBUztnQkFDTEMsTUFBTTtvQkFDRkQsU0FBUzt3QkFDTEUsYUFBYTs0QkFDVEMsUUFBUTtnQ0FBRUMsTUFBTTs0QkFBSzt3QkFDekI7b0JBQ0o7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0FYLFFBQVFZLE9BQU8sQ0FBQztRQUVoQixvQkFBb0I7UUFDcEIsSUFBSSxDQUFDVixNQUFNO1lBQ1AsT0FBTztnQkFDSFcsU0FBUztnQkFDVEMsU0FBUztZQUNiO1FBQ0o7UUFFQSxrQkFBa0I7UUFDbEIsTUFBTUMsa0JBQWtCLE1BQU1DLGlCQUFNLENBQUNDLE9BQU8sQ0FBQ2xCLFVBQVVHLEtBQUtILFFBQVE7UUFDcEUsSUFBSSxDQUFDZ0IsaUJBQWlCO1lBQ2xCLE9BQU87Z0JBQ0hGLFNBQVM7Z0JBQ1RDLFNBQVM7WUFDYjtRQUNKO1FBRUEsaUVBQWlFO1FBQ2pFLElBQUlMLGNBQXdCLEVBQUU7UUFDOUIsSUFBSVAsS0FBS00sSUFBSSxFQUFFQyxhQUFhO1lBQ3hCQSxjQUFjUCxLQUFLTSxJQUFJLENBQUNDLFdBQVcsQ0FBQ1MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFUixJQUFJO1FBQ3ZELE9BQU8sSUFBSVQsS0FBS08sV0FBVyxJQUFJVyxNQUFNQyxPQUFPLENBQUNuQixLQUFLTyxXQUFXLEdBQUc7WUFDNUQsa0NBQWtDO1lBQ2xDLE1BQU1hLG9CQUFvQixNQUFNbkIsZUFBTSxDQUFDb0IsVUFBVSxDQUFDQyxRQUFRLENBQUM7Z0JBQ3ZEbkIsT0FBTztvQkFDSG9CLElBQUk7d0JBQ0FDLElBQUl4QixLQUFLTyxXQUFXLENBQUNTLEdBQUcsQ0FBQ08sQ0FBQUEsS0FBTTdCLFNBQVM2QixHQUFHRSxRQUFRO29CQUN2RDtnQkFDSjtnQkFDQWpCLFFBQVE7b0JBQUVDLE1BQU07Z0JBQUs7WUFDekI7WUFDQUYsY0FBY2Esa0JBQWtCSixHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVSLElBQUk7UUFDbkQ7UUFFQSxxQkFBcUI7UUFDckIsTUFBTWlCLFFBQVEvQyxjQUFjO1lBQ3hCZ0QsS0FBSzNCLEtBQUt1QixFQUFFO1lBQ1pLLFVBQVU1QixLQUFLUyxJQUFJO1lBQ25CYixPQUFPSSxLQUFLSixLQUFLO1lBQ2pCaUMsUUFBUTdCLEtBQUs2QixNQUFNO1lBQ25CQyxRQUFROUIsS0FBSzhCLE1BQU07WUFDbkJ2QjtRQUNKO1FBRUEsTUFBTXdCLGNBQWM7WUFDaEJSLElBQUl2QixLQUFLdUIsRUFBRTtZQUNYSyxVQUFVNUIsS0FBS1MsSUFBSTtZQUNuQnVCLFVBQVVoQyxLQUFLUyxJQUFJO1lBQ25CYixPQUFPSSxLQUFLSixLQUFLO1lBQ2pCaUMsUUFBUTdCLEtBQUs2QixNQUFNO1lBQ25CSSxVQUFVakMsS0FBS00sSUFBSSxFQUFFRyxRQUFRVCxLQUFLaUMsUUFBUSxJQUFJO1lBQzlDSCxRQUFROUIsS0FBSzhCLE1BQU07WUFDbkJ2QjtZQUNBRCxNQUFNTixLQUFLTSxJQUFJO1FBQ25CO1FBRUEsb0RBQW9EO1FBQ3BELE1BQU00QixXQUFXQyxtQkFBWSxDQUFDQyxXQUFXLENBQUNDLG1CQUFZLENBQUNDLElBQUksQ0FBQ0MsWUFBWSxFQUFFO1lBQUVDLFFBQVF4QyxLQUFLdUIsRUFBRTtRQUFDO1FBQzVGLE1BQU1ZLG1CQUFZLENBQUNNLEdBQUcsQ0FBQ1AsVUFBVUgsYUFBYU0sbUJBQVksQ0FBQ0ssR0FBRyxDQUFDSCxZQUFZO1FBRTNFLE9BQU87WUFDSDVCLFNBQVM7WUFDVGU7WUFDQTFCLE1BQU07Z0JBQ0Z1QixJQUFJdkIsS0FBS3VCLEVBQUU7Z0JBQ1hLLFVBQVU1QixLQUFLUyxJQUFJO2dCQUNuQnVCLFVBQVVoQyxLQUFLUyxJQUFJO2dCQUNuQmIsT0FBT0ksS0FBS0osS0FBSztnQkFDakJpQyxRQUFRN0IsS0FBSzZCLE1BQU07Z0JBQ25CSSxVQUFVakMsS0FBS00sSUFBSSxFQUFFRyxRQUFRVCxLQUFLaUMsUUFBUSxJQUFJO2dCQUM5Q0gsUUFBUTlCLEtBQUs4QixNQUFNO2dCQUNuQnZCO1lBQ0o7UUFDSjtJQUNKLEVBQUUsT0FBT29DLE9BQU87UUFDWjdDLFFBQVE2QyxLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxPQUFPO1lBQ0hoQyxTQUFTO1lBQ1RDLFNBQVM7UUFDYjtJQUNKO0FBQ0o7QUFLTyxNQUFNakMsZ0JBQWdCLENBQUNpRTtJQUMxQixPQUFPQyxxQkFBRyxDQUFDQyxJQUFJLENBQUNGLFNBQVMzRCxZQUFZO1FBQUU4RCxXQUFXM0Q7SUFBZTtBQUNyRTtBQUtPLE1BQU1KLGNBQWMsT0FBTzBDO0lBQzlCLE1BQU1zQixXQUFXYixtQkFBWSxDQUFDQyxXQUFXLENBQUNDLG1CQUFZLENBQUNDLElBQUksQ0FBQ1csZ0JBQWdCLEVBQUU7UUFBRXZCLE9BQU9BLE1BQU13QixTQUFTLENBQUMsR0FBRztJQUFJO0lBRTlHLElBQUk7UUFDQSxnREFBZ0Q7UUFDaEQsTUFBTUMsZUFBZSxNQUFNaEIsbUJBQVksQ0FBQ2lCLEdBQUcsQ0FBQ0o7UUFDNUMsSUFBSUcsY0FBYztZQUNkLE9BQU9BO1FBQ1g7UUFFQSxlQUFlO1FBQ2YsTUFBTVAsVUFBVUMscUJBQUcsQ0FBQ1EsTUFBTSxDQUFDM0IsT0FBT3pDO1FBRWxDLDJEQUEyRDtRQUMzRCxNQUFNa0QsbUJBQVksQ0FBQ00sR0FBRyxDQUFDTyxVQUFVSixTQUFTUCxtQkFBWSxDQUFDSyxHQUFHLENBQUNPLGdCQUFnQjtRQUUzRSxPQUFPTDtJQUNYLEVBQUUsT0FBT0QsT0FBTztRQUNaLGdDQUFnQztRQUNoQyxJQUFJQSxpQkFBaUJFLHFCQUFHLENBQUNTLGlCQUFpQixFQUFFO1lBQ3hDeEQsUUFBUTZDLEtBQUssQ0FBQyxzQ0FBc0NBLE1BQU1ZLFNBQVM7UUFDdkUsT0FBTyxJQUFJWixpQkFBaUJFLHFCQUFHLENBQUNXLGlCQUFpQixFQUFFO1lBQy9DMUQsUUFBUTZDLEtBQUssQ0FBQyxzQ0FBc0NBLE1BQU0vQixPQUFPO1FBQ3JFLE9BQU87WUFDSGQsUUFBUTZDLEtBQUssQ0FBQyxxQ0FBcUNBO1FBQ3ZEO1FBQ0EsTUFBTUEsT0FBTyxxQkFBcUI7SUFDdEM7QUFDSjtBQUtPLE1BQU03RCxnQkFBZ0IsT0FBTzJFLGNBQTRCcEM7SUFDNUQsZ0RBQWdEO0lBQ2hELE1BQU0sRUFBRXZDLGVBQWU0RSxlQUFlLEVBQUUsR0FBRyxNQUFNLG1FQUFBLFFBQU87SUFFeEQsdUNBQXVDO0lBQ3ZDLElBQUlELGFBQWFsRCxXQUFXLEVBQUU7UUFDMUIsSUFBSW1ELGdCQUFnQkQsYUFBYWxELFdBQVcsRUFBRWMsYUFBYTtZQUN2RCxPQUFPO1FBQ1g7SUFDSjtJQUVBLGlEQUFpRDtJQUNqRCxNQUFNc0Msc0JBQXNCeEIsbUJBQVksQ0FBQ0MsV0FBVyxDQUFDQyxtQkFBWSxDQUFDQyxJQUFJLENBQUNzQixnQkFBZ0IsRUFBRTtRQUFFcEIsUUFBUWlCLGFBQWE5QixHQUFHO0lBQUM7SUFFcEgsSUFBSTtRQUNBLE1BQU1rQyxvQkFBb0IsTUFBTTFCLG1CQUFZLENBQUNpQixHQUFHLENBQUNPO1FBQ2pELElBQUlFLG1CQUFtQjtZQUNuQixPQUFPSCxnQkFBZ0JHLG1CQUFtQnhDO1FBQzlDO1FBRUEsMkNBQTJDO1FBQzNDLE1BQU1yQixPQUFPLE1BQU1DLGVBQU0sQ0FBQ0QsSUFBSSxDQUFDRSxTQUFTLENBQUM7WUFDckNDLE9BQU87Z0JBQUVvQixJQUFJa0MsYUFBYTlCLEdBQUc7Z0JBQUV2QixVQUFVO1lBQUs7WUFDOUNDLFNBQVM7Z0JBQ0xDLE1BQU07b0JBQ0ZELFNBQVM7d0JBQ0xFLGFBQWE7NEJBQUVDLFFBQVE7Z0NBQUVDLE1BQU07NEJBQUs7d0JBQUU7b0JBQzFDO2dCQUNKO1lBQ0o7UUFDSjtRQUVBLElBQUlULE1BQU07WUFDTixNQUFNTyxjQUFjUCxLQUFLTSxJQUFJLENBQUNDLFdBQVcsQ0FBQ1MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFUixJQUFJO1lBQ3pELHNDQUFzQztZQUN0QyxNQUFNMEIsbUJBQVksQ0FBQ00sR0FBRyxDQUFDa0IscUJBQXFCcEQsYUFBYThCLG1CQUFZLENBQUNLLEdBQUcsQ0FBQ2tCLGdCQUFnQjtZQUMxRixPQUFPRixnQkFBZ0JuRCxhQUFhYztRQUN4QztJQUNKLEVBQUUsT0FBT3NCLE9BQU87UUFDWjdDLFFBQVE2QyxLQUFLLENBQUMsK0JBQStCQTtJQUNqRDtJQUVBLE9BQU87QUFDWDtBQUtPLE1BQU0vRCw0QkFBNEIsT0FBT2dFO0lBQzVDOUMsUUFBUWdFLEdBQUcsQ0FBQywrQ0FBK0NsQjtJQUUzRCxJQUFJLENBQUNBLFNBQVM7UUFDVjlDLFFBQVE2QyxLQUFLLENBQUM7UUFDZCxPQUFPO0lBQ1g7SUFFQSxJQUFJLENBQUNDLFFBQVFqQixHQUFHLEVBQUU7UUFDZDdCLFFBQVE2QyxLQUFLLENBQUM7UUFDZCxPQUFPO0lBQ1g7SUFFQSxNQUFNSCxTQUFTdUIsT0FBT25CLFFBQVFqQixHQUFHO0lBQ2pDLE1BQU1PLFdBQVdDLG1CQUFZLENBQUNDLFdBQVcsQ0FBQ0MsbUJBQVksQ0FBQ0MsSUFBSSxDQUFDQyxZQUFZLEVBQUU7UUFBRUM7SUFBTztJQUVuRixJQUFJO1FBQ0EsbUNBQW1DO1FBQ25DLE1BQU13QixhQUFhLE1BQU03QixtQkFBWSxDQUFDaUIsR0FBRyxDQUFDbEI7UUFDMUMsSUFBSThCLFlBQVk7WUFDWmxFLFFBQVFnRSxHQUFHLENBQUMsd0JBQXdCdEI7WUFDcEMsT0FBT3dCO1FBQ1g7UUFFQWxFLFFBQVFnRSxHQUFHLENBQUMsNEJBQTRCdEI7UUFDeEMxQyxRQUFRQyxJQUFJLENBQUMsbUNBQW1DLGNBQWM7UUFDOUQsTUFBTUMsT0FBTyxNQUFNQyxlQUFNLENBQUNELElBQUksQ0FBQ0UsU0FBUyxDQUFDO1lBQ3JDQyxPQUFPO2dCQUNIb0IsSUFBSWlCO2dCQUNKcEMsVUFBVTtZQUNkO1lBQ0FDLFNBQVM7Z0JBQ0xDLE1BQU07b0JBQ0ZELFNBQVM7d0JBQ0xFLGFBQWE7NEJBQ1RDLFFBQVE7Z0NBQUVDLE1BQU07NEJBQUs7d0JBQ3pCO29CQUNKO2dCQUNKO1lBQ0o7UUFDSjtRQUNBWCxRQUFRWSxPQUFPLENBQUMsbUNBQW1DLFlBQVk7UUFFL0QsSUFBSSxDQUFDVixNQUFNO1lBQ1BGLFFBQVE2QyxLQUFLLENBQUMsMEJBQTBCSDtZQUN4QyxPQUFPO1FBQ1g7UUFFQSxNQUFNeUIsc0JBQXNCO1lBQ3hCLEdBQUdqRSxJQUFJO1lBQ1BpQyxVQUFVakMsS0FBS00sSUFBSSxDQUFDRyxJQUFJO1lBQ3hCRixhQUFhUCxLQUFLTSxJQUFJLENBQUNDLFdBQVcsQ0FBQ1MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFUixJQUFJO1FBQ3REO1FBRUEseUJBQXlCO1FBQ3pCLE1BQU0wQixtQkFBWSxDQUFDTSxHQUFHLENBQUNQLFVBQVUrQixxQkFBcUI1QixtQkFBWSxDQUFDSyxHQUFHLENBQUNILFlBQVk7UUFFbkZ6QyxRQUFRZ0UsR0FBRyxDQUFDLDBCQUEwQjlELEtBQUt1QixFQUFFLEVBQUV2QixLQUFLUyxJQUFJO1FBQ3hELE9BQU93RDtJQUNYLEVBQUUsT0FBT3RCLE9BQU87UUFDWjdDLFFBQVE2QyxLQUFLLENBQUMsNENBQTRDQTtRQUMxRCxPQUFPO0lBQ1g7QUFDSjtBQU1PLE1BQU05RCxtQkFBbUIsT0FBTzZDO0lBQ25DLE1BQU1rQixVQUFVLE1BQU01RCxZQUFZMEM7SUFDbEMsT0FBTzlDLDBCQUEwQmdFO0FBQ3JDIn0=