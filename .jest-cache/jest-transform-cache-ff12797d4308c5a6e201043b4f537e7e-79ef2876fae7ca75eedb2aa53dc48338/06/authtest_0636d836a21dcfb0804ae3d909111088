a07b2f60daa9cb100576953b6bf6830a
// Set up environment variables before any imports
"use strict";
jest.mock("jose", ()=>({
        jwtVerify: mockJwtVerify
    }));
jest.mock("@/lib/prisma", ()=>({
        __esModule: true,
        default: mockPrisma
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _auth = require("../../src/lib/auth");
process.env.JWT_SECRET = "test-secret-key-for-testing";
process.env.NEXTAUTH_SECRET = "test-nextauth-secret";
// Mock jose library
const mockJwtVerify = jest.fn();
// Mock prisma
const mockPrisma = {
    user: {
        findUnique: jest.fn()
    }
};
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{})
};
describe("Auth Utility Functions", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
    });
    describe("verifyToken", ()=>{
        it("should verify valid token", async ()=>{
            const mockPayload = {
                sub: "1",
                permissions: [
                    "read"
                ]
            };
            mockJwtVerify.mockResolvedValue({
                payload: mockPayload
            });
            const result = await (0, _auth.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockJwtVerify).toHaveBeenCalledWith("valid-token", expect.any(Uint8Array));
        });
        it("should handle expired token", async ()=>{
            const error = new Error("Token expired");
            error.code = "ERR_JWT_EXPIRED";
            mockJwtVerify.mockRejectedValue(error);
            const result = await (0, _auth.verifyToken)("expired-token");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Token expired:", "Token expired");
        });
        it("should handle invalid token signature", async ()=>{
            const error = new Error("Invalid signature");
            error.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
            mockJwtVerify.mockRejectedValue(error);
            const result = await (0, _auth.verifyToken)("invalid-token");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Invalid token:", "Invalid signature");
        });
        it("should handle other verification errors", async ()=>{
            const error = new Error("Unknown error");
            error.code = "ERR_UNKNOWN";
            mockJwtVerify.mockRejectedValue(error);
            const result = await (0, _auth.verifyToken)("error-token");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Token verification error:", "Unknown error");
        });
    });
    describe("extractToken", ()=>{
        it("should extract token from valid authorization header", ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token-123")
                }
            };
            const result = (0, _auth.extractToken)(req);
            expect(result).toBe("valid-token-123");
            expect(req.headers.get).toHaveBeenCalledWith("authorization");
        });
        it("should return null for missing authorization header", ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            const result = (0, _auth.extractToken)(req);
            expect(result).toBeNull();
        });
        it("should return null for invalid authorization header format", ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Invalid token-123")
                }
            };
            const result = (0, _auth.extractToken)(req);
            expect(result).toBeNull();
        });
        it("should return null for empty authorization header", ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("")
                }
            };
            const result = (0, _auth.extractToken)(req);
            expect(result).toBeNull();
        });
    });
    describe("validateTokenPermission", ()=>{
        it("should return invalid for missing token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "Authentication required"
            });
        });
        it("should grant permission for dev-token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer dev-token")
                }
            };
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: true
            });
            expect(consoleSpy.log).toHaveBeenCalledWith("Development mode: granting permission 'read'");
        });
        it("should return invalid for invalid token payload", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer invalid-token")
                }
            };
            mockJwtVerify.mockResolvedValue({
                payload: null
            });
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "Invalid authentication token"
            });
        });
        it("should grant permission from token payload", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockJwtVerify.mockResolvedValue({
                payload: {
                    sub: "1",
                    permissions: [
                        "read",
                        "write"
                    ]
                }
            });
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: true
            });
        });
        it("should fallback to database when permission not in token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockJwtVerify.mockResolvedValue({
                payload: {
                    sub: "1",
                    permissions: [
                        "write"
                    ]
                }
            });
            mockPrisma.user.findUnique.mockResolvedValue({
                id: 1,
                permissions: [
                    "read",
                    "write"
                ]
            });
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: true
            });
        });
        it("should return invalid for user not found", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockJwtVerify.mockResolvedValue({
                payload: {
                    sub: "999"
                }
            });
            mockPrisma.user.findUnique.mockResolvedValue(null);
            const result = await (0, _auth.validateTokenPermission)(req, "read");
            expect(result).toEqual({
                isValid: false,
                message: "User not found"
            });
        });
    });
    describe("getUserIdFromToken", ()=>{
        it("should return null for missing token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            const result = await (0, _auth.getUserIdFromToken)(req);
            expect(result).toBeNull();
        });
        it("should return 1 for dev-token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer dev-token")
                }
            };
            const result = await (0, _auth.getUserIdFromToken)(req);
            expect(result).toBe(1);
        });
        it("should return user ID from valid token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockJwtVerify.mockResolvedValue({
                payload: {
                    sub: "123"
                }
            });
            const result = await (0, _auth.getUserIdFromToken)(req);
            expect(result).toBe(123);
        });
        it("should return null for invalid token payload", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer invalid-token")
                }
            };
            mockJwtVerify.mockResolvedValue({
                payload: null
            });
            const result = await (0, _auth.getUserIdFromToken)(req);
            expect(result).toBeNull();
        });
    });
    describe("getShopIdFromToken", ()=>{
        it("should return null for missing token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBeNull();
        });
        it("should return default shop ID for dev-token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer dev-token")
                }
            };
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBe("cmbtr9q6l000061romoxi7uvf");
        });
        it("should return shop ID from valid token", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockJwtVerify.mockResolvedValue({
                payload: {
                    sub: "1",
                    shopId: "shop123"
                }
            });
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBe("shop123");
        });
        it("should return null for token without shopId", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer no-shop-token")
                }
            };
            mockJwtVerify.mockResolvedValue({
                payload: {
                    sub: "1"
                }
            });
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBeNull();
        });
        it("should convert numeric shopId to string", async ()=>{
            const req = {
                headers: {
                    get: jest.fn().mockReturnValue("Bearer valid-token")
                }
            };
            mockJwtVerify.mockResolvedValue({
                payload: {
                    sub: "1",
                    shopId: 123
                }
            });
            const result = await (0, _auth.getShopIdFromToken)(req);
            expect(result).toBe("123");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9hdXRoLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2V0IHVwIGVudmlyb25tZW50IHZhcmlhYmxlcyBiZWZvcmUgYW55IGltcG9ydHNcbnByb2Nlc3MuZW52LkpXVF9TRUNSRVQgPSAndGVzdC1zZWNyZXQta2V5LWZvci10ZXN0aW5nJztcbnByb2Nlc3MuZW52Lk5FWFRBVVRIX1NFQ1JFVCA9ICd0ZXN0LW5leHRhdXRoLXNlY3JldCc7XG5cbi8vIE1vY2sgam9zZSBsaWJyYXJ5XG5jb25zdCBtb2NrSnd0VmVyaWZ5ID0gamVzdC5mbigpO1xuamVzdC5tb2NrKCdqb3NlJywgKCkgPT4gKHtcbiAgand0VmVyaWZ5OiBtb2NrSnd0VmVyaWZ5LFxufSkpO1xuXG4vLyBNb2NrIHByaXNtYVxuY29uc3QgbW9ja1ByaXNtYSA9IHtcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSxcbiAgfSxcbn07XG5qZXN0Lm1vY2soJ0AvbGliL3ByaXNtYScsICgpID0+ICh7XG4gIF9fZXNNb2R1bGU6IHRydWUsXG4gIGRlZmF1bHQ6IG1vY2tQcmlzbWEsXG59KSk7XG5cbmltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgdmVyaWZ5VG9rZW4sIGV4dHJhY3RUb2tlbiwgdmFsaWRhdGVUb2tlblBlcm1pc3Npb24sIGdldFVzZXJJZEZyb21Ub2tlbiwgZ2V0U2hvcElkRnJvbVRva2VuIH0gZnJvbSAnQC9saWIvYXV0aCc7XG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBjb25zb2xlU3B5ID0ge1xuICBsb2c6IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIGVycm9yOiBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG59O1xuXG5kZXNjcmliZSgnQXV0aCBVdGlsaXR5IEZ1bmN0aW9ucycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgY29uc29sZVNweS5sb2cubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS5lcnJvci5tb2NrQ2xlYXIoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJBbGwoKCkgPT4ge1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS5lcnJvci5tb2NrUmVzdG9yZSgpO1xuICB9KTtcblxuICBkZXNjcmliZSgndmVyaWZ5VG9rZW4nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2ZXJpZnkgdmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUGF5bG9hZCA9IHsgc3ViOiAnMScsIHBlcm1pc3Npb25zOiBbJ3JlYWQnXSB9O1xuICAgICAgbW9ja0p3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHBheWxvYWQ6IG1vY2tQYXlsb2FkIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbigndmFsaWQtdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1BheWxvYWQpO1xuICAgICAgZXhwZWN0KG1vY2tKd3RWZXJpZnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAndmFsaWQtdG9rZW4nLFxuICAgICAgICBleHBlY3QuYW55KFVpbnQ4QXJyYXkpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXhwaXJlZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUb2tlbiBleHBpcmVkJyk7XG4gICAgICAoZXJyb3IgYXMgYW55KS5jb2RlID0gJ0VSUl9KV1RfRVhQSVJFRCc7XG4gICAgICBtb2NrSnd0VmVyaWZ5Lm1vY2tSZWplY3RlZFZhbHVlKGVycm9yKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJ2V4cGlyZWQtdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ1Rva2VuIGV4cGlyZWQ6JywgJ1Rva2VuIGV4cGlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgdG9rZW4gc2lnbmF0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICAoZXJyb3IgYXMgYW55KS5jb2RlID0gJ0VSUl9KV1NfU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMRUQnO1xuICAgICAgbW9ja0p3dFZlcmlmeS5tb2NrUmVqZWN0ZWRWYWx1ZShlcnJvcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCdpbnZhbGlkLXRva2VuJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdJbnZhbGlkIHRva2VuOicsICdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgb3RoZXIgdmVyaWZpY2F0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdVbmtub3duIGVycm9yJyk7XG4gICAgICAoZXJyb3IgYXMgYW55KS5jb2RlID0gJ0VSUl9VTktOT1dOJztcbiAgICAgIG1vY2tKd3RWZXJpZnkubW9ja1JlamVjdGVkVmFsdWUoZXJyb3IpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbignZXJyb3ItdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ1Rva2VuIHZlcmlmaWNhdGlvbiBlcnJvcjonLCAnVW5rbm93biBlcnJvcicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXh0cmFjdFRva2VuJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZXh0cmFjdCB0b2tlbiBmcm9tIHZhbGlkIGF1dGhvcml6YXRpb24gaGVhZGVyJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgdmFsaWQtdG9rZW4tMTIzJylcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBleHRyYWN0VG9rZW4ocmVxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ3ZhbGlkLXRva2VuLTEyMycpO1xuICAgICAgZXhwZWN0KHJlcS5oZWFkZXJzLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2F1dGhvcml6YXRpb24nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG1pc3NpbmcgYXV0aG9yaXphdGlvbiBoZWFkZXInLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobnVsbClcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBleHRyYWN0VG9rZW4ocmVxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBpbnZhbGlkIGF1dGhvcml6YXRpb24gaGVhZGVyIGZvcm1hdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnSW52YWxpZCB0b2tlbi0xMjMnKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4dHJhY3RUb2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGVtcHR5IGF1dGhvcml6YXRpb24gaGVhZGVyJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCcnKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4dHJhY3RUb2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3ZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGludmFsaWQgZm9yIG1pc3NpbmcgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobnVsbClcbiAgICAgICAgfVxuICAgICAgfSBhcyB1bmtub3duIGFzIE5leHRSZXF1ZXN0O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVRva2VuUGVybWlzc2lvbihyZXEsICdyZWFkJyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCdcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBncmFudCBwZXJtaXNzaW9uIGZvciBkZXYtdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0JlYXJlciBkZXYtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uKHJlcSwgJ3JlYWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBpc1ZhbGlkOiB0cnVlIH0pO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkubG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIkRldmVsb3BtZW50IG1vZGU6IGdyYW50aW5nIHBlcm1pc3Npb24gJ3JlYWQnXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gaW52YWxpZCBmb3IgaW52YWxpZCB0b2tlbiBwYXlsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgaW52YWxpZC10b2tlbicpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgbW9ja0p3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHBheWxvYWQ6IG51bGwgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uKHJlcSwgJ3JlYWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgYXV0aGVudGljYXRpb24gdG9rZW4nXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ3JhbnQgcGVybWlzc2lvbiBmcm9tIHRva2VuIHBheWxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0JlYXJlciB2YWxpZC10b2tlbicpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgbW9ja0p3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHBheWxvYWQ6IHsgc3ViOiAnMScsIHBlcm1pc3Npb25zOiBbJ3JlYWQnLCAnd3JpdGUnXSB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVUb2tlblBlcm1pc3Npb24ocmVxLCAncmVhZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IGlzVmFsaWQ6IHRydWUgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZhbGxiYWNrIHRvIGRhdGFiYXNlIHdoZW4gcGVybWlzc2lvbiBub3QgaW4gdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0JlYXJlciB2YWxpZC10b2tlbicpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgbW9ja0p3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHBheWxvYWQ6IHsgc3ViOiAnMScsIHBlcm1pc3Npb25zOiBbJ3dyaXRlJ10gfVxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWQnLCAnd3JpdGUnXVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uKHJlcSwgJ3JlYWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBpc1ZhbGlkOiB0cnVlIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gaW52YWxpZCBmb3IgdXNlciBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0JlYXJlciB2YWxpZC10b2tlbicpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgbW9ja0p3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHBheWxvYWQ6IHsgc3ViOiAnOTk5JyB9XG4gICAgICB9KTtcblxuICAgICAgbW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlVG9rZW5QZXJtaXNzaW9uKHJlcSwgJ3JlYWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogJ1VzZXIgbm90IGZvdW5kJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRVc2VySWRGcm9tVG9rZW4nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgbWlzc2luZyB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShudWxsKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDEgZm9yIGRldi10b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIGRldi10b2tlbicpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlcklkRnJvbVRva2VuKHJlcSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdXNlciBJRCBmcm9tIHZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgdmFsaWQtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tKd3RWZXJpZnkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBwYXlsb2FkOiB7IHN1YjogJzEyMycgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgxMjMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgaW52YWxpZCB0b2tlbiBwYXlsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgaW52YWxpZC10b2tlbicpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgbW9ja0p3dFZlcmlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHBheWxvYWQ6IG51bGwgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFNob3BJZEZyb21Ub2tlbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBtaXNzaW5nIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG51bGwpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgdW5rbm93biBhcyBOZXh0UmVxdWVzdDtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0U2hvcElkRnJvbVRva2VuKHJlcSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZGVmYXVsdCBzaG9wIElEIGZvciBkZXYtdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXEgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ0JlYXJlciBkZXYtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFNob3BJZEZyb21Ub2tlbihyZXEpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgnY21idHI5cTZsMDAwMDYxcm9tb3hpN3V2ZicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc2hvcCBJRCBmcm9tIHZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgdmFsaWQtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tKd3RWZXJpZnkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBwYXlsb2FkOiB7IHN1YjogJzEnLCBzaG9wSWQ6ICdzaG9wMTIzJyB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0U2hvcElkRnJvbVRva2VuKHJlcSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdzaG9wMTIzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciB0b2tlbiB3aXRob3V0IHNob3BJZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnQmVhcmVyIG5vLXNob3AtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tKd3RWZXJpZnkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBwYXlsb2FkOiB7IHN1YjogJzEnIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRTaG9wSWRGcm9tVG9rZW4ocmVxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgbnVtZXJpYyBzaG9wSWQgdG8gc3RyaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdCZWFyZXIgdmFsaWQtdG9rZW4nKVxuICAgICAgICB9XG4gICAgICB9IGFzIHVua25vd24gYXMgTmV4dFJlcXVlc3Q7XG5cbiAgICAgIG1vY2tKd3RWZXJpZnkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBwYXlsb2FkOiB7IHN1YjogJzEnLCBzaG9wSWQ6IDEyMyB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0U2hvcElkRnJvbVRva2VuKHJlcSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCcxMjMnKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJqd3RWZXJpZnkiLCJtb2NrSnd0VmVyaWZ5IiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJtb2NrUHJpc21hIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJORVhUQVVUSF9TRUNSRVQiLCJmbiIsInVzZXIiLCJmaW5kVW5pcXVlIiwiY29uc29sZVNweSIsImxvZyIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImVycm9yIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsImFmdGVyQWxsIiwibW9ja1Jlc3RvcmUiLCJpdCIsIm1vY2tQYXlsb2FkIiwic3ViIiwicGVybWlzc2lvbnMiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInBheWxvYWQiLCJyZXN1bHQiLCJ2ZXJpZnlUb2tlbiIsImV4cGVjdCIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImFueSIsIlVpbnQ4QXJyYXkiLCJFcnJvciIsImNvZGUiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsInRvQmVOdWxsIiwicmVxIiwiaGVhZGVycyIsImdldCIsIm1vY2tSZXR1cm5WYWx1ZSIsImV4dHJhY3RUb2tlbiIsInRvQmUiLCJ2YWxpZGF0ZVRva2VuUGVybWlzc2lvbiIsImlzVmFsaWQiLCJtZXNzYWdlIiwiaWQiLCJnZXRVc2VySWRGcm9tVG9rZW4iLCJnZXRTaG9wSWRGcm9tVG9rZW4iLCJzaG9wSWQiXSwibWFwcGluZ3MiOiJBQUFBLGtEQUFrRDs7QUFNbERBLEtBQUtDLElBQUksQ0FBQyxRQUFRLElBQU8sQ0FBQTtRQUN2QkMsV0FBV0M7SUFDYixDQUFBO0FBUUFILEtBQUtDLElBQUksQ0FBQyxnQkFBZ0IsSUFBTyxDQUFBO1FBQy9CRyxZQUFZO1FBQ1pDLFNBQVNDO0lBQ1gsQ0FBQTs7OztzQkFHMkc7QUFyQjNHQyxRQUFRQyxHQUFHLENBQUNDLFVBQVUsR0FBRztBQUN6QkYsUUFBUUMsR0FBRyxDQUFDRSxlQUFlLEdBQUc7QUFFOUIsb0JBQW9CO0FBQ3BCLE1BQU1QLGdCQUFnQkgsS0FBS1csRUFBRTtBQUs3QixjQUFjO0FBQ2QsTUFBTUwsYUFBYTtJQUNqQk0sTUFBTTtRQUNKQyxZQUFZYixLQUFLVyxFQUFFO0lBQ3JCO0FBQ0Y7QUFTQSx1QkFBdUI7QUFDdkIsTUFBTUcsYUFBYTtJQUNqQkMsS0FBS2YsS0FBS2dCLEtBQUssQ0FBQ0MsU0FBUyxPQUFPQyxrQkFBa0IsQ0FBQyxLQUFPO0lBQzFEQyxP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