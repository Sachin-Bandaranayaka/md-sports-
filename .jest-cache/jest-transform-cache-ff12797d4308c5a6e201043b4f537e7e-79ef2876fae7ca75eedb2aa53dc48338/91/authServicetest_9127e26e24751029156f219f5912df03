f39c6bd96506a9e8495af6b1473393f4
// Fixed Unit tests for AuthService
// This file tests the authentication service functionality
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _authService = /*#__PURE__*/ _interop_require_wildcard(require("../../src/services/authService"));
const _jsonwebtoken = /*#__PURE__*/ _interop_require_wildcard(require("jsonwebtoken"));
const _cache = require("../../src/lib/cache");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock dependencies BEFORE importing the service
const mockCacheService = {
    get: _globals.jest.fn(),
    set: _globals.jest.fn(),
    delete: _globals.jest.fn(),
    increment: _globals.jest.fn(),
    generateKey: _globals.jest.fn(),
    clear: _globals.jest.fn()
};
const mockPrisma = {
    user: {
        findUnique: _globals.jest.fn(),
        findFirst: _globals.jest.fn(),
        create: _globals.jest.fn(),
        update: _globals.jest.fn(),
        findMany: _globals.jest.fn(),
        delete: _globals.jest.fn()
    },
    permission: {
        findMany: _globals.jest.fn()
    },
    session: {
        create: _globals.jest.fn(),
        findUnique: _globals.jest.fn(),
        update: _globals.jest.fn(),
        deleteMany: _globals.jest.fn()
    },
    auditLog: {
        create: _globals.jest.fn()
    }
};
const mockBcrypt = {
    compare: _globals.jest.fn(),
    hash: _globals.jest.fn(),
    genSalt: _globals.jest.fn()
};
// Mock modules
_globals.jest.mock("@/lib/prisma", ()=>({
        __esModule: true,
        default: mockPrisma
    }));
_globals.jest.mock("@/lib/cache", ()=>({
        __esModule: true,
        cacheService: mockCacheService,
        cache: mockCacheService,
        CACHE_CONFIG: {
            KEYS: {
                USER_SESSION: "user_session",
                TOKEN_VALIDATION: "token_validation"
            },
            TTL: {
                USER_SESSION: 3600,
                TOKEN_VALIDATION: 1800
            }
        }
    }));
_globals.jest.mock("bcryptjs", ()=>mockBcrypt);
// Mock jsonwebtoken with a simple approach
const mockJwt = {
    sign: _globals.jest.fn(),
    verify: _globals.jest.fn(),
    decode: _globals.jest.fn(),
    TokenExpiredError: class extends Error {
        constructor(message, expiredAt){
            super(message);
            this.name = "TokenExpiredError";
            this.expiredAt = expiredAt || new Date();
        }
    },
    JsonWebTokenError: class extends Error {
        constructor(message){
            super(message);
            this.name = "JsonWebTokenError";
        }
    }
};
_globals.jest.mock("jsonwebtoken", ()=>mockJwt);
// Spy on the imported jwt to ensure our mocks work
const jwtVerifySpy = _globals.jest.spyOn(_jsonwebtoken, "verify");
const jwtSignSpy = _globals.jest.spyOn(_jsonwebtoken, "sign");
// Spy on the actual cacheService to verify mocking
const cacheServiceGenerateKeySpy = _globals.jest.spyOn(_cache.cacheService, "generateKey");
const cacheServiceGetSpy = _globals.jest.spyOn(_cache.cacheService, "get");
const cacheServiceSetSpy = _globals.jest.spyOn(_cache.cacheService, "set");
// Spy on executeWithRetry to bypass the retry logic in tests
const executeWithRetrySpy = _globals.jest.spyOn(_authService, "executeWithRetry").mockImplementation((operation)=>operation());
// Create proper mock types for easier access
const mockUserFindFirst = mockPrisma.user.findFirst;
const mockPermissionFindMany = mockPrisma.permission.findMany;
// mockJwt is already defined above
describe("AuthService", ()=>{
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        process.env.JWT_SECRET = "test-secret-key";
        process.env.JWT_ACCESS_TOKEN_EXPIRES_IN = "12h";
        // Setup default cache mocks
        mockCacheService.generateKey.mockReturnValue("mock-cache-key");
        mockCacheService.get.mockResolvedValue(null);
        mockCacheService.set.mockResolvedValue(true);
        mockCacheService.delete.mockResolvedValue(true);
        // Reset Prisma mocks
        mockUserFindFirst.mockResolvedValue(null);
        mockPermissionFindMany.mockResolvedValue([]);
        // Reset JWT mocks
        mockJwt.sign.mockReturnValue("mocked-jwt-token");
        mockJwt.verify.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
        mockJwt.decode.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
        jwtVerifySpy.mockClear();
        jwtSignSpy.mockClear();
    });
    describe("parseTimeStringToSeconds", ()=>{
        test("should parse seconds correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("30s")).toBe(30);
        });
        test("should parse minutes correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("5m")).toBe(300);
        });
        test("should parse hours correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("2h")).toBe(7200);
        });
        test("should parse days correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("1d")).toBe(86400);
        });
        test("should return 0 for invalid input", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("invalid")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("abc")).toBe(0);
        });
        test("should handle edge cases", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("0s")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("100x")).toBe(100); // Falls back to parsing the number part
        });
    });
    describe("authenticateUser", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            password: "hashedpassword",
            isActive: true,
            roleId: 1,
            shopId: 1,
            roleName: "admin",
            permissions: null,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should authenticate valid user credentials", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(true);
            mockJwt.sign.mockReturnValue("mock-jwt-token");
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(true);
            expect(result.token).toBe("mock-jwt-token");
            expect(result.user).toEqual({
                id: 1,
                email: "test@example.com",
                username: "testuser",
                fullName: "testuser",
                roleId: 1,
                roleName: "admin",
                shopId: 1,
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockUserFindFirst).toHaveBeenCalledWith({
                where: {
                    email: "test@example.com",
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            });
        });
        test("should reject invalid email", async ()=>{
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.authenticateUser)("invalid@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject invalid password", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(false);
            const result = await (0, _authService.authenticateUser)("test@example.com", "wrongpassword");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject inactive user", async ()=>{
            mockUserFindFirst.mockResolvedValue(null); // findFirst with isActive: true returns null
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should handle database errors gracefully", async ()=>{
            mockUserFindFirst.mockRejectedValue(new Error("Database connection failed"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
        test("should handle bcrypt errors gracefully", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockRejectedValue(new Error("Bcrypt error"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
    });
    describe("generateToken", ()=>{
        const mockPayload = {
            sub: 1,
            username: "testuser",
            email: "test@example.com",
            roleId: 1,
            shopId: 1,
            permissions: [
                "read_products",
                "write_products"
            ]
        };
        test("should generate JWT token", ()=>{
            const mockToken = "mock-jwt-token";
            mockJwt.sign.mockReturnValue(mockToken);
            const result = (0, _authService.generateToken)(mockPayload);
            expect(result).toBe(mockToken);
            expect(mockJwt.sign).toHaveBeenCalledWith(mockPayload, "test-secret-key", {
                expiresIn: "12h"
            });
        });
    });
    describe("verifyToken", ()=>{
        test("should verify valid token from cache", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should verify valid token and cache result", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockJwt.verify.mockReturnValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockJwt.verify).toHaveBeenCalledWith("valid-token", "test-secret-key");
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            const invalidError = new Error("Invalid token");
            mockJwt.verify.mockImplementation(()=>{
                throw invalidError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw invalidError;
            });
            await expect((0, _authService.verifyToken)("invalid-token")).rejects.toThrow("Invalid token");
        });
        test("should throw error for expired token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            const expiredError = new mockJwt.TokenExpiredError("Token expired", new Date());
            mockJwt.verify.mockImplementation(()=>{
                throw expiredError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw expiredError;
            });
            await expect((0, _authService.verifyToken)("expired-token")).rejects.toThrow("Token expired");
        });
    });
    describe("getUserFromDecodedPayload", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            isActive: true,
            roleId: 1,
            shopId: 1,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should return user from cache", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const cachedUser = {
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            };
            mockCacheService.get.mockResolvedValue(cachedUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual(cachedUser);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should return user from database and cache it", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            // Mock the findFirst call to return the user when called with the correct parameters
            mockUserFindFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should return null for null payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)(null);
            expect(result).toBeNull();
        });
        test("should return null for invalid payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)({});
            expect(result).toBeNull();
        });
        test("should return null when user not found", async ()=>{
            const payload = {
                sub: 999,
                username: "nonexistent",
                email: "nonexistent@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null);
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toBeNull();
        });
    });
    describe("getUserFromToken", ()=>{
        test("should return user from valid token", async ()=>{
            const mockPayload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const mockUser = {
                id: 1,
                email: "test@example.com",
                name: "testuser",
                isActive: true,
                roleId: 1,
                shopId: 1,
                role: {
                    id: 1,
                    name: "admin",
                    permissions: [
                        {
                            name: "read_products"
                        }
                    ]
                }
            };
            // Mock verifyToken to return payload
            mockCacheService.get.mockResolvedValue(null); // Cache miss for user lookup
            mockCacheService.generateKey.mockReturnValue("test-cache-key");
            mockCacheService.set.mockResolvedValue(undefined);
            mockJwt.verify.mockReturnValue(mockPayload);
            jwtVerifySpy.mockReturnValue(mockPayload);
            // Mock the findFirst call to return the user
            mockUserFindFirst.mockResolvedValue(mockUser);
            // Set up spies to return expected values
            cacheServiceGenerateKeySpy.mockReturnValue("test-cache-key");
            cacheServiceGetSpy.mockResolvedValue(null);
            cacheServiceSetSpy.mockResolvedValue(undefined);
            // Reset cache mock to ensure it always returns null (cache miss)
            mockCacheService.get.mockResolvedValue(null);
            // Test verifyToken separately first
            const verifyResult = await (0, _authService.verifyToken)("valid-token");
            expect(verifyResult).toBeDefined();
            expect(verifyResult).toHaveProperty("sub", 1);
            // Test getUserFromDecodedPayload separately
            // First verify the function exists
            expect(typeof _authService.getUserFromDecodedPayload).toBe("function");
            // Test with null payload first to see if we get the expected error path
            const nullResult = await (0, _authService.getUserFromDecodedPayload)(null);
            expect(nullResult).toBeNull();
            // Test with payload missing sub
            const noSubResult = await (0, _authService.getUserFromDecodedPayload)({
                username: "test"
            });
            expect(noSubResult).toBeNull();
            // Test with mockPayload
            const decodedResult = await (0, _authService.getUserFromDecodedPayload)(mockPayload);
            // Check if the actual cacheService methods are being called
            expect(cacheServiceGenerateKeySpy).toHaveBeenCalledWith("user_session", {
                userId: 1
            });
            expect(cacheServiceGetSpy).toHaveBeenCalled();
            expect(decodedResult).toBeDefined();
            expect(decodedResult).not.toBeNull();
            // Now test the full flow
            const result = await (0, _authService.getUserFromToken)("valid-token");
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products"
                ]
            });
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockCacheService.generateKey.mockReturnValue("test-cache-key");
            // Mock both the direct mock and the spy
            const jwtError = new mockJwt.JsonWebTokenError("jwt malformed");
            mockJwt.verify.mockImplementation(()=>{
                throw jwtError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw jwtError;
            });
            await expect((0, _authService.getUserFromToken)("invalid")).rejects.toThrow("jwt malformed");
        });
    });
    describe("Error Handling", ()=>{
        test("should handle missing JWT_SECRET", async ()=>{
            const originalSecret = process.env.JWT_SECRET;
            delete process.env.JWT_SECRET;
            mockCacheService.get.mockResolvedValue(null);
            const secretError = new Error("secretOrPrivateKey must have a value");
            mockJwt.verify.mockImplementation(()=>{
                throw secretError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw secretError;
            });
            await expect((0, _authService.verifyToken)("any-token")).rejects.toThrow();
            // Restore the secret
            process.env.JWT_SECRET = originalSecret;
        });
        test("should handle malformed tokens gracefully", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            // Mock both the direct mock and the spy
            const jwtError = new mockJwt.JsonWebTokenError("jwt malformed");
            mockJwt.verify.mockImplementation(()=>{
                throw jwtError;
            });
            jwtVerifySpy.mockImplementation(()=>{
                throw jwtError;
            });
            await expect((0, _authService.verifyToken)("malformed-token")).rejects.toThrow("jwt malformed");
        });
        test("should handle empty token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            await expect((0, _authService.verifyToken)("")).rejects.toThrow("jwt must be provided");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9hdXRoU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpeGVkIFVuaXQgdGVzdHMgZm9yIEF1dGhTZXJ2aWNlXG4vLyBUaGlzIGZpbGUgdGVzdHMgdGhlIGF1dGhlbnRpY2F0aW9uIHNlcnZpY2UgZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzIEJFRk9SRSBpbXBvcnRpbmcgdGhlIHNlcnZpY2VcbmNvbnN0IG1vY2tDYWNoZVNlcnZpY2UgPSB7XG4gIGdldDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgc2V0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBkZWxldGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGluY3JlbWVudDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgZ2VuZXJhdGVLZXk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGNsZWFyOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxufTtcblxuY29uc3QgbW9ja1ByaXNtYSA9IHtcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZEZpcnN0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICAgIGNyZWF0ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICB9LFxuICBwZXJtaXNzaW9uOiB7XG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG4gIHNlc3Npb246IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlTWFueTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgfSxcbiAgYXVkaXRMb2c6IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG59O1xuXG5jb25zdCBtb2NrQmNyeXB0ID0ge1xuICBjb21wYXJlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBoYXNoOiBqZXN0LmZuKCksXG4gIGdlblNhbHQ6IGplc3QuZm4oKSxcbn07XG5cbi8vIE1vY2sgbW9kdWxlc1xuamVzdC5tb2NrKCdAL2xpYi9wcmlzbWEnLCAoKSA9PiAoe1xuICBfX2VzTW9kdWxlOiB0cnVlLFxuICBkZWZhdWx0OiBtb2NrUHJpc21hLFxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvbGliL2NhY2hlJywgKCkgPT4gKHtcbiAgX19lc01vZHVsZTogdHJ1ZSxcbiAgY2FjaGVTZXJ2aWNlOiBtb2NrQ2FjaGVTZXJ2aWNlLFxuICBjYWNoZTogbW9ja0NhY2hlU2VydmljZSxcbiAgQ0FDSEVfQ09ORklHOiB7XG4gICAgS0VZUzoge1xuICAgICAgVVNFUl9TRVNTSU9OOiAndXNlcl9zZXNzaW9uJyxcbiAgICAgIFRPS0VOX1ZBTElEQVRJT046ICd0b2tlbl92YWxpZGF0aW9uJyxcbiAgICB9LFxuICAgIFRUTDoge1xuICAgICAgVVNFUl9TRVNTSU9OOiAzNjAwLFxuICAgICAgVE9LRU5fVkFMSURBVElPTjogMTgwMCxcbiAgICB9LFxuICB9LFxufSkpO1xuXG5qZXN0Lm1vY2soJ2JjcnlwdGpzJywgKCkgPT4gbW9ja0JjcnlwdCk7XG4vLyBNb2NrIGpzb253ZWJ0b2tlbiB3aXRoIGEgc2ltcGxlIGFwcHJvYWNoXG5jb25zdCBtb2NrSnd0ID0ge1xuICBzaWduOiBqZXN0LmZuKCksXG4gIHZlcmlmeTogamVzdC5mbigpLFxuICBkZWNvZGU6IGplc3QuZm4oKSxcbiAgVG9rZW5FeHBpcmVkRXJyb3I6IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgIGV4cGlyZWRBdDogRGF0ZTtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGV4cGlyZWRBdD86IERhdGUpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuRXhwaXJlZEVycm9yJztcbiAgICAgIHRoaXMuZXhwaXJlZEF0ID0gZXhwaXJlZEF0IHx8IG5ldyBEYXRlKCk7XG4gICAgfVxuICB9LFxuICBKc29uV2ViVG9rZW5FcnJvcjogY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIHRoaXMubmFtZSA9ICdKc29uV2ViVG9rZW5FcnJvcic7XG4gICAgfVxuICB9LFxufTtcblxuamVzdC5tb2NrKCdqc29ud2VidG9rZW4nLCAoKSA9PiBtb2NrSnd0KTtcblxuLy8gSW1wb3J0IGFmdGVyIG1vY2tpbmdcbmltcG9ydCB7IGF1dGhlbnRpY2F0ZVVzZXIsIGdlbmVyYXRlVG9rZW4sIHZlcmlmeVRva2VuLCBwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMsIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQsIGdldFVzZXJGcm9tVG9rZW4gfSBmcm9tICdAL3NlcnZpY2VzL2F1dGhTZXJ2aWNlJztcbmltcG9ydCAqIGFzIGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuaW1wb3J0IHsgY2FjaGVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvY2FjaGUnO1xuXG4vLyBJbXBvcnQgdGhlIGV4ZWN1dGVXaXRoUmV0cnkgZnVuY3Rpb24gdG8gc3B5IG9uIGl0XG5pbXBvcnQgKiBhcyBhdXRoU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL2F1dGhTZXJ2aWNlJztcblxuLy8gU3B5IG9uIHRoZSBpbXBvcnRlZCBqd3QgdG8gZW5zdXJlIG91ciBtb2NrcyB3b3JrXG5jb25zdCBqd3RWZXJpZnlTcHkgPSBqZXN0LnNweU9uKGp3dCwgJ3ZlcmlmeScpO1xuY29uc3Qgand0U2lnblNweSA9IGplc3Quc3B5T24oand0LCAnc2lnbicpO1xuXG4vLyBTcHkgb24gdGhlIGFjdHVhbCBjYWNoZVNlcnZpY2UgdG8gdmVyaWZ5IG1vY2tpbmdcbmNvbnN0IGNhY2hlU2VydmljZUdlbmVyYXRlS2V5U3B5ID0gamVzdC5zcHlPbihjYWNoZVNlcnZpY2UsICdnZW5lcmF0ZUtleScpO1xuY29uc3QgY2FjaGVTZXJ2aWNlR2V0U3B5ID0gamVzdC5zcHlPbihjYWNoZVNlcnZpY2UsICdnZXQnKTtcbmNvbnN0IGNhY2hlU2VydmljZVNldFNweSA9IGplc3Quc3B5T24oY2FjaGVTZXJ2aWNlLCAnc2V0Jyk7XG5cbi8vIFNweSBvbiBleGVjdXRlV2l0aFJldHJ5IHRvIGJ5cGFzcyB0aGUgcmV0cnkgbG9naWMgaW4gdGVzdHNcbmNvbnN0IGV4ZWN1dGVXaXRoUmV0cnlTcHkgPSBqZXN0LnNweU9uKGF1dGhTZXJ2aWNlIGFzIGFueSwgJ2V4ZWN1dGVXaXRoUmV0cnknKS5tb2NrSW1wbGVtZW50YXRpb24oKG9wZXJhdGlvbikgPT4gb3BlcmF0aW9uKCkpO1xuXG4vLyBDcmVhdGUgcHJvcGVyIG1vY2sgdHlwZXMgZm9yIGVhc2llciBhY2Nlc3NcbmNvbnN0IG1vY2tVc2VyRmluZEZpcnN0ID0gbW9ja1ByaXNtYS51c2VyLmZpbmRGaXJzdCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG5jb25zdCBtb2NrUGVybWlzc2lvbkZpbmRNYW55ID0gbW9ja1ByaXNtYS5wZXJtaXNzaW9uLmZpbmRNYW55IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55Pjtcbi8vIG1vY2tKd3QgaXMgYWxyZWFkeSBkZWZpbmVkIGFib3ZlXG5cbmRlc2NyaWJlKCdBdXRoU2VydmljZScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCA9ICd0ZXN0LXNlY3JldC1rZXknO1xuICAgIHByb2Nlc3MuZW52LkpXVF9BQ0NFU1NfVE9LRU5fRVhQSVJFU19JTiA9ICcxMmgnO1xuICAgIFxuICAgIC8vIFNldHVwIGRlZmF1bHQgY2FjaGUgbW9ja3NcbiAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5Lm1vY2tSZXR1cm5WYWx1ZSgnbW9jay1jYWNoZS1rZXknKTtcbiAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICBtb2NrQ2FjaGVTZXJ2aWNlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgICBtb2NrQ2FjaGVTZXJ2aWNlLmRlbGV0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgICBcbiAgICAvLyBSZXNldCBQcmlzbWEgbW9ja3NcbiAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICBtb2NrUGVybWlzc2lvbkZpbmRNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcbiAgICBcbiAgICAvLyBSZXNldCBKV1QgbW9ja3NcbiAgICBtb2NrSnd0LnNpZ24ubW9ja1JldHVyblZhbHVlKCdtb2NrZWQtand0LXRva2VuJyk7XG4gICAgbW9ja0p3dC52ZXJpZnkubW9ja1JldHVyblZhbHVlKHsgdXNlcklkOiAxLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0pO1xuICAgIG1vY2tKd3QuZGVjb2RlLm1vY2tSZXR1cm5WYWx1ZSh7IHVzZXJJZDogMSwgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9KTtcbiAgICBqd3RWZXJpZnlTcHkubW9ja0NsZWFyKCk7XG4gICAgand0U2lnblNweS5tb2NrQ2xlYXIoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3BhcnNlVGltZVN0cmluZ1RvU2Vjb25kcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcGFyc2Ugc2Vjb25kcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCczMHMnKSkudG9CZSgzMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgbWludXRlcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCc1bScpKS50b0JlKDMwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgaG91cnMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMmgnKSkudG9CZSg3MjAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwYXJzZSBkYXlzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzFkJykpLnRvQmUoODY0MDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiAwIGZvciBpbnZhbGlkIGlucHV0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnJykpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCdpbnZhbGlkJykpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCdhYmMnKSkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZWRnZSBjYXNlcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzBzJykpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcxMDB4JykpLnRvQmUoMTAwKTsgLy8gRmFsbHMgYmFjayB0byBwYXJzaW5nIHRoZSBudW1iZXIgcGFydFxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnYXV0aGVudGljYXRlVXNlcicsICgpID0+IHtcbiAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgIGlkOiAxLFxuICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIG5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBwYXNzd29yZDogJ2hhc2hlZHBhc3N3b3JkJyxcbiAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgcm9sZUlkOiAxLFxuICAgICAgc2hvcElkOiAxLFxuICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICBwZXJtaXNzaW9uczogbnVsbCxcbiAgICAgIHJvbGU6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbXG4gICAgICAgICAgeyBuYW1lOiAncmVhZF9wcm9kdWN0cycgfSxcbiAgICAgICAgICB7IG5hbWU6ICd3cml0ZV9wcm9kdWN0cycgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhdXRoZW50aWNhdGUgdmFsaWQgdXNlciBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIG1vY2tCY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlIGFzIGFueSk7XG4gICAgICBtb2NrSnd0LnNpZ24ubW9ja1JldHVyblZhbHVlKCdtb2NrLWp3dC10b2tlbicgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnRva2VuKS50b0JlKCdtb2NrLWp3dC10b2tlbicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC51c2VyKS50b0VxdWFsKHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBmdWxsTmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgcm9sZUlkOiAxLFxuICAgICAgICByb2xlTmFtZTogJ2FkbWluJyxcbiAgICAgICAgc2hvcElkOiAxLFxuICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJywgJ3dyaXRlX3Byb2R1Y3RzJ11cbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KG1vY2tVc2VyRmluZEZpcnN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgcm9sZToge1xuICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICBwZXJtaXNzaW9uczoge1xuICAgICAgICAgICAgICAgIHNlbGVjdDogeyBuYW1lOiB0cnVlIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgZW1haWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcignaW52YWxpZEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgcGFzc3dvcmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgICBtb2NrQmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUoZmFsc2UgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICd3cm9uZ3Bhc3N3b3JkJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3QgaW5hY3RpdmUgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBmaW5kRmlyc3Qgd2l0aCBpc0FjdGl2ZTogdHJ1ZSByZXR1cm5zIG51bGxcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdBdXRoZW50aWNhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgYmNyeXB0IGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuICAgICAgbW9ja0JjcnlwdC5jb21wYXJlLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQmNyeXB0IGVycm9yJykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2VuZXJhdGVUb2tlbicsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUGF5bG9hZCA9IHtcbiAgICAgIHN1YjogMSxcbiAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIHJvbGVJZDogMSxcbiAgICAgIHNob3BJZDogMSxcbiAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgIH07XG5cbiAgICB0ZXN0KCdzaG91bGQgZ2VuZXJhdGUgSldUIHRva2VuJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Rva2VuID0gJ21vY2stand0LXRva2VuJztcbiAgICAgIG1vY2tKd3Quc2lnbi5tb2NrUmV0dXJuVmFsdWUobW9ja1Rva2VuKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZ2VuZXJhdGVUb2tlbihtb2NrUGF5bG9hZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUobW9ja1Rva2VuKTtcbiAgICAgIGV4cGVjdChtb2NrSnd0LnNpZ24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIG1vY2tQYXlsb2FkLFxuICAgICAgICAgICd0ZXN0LXNlY3JldC1rZXknLFxuICAgICAgICAgIHsgZXhwaXJlc0luOiAnMTJoJyB9XG4gICAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd2ZXJpZnlUb2tlbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdmVyaWZ5IHZhbGlkIHRva2VuIGZyb20gY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUGF5bG9hZCA9IHtcbiAgICAgICAgc3ViOiAnMScsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDEsXG4gICAgICAgIGlhdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgIGV4cDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAzNjAwXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUGF5bG9hZCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCd2YWxpZC10b2tlbicpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tQYXlsb2FkKTtcbiAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmdldCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHZlcmlmeSB2YWxpZCB0b2tlbiBhbmQgY2FjaGUgcmVzdWx0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICAgIHN1YjogJzEnLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxLFxuICAgICAgICBpYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICBleHA6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgMzYwMFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIE5vdCBpbiBjYWNoZVxuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja1JldHVyblZhbHVlKG1vY2tQYXlsb2FkIGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCd2YWxpZC10b2tlbicpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tQYXlsb2FkKTtcbiAgICAgIGV4cGVjdChtb2NrSnd0LnZlcmlmeSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3ZhbGlkLXRva2VuJywgJ3Rlc3Qtc2VjcmV0LWtleScpO1xuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2Uuc2V0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGludmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIGNvbnN0IGludmFsaWRFcnJvciA9IG5ldyBFcnJvcignSW52YWxpZCB0b2tlbicpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgaW52YWxpZEVycm9yO1xuICAgICAgfSk7XG4gICAgICBqd3RWZXJpZnlTcHkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgIHRocm93IGludmFsaWRFcnJvcjtcbiAgICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdpbnZhbGlkLXRva2VuJykpLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCB0b2tlbicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBleHBpcmVkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBjb25zdCBleHBpcmVkRXJyb3IgPSBuZXcgbW9ja0p3dC5Ub2tlbkV4cGlyZWRFcnJvcignVG9rZW4gZXhwaXJlZCcsIG5ldyBEYXRlKCkpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgZXhwaXJlZEVycm9yO1xuICAgICAgfSk7XG4gICAgICBqd3RWZXJpZnlTcHkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgIHRocm93IGV4cGlyZWRFcnJvcjtcbiAgICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdleHBpcmVkLXRva2VuJykpLnJlamVjdHMudG9UaHJvdygnVG9rZW4gZXhwaXJlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCcsICgpID0+IHtcbiAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgIGlkOiAxLFxuICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIG5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIHJvbGVJZDogMSxcbiAgICAgIHNob3BJZDogMSxcbiAgICAgIHJvbGU6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbXG4gICAgICAgICAgeyBuYW1lOiAncmVhZF9wcm9kdWN0cycgfSxcbiAgICAgICAgICB7IG5hbWU6ICd3cml0ZV9wcm9kdWN0cycgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgc3ViOiAxLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBjYWNoZWRVc2VyID0ge1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUoY2FjaGVkVXNlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoY2FjaGVkVXNlcik7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIGRhdGFiYXNlIGFuZCBjYWNoZSBpdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIE5vdCBpbiBjYWNoZVxuICAgICAgLy8gTW9jayB0aGUgZmluZEZpcnN0IGNhbGwgdG8gcmV0dXJuIHRoZSB1c2VyIHdoZW4gY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgcGFyYW1ldGVyc1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHBheWxvYWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgLi4ubW9ja1VzZXIsXG4gICAgICAgIHJvbGVOYW1lOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJywgJ3dyaXRlX3Byb2R1Y3RzJ11cbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2Uuc2V0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG51bGwgcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQobnVsbCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBpbnZhbGlkIHBheWxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHt9IGFzIGFueSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiBudWxsIHdoZW4gdXNlciBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBzdWI6IDk5OSxcbiAgICAgICAgdXNlcm5hbWU6ICdub25leGlzdGVudCcsXG4gICAgICAgIGVtYWlsOiAnbm9uZXhpc3RlbnRAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VXNlckZyb21Ub2tlbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIHVzZXIgZnJvbSB2YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgICBzdWI6IDEsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgc2hvcElkOiAxLFxuICAgICAgICByb2xlOiB7XG4gICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgbmFtZTogJ2FkbWluJyxcbiAgICAgICAgICBwZXJtaXNzaW9uczogW3sgbmFtZTogJ3JlYWRfcHJvZHVjdHMnIH1dXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgdmVyaWZ5VG9rZW4gdG8gcmV0dXJuIHBheWxvYWRcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBDYWNoZSBtaXNzIGZvciB1c2VyIGxvb2t1cFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZW5lcmF0ZUtleS5tb2NrUmV0dXJuVmFsdWUoJ3Rlc3QtY2FjaGUta2V5Jyk7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja1JldHVyblZhbHVlKG1vY2tQYXlsb2FkKTtcbiAgICAgIGp3dFZlcmlmeVNweS5tb2NrUmV0dXJuVmFsdWUobW9ja1BheWxvYWQgYXMgYW55KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayB0aGUgZmluZEZpcnN0IGNhbGwgdG8gcmV0dXJuIHRoZSB1c2VyXG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgICBcbiAgICAgIC8vIFNldCB1cCBzcGllcyB0byByZXR1cm4gZXhwZWN0ZWQgdmFsdWVzXG4gICAgICBjYWNoZVNlcnZpY2VHZW5lcmF0ZUtleVNweS5tb2NrUmV0dXJuVmFsdWUoJ3Rlc3QtY2FjaGUta2V5Jyk7XG4gICAgICBjYWNoZVNlcnZpY2VHZXRTcHkubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBjYWNoZVNlcnZpY2VTZXRTcHkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgLy8gUmVzZXQgY2FjaGUgbW9jayB0byBlbnN1cmUgaXQgYWx3YXlzIHJldHVybnMgbnVsbCAoY2FjaGUgbWlzcylcbiAgICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgLy8gVGVzdCB2ZXJpZnlUb2tlbiBzZXBhcmF0ZWx5IGZpcnN0XG4gICAgICAgY29uc3QgdmVyaWZ5UmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJ3ZhbGlkLXRva2VuJyk7XG4gICAgICAgZXhwZWN0KHZlcmlmeVJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgICBleHBlY3QodmVyaWZ5UmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgnc3ViJywgMSk7XG4gICAgICAgXG4gICAgICAgLy8gVGVzdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkIHNlcGFyYXRlbHlcbiAgICAgICAvLyBGaXJzdCB2ZXJpZnkgdGhlIGZ1bmN0aW9uIGV4aXN0c1xuICAgICAgIGV4cGVjdCh0eXBlb2YgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCkudG9CZSgnZnVuY3Rpb24nKTtcbiAgICAgICBcbiAgICAgICAvLyBUZXN0IHdpdGggbnVsbCBwYXlsb2FkIGZpcnN0IHRvIHNlZSBpZiB3ZSBnZXQgdGhlIGV4cGVjdGVkIGVycm9yIHBhdGhcbiAgICAgICBjb25zdCBudWxsUmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChudWxsKTtcbiAgICAgICBleHBlY3QobnVsbFJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgICBcbiAgICAgICAvLyBUZXN0IHdpdGggcGF5bG9hZCBtaXNzaW5nIHN1YlxuICAgICAgIGNvbnN0IG5vU3ViUmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCh7IHVzZXJuYW1lOiAndGVzdCcgfSBhcyBhbnkpO1xuICAgICAgIGV4cGVjdChub1N1YlJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgICBcbiAgICAgICAvLyBUZXN0IHdpdGggbW9ja1BheWxvYWRcbiAgICAgICBjb25zdCBkZWNvZGVkUmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChtb2NrUGF5bG9hZCk7XG4gICAgICAgXG4gICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFjdHVhbCBjYWNoZVNlcnZpY2UgbWV0aG9kcyBhcmUgYmVpbmcgY2FsbGVkXG4gICAgICAgZXhwZWN0KGNhY2hlU2VydmljZUdlbmVyYXRlS2V5U3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndXNlcl9zZXNzaW9uJywgeyB1c2VySWQ6IDEgfSk7XG4gICAgICAgZXhwZWN0KGNhY2hlU2VydmljZUdldFNweSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgIFxuICAgICAgIGV4cGVjdChkZWNvZGVkUmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgIGV4cGVjdChkZWNvZGVkUmVzdWx0KS5ub3QudG9CZU51bGwoKTtcbiAgICAgICBcbiAgICAgICAvLyBOb3cgdGVzdCB0aGUgZnVsbCBmbG93XG4gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21Ub2tlbigndmFsaWQtdG9rZW4nKTtcbiAgICAgICBcbiAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgIC4uLm1vY2tVc2VyLFxuICAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJ11cbiAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB0aHJvdyBlcnJvciBmb3IgaW52YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZW5lcmF0ZUtleS5tb2NrUmV0dXJuVmFsdWUoJ3Rlc3QtY2FjaGUta2V5Jyk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgYm90aCB0aGUgZGlyZWN0IG1vY2sgYW5kIHRoZSBzcHlcbiAgICAgIGNvbnN0IGp3dEVycm9yID0gbmV3IG1vY2tKd3QuSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IGp3dEVycm9yO1xuICAgICAgfSk7XG4gICAgICBqd3RWZXJpZnlTcHkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgIHRocm93IGp3dEVycm9yO1xuICAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QoZ2V0VXNlckZyb21Ub2tlbignaW52YWxpZCcpKS5yZWplY3RzLnRvVGhyb3coJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyBKV1RfU0VDUkVUJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxTZWNyZXQgPSBwcm9jZXNzLmVudi5KV1RfU0VDUkVUO1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQ7XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgY29uc3Qgc2VjcmV0RXJyb3IgPSBuZXcgRXJyb3IoJ3NlY3JldE9yUHJpdmF0ZUtleSBtdXN0IGhhdmUgYSB2YWx1ZScpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgc2VjcmV0RXJyb3I7XG4gICAgICB9KTtcbiAgICAgIGp3dFZlcmlmeVNweS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgdGhyb3cgc2VjcmV0RXJyb3I7XG4gICAgICAgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbignYW55LXRva2VuJykpLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIHRoZSBzZWNyZXRcbiAgICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgPSBvcmlnaW5hbFNlY3JldDtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWFsZm9ybWVkIHRva2VucyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgYm90aCB0aGUgZGlyZWN0IG1vY2sgYW5kIHRoZSBzcHlcbiAgICAgIGNvbnN0IGp3dEVycm9yID0gbmV3IG1vY2tKd3QuSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IGp3dEVycm9yO1xuICAgICAgfSk7XG4gICAgICBqd3RWZXJpZnlTcHkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgand0RXJyb3I7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdtYWxmb3JtZWQtdG9rZW4nKSkucmVqZWN0cy50b1Rocm93KCdqd3QgbWFsZm9ybWVkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbignJykpLnJlamVjdHMudG9UaHJvdygnand0IG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsibW9ja0NhY2hlU2VydmljZSIsImdldCIsImplc3QiLCJmbiIsInNldCIsImRlbGV0ZSIsImluY3JlbWVudCIsImdlbmVyYXRlS2V5IiwiY2xlYXIiLCJtb2NrUHJpc21hIiwidXNlciIsImZpbmRVbmlxdWUiLCJmaW5kRmlyc3QiLCJjcmVhdGUiLCJ1cGRhdGUiLCJmaW5kTWFueSIsInBlcm1pc3Npb24iLCJzZXNzaW9uIiwiZGVsZXRlTWFueSIsImF1ZGl0TG9nIiwibW9ja0JjcnlwdCIsImNvbXBhcmUiLCJoYXNoIiwiZ2VuU2FsdCIsIm1vY2siLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImNhY2hlU2VydmljZSIsImNhY2hlIiwiQ0FDSEVfQ09ORklHIiwiS0VZUyIsIlVTRVJfU0VTU0lPTiIsIlRPS0VOX1ZBTElEQVRJT04iLCJUVEwiLCJtb2NrSnd0Iiwic2lnbiIsInZlcmlmeSIsImRlY29kZSIsIlRva2VuRXhwaXJlZEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJleHBpcmVkQXQiLCJuYW1lIiwiRGF0ZSIsIkpzb25XZWJUb2tlbkVycm9yIiwiand0VmVyaWZ5U3B5Iiwic3B5T24iLCJqd3QiLCJqd3RTaWduU3B5IiwiY2FjaGVTZXJ2aWNlR2VuZXJhdGVLZXlTcHkiLCJjYWNoZVNlcnZpY2VHZXRTcHkiLCJjYWNoZVNlcnZpY2VTZXRTcHkiLCJleGVjdXRlV2l0aFJldHJ5U3B5IiwiYXV0aFNlcnZpY2UiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJvcGVyYXRpb24iLCJtb2NrVXNlckZpbmRGaXJzdCIsIm1vY2tQZXJtaXNzaW9uRmluZE1hbnkiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJKV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4iLCJtb2NrUmV0dXJuVmFsdWUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInVzZXJJZCIsImVtYWlsIiwibW9ja0NsZWFyIiwidGVzdCIsImV4cGVjdCIsInBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcyIsInRvQmUiLCJtb2NrVXNlciIsImlkIiwicGFzc3dvcmQiLCJpc0FjdGl2ZSIsInJvbGVJZCIsInNob3BJZCIsInJvbGVOYW1lIiwicGVybWlzc2lvbnMiLCJyb2xlIiwicmVzdWx0IiwiYXV0aGVudGljYXRlVXNlciIsInN1Y2Nlc3MiLCJ0b2tlbiIsInRvRXF1YWwiLCJ1c2VybmFtZSIsImZ1bGxOYW1lIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ3aGVyZSIsImluY2x1ZGUiLCJzZWxlY3QiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIm1vY2tQYXlsb2FkIiwic3ViIiwibW9ja1Rva2VuIiwiZ2VuZXJhdGVUb2tlbiIsImV4cGlyZXNJbiIsImlhdCIsIk1hdGgiLCJmbG9vciIsIm5vdyIsImV4cCIsInZlcmlmeVRva2VuIiwidG9IYXZlQmVlbkNhbGxlZCIsImludmFsaWRFcnJvciIsInJlamVjdHMiLCJ0b1Rocm93IiwiZXhwaXJlZEVycm9yIiwicGF5bG9hZCIsImNhY2hlZFVzZXIiLCJnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkIiwidG9CZU51bGwiLCJ1bmRlZmluZWQiLCJ2ZXJpZnlSZXN1bHQiLCJ0b0JlRGVmaW5lZCIsInRvSGF2ZVByb3BlcnR5IiwibnVsbFJlc3VsdCIsIm5vU3ViUmVzdWx0IiwiZGVjb2RlZFJlc3VsdCIsIm5vdCIsImdldFVzZXJGcm9tVG9rZW4iLCJqd3RFcnJvciIsIm9yaWdpbmFsU2VjcmV0Iiwic2VjcmV0RXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBLG1DQUFtQztBQUNuQywyREFBMkQ7Ozs7O3lCQUV0QztxRUF3RitHO3NFQUMvRzt1QkFDUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeEY3QixpREFBaUQ7QUFDakQsTUFBTUEsbUJBQW1CO0lBQ3ZCQyxLQUFLQyxhQUFJLENBQUNDLEVBQUU7SUFDWkMsS0FBS0YsYUFBSSxDQUFDQyxFQUFFO0lBQ1pFLFFBQVFILGFBQUksQ0FBQ0MsRUFBRTtJQUNmRyxXQUFXSixhQUFJLENBQUNDLEVBQUU7SUFDbEJJLGFBQWFMLGFBQUksQ0FBQ0MsRUFBRTtJQUNwQkssT0FBT04sYUFBSSxDQUFDQyxFQUFFO0FBQ2hCO0FBRUEsTUFBTU0sYUFBYTtJQUNqQkMsTUFBTTtRQUNKQyxZQUFZVCxhQUFJLENBQUNDLEVBQUU7UUFDbkJTLFdBQVdWLGFBQUksQ0FBQ0MsRUFBRTtRQUNsQlUsUUFBUVgsYUFBSSxDQUFDQyxFQUFFO1FBQ2ZXLFFBQVFaLGFBQUksQ0FBQ0MsRUFBRTtRQUNmWSxVQUFVYixhQUFJLENBQUNDLEVBQUU7UUFDakJFLFFBQVFILGFBQUksQ0FBQ0MsRUFBRTtJQUNqQjtJQUNBYSxZQUFZO1FBQ1ZELFVBQVViLGFBQUksQ0FBQ0MsRUFBRTtJQUNuQjtJQUNBYyxTQUFTO1FBQ1BKLFFBQVFYLGFBQUksQ0FBQ0MsRUFBRTtRQUNmUSxZQUFZVCxhQUFJLENBQUNDLEVBQUU7UUFDbkJXLFFBQVFaLGFBQUksQ0FBQ0MsRUFBRTtRQUNmZSxZQUFZaEIsYUFBSSxDQUFDQyxFQUFFO0lBQ3JCO0lBQ0FnQixVQUFVO1FBQ1JOLFFBQVFYLGFBQUksQ0FBQ0MsRUFBRTtJQUNqQjtBQUNGO0FBRUEsTUFB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