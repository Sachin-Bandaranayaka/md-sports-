b64d5d0c1a0b991378e07e7fc7b909d1
// Fixed Unit tests for AuthService
// This file tests the authentication service functionality
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _authService = require("../../src/services/authService");
const _jsonwebtoken = /*#__PURE__*/ _interop_require_wildcard(require("jsonwebtoken"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock dependencies BEFORE importing the service
const mockCacheService = {
    get: _globals.jest.fn(),
    set: _globals.jest.fn(),
    delete: _globals.jest.fn(),
    increment: _globals.jest.fn(),
    generateKey: _globals.jest.fn(),
    clear: _globals.jest.fn()
};
const mockPrisma = {
    user: {
        findUnique: _globals.jest.fn(),
        findFirst: _globals.jest.fn(),
        create: _globals.jest.fn(),
        update: _globals.jest.fn(),
        findMany: _globals.jest.fn(),
        delete: _globals.jest.fn()
    },
    permission: {
        findMany: _globals.jest.fn()
    },
    session: {
        create: _globals.jest.fn(),
        findUnique: _globals.jest.fn(),
        update: _globals.jest.fn(),
        deleteMany: _globals.jest.fn()
    },
    auditLog: {
        create: _globals.jest.fn()
    }
};
const mockBcrypt = {
    compare: _globals.jest.fn(),
    hash: _globals.jest.fn(),
    genSalt: _globals.jest.fn()
};
// Mock modules
_globals.jest.mock("@/lib/prisma", ()=>({
        __esModule: true,
        default: mockPrisma
    }));
_globals.jest.mock("@/lib/cache", ()=>({
        cacheService: mockCacheService,
        CACHE_CONFIG: {
            KEYS: {
                USER_SESSION: "user_session",
                TOKEN_VALIDATION: "token_validation"
            },
            TTL: {
                USER_SESSION: 3600,
                TOKEN_VALIDATION: 1800
            }
        }
    }));
_globals.jest.mock("bcryptjs", ()=>mockBcrypt);
// Mock jsonwebtoken with a simple approach
const mockJwt = {
    sign: _globals.jest.fn(),
    verify: _globals.jest.fn(),
    decode: _globals.jest.fn(),
    TokenExpiredError: class extends Error {
        constructor(message, expiredAt){
            super(message);
            this.name = "TokenExpiredError";
            this.expiredAt = expiredAt || new Date();
        }
    },
    JsonWebTokenError: class extends Error {
        constructor(message){
            super(message);
            this.name = "JsonWebTokenError";
        }
    }
};
_globals.jest.mock("jsonwebtoken", ()=>mockJwt);
// Spy on the imported jwt to ensure our mocks work
const jwtSpy = _globals.jest.spyOn(_jsonwebtoken, "verify");
// Create proper mock types for easier access
const mockUserFindFirst = mockPrisma.user.findFirst;
const mockPermissionFindMany = mockPrisma.permission.findMany;
// mockJwt is already defined above
describe("AuthService", ()=>{
    beforeEach(()=>{
        _globals.jest.clearAllMocks();
        process.env.JWT_SECRET = "test-secret-key";
        process.env.JWT_ACCESS_TOKEN_EXPIRES_IN = "12h";
        // Setup default cache mocks
        mockCacheService.generateKey.mockReturnValue("mock-cache-key");
        mockCacheService.get.mockResolvedValue(null);
        mockCacheService.set.mockResolvedValue(true);
        mockCacheService.delete.mockResolvedValue(true);
        // Reset Prisma mocks
        mockUserFindFirst.mockResolvedValue(null);
        mockPermissionFindMany.mockResolvedValue([]);
        // Reset JWT mocks
        mockJwt.sign.mockReturnValue("mocked-jwt-token");
        mockJwt.verify.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
        mockJwt.decode.mockReturnValue({
            userId: 1,
            email: "test@example.com"
        });
    });
    describe("parseTimeStringToSeconds", ()=>{
        test("should parse seconds correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("30s")).toBe(30);
        });
        test("should parse minutes correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("5m")).toBe(300);
        });
        test("should parse hours correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("2h")).toBe(7200);
        });
        test("should parse days correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("1d")).toBe(86400);
        });
        test("should return 0 for invalid input", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("invalid")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("abc")).toBe(0);
        });
        test("should handle edge cases", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("0s")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("100x")).toBe(100); // Falls back to parsing the number part
        });
    });
    describe("authenticateUser", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            password: "hashedpassword",
            isActive: true,
            roleId: 1,
            shopId: 1,
            roleName: "admin",
            permissions: null,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should authenticate valid user credentials", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(true);
            mockJwt.sign.mockReturnValue("mock-jwt-token");
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(true);
            expect(result.token).toBe("mock-jwt-token");
            expect(result.user).toEqual({
                id: 1,
                email: "test@example.com",
                username: "testuser",
                fullName: "testuser",
                roleId: 1,
                roleName: "admin",
                shopId: 1,
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockUserFindFirst).toHaveBeenCalledWith({
                where: {
                    email: "test@example.com",
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            });
        });
        test("should reject invalid email", async ()=>{
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.authenticateUser)("invalid@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject invalid password", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(false);
            const result = await (0, _authService.authenticateUser)("test@example.com", "wrongpassword");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should reject inactive user", async ()=>{
            mockUserFindFirst.mockResolvedValue(null); // findFirst with isActive: true returns null
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should handle database errors gracefully", async ()=>{
            mockUserFindFirst.mockRejectedValue(new Error("Database connection failed"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
        test("should handle bcrypt errors gracefully", async ()=>{
            mockUserFindFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockRejectedValue(new Error("Bcrypt error"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
    });
    describe("generateToken", ()=>{
        const mockPayload = {
            sub: 1,
            username: "testuser",
            email: "test@example.com",
            roleId: 1,
            shopId: 1,
            permissions: [
                "read_products",
                "write_products"
            ]
        };
        test("should generate JWT token", ()=>{
            const mockToken = "mock-jwt-token";
            mockJwt.sign.mockReturnValue(mockToken);
            const result = (0, _authService.generateToken)(mockPayload);
            expect(result).toBe(mockToken);
            expect(mockJwt.sign).toHaveBeenCalledWith(mockPayload, "test-secret-key", {
                expiresIn: "12h"
            });
        });
    });
    describe("verifyToken", ()=>{
        test("should verify valid token from cache", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should verify valid token and cache result", async ()=>{
            const mockPayload = {
                sub: "1",
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockJwt.verify.mockReturnValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockJwt.verify).toHaveBeenCalledWith("valid-token", "test-secret-key");
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("Invalid token");
            });
            await expect((0, _authService.verifyToken)("invalid-token")).rejects.toThrow("Invalid token");
        });
        test("should throw error for expired token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                const error = new Error("Token expired");
                error.name = "TokenExpiredError";
                error.expiredAt = new Date();
                throw error;
            });
            await expect((0, _authService.verifyToken)("expired-token")).rejects.toThrow("Token expired");
        });
    });
    describe("getUserFromDecodedPayload", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "testuser",
            isActive: true,
            roleId: 1,
            shopId: 1,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should return user from cache", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const cachedUser = {
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            };
            mockCacheService.get.mockResolvedValue(cachedUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual(cachedUser);
            expect(mockCacheService.get).toHaveBeenCalled();
        });
        test("should return user from database and cache it", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null); // Not in cache
            mockUserFindFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockCacheService.set).toHaveBeenCalled();
        });
        test("should return null for null payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)(null);
            expect(result).toBeNull();
        });
        test("should return null for invalid payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)({});
            expect(result).toBeNull();
        });
        test("should return null when user not found", async ()=>{
            const payload = {
                sub: 999,
                username: "nonexistent",
                email: "nonexistent@example.com",
                roleId: 1
            };
            mockCacheService.get.mockResolvedValue(null);
            mockUserFindFirst.mockResolvedValue(null);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toBeNull();
        });
    });
    describe("getUserFromToken", ()=>{
        test("should return user from valid token", async ()=>{
            const mockPayload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const mockUser = {
                id: 1,
                email: "test@example.com",
                name: "testuser",
                isActive: true,
                roleId: 1,
                shopId: 1,
                role: {
                    id: 1,
                    name: "admin",
                    permissions: [
                        {
                            name: "read_products"
                        }
                    ]
                }
            };
            // Mock verifyToken to return payload
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>mockPayload);
            // Mock getUserFromDecodedPayload
            mockUserFindFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromToken)("valid-token");
            expect(result).toEqual({
                ...mockUser,
                roleName: "admin",
                permissions: [
                    "read_products"
                ]
            });
        });
        test("should throw error for invalid token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            mockCacheService.generateKey.mockReturnValue("test-cache-key");
            const jwt = require("jsonwebtoken");
            // Mock jwt.verify to throw JsonWebTokenError
            mockJwt.verify.mockImplementation(()=>{
                const error = new Error("jwt malformed");
                error.name = "JsonWebTokenError";
                throw error;
            });
            await expect((0, _authService.getUserFromToken)("invalid")).rejects.toThrow("jwt malformed");
        });
    });
    describe("Error Handling", ()=>{
        test("should handle missing JWT_SECRET", async ()=>{
            const originalSecret = process.env.JWT_SECRET;
            delete process.env.JWT_SECRET;
            mockCacheService.get.mockResolvedValue(null);
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("secretOrPrivateKey must have a value");
            });
            await expect((0, _authService.verifyToken)("any-token")).rejects.toThrow();
            // Restore the secret
            process.env.JWT_SECRET = originalSecret;
        });
        test("should handle malformed tokens gracefully", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            // Mock both the direct mock and the spy
            const jwtError = new mockJwt.JsonWebTokenError("jwt malformed");
            mockJwt.verify.mockImplementation(()=>{
                throw jwtError;
            });
            jwtSpy.mockImplementation(()=>{
                throw jwtError;
            });
            await expect((0, _authService.verifyToken)("malformed-token")).rejects.toThrow("jwt malformed");
        });
        test("should handle empty token", async ()=>{
            mockCacheService.get.mockResolvedValue(null);
            await expect((0, _authService.verifyToken)("")).rejects.toThrow("jwt must be provided");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9hdXRoU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpeGVkIFVuaXQgdGVzdHMgZm9yIEF1dGhTZXJ2aWNlXG4vLyBUaGlzIGZpbGUgdGVzdHMgdGhlIGF1dGhlbnRpY2F0aW9uIHNlcnZpY2UgZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzIEJFRk9SRSBpbXBvcnRpbmcgdGhlIHNlcnZpY2VcbmNvbnN0IG1vY2tDYWNoZVNlcnZpY2UgPSB7XG4gIGdldDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgc2V0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBkZWxldGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGluY3JlbWVudDogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgZ2VuZXJhdGVLZXk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIGNsZWFyOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxufTtcblxuY29uc3QgbW9ja1ByaXNtYSA9IHtcbiAgdXNlcjoge1xuICAgIGZpbmRVbmlxdWU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZEZpcnN0OiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICAgIGNyZWF0ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICB9LFxuICBwZXJtaXNzaW9uOiB7XG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG4gIHNlc3Npb246IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgICB1cGRhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gICAgZGVsZXRlTWFueTogamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PixcbiAgfSxcbiAgYXVkaXRMb2c6IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT4sXG4gIH0sXG59O1xuXG5jb25zdCBtb2NrQmNyeXB0ID0ge1xuICBjb21wYXJlOiBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+LFxuICBoYXNoOiBqZXN0LmZuKCksXG4gIGdlblNhbHQ6IGplc3QuZm4oKSxcbn07XG5cbi8vIE1vY2sgbW9kdWxlc1xuamVzdC5tb2NrKCdAL2xpYi9wcmlzbWEnLCAoKSA9PiAoe1xuICBfX2VzTW9kdWxlOiB0cnVlLFxuICBkZWZhdWx0OiBtb2NrUHJpc21hLFxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvbGliL2NhY2hlJywgKCkgPT4gKHtcbiAgY2FjaGVTZXJ2aWNlOiBtb2NrQ2FjaGVTZXJ2aWNlLFxuICBDQUNIRV9DT05GSUc6IHtcbiAgICBLRVlTOiB7XG4gICAgICBVU0VSX1NFU1NJT046ICd1c2VyX3Nlc3Npb24nLFxuICAgICAgVE9LRU5fVkFMSURBVElPTjogJ3Rva2VuX3ZhbGlkYXRpb24nLFxuICAgIH0sXG4gICAgVFRMOiB7XG4gICAgICBVU0VSX1NFU1NJT046IDM2MDAsXG4gICAgICBUT0tFTl9WQUxJREFUSU9OOiAxODAwLFxuICAgIH0sXG4gIH0sXG59KSk7XG5cbmplc3QubW9jaygnYmNyeXB0anMnLCAoKSA9PiBtb2NrQmNyeXB0KTtcbi8vIE1vY2sganNvbndlYnRva2VuIHdpdGggYSBzaW1wbGUgYXBwcm9hY2hcbmNvbnN0IG1vY2tKd3QgPSB7XG4gIHNpZ246IGplc3QuZm4oKSxcbiAgdmVyaWZ5OiBqZXN0LmZuKCksXG4gIGRlY29kZTogamVzdC5mbigpLFxuICBUb2tlbkV4cGlyZWRFcnJvcjogY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgZXhwaXJlZEF0OiBEYXRlO1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgZXhwaXJlZEF0PzogRGF0ZSkge1xuICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICB0aGlzLm5hbWUgPSAnVG9rZW5FeHBpcmVkRXJyb3InO1xuICAgICAgdGhpcy5leHBpcmVkQXQgPSBleHBpcmVkQXQgfHwgbmV3IERhdGUoKTtcbiAgICB9XG4gIH0sXG4gIEpzb25XZWJUb2tlbkVycm9yOiBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5uYW1lID0gJ0pzb25XZWJUb2tlbkVycm9yJztcbiAgICB9XG4gIH0sXG59O1xuXG5qZXN0Lm1vY2soJ2pzb253ZWJ0b2tlbicsICgpID0+IG1vY2tKd3QpO1xuXG4vLyBJbXBvcnQgYWZ0ZXIgbW9ja2luZ1xuaW1wb3J0IHsgYXV0aGVudGljYXRlVXNlciwgZ2VuZXJhdGVUb2tlbiwgdmVyaWZ5VG9rZW4sIHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcywgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCwgZ2V0VXNlckZyb21Ub2tlbiB9IGZyb20gJ0Avc2VydmljZXMvYXV0aFNlcnZpY2UnO1xuaW1wb3J0ICogYXMgand0IGZyb20gJ2pzb253ZWJ0b2tlbic7XG5cbi8vIFNweSBvbiB0aGUgaW1wb3J0ZWQgand0IHRvIGVuc3VyZSBvdXIgbW9ja3Mgd29ya1xuY29uc3Qgand0U3B5ID0gamVzdC5zcHlPbihqd3QsICd2ZXJpZnknKTtcblxuLy8gQ3JlYXRlIHByb3BlciBtb2NrIHR5cGVzIGZvciBlYXNpZXIgYWNjZXNzXG5jb25zdCBtb2NrVXNlckZpbmRGaXJzdCA9IG1vY2tQcmlzbWEudXNlci5maW5kRmlyc3QgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuY29uc3QgbW9ja1Blcm1pc3Npb25GaW5kTWFueSA9IG1vY2tQcmlzbWEucGVybWlzc2lvbi5maW5kTWFueSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG4vLyBtb2NrSnd0IGlzIGFscmVhZHkgZGVmaW5lZCBhYm92ZVxuXG5kZXNjcmliZSgnQXV0aFNlcnZpY2UnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgPSAndGVzdC1zZWNyZXQta2V5JztcbiAgICBwcm9jZXNzLmVudi5KV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4gPSAnMTJoJztcbiAgICBcbiAgICAvLyBTZXR1cCBkZWZhdWx0IGNhY2hlIG1vY2tzXG4gICAgbW9ja0NhY2hlU2VydmljZS5nZW5lcmF0ZUtleS5tb2NrUmV0dXJuVmFsdWUoJ21vY2stY2FjaGUta2V5Jyk7XG4gICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgbW9ja0NhY2hlU2VydmljZS5zZXQubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG4gICAgbW9ja0NhY2hlU2VydmljZS5kZWxldGUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG4gICAgXG4gICAgLy8gUmVzZXQgUHJpc21hIG1vY2tzXG4gICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgbW9ja1Blcm1pc3Npb25GaW5kTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgXG4gICAgLy8gUmVzZXQgSldUIG1vY2tzXG4gICAgbW9ja0p3dC5zaWduLm1vY2tSZXR1cm5WYWx1ZSgnbW9ja2VkLWp3dC10b2tlbicpO1xuICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tSZXR1cm5WYWx1ZSh7IHVzZXJJZDogMSwgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9KTtcbiAgICBtb2NrSnd0LmRlY29kZS5tb2NrUmV0dXJuVmFsdWUoeyB1c2VySWQ6IDEsIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIHNlY29uZHMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMzBzJykpLnRvQmUoMzApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIG1pbnV0ZXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnNW0nKSkudG9CZSgzMDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHBhcnNlIGhvdXJzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzJoJykpLnRvQmUoNzIwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgZGF5cyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcxZCcpKS50b0JlKDg2NDAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gMCBmb3IgaW52YWxpZCBpbnB1dCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJycpKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnaW52YWxpZCcpKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnYWJjJykpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZXMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcwcycpKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMTAweCcpKS50b0JlKDEwMCk7IC8vIEZhbGxzIGJhY2sgdG8gcGFyc2luZyB0aGUgbnVtYmVyIHBhcnRcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2F1dGhlbnRpY2F0ZVVzZXInLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICBuYW1lOiAndGVzdHVzZXInLFxuICAgICAgcGFzc3dvcmQ6ICdoYXNoZWRwYXNzd29yZCcsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIHJvbGVJZDogMSxcbiAgICAgIHNob3BJZDogMSxcbiAgICAgIHJvbGVOYW1lOiAnYWRtaW4nLFxuICAgICAgcGVybWlzc2lvbnM6IG51bGwsXG4gICAgICByb2xlOiB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBuYW1lOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczogW1xuICAgICAgICAgIHsgbmFtZTogJ3JlYWRfcHJvZHVjdHMnIH0sXG4gICAgICAgICAgeyBuYW1lOiAnd3JpdGVfcHJvZHVjdHMnIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0ZXN0KCdzaG91bGQgYXV0aGVudGljYXRlIHZhbGlkIHVzZXIgY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgICBtb2NrQmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSBhcyBhbnkpO1xuICAgICAgbW9ja0p3dC5zaWduLm1vY2tSZXR1cm5WYWx1ZSgnbW9jay1qd3QtdG9rZW4nIGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC50b2tlbikudG9CZSgnbW9jay1qd3QtdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcikudG9FcXVhbCh7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZnVsbE5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHNob3BJZDogMSxcbiAgICAgICAgcGVybWlzc2lvbnM6IFsncmVhZF9wcm9kdWN0cycsICd3cml0ZV9wcm9kdWN0cyddXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChtb2NrVXNlckZpbmRGaXJzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgaXNBY3RpdmU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ2ludmFsaWRAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIHBhc3N3b3JkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuICAgICAgbW9ja0JjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlIGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnd3JvbmdwYXNzd29yZCcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGluYWN0aXZlIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTsgLy8gZmluZEZpcnN0IHdpdGggaXNBY3RpdmU6IHRydWUgcmV0dXJucyBudWxsXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnQXV0aGVudGljYXRpb24gZmFpbGVkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGJjcnlwdCBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tVc2VyRmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIG1vY2tCY3J5cHQuY29tcGFyZS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0JjcnlwdCBlcnJvcicpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcigndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdBdXRoZW50aWNhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dlbmVyYXRlVG9rZW4nLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICBzdWI6IDEsXG4gICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICByb2xlSWQ6IDEsXG4gICAgICBzaG9wSWQ6IDEsXG4gICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJywgJ3dyaXRlX3Byb2R1Y3RzJ11cbiAgICB9O1xuXG4gICAgdGVzdCgnc2hvdWxkIGdlbmVyYXRlIEpXVCB0b2tlbicsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tUb2tlbiA9ICdtb2NrLWp3dC10b2tlbic7XG4gICAgICBtb2NrSnd0LnNpZ24ubW9ja1JldHVyblZhbHVlKG1vY2tUb2tlbik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdlbmVyYXRlVG9rZW4obW9ja1BheWxvYWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKG1vY2tUb2tlbik7XG4gICAgICBleHBlY3QobW9ja0p3dC5zaWduKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBtb2NrUGF5bG9hZCxcbiAgICAgICAgICAndGVzdC1zZWNyZXQta2V5JyxcbiAgICAgICAgICB7IGV4cGlyZXNJbjogJzEyaCcgfVxuICAgICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmVyaWZ5VG9rZW4nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHZlcmlmeSB2YWxpZCB0b2tlbiBmcm9tIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICAgIHN1YjogJzEnLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxLFxuICAgICAgICBpYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICBleHA6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgMzYwMFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1BheWxvYWQpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbigndmFsaWQtdG9rZW4nKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUGF5bG9hZCk7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB2ZXJpZnkgdmFsaWQgdG9rZW4gYW5kIGNhY2hlIHJlc3VsdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgICBzdWI6ICcxJyxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgaWF0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDM2MDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBOb3QgaW4gY2FjaGVcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tSZXR1cm5WYWx1ZShtb2NrUGF5bG9hZCBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbigndmFsaWQtdG9rZW4nKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUGF5bG9hZCk7XG4gICAgICBleHBlY3QobW9ja0p3dC52ZXJpZnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd2YWxpZC10b2tlbicsICd0ZXN0LXNlY3JldC1rZXknKTtcbiAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLnNldCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBpbnZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4nKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QodmVyaWZ5VG9rZW4oJ2ludmFsaWQtdG9rZW4nKSkucmVqZWN0cy50b1Rocm93KCdJbnZhbGlkIHRva2VuJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGV4cGlyZWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUb2tlbiBleHBpcmVkJykgYXMgYW55O1xuICAgICAgICBlcnJvci5uYW1lID0gJ1Rva2VuRXhwaXJlZEVycm9yJztcbiAgICAgICAgZXJyb3IuZXhwaXJlZEF0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdleHBpcmVkLXRva2VuJykpLnJlamVjdHMudG9UaHJvdygnVG9rZW4gZXhwaXJlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZCcsICgpID0+IHtcbiAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgIGlkOiAxLFxuICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIG5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIHJvbGVJZDogMSxcbiAgICAgIHNob3BJZDogMSxcbiAgICAgIHJvbGU6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbXG4gICAgICAgICAgeyBuYW1lOiAncmVhZF9wcm9kdWN0cycgfSxcbiAgICAgICAgICB7IG5hbWU6ICd3cml0ZV9wcm9kdWN0cycgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgc3ViOiAxLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZUlkOiAxXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBjYWNoZWRVc2VyID0ge1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUoY2FjaGVkVXNlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoY2FjaGVkVXNlcik7XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIGRhdGFiYXNlIGFuZCBjYWNoZSBpdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIE5vdCBpbiBjYWNoZVxuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHBheWxvYWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgLi4ubW9ja1VzZXIsXG4gICAgICAgIHJvbGVOYW1lOiAnYWRtaW4nLFxuICAgICAgICBwZXJtaXNzaW9uczogWydyZWFkX3Byb2R1Y3RzJywgJ3dyaXRlX3Byb2R1Y3RzJ11cbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2Uuc2V0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG51bGwgcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQobnVsbCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBpbnZhbGlkIHBheWxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHt9IGFzIGFueSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiBudWxsIHdoZW4gdXNlciBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBzdWI6IDk5OSxcbiAgICAgICAgdXNlcm5hbWU6ICdub25leGlzdGVudCcsXG4gICAgICAgIGVtYWlsOiAnbm9uZXhpc3RlbnRAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgbW9ja1VzZXJGaW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VXNlckZyb21Ub2tlbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIHVzZXIgZnJvbSB2YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tQYXlsb2FkID0ge1xuICAgICAgICBzdWI6IDEsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgc2hvcElkOiAxLFxuICAgICAgICByb2xlOiB7XG4gICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgbmFtZTogJ2FkbWluJyxcbiAgICAgICAgICBwZXJtaXNzaW9uczogW3sgbmFtZTogJ3JlYWRfcHJvZHVjdHMnIH1dXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgdmVyaWZ5VG9rZW4gdG8gcmV0dXJuIHBheWxvYWRcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tQYXlsb2FkKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkXG4gICAgICBtb2NrVXNlckZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tVG9rZW4oJ3ZhbGlkLXRva2VuJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICAuLi5tb2NrVXNlcixcbiAgICAgICAgcm9sZU5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnXVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIGludmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgIG1vY2tDYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkubW9ja1JldHVyblZhbHVlKCd0ZXN0LWNhY2hlLWtleScpO1xuICAgICAgY29uc3Qgand0ID0gcmVxdWlyZSgnanNvbndlYnRva2VuJyk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgand0LnZlcmlmeSB0byB0aHJvdyBKc29uV2ViVG9rZW5FcnJvclxuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdKc29uV2ViVG9rZW5FcnJvcic7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChnZXRVc2VyRnJvbVRva2VuKCdpbnZhbGlkJykpLnJlamVjdHMudG9UaHJvdygnand0IG1hbGZvcm1lZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIEpXVF9TRUNSRVQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbFNlY3JldCA9IHByb2Nlc3MuZW52LkpXVF9TRUNSRVQ7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVDtcbiAgICAgIFxuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY3JldE9yUHJpdmF0ZUtleSBtdXN0IGhhdmUgYSB2YWx1ZScpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbignYW55LXRva2VuJykpLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIHRoZSBzZWNyZXRcbiAgICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgPSBvcmlnaW5hbFNlY3JldDtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWFsZm9ybWVkIHRva2VucyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgYm90aCB0aGUgZGlyZWN0IG1vY2sgYW5kIHRoZSBzcHlcbiAgICAgIGNvbnN0IGp3dEVycm9yID0gbmV3IG1vY2tKd3QuSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IGp3dEVycm9yO1xuICAgICAgfSk7XG4gICAgICBqd3RTcHkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgand0RXJyb3I7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KHZlcmlmeVRva2VuKCdtYWxmb3JtZWQtdG9rZW4nKSkucmVqZWN0cy50b1Rocm93KCdqd3QgbWFsZm9ybWVkJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdCh2ZXJpZnlUb2tlbignJykpLnJlamVjdHMudG9UaHJvdygnand0IG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsibW9ja0NhY2hlU2VydmljZSIsImdldCIsImplc3QiLCJmbiIsInNldCIsImRlbGV0ZSIsImluY3JlbWVudCIsImdlbmVyYXRlS2V5IiwiY2xlYXIiLCJtb2NrUHJpc21hIiwidXNlciIsImZpbmRVbmlxdWUiLCJmaW5kRmlyc3QiLCJjcmVhdGUiLCJ1cGRhdGUiLCJmaW5kTWFueSIsInBlcm1pc3Npb24iLCJzZXNzaW9uIiwiZGVsZXRlTWFueSIsImF1ZGl0TG9nIiwibW9ja0JjcnlwdCIsImNvbXBhcmUiLCJoYXNoIiwiZ2VuU2FsdCIsIm1vY2siLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImNhY2hlU2VydmljZSIsIkNBQ0hFX0NPTkZJRyIsIktFWVMiLCJVU0VSX1NFU1NJT04iLCJUT0tFTl9WQUxJREFUSU9OIiwiVFRMIiwibW9ja0p3dCIsInNpZ24iLCJ2ZXJpZnkiLCJkZWNvZGUiLCJUb2tlbkV4cGlyZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiZXhwaXJlZEF0IiwibmFtZSIsIkRhdGUiLCJKc29uV2ViVG9rZW5FcnJvciIsImp3dFNweSIsInNweU9uIiwiand0IiwibW9ja1VzZXJGaW5kRmlyc3QiLCJtb2NrUGVybWlzc2lvbkZpbmRNYW55IiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInByb2Nlc3MiLCJlbnYiLCJKV1RfU0VDUkVUIiwiSldUX0FDQ0VTU19UT0tFTl9FWFBJUkVTX0lOIiwibW9ja1JldHVyblZhbHVlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ1c2VySWQiLCJlbWFpbCIsInRlc3QiLCJleHBlY3QiLCJwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMiLCJ0b0JlIiwibW9ja1VzZXIiLCJpZCIsInBhc3N3b3JkIiwiaXNBY3RpdmUiLCJyb2xlSWQiLCJzaG9wSWQiLCJyb2xlTmFtZSIsInBlcm1pc3Npb25zIiwicm9sZSIsInJlc3VsdCIsImF1dGhlbnRpY2F0ZVVzZXIiLCJzdWNjZXNzIiwidG9rZW4iLCJ0b0VxdWFsIiwidXNlcm5hbWUiLCJmdWxsTmFtZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwid2hlcmUiLCJpbmNsdWRlIiwic2VsZWN0IiwibW9ja1JlamVjdGVkVmFsdWUiLCJtb2NrUGF5bG9hZCIsInN1YiIsIm1vY2tUb2tlbiIsImdlbmVyYXRlVG9rZW4iLCJleHBpcmVzSW4iLCJpYXQiLCJNYXRoIiwiZmxvb3IiLCJub3ciLCJleHAiLCJ2ZXJpZnlUb2tlbiIsInRvSGF2ZUJlZW5DYWxsZWQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJyZWplY3RzIiwidG9UaHJvdyIsImVycm9yIiwicGF5bG9hZCIsImNhY2hlZFVzZXIiLCJnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkIiwidG9CZU51bGwiLCJnZXRVc2VyRnJvbVRva2VuIiwicmVxdWlyZSIsIm9yaWdpbmFsU2VjcmV0Iiwiand0RXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBLG1DQUFtQztBQUNuQywyREFBMkQ7Ozs7O3lCQUV0Qzs2QkFzRitHO3NFQUMvRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBckZyQixpREFBaUQ7QUFDakQsTUFBTUEsbUJBQW1CO0lBQ3ZCQyxLQUFLQyxhQUFJLENBQUNDLEVBQUU7SUFDWkMsS0FBS0YsYUFBSSxDQUFDQyxFQUFFO0lBQ1pFLFFBQVFILGFBQUksQ0FBQ0MsRUFBRTtJQUNmRyxXQUFXSixhQUFJLENBQUNDLEVBQUU7SUFDbEJJLGFBQWFMLGFBQUksQ0FBQ0MsRUFBRTtJQUNwQkssT0FBT04sYUFBSSxDQUFDQyxFQUFFO0FBQ2hCO0FBRUEsTUFBTU0sYUFBYTtJQUNqQkMsTUFBTTtRQUNKQyxZQUFZVCxhQUFJLENBQUNDLEVBQUU7UUFDbkJTLFdBQVdWLGFBQUksQ0FBQ0MsRUFBRTtRQUNsQlUsUUFBUVgsYUFBSSxDQUFDQyxFQUFFO1FBQ2ZXLFFBQVFaLGFBQUksQ0FBQ0MsRUFBRTtRQUNmWSxVQUFVYixhQUFJ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