0e3559610bd078fa11d7da1a95ac737a
"use strict";
jest.mock("@/hooks/useAuth", ()=>({
        useAuth: ()=>mockUseAuth()
    }));
// Mock next/navigation
jest.mock("next/navigation", ()=>({
        useRouter: ()=>({
                push: jest.fn(),
                replace: jest.fn(),
                back: jest.fn(),
                forward: jest.fn(),
                refresh: jest.fn(),
                prefetch: jest.fn()
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
require("@testing-library/jest-dom");
// Mock the useAuth hook
const mockUseAuth = jest.fn();
// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;
describe("Sales Invoice API Integration", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock localStorage
        Object.defineProperty(window, "localStorage", {
            value: {
                getItem: jest.fn(()=>"mock-token"),
                setItem: jest.fn(),
                removeItem: jest.fn()
            },
            writable: true
        });
        // Mock user with sales permissions
        mockUseAuth.mockReturnValue({
            user: {
                id: "1",
                name: "Sales User",
                email: "sales@test.com",
                permissions: [
                    "sales:view",
                    "sales:create",
                    "sales:edit",
                    "sales:delete",
                    "payments:create"
                ]
            },
            isLoading: false,
            isAuthenticated: true,
            login: jest.fn(),
            logout: jest.fn()
        });
    });
    describe("Invoice Creation API", ()=>{
        test("should create invoice via API call", async ()=>{
            const mockInvoiceData = {
                customerId: 1,
                items: [
                    {
                        productId: 1,
                        quantity: 2,
                        unitPrice: 100
                    },
                    {
                        productId: 2,
                        quantity: 1,
                        unitPrice: 50
                    }
                ],
                dueDate: "2024-02-15",
                notes: "Test invoice"
            };
            const mockResponse = {
                id: 1,
                invoiceNumber: "INV-001",
                ...mockInvoiceData,
                status: "draft",
                subtotal: 250,
                taxAmount: 25,
                total: 275,
                createdAt: "2024-01-15T10:00:00Z"
            };
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockResponse
            });
            const createInvoice = async (invoiceData)=>{
                const response = await fetch("/api/invoices", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    },
                    body: JSON.stringify(invoiceData)
                });
                if (!response.ok) {
                    throw new Error("Failed to create invoice");
                }
                return response.json();
            };
            const result = await createInvoice(mockInvoiceData);
            expect(mockFetch).toHaveBeenCalledWith("/api/invoices", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer mock-token"
                },
                body: JSON.stringify(mockInvoiceData)
            });
            expect(result.id).toBe(1);
            expect(result.invoiceNumber).toBe("INV-001");
            expect(result.total).toBe(275);
        });
        test("should handle API errors during creation", async ()=>{
            const mockInvoiceData = {
                customerId: 1,
                items: []
            };
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                json: async ()=>({
                        error: "Validation failed",
                        details: [
                            "At least one item is required"
                        ]
                    })
            });
            const createInvoice = async (invoiceData)=>{
                const response = await fetch("/api/invoices", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    },
                    body: JSON.stringify(invoiceData)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error);
                }
                return response.json();
            };
            await expect(createInvoice(mockInvoiceData)).rejects.toThrow("Validation failed");
        });
    });
    describe("Invoice Update API", ()=>{
        test("should update invoice via API call", async ()=>{
            const invoiceId = 1;
            const updateData = {
                notes: "Updated notes",
                dueDate: "2024-02-20",
                items: [
                    {
                        productId: 1,
                        quantity: 3,
                        unitPrice: 100
                    }
                ]
            };
            const mockResponse = {
                id: invoiceId,
                ...updateData,
                status: "draft",
                updatedAt: "2024-01-15T11:00:00Z"
            };
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockResponse
            });
            const updateInvoice = async (id, data)=>{
                const response = await fetch(`/api/invoices/${id}`, {
                    method: "PUT",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    },
                    body: JSON.stringify(data)
                });
                if (!response.ok) {
                    throw new Error("Failed to update invoice");
                }
                return response.json();
            };
            const result = await updateInvoice(invoiceId, updateData);
            expect(mockFetch).toHaveBeenCalledWith("/api/invoices/1", {
                method: "PUT",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer mock-token"
                },
                body: JSON.stringify(updateData)
            });
            expect(result.notes).toBe("Updated notes");
            expect(result.dueDate).toBe("2024-02-20");
        });
        test("should handle update permission errors", async ()=>{
            const invoiceId = 1;
            const updateData = {
                notes: "Updated notes"
            };
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 403,
                json: async ()=>({
                        error: "Insufficient permissions",
                        message: "You do not have permission to edit this invoice"
                    })
            });
            const updateInvoice = async (id, data)=>{
                const response = await fetch(`/api/invoices/${id}`, {
                    method: "PUT",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    },
                    body: JSON.stringify(data)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error);
                }
                return response.json();
            };
            await expect(updateInvoice(invoiceId, updateData)).rejects.toThrow("Insufficient permissions");
        });
    });
    describe("Invoice Deletion API", ()=>{
        test("should delete invoice via API call", async ()=>{
            const invoiceId = 1;
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        message: "Invoice deleted successfully",
                        deletedId: invoiceId
                    })
            });
            const deleteInvoice = async (id)=>{
                const response = await fetch(`/api/invoices/${id}`, {
                    method: "DELETE",
                    headers: {
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    }
                });
                if (!response.ok) {
                    throw new Error("Failed to delete invoice");
                }
                return response.json();
            };
            const result = await deleteInvoice(invoiceId);
            expect(mockFetch).toHaveBeenCalledWith("/api/invoices/1", {
                method: "DELETE",
                headers: {
                    "Authorization": "Bearer mock-token"
                }
            });
            expect(result.message).toBe("Invoice deleted successfully");
            expect(result.deletedId).toBe(invoiceId);
        });
        test("should handle deletion restrictions", async ()=>{
            const invoiceId = 1;
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                json: async ()=>({
                        error: "Cannot delete invoice",
                        message: "Invoice has payments and cannot be deleted"
                    })
            });
            const deleteInvoice = async (id)=>{
                const response = await fetch(`/api/invoices/${id}`, {
                    method: "DELETE",
                    headers: {
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    }
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error);
                }
                return response.json();
            };
            await expect(deleteInvoice(invoiceId)).rejects.toThrow("Cannot delete invoice");
        });
    });
    describe("Payment Processing API", ()=>{
        test("should process payment via API call", async ()=>{
            const invoiceId = 1;
            const paymentData = {
                amount: 500,
                paymentMethod: "cash",
                paymentDate: "2024-01-15",
                notes: "Cash payment"
            };
            const mockResponse = {
                id: 1,
                invoiceId,
                ...paymentData,
                status: "completed",
                processedAt: "2024-01-15T12:00:00Z"
            };
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockResponse
            });
            const processPayment = async (invoiceId, paymentData)=>{
                const response = await fetch(`/api/invoices/${invoiceId}/payments`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    },
                    body: JSON.stringify(paymentData)
                });
                if (!response.ok) {
                    throw new Error("Failed to process payment");
                }
                return response.json();
            };
            const result = await processPayment(invoiceId, paymentData);
            expect(mockFetch).toHaveBeenCalledWith("/api/invoices/1/payments", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer mock-token"
                },
                body: JSON.stringify(paymentData)
            });
            expect(result.amount).toBe(500);
            expect(result.status).toBe("completed");
            expect(result.paymentMethod).toBe("cash");
        });
        test("should handle payment validation errors", async ()=>{
            const invoiceId = 1;
            const paymentData = {
                amount: 1500,
                paymentMethod: "cash",
                paymentDate: "2024-01-15"
            };
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                json: async ()=>({
                        error: "Payment validation failed",
                        details: [
                            "Payment amount exceeds remaining balance"
                        ]
                    })
            });
            const processPayment = async (invoiceId, paymentData)=>{
                const response = await fetch(`/api/invoices/${invoiceId}/payments`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    },
                    body: JSON.stringify(paymentData)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error);
                }
                return response.json();
            };
            await expect(processPayment(invoiceId, paymentData)).rejects.toThrow("Payment validation failed");
        });
    });
    describe("Invoice Retrieval API", ()=>{
        test("should fetch invoice list via API call", async ()=>{
            const mockInvoices = [
                {
                    id: 1,
                    invoiceNumber: "INV-001",
                    customerId: 1,
                    customerName: "John Doe",
                    total: 275,
                    status: "sent",
                    dueDate: "2024-02-15"
                },
                {
                    id: 2,
                    invoiceNumber: "INV-002",
                    customerId: 2,
                    customerName: "Jane Smith",
                    total: 150,
                    status: "paid",
                    dueDate: "2024-02-10"
                }
            ];
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        invoices: mockInvoices,
                        total: 2,
                        page: 1,
                        limit: 10
                    })
            });
            const fetchInvoices = async (params = {})=>{
                const queryString = new URLSearchParams(params).toString();
                const url = `/api/invoices${queryString ? `?${queryString}` : ""}`;
                const response = await fetch(url, {
                    headers: {
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    }
                });
                if (!response.ok) {
                    throw new Error("Failed to fetch invoices");
                }
                return response.json();
            };
            const result = await fetchInvoices({
                page: 1,
                limit: 10
            });
            expect(mockFetch).toHaveBeenCalledWith("/api/invoices?page=1&limit=10", {
                headers: {
                    "Authorization": "Bearer mock-token"
                }
            });
            expect(result.invoices).toHaveLength(2);
            expect(result.total).toBe(2);
        });
        test("should fetch single invoice via API call", async ()=>{
            const invoiceId = 1;
            const mockInvoice = {
                id: invoiceId,
                invoiceNumber: "INV-001",
                customerId: 1,
                customerName: "John Doe",
                items: [
                    {
                        productId: 1,
                        productName: "Product A",
                        quantity: 2,
                        unitPrice: 100
                    },
                    {
                        productId: 2,
                        productName: "Product B",
                        quantity: 1,
                        unitPrice: 50
                    }
                ],
                subtotal: 250,
                taxAmount: 25,
                total: 275,
                status: "sent",
                payments: [
                    {
                        id: 1,
                        amount: 100,
                        paymentMethod: "cash",
                        paymentDate: "2024-01-10"
                    }
                ]
            };
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockInvoice
            });
            const fetchInvoice = async (id)=>{
                const response = await fetch(`/api/invoices/${id}`, {
                    headers: {
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    }
                });
                if (!response.ok) {
                    throw new Error("Failed to fetch invoice");
                }
                return response.json();
            };
            const result = await fetchInvoice(invoiceId);
            expect(mockFetch).toHaveBeenCalledWith("/api/invoices/1", {
                headers: {
                    "Authorization": "Bearer mock-token"
                }
            });
            expect(result.id).toBe(invoiceId);
            expect(result.items).toHaveLength(2);
            expect(result.payments).toHaveLength(1);
        });
    });
    describe("Invoice Status Updates API", ()=>{
        test("should update invoice status via API call", async ()=>{
            const invoiceId = 1;
            const statusData = {
                status: "sent",
                sentDate: "2024-01-15T10:00:00Z"
            };
            const mockResponse = {
                id: invoiceId,
                status: "sent",
                sentDate: "2024-01-15T10:00:00Z",
                updatedAt: "2024-01-15T10:00:00Z"
            };
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockResponse
            });
            const updateInvoiceStatus = async (id, statusData)=>{
                const response = await fetch(`/api/invoices/${id}/status`, {
                    method: "PATCH",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    },
                    body: JSON.stringify(statusData)
                });
                if (!response.ok) {
                    throw new Error("Failed to update invoice status");
                }
                return response.json();
            };
            const result = await updateInvoiceStatus(invoiceId, statusData);
            expect(mockFetch).toHaveBeenCalledWith("/api/invoices/1/status", {
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer mock-token"
                },
                body: JSON.stringify(statusData)
            });
            expect(result.status).toBe("sent");
            expect(result.sentDate).toBe("2024-01-15T10:00:00Z");
        });
        test("should handle invalid status transitions", async ()=>{
            const invoiceId = 1;
            const statusData = {
                status: "draft" // Invalid transition from paid to draft
            };
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 400,
                json: async ()=>({
                        error: "Invalid status transition",
                        message: "Cannot change status from paid to draft"
                    })
            });
            const updateInvoiceStatus = async (id, statusData)=>{
                const response = await fetch(`/api/invoices/${id}/status`, {
                    method: "PATCH",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${localStorage.getItem("token")}`
                    },
                    body: JSON.stringify(statusData)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error);
                }
                return response.json();
            };
            await expect(updateInvoiceStatus(invoiceId, statusData)).rejects.toThrow("Invalid status transition");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvYXBpL3NhbGVzSW52b2ljZXNBcGkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgZmlyZUV2ZW50LCB3YWl0Rm9yIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvamVzdC1kb20nO1xuXG4vLyBNb2NrIHRoZSB1c2VBdXRoIGhvb2tcbmNvbnN0IG1vY2tVc2VBdXRoID0gamVzdC5mbigpO1xuamVzdC5tb2NrKCdAL2hvb2tzL3VzZUF1dGgnLCAoKSA9PiAoe1xuICB1c2VBdXRoOiAoKSA9PiBtb2NrVXNlQXV0aCgpLFxufSkpO1xuXG4vLyBNb2NrIG5leHQvbmF2aWdhdGlvblxuamVzdC5tb2NrKCduZXh0L25hdmlnYXRpb24nLCAoKSA9PiAoe1xuICB1c2VSb3V0ZXI6ICgpID0+ICh7XG4gICAgcHVzaDogamVzdC5mbigpLFxuICAgIHJlcGxhY2U6IGplc3QuZm4oKSxcbiAgICBiYWNrOiBqZXN0LmZuKCksXG4gICAgZm9yd2FyZDogamVzdC5mbigpLFxuICAgIHJlZnJlc2g6IGplc3QuZm4oKSxcbiAgICBwcmVmZXRjaDogamVzdC5mbigpLFxuICB9KSxcbn0pKTtcblxuLy8gTW9jayBmZXRjaCBnbG9iYWxseVxuY29uc3QgbW9ja0ZldGNoID0gamVzdC5mbigpO1xuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoO1xuXG5kZXNjcmliZSgnU2FsZXMgSW52b2ljZSBBUEkgSW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIE1vY2sgbG9jYWxTdG9yYWdlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2xvY2FsU3RvcmFnZScsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGdldEl0ZW06IGplc3QuZm4oKCkgPT4gJ21vY2stdG9rZW4nKSxcbiAgICAgICAgc2V0SXRlbTogamVzdC5mbigpLFxuICAgICAgICByZW1vdmVJdGVtOiBqZXN0LmZuKCksXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLyBNb2NrIHVzZXIgd2l0aCBzYWxlcyBwZXJtaXNzaW9uc1xuICAgIG1vY2tVc2VBdXRoLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICB1c2VyOiB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIG5hbWU6ICdTYWxlcyBVc2VyJyxcbiAgICAgICAgZW1haWw6ICdzYWxlc0B0ZXN0LmNvbScsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3NhbGVzOnZpZXcnLCAnc2FsZXM6Y3JlYXRlJywgJ3NhbGVzOmVkaXQnLCAnc2FsZXM6ZGVsZXRlJywgJ3BheW1lbnRzOmNyZWF0ZSddXG4gICAgICB9LFxuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgIGxvZ2luOiBqZXN0LmZuKCksXG4gICAgICBsb2dvdXQ6IGplc3QuZm4oKSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludm9pY2UgQ3JlYXRpb24gQVBJJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBjcmVhdGUgaW52b2ljZSB2aWEgQVBJIGNhbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrSW52b2ljZURhdGEgPSB7XG4gICAgICAgIGN1c3RvbWVySWQ6IDEsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgeyBwcm9kdWN0SWQ6IDEsIHF1YW50aXR5OiAyLCB1bml0UHJpY2U6IDEwMCB9LFxuICAgICAgICAgIHsgcHJvZHVjdElkOiAyLCBxdWFudGl0eTogMSwgdW5pdFByaWNlOiA1MCB9XG4gICAgICAgIF0sXG4gICAgICAgIGR1ZURhdGU6ICcyMDI0LTAyLTE1JyxcbiAgICAgICAgbm90ZXM6ICdUZXN0IGludm9pY2UnXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBpbnZvaWNlTnVtYmVyOiAnSU5WLTAwMScsXG4gICAgICAgIC4uLm1vY2tJbnZvaWNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiAnZHJhZnQnLFxuICAgICAgICBzdWJ0b3RhbDogMjUwLFxuICAgICAgICB0YXhBbW91bnQ6IDI1LFxuICAgICAgICB0b3RhbDogMjc1LFxuICAgICAgICBjcmVhdGVkQXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWidcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1Jlc3BvbnNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNyZWF0ZUludm9pY2UgPSBhc3luYyAoaW52b2ljZURhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2ludm9pY2VzJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKX1gXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbnZvaWNlRGF0YSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBpbnZvaWNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlSW52b2ljZShtb2NrSW52b2ljZURhdGEpO1xuXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9pbnZvaWNlcycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtb2NrSW52b2ljZURhdGEpXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pZCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuaW52b2ljZU51bWJlcikudG9CZSgnSU5WLTAwMScpO1xuICAgICAgZXhwZWN0KHJlc3VsdC50b3RhbCkudG9CZSgyNzUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBBUEkgZXJyb3JzIGR1cmluZyBjcmVhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tJbnZvaWNlRGF0YSA9IHtcbiAgICAgICAgY3VzdG9tZXJJZDogMSxcbiAgICAgICAgaXRlbXM6IFtdXG4gICAgICB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBlcnJvcjogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICBkZXRhaWxzOiBbJ0F0IGxlYXN0IG9uZSBpdGVtIGlzIHJlcXVpcmVkJ11cbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY3JlYXRlSW52b2ljZSA9IGFzeW5jIChpbnZvaWNlRGF0YTogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvaW52b2ljZXMnLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2xvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpfWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGludm9pY2VEYXRhKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IGV4cGVjdChjcmVhdGVJbnZvaWNlKG1vY2tJbnZvaWNlRGF0YSkpLnJlamVjdHMudG9UaHJvdygnVmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludm9pY2UgVXBkYXRlIEFQSScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdXBkYXRlIGludm9pY2UgdmlhIEFQSSBjYWxsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52b2ljZUlkID0gMTtcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7XG4gICAgICAgIG5vdGVzOiAnVXBkYXRlZCBub3RlcycsXG4gICAgICAgIGR1ZURhdGU6ICcyMDI0LTAyLTIwJyxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICB7IHByb2R1Y3RJZDogMSwgcXVhbnRpdHk6IDMsIHVuaXRQcmljZTogMTAwIH1cbiAgICAgICAgXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICBpZDogaW52b2ljZUlkLFxuICAgICAgICAuLi51cGRhdGVEYXRhLFxuICAgICAgICBzdGF0dXM6ICdkcmFmdCcsXG4gICAgICAgIHVwZGF0ZWRBdDogJzIwMjQtMDEtMTVUMTE6MDA6MDBaJ1xuICAgICAgfTtcblxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrUmVzcG9uc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdXBkYXRlSW52b2ljZSA9IGFzeW5jIChpZDogbnVtYmVyLCBkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9pbnZvaWNlcy8ke2lkfWAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKX1gXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGludm9pY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGRhdGVJbnZvaWNlKGludm9pY2VJZCwgdXBkYXRlRGF0YSk7XG5cbiAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXBpL2ludm9pY2VzLzEnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQubm90ZXMpLnRvQmUoJ1VwZGF0ZWQgbm90ZXMnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZHVlRGF0ZSkudG9CZSgnMjAyNC0wMi0yMCcpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSB1cGRhdGUgcGVybWlzc2lvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZvaWNlSWQgPSAxO1xuICAgICAgY29uc3QgdXBkYXRlRGF0YSA9IHsgbm90ZXM6ICdVcGRhdGVkIG5vdGVzJyB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDQwMyxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBlcnJvcjogJ0luc3VmZmljaWVudCBwZXJtaXNzaW9ucycsXG4gICAgICAgICAgbWVzc2FnZTogJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGVkaXQgdGhpcyBpbnZvaWNlJ1xuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGRhdGVJbnZvaWNlID0gYXN5bmMgKGlkOiBudW1iZXIsIGRhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2ludm9pY2VzLyR7aWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2xvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpfWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHVwZGF0ZUludm9pY2UoaW52b2ljZUlkLCB1cGRhdGVEYXRhKSkucmVqZWN0cy50b1Rocm93KCdJbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludm9pY2UgRGVsZXRpb24gQVBJJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBkZWxldGUgaW52b2ljZSB2aWEgQVBJIGNhbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZvaWNlSWQgPSAxO1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgbWVzc2FnZTogJ0ludm9pY2UgZGVsZXRlZCBzdWNjZXNzZnVsbHknLFxuICAgICAgICAgIGRlbGV0ZWRJZDogaW52b2ljZUlkXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGRlbGV0ZUludm9pY2UgPSBhc3luYyAoaWQ6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2ludm9pY2VzLyR7aWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7bG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJyl9YFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBpbnZvaWNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVsZXRlSW52b2ljZShpbnZvaWNlSWQpO1xuXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9pbnZvaWNlcy8xJywge1xuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0ludm9pY2UgZGVsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGVsZXRlZElkKS50b0JlKGludm9pY2VJZCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGRlbGV0aW9uIHJlc3RyaWN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludm9pY2VJZCA9IDE7XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIGVycm9yOiAnQ2Fubm90IGRlbGV0ZSBpbnZvaWNlJyxcbiAgICAgICAgICBtZXNzYWdlOiAnSW52b2ljZSBoYXMgcGF5bWVudHMgYW5kIGNhbm5vdCBiZSBkZWxldGVkJ1xuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkZWxldGVJbnZvaWNlID0gYXN5bmMgKGlkOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9pbnZvaWNlcy8ke2lkfWAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2xvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpfWBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfTtcblxuICAgICAgYXdhaXQgZXhwZWN0KGRlbGV0ZUludm9pY2UoaW52b2ljZUlkKSkucmVqZWN0cy50b1Rocm93KCdDYW5ub3QgZGVsZXRlIGludm9pY2UnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BheW1lbnQgUHJvY2Vzc2luZyBBUEknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHByb2Nlc3MgcGF5bWVudCB2aWEgQVBJIGNhbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZvaWNlSWQgPSAxO1xuICAgICAgY29uc3QgcGF5bWVudERhdGEgPSB7XG4gICAgICAgIGFtb3VudDogNTAwLFxuICAgICAgICBwYXltZW50TWV0aG9kOiAnY2FzaCcsXG4gICAgICAgIHBheW1lbnREYXRlOiAnMjAyNC0wMS0xNScsXG4gICAgICAgIG5vdGVzOiAnQ2FzaCBwYXltZW50J1xuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgaW52b2ljZUlkLFxuICAgICAgICAuLi5wYXltZW50RGF0YSxcbiAgICAgICAgc3RhdHVzOiAnY29tcGxldGVkJyxcbiAgICAgICAgcHJvY2Vzc2VkQXQ6ICcyMDI0LTAxLTE1VDEyOjAwOjAwWidcbiAgICAgIH07XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1Jlc3BvbnNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHByb2Nlc3NQYXltZW50ID0gYXN5bmMgKGludm9pY2VJZDogbnVtYmVyLCBwYXltZW50RGF0YTogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvaW52b2ljZXMvJHtpbnZvaWNlSWR9L3BheW1lbnRzYCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKX1gXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXltZW50RGF0YSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgcGF5bWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NQYXltZW50KGludm9pY2VJZCwgcGF5bWVudERhdGEpO1xuXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9pbnZvaWNlcy8xL3BheW1lbnRzJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIG1vY2stdG9rZW4nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheW1lbnREYXRhKVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuYW1vdW50KS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZSgnY29tcGxldGVkJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnBheW1lbnRNZXRob2QpLnRvQmUoJ2Nhc2gnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgcGF5bWVudCB2YWxpZGF0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludm9pY2VJZCA9IDE7XG4gICAgICBjb25zdCBwYXltZW50RGF0YSA9IHtcbiAgICAgICAgYW1vdW50OiAxNTAwLCAvLyBFeGNlZWRzIGludm9pY2UgdG90YWxcbiAgICAgICAgcGF5bWVudE1ldGhvZDogJ2Nhc2gnLFxuICAgICAgICBwYXltZW50RGF0ZTogJzIwMjQtMDEtMTUnXG4gICAgICB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBlcnJvcjogJ1BheW1lbnQgdmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgIGRldGFpbHM6IFsnUGF5bWVudCBhbW91bnQgZXhjZWVkcyByZW1haW5pbmcgYmFsYW5jZSddXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHByb2Nlc3NQYXltZW50ID0gYXN5bmMgKGludm9pY2VJZDogbnVtYmVyLCBwYXltZW50RGF0YTogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvaW52b2ljZXMvJHtpbnZvaWNlSWR9L3BheW1lbnRzYCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKX1gXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXltZW50RGF0YSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3QocHJvY2Vzc1BheW1lbnQoaW52b2ljZUlkLCBwYXltZW50RGF0YSkpLnJlamVjdHMudG9UaHJvdygnUGF5bWVudCB2YWxpZGF0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW52b2ljZSBSZXRyaWV2YWwgQVBJJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBmZXRjaCBpbnZvaWNlIGxpc3QgdmlhIEFQSSBjYWxsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0ludm9pY2VzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgaW52b2ljZU51bWJlcjogJ0lOVi0wMDEnLFxuICAgICAgICAgIGN1c3RvbWVySWQ6IDEsXG4gICAgICAgICAgY3VzdG9tZXJOYW1lOiAnSm9obiBEb2UnLFxuICAgICAgICAgIHRvdGFsOiAyNzUsXG4gICAgICAgICAgc3RhdHVzOiAnc2VudCcsXG4gICAgICAgICAgZHVlRGF0ZTogJzIwMjQtMDItMTUnXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogMixcbiAgICAgICAgICBpbnZvaWNlTnVtYmVyOiAnSU5WLTAwMicsXG4gICAgICAgICAgY3VzdG9tZXJJZDogMixcbiAgICAgICAgICBjdXN0b21lck5hbWU6ICdKYW5lIFNtaXRoJyxcbiAgICAgICAgICB0b3RhbDogMTUwLFxuICAgICAgICAgIHN0YXR1czogJ3BhaWQnLFxuICAgICAgICAgIGR1ZURhdGU6ICcyMDI0LTAyLTEwJ1xuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgaW52b2ljZXM6IG1vY2tJbnZvaWNlcyxcbiAgICAgICAgICB0b3RhbDogMixcbiAgICAgICAgICBwYWdlOiAxLFxuICAgICAgICAgIGxpbWl0OiAxMFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBmZXRjaEludm9pY2VzID0gYXN5bmMgKHBhcmFtczogYW55ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgdXJsID0gYC9hcGkvaW52b2ljZXMke3F1ZXJ5U3RyaW5nID8gYD8ke3F1ZXJ5U3RyaW5nfWAgOiAnJ31gO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKX1gXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggaW52b2ljZXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEludm9pY2VzKHsgcGFnZTogMSwgbGltaXQ6IDEwIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9pbnZvaWNlcz9wYWdlPTEmbGltaXQ9MTAnLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9jay10b2tlbidcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuaW52b2ljZXMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudG90YWwpLnRvQmUoMik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZmV0Y2ggc2luZ2xlIGludm9pY2UgdmlhIEFQSSBjYWxsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52b2ljZUlkID0gMTtcbiAgICAgIGNvbnN0IG1vY2tJbnZvaWNlID0ge1xuICAgICAgICBpZDogaW52b2ljZUlkLFxuICAgICAgICBpbnZvaWNlTnVtYmVyOiAnSU5WLTAwMScsXG4gICAgICAgIGN1c3RvbWVySWQ6IDEsXG4gICAgICAgIGN1c3RvbWVyTmFtZTogJ0pvaG4gRG9lJyxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICB7IHByb2R1Y3RJZDogMSwgcHJvZHVjdE5hbWU6ICdQcm9kdWN0IEEnLCBxdWFudGl0eTogMiwgdW5pdFByaWNlOiAxMDAgfSxcbiAgICAgICAgICB7IHByb2R1Y3RJZDogMiwgcHJvZHVjdE5hbWU6ICdQcm9kdWN0IEInLCBxdWFudGl0eTogMSwgdW5pdFByaWNlOiA1MCB9XG4gICAgICAgIF0sXG4gICAgICAgIHN1YnRvdGFsOiAyNTAsXG4gICAgICAgIHRheEFtb3VudDogMjUsXG4gICAgICAgIHRvdGFsOiAyNzUsXG4gICAgICAgIHN0YXR1czogJ3NlbnQnLFxuICAgICAgICBwYXltZW50czogW1xuICAgICAgICAgIHsgaWQ6IDEsIGFtb3VudDogMTAwLCBwYXltZW50TWV0aG9kOiAnY2FzaCcsIHBheW1lbnREYXRlOiAnMjAyNC0wMS0xMCcgfVxuICAgICAgICBdXG4gICAgICB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tJbnZvaWNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGZldGNoSW52b2ljZSA9IGFzeW5jIChpZDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvaW52b2ljZXMvJHtpZH1gLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7bG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJyl9YFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGludm9pY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEludm9pY2UoaW52b2ljZUlkKTtcblxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvaW52b2ljZXMvMScsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pZCkudG9CZShpbnZvaWNlSWQpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5pdGVtcykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5wYXltZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW52b2ljZSBTdGF0dXMgVXBkYXRlcyBBUEknLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHVwZGF0ZSBpbnZvaWNlIHN0YXR1cyB2aWEgQVBJIGNhbGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZvaWNlSWQgPSAxO1xuICAgICAgY29uc3Qgc3RhdHVzRGF0YSA9IHtcbiAgICAgICAgc3RhdHVzOiAnc2VudCcsXG4gICAgICAgIHNlbnREYXRlOiAnMjAyNC0wMS0xNVQxMDowMDowMFonXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUmVzcG9uc2UgPSB7XG4gICAgICAgIGlkOiBpbnZvaWNlSWQsXG4gICAgICAgIHN0YXR1czogJ3NlbnQnLFxuICAgICAgICBzZW50RGF0ZTogJzIwMjQtMDEtMTVUMTA6MDA6MDBaJyxcbiAgICAgICAgdXBkYXRlZEF0OiAnMjAyNC0wMS0xNVQxMDowMDowMFonXG4gICAgICB9O1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tSZXNwb25zZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGRhdGVJbnZvaWNlU3RhdHVzID0gYXN5bmMgKGlkOiBudW1iZXIsIHN0YXR1c0RhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2ludm9pY2VzLyR7aWR9L3N0YXR1c2AsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2xvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpfWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHN0YXR1c0RhdGEpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgaW52b2ljZSBzdGF0dXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGRhdGVJbnZvaWNlU3RhdHVzKGludm9pY2VJZCwgc3RhdHVzRGF0YSk7XG5cbiAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXBpL2ludm9pY2VzLzEvc3RhdHVzJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBtb2NrLXRva2VuJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShzdGF0dXNEYXRhKVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKCdzZW50Jyk7XG4gICAgICBleHBlY3QocmVzdWx0LnNlbnREYXRlKS50b0JlKCcyMDI0LTAxLTE1VDEwOjAwOjAwWicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHN0YXR1cyB0cmFuc2l0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludm9pY2VJZCA9IDE7XG4gICAgICBjb25zdCBzdGF0dXNEYXRhID0ge1xuICAgICAgICBzdGF0dXM6ICdkcmFmdCcgLy8gSW52YWxpZCB0cmFuc2l0aW9uIGZyb20gcGFpZCB0byBkcmFmdFxuICAgICAgfTtcblxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIHN0YXR1cyB0cmFuc2l0aW9uJyxcbiAgICAgICAgICBtZXNzYWdlOiAnQ2Fubm90IGNoYW5nZSBzdGF0dXMgZnJvbSBwYWlkIHRvIGRyYWZ0J1xuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGRhdGVJbnZvaWNlU3RhdHVzID0gYXN5bmMgKGlkOiBudW1iZXIsIHN0YXR1c0RhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2ludm9pY2VzLyR7aWR9L3N0YXR1c2AsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2xvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpfWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHN0YXR1c0RhdGEpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHVwZGF0ZUludm9pY2VTdGF0dXMoaW52b2ljZUlkLCBzdGF0dXNEYXRhKSkucmVqZWN0cy50b1Rocm93KCdJbnZhbGlkIHN0YXR1cyB0cmFuc2l0aW9uJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwidXNlQXV0aCIsIm1vY2tVc2VBdXRoIiwidXNlUm91dGVyIiwicHVzaCIsImZuIiwicmVwbGFjZSIsImJhY2siLCJmb3J3YXJkIiwicmVmcmVzaCIsInByZWZldGNoIiwibW9ja0ZldGNoIiwiZ2xvYmFsIiwiZmV0Y2giLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3aW5kb3ciLCJ2YWx1ZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIndyaXRhYmxlIiwibW9ja1JldHVyblZhbHVlIiwidXNlciIsImlkIiwibmFtZSIsImVtYWlsIiwicGVybWlzc2lvbnMiLCJpc0xvYWRpbmciLCJpc0F1dGhlbnRpY2F0ZWQiLCJsb2dpbiIsImxvZ291dCIsInRlc3QiLCJtb2NrSW52b2ljZURhdGEiLCJjdXN0b21lcklkIiwiaXRlbXMiLCJwcm9kdWN0SWQiLCJxdWFudGl0eSIsInVuaXRQcmljZSIsImR1ZURhdGUiLCJub3RlcyIsIm1vY2tSZXNwb25zZSIsImludm9pY2VOdW1iZXIiLCJzdGF0dXMiLCJzdWJ0b3RhbCIsInRheEFtb3VudCIsInRvdGFsIiwiY3JlYXRlZEF0IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJqc29uIiwiY3JlYXRlSW52b2ljZSIsImludm9pY2VEYXRhIiwicmVzcG9uc2UiLCJtZXRob2QiLCJoZWFkZXJzIiwibG9jYWxTdG9yYWdlIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJFcnJvciIsInJlc3VsdCIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwidG9CZSIsImVycm9yIiwiZGV0YWlscyIsImVycm9yRGF0YSIsInJlamVjdHMiLCJ0b1Rocm93IiwiaW52b2ljZUlkIiwidXBkYXRlRGF0YSIsInVwZGF0ZWRBdCIsInVwZGF0ZUludm9pY2UiLCJkYXRhIiwibWVzc2FnZSIsImRlbGV0ZWRJZCIsImRlbGV0ZUludm9pY2UiLCJwYXltZW50RGF0YSIsImFtb3VudCIsInBheW1lbnRNZXRob2QiLCJwYXltZW50RGF0ZSIsInByb2Nlc3NlZEF0IiwicHJvY2Vzc1BheW1lbnQiLCJtb2NrSW52b2ljZXMiLCJjdXN0b21lck5hbWUiLCJpbnZvaWNlcyIsInBhZ2UiLCJsaW1pdCIsImZldGNoSW52b2ljZXMiLCJwYXJhbXMiLCJxdWVyeVN0cmluZyIsIlVSTFNlYXJjaFBhcmFtcyIsInRvU3RyaW5nIiwidXJsIiwidG9IYXZlTGVuZ3RoIiwibW9ja0ludm9pY2UiLCJwcm9kdWN0TmFtZSIsInBheW1lbnRzIiwiZmV0Y2hJbnZvaWNlIiwic3RhdHVzRGF0YSIsInNlbnREYXRlIiwidXBkYXRlSW52b2ljZVN0YXR1cyJdLCJtYXBwaW5ncyI6IjtBQUtBQSxLQUFLQyxJ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