d851bbacc323d0765d4e35da63a7e8d3
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    authenticateUser: function() {
        return authenticateUser;
    },
    generateToken: function() {
        return generateToken;
    },
    getUserFromDecodedPayload: function() {
        return getUserFromDecodedPayload;
    },
    getUserFromToken: function() {
        return getUserFromToken;
    },
    hasPermission: function() {
        return hasPermission;
    },
    parseTimeStringToSeconds: function() {
        return parseTimeStringToSeconds;
    },
    verifyToken: function() {
        return verifyToken;
    }
});
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
const _prisma = /*#__PURE__*/ _interop_require_default(require("../lib/prisma"));
const _cache = require("../lib/cache");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Secret key for JWT - should be moved to environment variables in production
const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
// Changed token expiration to 12h (from 24h) for better security
const JWT_EXPIRES_IN = process.env.JWT_ACCESS_TOKEN_EXPIRES_IN || "12h";
const parseTimeStringToSeconds = (timeStr)=>{
    if (!timeStr) return 0;
    const lastChar = timeStr.slice(-1);
    const num = parseInt(timeStr.slice(0, -1));
    if (isNaN(num)) return 0;
    switch(lastChar){
        case "s":
            return num;
        case "m":
            return num * 60;
        case "h":
            return num * 60 * 60;
        case "d":
            return num * 60 * 60 * 24;
        default:
            if (!isNaN(parseInt(timeStr))) return parseInt(timeStr);
            return 0;
    }
};
const authenticateUser = async (email, password)=>{
    try {
        console.time("user authentication query");
        // Optimized single query using the new composite index
        const user = await _prisma.default.user.findFirst({
            where: {
                email: email,
                isActive: true
            },
            include: {
                role: {
                    include: {
                        permissions: {
                            select: {
                                name: true
                            }
                        }
                    }
                }
            }
        });
        console.timeEnd("user authentication query");
        // If user not found
        if (!user) {
            return {
                success: false,
                message: "Invalid email or password"
            };
        }
        // Verify password
        const isPasswordValid = await _bcryptjs.default.compare(password, user.password);
        if (!isPasswordValid) {
            return {
                success: false,
                message: "Invalid email or password"
            };
        }
        // Get permissions from role (handle case where user has no role)
        let permissions = [];
        if (user.role?.permissions) {
            permissions = user.role.permissions.map((p)=>p.name);
        } else if (user.permissions && Array.isArray(user.permissions)) {
            // Handle special case for "ALL" permissions
            if (user.permissions.includes("ALL")) {
                permissions = [
                    "ALL"
                ];
            } else {
                // Convert permission IDs to names, filtering out invalid values
                const validPermissionIds = user.permissions.map((id)=>parseInt(id.toString())).filter((id)=>!isNaN(id));
                if (validPermissionIds.length > 0) {
                    const permissionRecords = await _prisma.default.permission.findMany({
                        where: {
                            id: {
                                in: validPermissionIds
                            }
                        },
                        select: {
                            name: true
                        }
                    });
                    permissions = permissionRecords.map((p)=>p.name);
                }
            }
        }
        // Generate JWT token
        const token = generateToken({
            sub: user.id,
            username: user.name,
            email: user.email,
            roleId: user.roleId,
            shopId: user.shopId,
            permissions
        });
        const userSession = {
            id: user.id,
            username: user.name,
            fullName: user.name,
            email: user.email,
            roleId: user.roleId,
            roleName: user.role?.name || user.roleName || null,
            shopId: user.shopId,
            permissions,
            role: user.role
        };
        // Cache user session for faster subsequent requests
        const cacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_SESSION, {
            userId: user.id
        });
        await _cache.cacheService.set(cacheKey, userSession, _cache.CACHE_CONFIG.TTL.USER_SESSION);
        return {
            success: true,
            token,
            user: {
                id: user.id,
                username: user.name,
                fullName: user.name,
                email: user.email,
                roleId: user.roleId,
                roleName: user.role?.name || user.roleName || null,
                shopId: user.shopId,
                permissions
            }
        };
    } catch (error) {
        console.error("Authentication error:", error);
        return {
            success: false,
            message: "Authentication failed"
        };
    }
};
const generateToken = (payload)=>{
    return _jsonwebtoken.default.sign(payload, JWT_SECRET, {
        expiresIn: JWT_EXPIRES_IN
    });
};
const verifyToken = async (token)=>{
    // Validate token input
    if (!token || token.trim() === "") {
        throw new Error("jwt must be provided");
    }
    // Ensure token is long enough for substring operation
    if (token.length < 20) {
        throw new Error("jwt malformed");
    }
    const tokenKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.TOKEN_VALIDATION, {
        token: token.substring(0, 20)
    });
    try {
        // Check cache first for token validation result
        const cachedResult = await _cache.cacheService.get(tokenKey);
        if (cachedResult) {
            return cachedResult;
        }
        // Verify token
        const payload = _jsonwebtoken.default.verify(token, JWT_SECRET);
        // Cache the valid token payload (shorter TTL for security)
        await _cache.cacheService.set(tokenKey, payload, _cache.CACHE_CONFIG.TTL.TOKEN_VALIDATION);
        return payload;
    } catch (error) {
        // Log the error here if desired
        if (error instanceof _jsonwebtoken.default.TokenExpiredError) {
            console.error("Token expired during verification:", error.expiredAt);
        } else if (error instanceof _jsonwebtoken.default.JsonWebTokenError) {
            console.error("Invalid token during verification:", error.message);
        } else {
            console.error("Unknown token verification error:", error);
        }
        throw error; // Re-throw the error
    }
};
const hasPermission = async (tokenPayload, permission)=>{
    // Import the proper permission checking utility
    const { hasPermission: checkPermission } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../lib/utils/permissions")));
    // Quick check from token payload first
    if (tokenPayload.permissions) {
        if (checkPermission(tokenPayload.permissions, permission)) {
            return true;
        }
    }
    // If not in token, check cached user permissions
    const permissionsCacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_PERMISSIONS, {
        userId: tokenPayload.sub
    });
    try {
        const cachedPermissions = await _cache.cacheService.get(permissionsCacheKey);
        if (cachedPermissions) {
            return checkPermission(cachedPermissions, permission);
        }
        // Fallback to database query if not cached
        const user = await _prisma.default.user.findFirst({
            where: {
                id: tokenPayload.sub,
                isActive: true
            },
            include: {
                role: {
                    include: {
                        permissions: {
                            select: {
                                name: true
                            }
                        }
                    }
                }
            }
        });
        if (user) {
            const permissions = user.role.permissions.map((p)=>p.name);
            // Cache permissions for future checks
            await _cache.cacheService.set(permissionsCacheKey, permissions, _cache.CACHE_CONFIG.TTL.USER_PERMISSIONS);
            return checkPermission(permissions, permission);
        }
    } catch (error) {
        console.error("Error checking permissions:", error);
    }
    return false;
};
const getUserFromDecodedPayload = async (payload)=>{
    console.log("getUserFromDecodedPayload received payload:", payload);
    if (!payload) {
        console.error("Invalid token payload provided to getUserFromDecodedPayload");
        return null;
    }
    if (!payload.sub) {
        console.error("Token payload missing user ID (sub claim)");
        return null;
    }
    const userId = payload.sub;
    const cacheKey = _cache.cacheService.generateKey(_cache.CACHE_CONFIG.KEYS.USER_SESSION, {
        userId
    });
    try {
        // Try to get user from cache first
        const cachedUser = await _cache.cacheService.get(cacheKey);
        if (cachedUser) {
            console.log("User found in cache:", userId);
            return cachedUser;
        }
        console.log("Looking up user with ID:", userId);
        console.time("prisma.user.findFirst for auth"); // Start timer
        const user = await _prisma.default.user.findFirst({
            where: {
                id: userId,
                isActive: true
            },
            include: {
                role: {
                    include: {
                        permissions: {
                            select: {
                                name: true
                            }
                        }
                    }
                }
            }
        });
        console.timeEnd("prisma.user.findFirst for auth"); // End timer
        if (!user) {
            console.error("User not found for ID:", userId);
            return null;
        }
        const userWithPermissions = {
            ...user,
            roleName: user.role.name,
            permissions: user.role.permissions.map((p)=>p.name)
        };
        // Cache the user session
        await _cache.cacheService.set(cacheKey, userWithPermissions, _cache.CACHE_CONFIG.TTL.USER_SESSION);
        console.log("User found and cached:", user.id, user.name);
        return userWithPermissions;
    } catch (error) {
        console.error("Error getting user from decoded payload:", error);
        return null;
    }
};
const getUserFromToken = async (token)=>{
    const payload = await verifyToken(token);
    return getUserFromDecodedPayload(payload);
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vc3JjL3NlcnZpY2VzL2F1dGhTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJztcbmltcG9ydCBiY3J5cHQgZnJvbSAnYmNyeXB0anMnO1xuaW1wb3J0IHByaXNtYSBmcm9tICdAL2xpYi9wcmlzbWEnO1xuaW1wb3J0IHsgY2FjaGVTZXJ2aWNlLCBDQUNIRV9DT05GSUcgfSBmcm9tICdAL2xpYi9jYWNoZSc7XG5cbi8vIFNlY3JldCBrZXkgZm9yIEpXVCAtIHNob3VsZCBiZSBtb3ZlZCB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW4gcHJvZHVjdGlvblxuY29uc3QgSldUX1NFQ1JFVCA9IHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgfHwgJ3lvdXItc2VjcmV0LWtleSc7XG4vLyBDaGFuZ2VkIHRva2VuIGV4cGlyYXRpb24gdG8gMTJoIChmcm9tIDI0aCkgZm9yIGJldHRlciBzZWN1cml0eVxuY29uc3QgSldUX0VYUElSRVNfSU4gPSBwcm9jZXNzLmVudi5KV1RfQUNDRVNTX1RPS0VOX0VYUElSRVNfSU4gfHwgJzEyaCc7XG5cbi8qKlxuICogUGFyc2VzIGEgdGltZSBzdHJpbmcgbGlrZSBcIjE1bVwiLCBcIjJoXCIsIFwiMWRcIiBpbnRvIHNlY29uZHMuXG4gKiBAcGFyYW0gdGltZVN0ciBUaGUgdGltZSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHNlY29uZHMsIG9yIDAgaWYgcGFyc2luZyBmYWlscy5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcyA9ICh0aW1lU3RyOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGlmICghdGltZVN0cikgcmV0dXJuIDA7XG4gICAgY29uc3QgbGFzdENoYXIgPSB0aW1lU3RyLnNsaWNlKC0xKTtcbiAgICBjb25zdCBudW0gPSBwYXJzZUludCh0aW1lU3RyLnNsaWNlKDAsIC0xKSk7XG5cbiAgICBpZiAoaXNOYU4obnVtKSkgcmV0dXJuIDA7XG5cbiAgICBzd2l0Y2ggKGxhc3RDaGFyKSB7XG4gICAgICAgIGNhc2UgJ3MnOiByZXR1cm4gbnVtO1xuICAgICAgICBjYXNlICdtJzogcmV0dXJuIG51bSAqIDYwO1xuICAgICAgICBjYXNlICdoJzogcmV0dXJuIG51bSAqIDYwICogNjA7XG4gICAgICAgIGNhc2UgJ2QnOiByZXR1cm4gbnVtICogNjAgKiA2MCAqIDI0O1xuICAgICAgICBkZWZhdWx0OiAvLyBJZiBubyB1bml0LCBhc3N1bWUgc2Vjb25kcyBpZiBpdCdzIGp1c3QgYSBudW1iZXIgc3RyaW5nXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHRpbWVTdHIpKSkgcmV0dXJuIHBhcnNlSW50KHRpbWVTdHIpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuaW50ZXJmYWNlIFRva2VuUGF5bG9hZCB7XG4gICAgc3ViOiBudW1iZXI7IC8vIFVzZXIgSUQgYXMgJ3N1YicgY2xhaW1cbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgcm9sZUlkOiBudW1iZXI7XG4gICAgc2hvcElkPzogbnVtYmVyIHwgbnVsbDtcbiAgICBwZXJtaXNzaW9ucz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZSBhIHVzZXIgd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgKG9wdGltaXplZCB3aXRoIHNpbmdsZSBxdWVyeSlcbiAqL1xuZXhwb3J0IGNvbnN0IGF1dGhlbnRpY2F0ZVVzZXIgPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUudGltZSgndXNlciBhdXRoZW50aWNhdGlvbiBxdWVyeScpO1xuICAgICAgICAvLyBPcHRpbWl6ZWQgc2luZ2xlIHF1ZXJ5IHVzaW5nIHRoZSBuZXcgY29tcG9zaXRlIGluZGV4XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgcm9sZToge1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDogeyBuYW1lOiB0cnVlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgndXNlciBhdXRoZW50aWNhdGlvbiBxdWVyeScpO1xuXG4gICAgICAgIC8vIElmIHVzZXIgbm90IGZvdW5kXG4gICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgcGFzc3dvcmRcbiAgICAgICAgY29uc3QgaXNQYXNzd29yZFZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUocGFzc3dvcmQsIHVzZXIucGFzc3dvcmQpO1xuICAgICAgICBpZiAoIWlzUGFzc3dvcmRWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgcGVybWlzc2lvbnMgZnJvbSByb2xlIChoYW5kbGUgY2FzZSB3aGVyZSB1c2VyIGhhcyBubyByb2xlKVxuICAgICAgICBsZXQgcGVybWlzc2lvbnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmICh1c2VyLnJvbGU/LnBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgICBwZXJtaXNzaW9ucyA9IHVzZXIucm9sZS5wZXJtaXNzaW9ucy5tYXAocCA9PiBwLm5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHVzZXIucGVybWlzc2lvbnMgJiYgQXJyYXkuaXNBcnJheSh1c2VyLnBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSBmb3IgXCJBTExcIiBwZXJtaXNzaW9uc1xuICAgICAgICAgICAgaWYgKHVzZXIucGVybWlzc2lvbnMuaW5jbHVkZXMoJ0FMTCcpKSB7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnMgPSBbJ0FMTCddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHBlcm1pc3Npb24gSURzIHRvIG5hbWVzLCBmaWx0ZXJpbmcgb3V0IGludmFsaWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRQZXJtaXNzaW9uSWRzID0gdXNlci5wZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAubWFwKGlkID0+IHBhcnNlSW50KGlkLnRvU3RyaW5nKCkpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGlkID0+ICFpc05hTihpZCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh2YWxpZFBlcm1pc3Npb25JZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uUmVjb3JkcyA9IGF3YWl0IHByaXNtYS5wZXJtaXNzaW9uLmZpbmRNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW46IHZhbGlkUGVybWlzc2lvbklkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25SZWNvcmRzLm1hcChwID0+IHAubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgSldUIHRva2VuXG4gICAgICAgIGNvbnN0IHRva2VuID0gZ2VuZXJhdGVUb2tlbih7XG4gICAgICAgICAgICBzdWI6IHVzZXIuaWQsXG4gICAgICAgICAgICB1c2VybmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgICAgICByb2xlSWQ6IHVzZXIucm9sZUlkLFxuICAgICAgICAgICAgc2hvcElkOiB1c2VyLnNob3BJZCxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVzZXJTZXNzaW9uID0ge1xuICAgICAgICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICB1c2VybmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgZnVsbE5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgICAgcm9sZUlkOiB1c2VyLnJvbGVJZCxcbiAgICAgICAgICAgIHJvbGVOYW1lOiB1c2VyLnJvbGU/Lm5hbWUgfHwgdXNlci5yb2xlTmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgc2hvcElkOiB1c2VyLnNob3BJZCxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgICAgICAgcm9sZTogdXNlci5yb2xlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FjaGUgdXNlciBzZXNzaW9uIGZvciBmYXN0ZXIgc3Vic2VxdWVudCByZXF1ZXN0c1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGNhY2hlU2VydmljZS5nZW5lcmF0ZUtleShDQUNIRV9DT05GSUcuS0VZUy5VU0VSX1NFU1NJT04sIHsgdXNlcklkOiB1c2VyLmlkIH0pO1xuICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KGNhY2hlS2V5LCB1c2VyU2Vzc2lvbiwgQ0FDSEVfQ09ORklHLlRUTC5VU0VSX1NFU1NJT04pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgICAgICAgICBmdWxsTmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgICAgICAgIHJvbGVJZDogdXNlci5yb2xlSWQsXG4gICAgICAgICAgICAgICAgcm9sZU5hbWU6IHVzZXIucm9sZT8ubmFtZSB8fCB1c2VyLnJvbGVOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc2hvcElkOiB1c2VyLnNob3BJZCxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCdcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgSldUIHRva2VuXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVRva2VuID0gKHBheWxvYWQ6IFRva2VuUGF5bG9hZCkgPT4ge1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBKV1RfU0VDUkVULCB7IGV4cGlyZXNJbjogSldUX0VYUElSRVNfSU4gfSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhIEpXVCB0b2tlbiB3aXRoIGNhY2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHZlcmlmeVRva2VuID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAvLyBWYWxpZGF0ZSB0b2tlbiBpbnB1dFxuICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHJpbSgpID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2p3dCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSB0b2tlbiBpcyBsb25nIGVub3VnaCBmb3Igc3Vic3RyaW5nIG9wZXJhdGlvblxuICAgIGlmICh0b2tlbi5sZW5ndGggPCAyMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2p3dCBtYWxmb3JtZWQnKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdG9rZW5LZXkgPSBjYWNoZVNlcnZpY2UuZ2VuZXJhdGVLZXkoQ0FDSEVfQ09ORklHLktFWVMuVE9LRU5fVkFMSURBVElPTiwgeyB0b2tlbjogdG9rZW4uc3Vic3RyaW5nKDAsIDIwKSB9KTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0IGZvciB0b2tlbiB2YWxpZGF0aW9uIHJlc3VsdFxuICAgICAgICBjb25zdCBjYWNoZWRSZXN1bHQgPSBhd2FpdCBjYWNoZVNlcnZpY2UuZ2V0KHRva2VuS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdCBhcyBUb2tlblBheWxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgdG9rZW5cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGp3dC52ZXJpZnkodG9rZW4sIEpXVF9TRUNSRVQpIGFzIFRva2VuUGF5bG9hZDtcblxuICAgICAgICAvLyBDYWNoZSB0aGUgdmFsaWQgdG9rZW4gcGF5bG9hZCAoc2hvcnRlciBUVEwgZm9yIHNlY3VyaXR5KVxuICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KHRva2VuS2V5LCBwYXlsb2FkLCBDQUNIRV9DT05GSUcuVFRMLlRPS0VOX1ZBTElEQVRJT04pO1xuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIExvZyB0aGUgZXJyb3IgaGVyZSBpZiBkZXNpcmVkXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGp3dC5Ub2tlbkV4cGlyZWRFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gZXhwaXJlZCBkdXJpbmcgdmVyaWZpY2F0aW9uOicsIGVycm9yLmV4cGlyZWRBdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBqd3QuSnNvbldlYlRva2VuRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdG9rZW4gZHVyaW5nIHZlcmlmaWNhdGlvbjonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vua25vd24gdG9rZW4gdmVyaWZpY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgdGhlIGVycm9yXG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHRva2VuIGhhcyBhIHNwZWNpZmljIHBlcm1pc3Npb24gd2l0aCBjYWNoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNQZXJtaXNzaW9uID0gYXN5bmMgKHRva2VuUGF5bG9hZDogVG9rZW5QYXlsb2FkLCBwZXJtaXNzaW9uOiBzdHJpbmcpID0+IHtcbiAgICAvLyBJbXBvcnQgdGhlIHByb3BlciBwZXJtaXNzaW9uIGNoZWNraW5nIHV0aWxpdHlcbiAgICBjb25zdCB7IGhhc1Blcm1pc3Npb246IGNoZWNrUGVybWlzc2lvbiB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi91dGlscy9wZXJtaXNzaW9ucycpO1xuICAgIFxuICAgIC8vIFF1aWNrIGNoZWNrIGZyb20gdG9rZW4gcGF5bG9hZCBmaXJzdFxuICAgIGlmICh0b2tlblBheWxvYWQucGVybWlzc2lvbnMpIHtcbiAgICAgICAgaWYgKGNoZWNrUGVybWlzc2lvbih0b2tlblBheWxvYWQucGVybWlzc2lvbnMsIHBlcm1pc3Npb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBpbiB0b2tlbiwgY2hlY2sgY2FjaGVkIHVzZXIgcGVybWlzc2lvbnNcbiAgICBjb25zdCBwZXJtaXNzaW9uc0NhY2hlS2V5ID0gY2FjaGVTZXJ2aWNlLmdlbmVyYXRlS2V5KENBQ0hFX0NPTkZJRy5LRVlTLlVTRVJfUEVSTUlTU0lPTlMsIHsgdXNlcklkOiB0b2tlblBheWxvYWQuc3ViIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGVkUGVybWlzc2lvbnMgPSBhd2FpdCBjYWNoZVNlcnZpY2UuZ2V0KHBlcm1pc3Npb25zQ2FjaGVLZXkpO1xuICAgICAgICBpZiAoY2FjaGVkUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1Blcm1pc3Npb24oY2FjaGVkUGVybWlzc2lvbnMsIHBlcm1pc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZGF0YWJhc2UgcXVlcnkgaWYgbm90IGNhY2hlZFxuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJpc21hLnVzZXIuZmluZEZpcnN0KHtcbiAgICAgICAgICAgIHdoZXJlOiB7IGlkOiB0b2tlblBheWxvYWQuc3ViLCBpc0FjdGl2ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHsgc2VsZWN0OiB7IG5hbWU6IHRydWUgfSB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHVzZXIucm9sZS5wZXJtaXNzaW9ucy5tYXAocCA9PiBwLm5hbWUpO1xuICAgICAgICAgICAgLy8gQ2FjaGUgcGVybWlzc2lvbnMgZm9yIGZ1dHVyZSBjaGVja3NcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlU2VydmljZS5zZXQocGVybWlzc2lvbnNDYWNoZUtleSwgcGVybWlzc2lvbnMsIENBQ0hFX0NPTkZJRy5UVEwuVVNFUl9QRVJNSVNTSU9OUyk7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJtaXNzaW9uKHBlcm1pc3Npb25zLCBwZXJtaXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHBlcm1pc3Npb25zOicsIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEdldCB1c2VyIGRldGFpbHMgZnJvbSBhIGRlY29kZWQgdG9rZW4gcGF5bG9hZCB3aXRoIGNhY2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQgPSBhc3luYyAocGF5bG9hZDogVG9rZW5QYXlsb2FkIHwgbnVsbCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkIHJlY2VpdmVkIHBheWxvYWQ6JywgcGF5bG9hZCk7XG5cbiAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCB0b2tlbiBwYXlsb2FkIHByb3ZpZGVkIHRvIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFwYXlsb2FkLnN1Yikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiBwYXlsb2FkIG1pc3NpbmcgdXNlciBJRCAoc3ViIGNsYWltKScpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VySWQgPSBwYXlsb2FkLnN1YjtcbiAgICBjb25zdCBjYWNoZUtleSA9IGNhY2hlU2VydmljZS5nZW5lcmF0ZUtleShDQUNIRV9DT05GSUcuS0VZUy5VU0VSX1NFU1NJT04sIHsgdXNlcklkIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCB1c2VyIGZyb20gY2FjaGUgZmlyc3RcbiAgICAgICAgY29uc3QgY2FjaGVkVXNlciA9IGF3YWl0IGNhY2hlU2VydmljZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoY2FjaGVkVXNlcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgZm91bmQgaW4gY2FjaGU6JywgdXNlcklkKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0xvb2tpbmcgdXAgdXNlciB3aXRoIElEOicsIHVzZXJJZCk7XG4gICAgICAgIGNvbnNvbGUudGltZSgncHJpc21hLnVzZXIuZmluZEZpcnN0IGZvciBhdXRoJyk7IC8vIFN0YXJ0IHRpbWVyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICBpZDogdXNlcklkLFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ3ByaXNtYS51c2VyLmZpbmRGaXJzdCBmb3IgYXV0aCcpOyAvLyBFbmQgdGltZXJcblxuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VzZXIgbm90IGZvdW5kIGZvciBJRDonLCB1c2VySWQpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1c2VyV2l0aFBlcm1pc3Npb25zID0ge1xuICAgICAgICAgICAgLi4udXNlcixcbiAgICAgICAgICAgIHJvbGVOYW1lOiB1c2VyLnJvbGUubmFtZSxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zOiB1c2VyLnJvbGUucGVybWlzc2lvbnMubWFwKHAgPT4gcC5uYW1lKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSB1c2VyIHNlc3Npb25cbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldChjYWNoZUtleSwgdXNlcldpdGhQZXJtaXNzaW9ucywgQ0FDSEVfQ09ORklHLlRUTC5VU0VSX1NFU1NJT04pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIGZvdW5kIGFuZCBjYWNoZWQ6JywgdXNlci5pZCwgdXNlci5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHVzZXJXaXRoUGVybWlzc2lvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGZyb20gZGVjb2RlZCBwYXlsb2FkOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgdXNlciBkZXRhaWxzIGZyb20gdG9rZW4gKExlZ2FjeSAtIGNvbnNpZGVyIHBoYXNpbmcgb3V0IG9yIHJlZmFjdG9yaW5nKVxuICogVGhpcyBmdW5jdGlvbiBub3cgY2FsbHMgdmVyaWZ5VG9rZW4gYW5kIHRoZW4gZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVzZXJGcm9tVG9rZW4gPSBhc3luYyAodG9rZW46IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB2ZXJpZnlUb2tlbih0b2tlbik7XG4gICAgcmV0dXJuIGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQocGF5bG9hZCk7XG59OyJdLCJuYW1lcyI6WyJhdXRoZW50aWNhdGVVc2VyIiwiZ2VuZXJhdGVUb2tlbiIsImdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQiLCJnZXRVc2VyRnJvbVRva2VuIiwiaGFzUGVybWlzc2lvbiIsInBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcyIsInZlcmlmeVRva2VuIiwiSldUX1NFQ1JFVCIsInByb2Nlc3MiLCJlbnYiLCJKV1RfRVhQSVJFU19JTiIsIkpXVF9BQ0NFU1NfVE9LRU5fRVhQSVJFU19JTiIsInRpbWVTdHIiLCJsYXN0Q2hhciIsInNsaWNlIiwibnVtIiwicGFyc2VJbnQiLCJpc05hTiIsImVtYWlsIiwicGFzc3dvcmQiLCJjb25zb2xlIiwidGltZSIsInVzZXIiLCJwcmlzbWEiLCJmaW5kRmlyc3QiLCJ3aGVyZSIsImlzQWN0aXZlIiwiaW5jbHVkZSIsInJvbGUiLCJwZXJtaXNzaW9ucyIsInNlbGVjdCIsIm5hbWUiLCJ0aW1lRW5kIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJpc1Bhc3N3b3JkVmFsaWQiLCJiY3J5cHQiLCJjb21wYXJlIiwibWFwIiwicCIsIkFycmF5IiwiaXNBcnJheSIsImluY2x1ZGVzIiwidmFsaWRQZXJtaXNzaW9uSWRzIiwiaWQiLCJ0b1N0cmluZyIsImZpbHRlciIsImxlbmd0aCIsInBlcm1pc3Npb25SZWNvcmRzIiwicGVybWlzc2lvbiIsImZpbmRNYW55IiwiaW4iLCJ0b2tlbiIsInN1YiIsInVzZXJuYW1lIiwicm9sZUlkIiwic2hvcElkIiwidXNlclNlc3Npb24iLCJmdWxsTmFtZSIsInJvbGVOYW1lIiwiY2FjaGVLZXkiLCJjYWNoZVNlcnZpY2UiLCJnZW5lcmF0ZUtleSIsIkNBQ0hFX0NPTkZJRyIsIktFWVMiLCJVU0VSX1NFU1NJT04iLCJ1c2VySWQiLCJzZXQiLCJUVEwiLCJlcnJvciIsInBheWxvYWQiLCJqd3QiLCJzaWduIiwiZXhwaXJlc0luIiwidHJpbSIsIkVycm9yIiwidG9rZW5LZXkiLCJUT0tFTl9WQUxJREFUSU9OIiwic3Vic3RyaW5nIiwiY2FjaGVkUmVzdWx0IiwiZ2V0IiwidmVyaWZ5IiwiVG9rZW5FeHBpcmVkRXJyb3IiLCJleHBpcmVkQXQiLCJKc29uV2ViVG9rZW5FcnJvciIsInRva2VuUGF5bG9hZCIsImNoZWNrUGVybWlzc2lvbiIsInBlcm1pc3Npb25zQ2FjaGVLZXkiLCJVU0VSX1BFUk1JU1NJT05TIiwiY2FjaGVkUGVybWlzc2lvbnMiLCJsb2ciLCJjYWNoZWRVc2VyIiwidXNlcldpdGhQZXJtaXNzaW9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7SUE2Q2FBLGdCQUFnQjtlQUFoQkE7O0lBc0hBQyxhQUFhO2VB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