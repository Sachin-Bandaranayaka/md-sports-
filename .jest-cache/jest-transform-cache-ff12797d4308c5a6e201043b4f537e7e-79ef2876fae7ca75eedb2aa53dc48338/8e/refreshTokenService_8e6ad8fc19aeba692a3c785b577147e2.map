{"version":3,"sources":["/Users/sachin/Documents/md-sports-/src/services/refreshTokenService.ts"],"sourcesContent":["import prisma from '@/lib/prisma';\n\n// Configuration\nconst REFRESH_TOKEN_EXPIRES_IN_DAYS = 30;\n\n// Generate a secure random token using Web Crypto API\nconst generateSecureToken = (length = 40): string => {\n    // Use Web Crypto API which is supported in Edge Runtime\n    if (typeof crypto !== 'undefined') {\n        const bytes = new Uint8Array(length);\n        crypto.getRandomValues(bytes);\n        return Array.from(bytes)\n            .map(byte => byte.toString(16).padStart(2, '0'))\n            .join('');\n    }\n\n    // Fallback (less secure but works everywhere)\n    return Array.from(\n        { length },\n        () => Math.floor(Math.random() * 16).toString(16)\n    ).join('');\n};\n\n/**\n * Generate a new refresh token for a user\n */\nexport const generateRefreshToken = async (userId: number): Promise<string> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            throw new Error('Database client not initialized correctly');\n        }\n\n        // Log for debugging\n        console.log('Generating refresh token for user ID:', userId);\n\n        // Generate a random token\n        const token = generateSecureToken(40);\n\n        // Calculate expiration date (30 days from now)\n        const expiresAt = new Date();\n        expiresAt.setDate(expiresAt.getDate() + REFRESH_TOKEN_EXPIRES_IN_DAYS);\n\n        // Log the token details before creating\n        console.log('Preparing to create refresh token with:', {\n            userId,\n            token: token.substring(0, 10) + '...',\n            expiresAt,\n        });\n\n        // Store the token in the database\n        const createdToken = await prisma.refreshToken.create({\n            data: {\n                userId,\n                token,\n                expiresAt,\n                updatedAt: new Date(),\n            },\n        });\n\n        console.log('Successfully created refresh token with ID:', createdToken.id);\n\n        return token;\n    } catch (error) {\n        // More detailed error logging\n        console.error('Error generating refresh token:', error);\n        if (error instanceof Error) {\n            console.error('Error message:', error.message);\n            console.error('Error stack:', error.stack);\n        }\n        throw new Error('Failed to generate refresh token');\n    }\n};\n\n/**\n * Verify a refresh token and return the associated user ID if valid\n */\nexport const verifyRefreshToken = async (token: string): Promise<number | null> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return null;\n        }\n\n        // Find the token in the database\n        const refreshToken = await prisma.refreshToken.findUnique({\n            where: { token },\n        });\n\n        // Check if token exists and is not revoked\n        if (!refreshToken || refreshToken.isRevoked) {\n            console.log('Token not found or revoked:', token.substring(0, 10) + '...');\n            return null;\n        }\n\n        // Check if token is expired\n        if (new Date() > refreshToken.expiresAt) {\n            console.log('Token expired:', token.substring(0, 10) + '...');\n\n            // Revoke expired token\n            await prisma.refreshToken.update({\n                where: { id: refreshToken.id },\n                data: { isRevoked: true },\n            });\n\n            return null;\n        }\n\n        return refreshToken.userId;\n    } catch (error) {\n        console.error('Error verifying refresh token:', error);\n        return null;\n    }\n};\n\n/**\n * Revoke a specific refresh token\n */\nexport const revokeRefreshToken = async (token: string): Promise<boolean> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return false;\n        }\n\n        await prisma.refreshToken.updateMany({\n            where: { token },\n            data: { isRevoked: true },\n        });\n\n        return true;\n    } catch (error) {\n        console.error('Error revoking refresh token:', error);\n        return false;\n    }\n};\n\n/**\n * Revoke all refresh tokens for a specific user\n */\nexport const revokeAllUserRefreshTokens = async (userId: number): Promise<boolean> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return false;\n        }\n\n        await prisma.refreshToken.updateMany({\n            where: { userId },\n            data: { isRevoked: true },\n        });\n\n        return true;\n    } catch (error) {\n        console.error('Error revoking user refresh tokens:', error);\n        return false;\n    }\n};\n\n/**\n * Clean up expired and revoked tokens\n * Note: This should be run periodically via a cron job\n */\nexport const cleanupRefreshTokens = async (): Promise<void> => {\n    try {\n        // Verify prisma client is initialized\n        if (!prisma || !prisma.refreshToken) {\n            console.error('Prisma client or RefreshToken model not available');\n            return;\n        }\n\n        const now = new Date();\n\n        await prisma.refreshToken.deleteMany({\n            where: {\n                OR: [\n                    { expiresAt: { lt: now } },\n                    { isRevoked: true },\n                ],\n            },\n        });\n    } catch (error) {\n        console.error('Error cleaning up refresh tokens:', error);\n    }\n}; "],"names":["cleanupRefreshTokens","generateRefreshToken","revokeAllUserRefreshTokens","revokeRefreshToken","verifyRefreshToken","REFRESH_TOKEN_EXPIRES_IN_DAYS","generateSecureToken","length","crypto","bytes","Uint8Array","getRandomValues","Array","from","map","byte","toString","padStart","join","Math","floor","random","userId","prisma","refreshToken","console","error","Error","log","token","expiresAt","Date","setDate","getDate","substring","createdToken","create","data","updatedAt","id","message","stack","findUnique","where","isRevoked","update","updateMany","now","deleteMany","OR","lt"],"mappings":"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"}