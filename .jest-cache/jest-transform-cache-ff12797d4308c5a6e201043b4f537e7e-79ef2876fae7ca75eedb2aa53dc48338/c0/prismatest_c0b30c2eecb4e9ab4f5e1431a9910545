9f1e752dba61532eccb1e1a3545dbda9
// Unit tests for Prisma utilities
// Testing the safeQuery helper function and Prisma client configuration
"use strict";
// Mock the PrismaClient constructor
jest.mock("@prisma/client", ()=>({
        PrismaClient: jest.fn().mockImplementation(()=>mockPrismaClient)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _client = require("@prisma/client");
// Mock PrismaClient
const mockPrismaClient = {
    $connect: jest.fn(),
    $disconnect: jest.fn(),
    user: {
        findMany: jest.fn(),
        findUnique: jest.fn(),
        create: jest.fn(),
        update: jest.fn(),
        delete: jest.fn()
    },
    shop: {
        findMany: jest.fn(),
        findUnique: jest.fn(),
        create: jest.fn(),
        update: jest.fn(),
        delete: jest.fn()
    }
};
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Prisma Utilities", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("PrismaClient Configuration", ()=>{
        it("should create PrismaClient with configuration", ()=>{
            // Re-import to trigger constructor
            jest.resetModules();
            require("@/lib/prisma");
            expect(_client.PrismaClient).toHaveBeenCalled();
            expect(_client.PrismaClient).toHaveBeenCalledWith(expect.objectContaining({
                datasources: expect.any(Object),
                log: expect.any(Array),
                errorFormat: expect.any(String)
            }));
        });
    });
    describe("safeQuery function (isolated implementation)", ()=>{
        // Isolated implementation of safeQuery matching the actual implementation
        const safeQuery = async (queryFn, fallback, logMessage = "Database operation failed")=>{
            try {
                return await queryFn();
            } catch (error) {
                console.error(`${logMessage}:`, error);
                return fallback;
            }
        };
        it("should return result for successful operation", async ()=>{
            const mockOperation = jest.fn().mockResolvedValue({
                id: 1,
                name: "Test User"
            });
            const result = await safeQuery(mockOperation, null, "Find user");
            expect(result).toEqual({
                id: 1,
                name: "Test User"
            });
            expect(mockOperation).toHaveBeenCalledTimes(1);
            expect(consoleSpy.error).not.toHaveBeenCalled();
        });
        it("should return fallback and log error for failed operation", async ()=>{
            const mockError = new Error("Database connection failed");
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            const result = await safeQuery(mockOperation, null, "Find user failed");
            expect(result).toBeNull();
            expect(mockOperation).toHaveBeenCalledTimes(1);
            expect(consoleSpy.error).toHaveBeenCalledWith("Find user failed:", mockError);
        });
        it("should handle database errors with fallback", async ()=>{
            const mockError = {
                code: "P2002",
                message: "Unique constraint failed"
            };
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            const fallbackValue = {
                error: "Operation failed"
            };
            const result = await safeQuery(mockOperation, fallbackValue, "Create user failed");
            expect(result).toEqual(fallbackValue);
            expect(consoleSpy.error).toHaveBeenCalledWith("Create user failed:", mockError);
        });
        it("should use default log message when none provided", async ()=>{
            const mockError = new Error("Generic error");
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            const result = await safeQuery(mockOperation, "default");
            expect(result).toBe("default");
            expect(consoleSpy.error).toHaveBeenCalledWith("Database operation failed:", mockError);
        });
        it("should handle different fallback types", async ()=>{
            const mockError = new Error("Operation failed");
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            // Test with array fallback
            const result1 = await safeQuery(mockOperation, [], "Array operation failed");
            expect(result1).toEqual([]);
            // Test with object fallback
            const result2 = await safeQuery(mockOperation, {
                error: true
            }, "Object operation failed");
            expect(result2).toEqual({
                error: true
            });
            // Test with number fallback
            const result3 = await safeQuery(mockOperation, 0, "Number operation failed");
            expect(result3).toBe(0);
        });
        it("should handle async operations correctly", async ()=>{
            const mockData = {
                id: 1,
                name: "Async User"
            };
            const mockOperation = jest.fn().mockImplementation(()=>new Promise((resolve)=>setTimeout(()=>resolve(mockData), 10)));
            const result = await safeQuery(mockOperation, null, "Async operation");
            expect(result).toEqual(mockData);
            expect(mockOperation).toHaveBeenCalledTimes(1);
        });
        it("should preserve error objects in logs", async ()=>{
            const mockError = {
                code: "P2002",
                message: "Unique constraint failed",
                meta: {
                    target: [
                        "email"
                    ]
                }
            };
            const mockOperation = jest.fn().mockRejectedValue(mockError);
            const result = await safeQuery(mockOperation, null, "Constraint error");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Constraint error:", mockError);
        });
    });
    describe("Database Operations with safeQuery", ()=>{
        // Use the actual safeQuery implementation for integration testing
        const safeQuery = async (queryFn, fallback, logMessage = "Database operation failed")=>{
            try {
                return await queryFn();
            } catch (error) {
                console.error(`${logMessage}:`, error);
                return fallback;
            }
        };
        it("should safely execute user findMany operation", async ()=>{
            const mockUsers = [
                {
                    id: 1,
                    name: "User 1"
                },
                {
                    id: 2,
                    name: "User 2"
                }
            ];
            mockPrismaClient.user.findMany.mockResolvedValue(mockUsers);
            const result = await safeQuery(()=>mockPrismaClient.user.findMany(), [], "Find all users");
            expect(result).toEqual(mockUsers);
            expect(mockPrismaClient.user.findMany).toHaveBeenCalledTimes(1);
        });
        it("should safely execute user create operation", async ()=>{
            const newUser = {
                id: 1,
                name: "New User",
                email: "new@example.com"
            };
            mockPrismaClient.user.create.mockResolvedValue(newUser);
            const result = await safeQuery(()=>mockPrismaClient.user.create({
                    data: {
                        name: "New User",
                        email: "new@example.com"
                    }
                }), null, "Create user");
            expect(result).toEqual(newUser);
            expect(mockPrismaClient.user.create).toHaveBeenCalledWith({
                data: {
                    name: "New User",
                    email: "new@example.com"
                }
            });
        });
        it("should safely execute shop operations", async ()=>{
            const mockShop = {
                id: "shop1",
                name: "Test Shop"
            };
            mockPrismaClient.shop.findUnique.mockResolvedValue(mockShop);
            const result = await safeQuery(()=>mockPrismaClient.shop.findUnique({
                    where: {
                        id: "shop1"
                    }
                }), null, "Find shop");
            expect(result).toEqual(mockShop);
            expect(mockPrismaClient.shop.findUnique).toHaveBeenCalledWith({
                where: {
                    id: "shop1"
                }
            });
        });
        it("should return fallback when operation fails", async ()=>{
            const mockError = new Error("Database error");
            mockPrismaClient.user.findUnique.mockRejectedValue(mockError);
            const result = await safeQuery(()=>mockPrismaClient.user.findUnique({
                    where: {
                        id: 999
                    }
                }), null, "Find non-existent user");
            expect(result).toBeNull();
            expect(consoleSpy.error).toHaveBeenCalledWith("Find non-existent user:", mockError);
        });
    });
    describe("Prisma Client Lifecycle", ()=>{
        it("should handle connection operations", async ()=>{
            mockPrismaClient.$connect.mockResolvedValue(undefined);
            await mockPrismaClient.$connect();
            expect(mockPrismaClient.$connect).toHaveBeenCalledTimes(1);
        });
        it("should handle disconnection operations", async ()=>{
            mockPrismaClient.$disconnect.mockResolvedValue(undefined);
            await mockPrismaClient.$disconnect();
            expect(mockPrismaClient.$disconnect).toHaveBeenCalledTimes(1);
        });
        it("should handle connection errors", async ()=>{
            const connectionError = new Error("Connection failed");
            mockPrismaClient.$connect.mockRejectedValue(connectionError);
            await expect(mockPrismaClient.$connect()).rejects.toThrow("Connection failed");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9wcmlzbWEudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbml0IHRlc3RzIGZvciBQcmlzbWEgdXRpbGl0aWVzXG4vLyBUZXN0aW5nIHRoZSBzYWZlUXVlcnkgaGVscGVyIGZ1bmN0aW9uIGFuZCBQcmlzbWEgY2xpZW50IGNvbmZpZ3VyYXRpb25cblxuaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSAnQHByaXNtYS9jbGllbnQnO1xuXG4vLyBNb2NrIFByaXNtYUNsaWVudFxuY29uc3QgbW9ja1ByaXNtYUNsaWVudCA9IHtcbiAgJGNvbm5lY3Q6IGplc3QuZm4oKSxcbiAgJGRpc2Nvbm5lY3Q6IGplc3QuZm4oKSxcbiAgdXNlcjoge1xuICAgIGZpbmRNYW55OiBqZXN0LmZuKCksXG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpLFxuICAgIGNyZWF0ZTogamVzdC5mbigpLFxuICAgIHVwZGF0ZTogamVzdC5mbigpLFxuICAgIGRlbGV0ZTogamVzdC5mbigpLFxuICB9LFxuICBzaG9wOiB7XG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgICBmaW5kVW5pcXVlOiBqZXN0LmZuKCksXG4gICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gICAgdXBkYXRlOiBqZXN0LmZuKCksXG4gICAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIH0sXG59O1xuXG4vLyBNb2NrIHRoZSBQcmlzbWFDbGllbnQgY29uc3RydWN0b3Jcbmplc3QubW9jaygnQHByaXNtYS9jbGllbnQnLCAoKSA9PiAoe1xuICBQcmlzbWFDbGllbnQ6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja1ByaXNtYUNsaWVudCksXG59KSk7XG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBjb25zb2xlU3B5ID0ge1xuICBsb2c6IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIGVycm9yOiBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIHdhcm46IGplc3Quc3B5T24oY29uc29sZSwgJ3dhcm4nKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pLFxufTtcblxuZGVzY3JpYmUoJ1ByaXNtYSBVdGlsaXRpZXMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkuZXJyb3IubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgY29uc29sZVNweS5sb2cubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcmlzbWFDbGllbnQgQ29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBQcmlzbWFDbGllbnQgd2l0aCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgLy8gUmUtaW1wb3J0IHRvIHRyaWdnZXIgY29uc3RydWN0b3JcbiAgICAgIGplc3QucmVzZXRNb2R1bGVzKCk7XG4gICAgICByZXF1aXJlKCdAL2xpYi9wcmlzbWEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KFByaXNtYUNsaWVudCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KFByaXNtYUNsaWVudCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBkYXRhc291cmNlczogZXhwZWN0LmFueShPYmplY3QpLFxuICAgICAgICAgIGxvZzogZXhwZWN0LmFueShBcnJheSksXG4gICAgICAgICAgZXJyb3JGb3JtYXQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzYWZlUXVlcnkgZnVuY3Rpb24gKGlzb2xhdGVkIGltcGxlbWVudGF0aW9uKScsICgpID0+IHtcbiAgICAvLyBJc29sYXRlZCBpbXBsZW1lbnRhdGlvbiBvZiBzYWZlUXVlcnkgbWF0Y2hpbmcgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHNhZmVRdWVyeSA9IGFzeW5jIDxUPihcbiAgICAgIHF1ZXJ5Rm46ICgpID0+IFByb21pc2U8VD4sXG4gICAgICBmYWxsYmFjazogVCxcbiAgICAgIGxvZ01lc3NhZ2UgPSAnRGF0YWJhc2Ugb3BlcmF0aW9uIGZhaWxlZCdcbiAgICApOiBQcm9taXNlPFQ+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBxdWVyeUZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2xvZ01lc3NhZ2V9OmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiByZXN1bHQgZm9yIHN1Y2Nlc3NmdWwgb3BlcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGlkOiAxLCBuYW1lOiAnVGVzdCBVc2VyJyB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KG1vY2tPcGVyYXRpb24sIG51bGwsICdGaW5kIHVzZXInKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IGlkOiAxLCBuYW1lOiAnVGVzdCBVc2VyJyB9KTtcbiAgICAgIGV4cGVjdChtb2NrT3BlcmF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbGxiYWNrIGFuZCBsb2cgZXJyb3IgZm9yIGZhaWxlZCBvcGVyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG1vY2tFcnJvcik7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCBudWxsLCAnRmluZCB1c2VyIGZhaWxlZCcpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KG1vY2tPcGVyYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0ZpbmQgdXNlciBmYWlsZWQ6JyxcbiAgICAgICAgbW9ja0Vycm9yXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIHdpdGggZmFsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSB7IGNvZGU6ICdQMjAwMicsIG1lc3NhZ2U6ICdVbmlxdWUgY29uc3RyYWludCBmYWlsZWQnIH07XG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG1vY2tFcnJvcik7XG4gICAgICBjb25zdCBmYWxsYmFja1ZhbHVlID0geyBlcnJvcjogJ09wZXJhdGlvbiBmYWlsZWQnIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCBmYWxsYmFja1ZhbHVlLCAnQ3JlYXRlIHVzZXIgZmFpbGVkJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZmFsbGJhY2tWYWx1ZSk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdDcmVhdGUgdXNlciBmYWlsZWQ6JyxcbiAgICAgICAgbW9ja0Vycm9yXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgZGVmYXVsdCBsb2cgbWVzc2FnZSB3aGVuIG5vbmUgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSBuZXcgRXJyb3IoJ0dlbmVyaWMgZXJyb3InKTtcbiAgICAgIGNvbnN0IG1vY2tPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobW9ja0Vycm9yKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KG1vY2tPcGVyYXRpb24sICdkZWZhdWx0Jyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ2RlZmF1bHQnKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0RhdGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQ6JyxcbiAgICAgICAgbW9ja0Vycm9yXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGlmZmVyZW50IGZhbGxiYWNrIHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yID0gbmV3IEVycm9yKCdPcGVyYXRpb24gZmFpbGVkJyk7XG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG1vY2tFcnJvcik7XG4gICAgICBcbiAgICAgIC8vIFRlc3Qgd2l0aCBhcnJheSBmYWxsYmFja1xuICAgICAgY29uc3QgcmVzdWx0MSA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCBbXSwgJ0FycmF5IG9wZXJhdGlvbiBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQxKS50b0VxdWFsKFtdKTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCB3aXRoIG9iamVjdCBmYWxsYmFja1xuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCB7IGVycm9yOiB0cnVlIH0sICdPYmplY3Qgb3BlcmF0aW9uIGZhaWxlZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdDIpLnRvRXF1YWwoeyBlcnJvcjogdHJ1ZSB9KTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCB3aXRoIG51bWJlciBmYWxsYmFja1xuICAgICAgY29uc3QgcmVzdWx0MyA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCAwLCAnTnVtYmVyIG9wZXJhdGlvbiBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQzKS50b0JlKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXN5bmMgb3BlcmF0aW9ucyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGF0YSA9IHsgaWQ6IDEsIG5hbWU6ICdBc3luYyBVc2VyJyB9O1xuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gXG4gICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKG1vY2tEYXRhKSwgMTApKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KG1vY2tPcGVyYXRpb24sIG51bGwsICdBc3luYyBvcGVyYXRpb24nKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrRGF0YSk7XG4gICAgICBleHBlY3QobW9ja09wZXJhdGlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSBlcnJvciBvYmplY3RzIGluIGxvZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3IgPSB7XG4gICAgICAgIGNvZGU6ICdQMjAwMicsXG4gICAgICAgIG1lc3NhZ2U6ICdVbmlxdWUgY29uc3RyYWludCBmYWlsZWQnLFxuICAgICAgICBtZXRhOiB7IHRhcmdldDogWydlbWFpbCddIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG1vY2tFcnJvcik7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShtb2NrT3BlcmF0aW9uLCBudWxsLCAnQ29uc3RyYWludCBlcnJvcicpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnQ29uc3RyYWludCBlcnJvcjonLFxuICAgICAgICBtb2NrRXJyb3JcbiAgICAgICk7XG4gICAgfSk7XG5cblxuXG5cblxuXG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEYXRhYmFzZSBPcGVyYXRpb25zIHdpdGggc2FmZVF1ZXJ5JywgKCkgPT4ge1xuICAgIC8vIFVzZSB0aGUgYWN0dWFsIHNhZmVRdWVyeSBpbXBsZW1lbnRhdGlvbiBmb3IgaW50ZWdyYXRpb24gdGVzdGluZ1xuICAgIGNvbnN0IHNhZmVRdWVyeSA9IGFzeW5jIDxUPihcbiAgICAgIHF1ZXJ5Rm46ICgpID0+IFByb21pc2U8VD4sXG4gICAgICBmYWxsYmFjazogVCxcbiAgICAgIGxvZ01lc3NhZ2UgPSAnRGF0YWJhc2Ugb3BlcmF0aW9uIGZhaWxlZCdcbiAgICApOiBQcm9taXNlPFQ+ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBxdWVyeUZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGAke2xvZ01lc3NhZ2V9OmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHNhZmVseSBleGVjdXRlIHVzZXIgZmluZE1hbnkgb3BlcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VzZXJzID0gW3sgaWQ6IDEsIG5hbWU6ICdVc2VyIDEnIH0sIHsgaWQ6IDIsIG5hbWU6ICdVc2VyIDInIH1dO1xuICAgICAgbW9ja1ByaXNtYUNsaWVudC51c2VyLmZpbmRNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2Vycyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShcbiAgICAgICAgKCkgPT4gbW9ja1ByaXNtYUNsaWVudC51c2VyLmZpbmRNYW55KCksXG4gICAgICAgIFtdLFxuICAgICAgICAnRmluZCBhbGwgdXNlcnMnXG4gICAgICApO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tVc2Vycyk7XG4gICAgICBleHBlY3QobW9ja1ByaXNtYUNsaWVudC51c2VyLmZpbmRNYW55KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNhZmVseSBleGVjdXRlIHVzZXIgY3JlYXRlIG9wZXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG5ld1VzZXIgPSB7IGlkOiAxLCBuYW1lOiAnTmV3IFVzZXInLCBlbWFpbDogJ25ld0BleGFtcGxlLmNvbScgfTtcbiAgICAgIG1vY2tQcmlzbWFDbGllbnQudXNlci5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUobmV3VXNlcik7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShcbiAgICAgICAgKCkgPT4gbW9ja1ByaXNtYUNsaWVudC51c2VyLmNyZWF0ZSh7XG4gICAgICAgICAgZGF0YTogeyBuYW1lOiAnTmV3IFVzZXInLCBlbWFpbDogJ25ld0BleGFtcGxlLmNvbScgfVxuICAgICAgICB9KSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgJ0NyZWF0ZSB1c2VyJ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChuZXdVc2VyKTtcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hQ2xpZW50LnVzZXIuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIGRhdGE6IHsgbmFtZTogJ05ldyBVc2VyJywgZW1haWw6ICduZXdAZXhhbXBsZS5jb20nIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzYWZlbHkgZXhlY3V0ZSBzaG9wIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2hvcCA9IHsgaWQ6ICdzaG9wMScsIG5hbWU6ICdUZXN0IFNob3AnIH07XG4gICAgICBtb2NrUHJpc21hQ2xpZW50LnNob3AuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU2hvcCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVRdWVyeShcbiAgICAgICAgKCkgPT4gbW9ja1ByaXNtYUNsaWVudC5zaG9wLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogJ3Nob3AxJyB9IH0pLFxuICAgICAgICBudWxsLFxuICAgICAgICAnRmluZCBzaG9wJ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrU2hvcCk7XG4gICAgICBleHBlY3QobW9ja1ByaXNtYUNsaWVudC5zaG9wLmZpbmRVbmlxdWUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgd2hlcmU6IHsgaWQ6ICdzaG9wMScgfSB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbGxiYWNrIHdoZW4gb3BlcmF0aW9uIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBlcnJvcicpO1xuICAgICAgbW9ja1ByaXNtYUNsaWVudC51c2VyLmZpbmRVbmlxdWUubW9ja1JlamVjdGVkVmFsdWUobW9ja0Vycm9yKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVF1ZXJ5KFxuICAgICAgICAoKSA9PiBtb2NrUHJpc21hQ2xpZW50LnVzZXIuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiA5OTkgfSB9KSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgJ0ZpbmQgbm9uLWV4aXN0ZW50IHVzZXInXG4gICAgICApO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdGaW5kIG5vbi1leGlzdGVudCB1c2VyOicsIG1vY2tFcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcmlzbWEgQ2xpZW50IExpZmVjeWNsZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25uZWN0aW9uIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJpc21hQ2xpZW50LiRjb25uZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBcbiAgICAgIGF3YWl0IG1vY2tQcmlzbWFDbGllbnQuJGNvbm5lY3QoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tQcmlzbWFDbGllbnQuJGNvbm5lY3QpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRpc2Nvbm5lY3Rpb24gb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tQcmlzbWFDbGllbnQuJGRpc2Nvbm5lY3QubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgYXdhaXQgbW9ja1ByaXNtYUNsaWVudC4kZGlzY29ubmVjdCgpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja1ByaXNtYUNsaWVudC4kZGlzY29ubmVjdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29ubmVjdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICBtb2NrUHJpc21hQ2xpZW50LiRjb25uZWN0Lm1vY2tSZWplY3RlZFZhbHVlKGNvbm5lY3Rpb25FcnJvcik7XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChtb2NrUHJpc21hQ2xpZW50LiRjb25uZWN0KCkpLnJlamVjdHMudG9UaHJvdygnQ29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJQcmlzbWFDbGllbnQiLCJmbiIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIm1vY2tQcmlzbWFDbGllbnQiLCIkY29ubmVjdCIsIiRkaXNjb25uZWN0IiwidXNlciIsImZpbmRNYW55IiwiZmluZFVuaXF1ZSIsImNyZWF0ZSIsInVwZGF0ZSIsImRlbGV0ZSIsInNob3AiLCJjb25zb2xlU3B5IiwibG9nIiwic3B5T24iLCJjb25zb2xlIiwiZXJyb3IiLCJ3YXJuIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsImFmdGVyQWxsIiwibW9ja1Jlc3RvcmUiLCJpdCIsInJlc2V0TW9kdWxlcyIsInJlcXVpcmUiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJvYmplY3RDb250YWluaW5nIiwiZGF0YXNvdXJjZXMiLCJhbnkiLCJPYmplY3QiLCJBcnJheSIsImVycm9yRm9ybWF0IiwiU3RyaW5nIiwic2FmZVF1ZXJ5IiwicXVlcnlGbiIsImZhbGxiYWNrIiwibG9nTWVzc2FnZSIsIm1vY2tPcGVyYXRpb24iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImlkIiwibmFtZSIsInJlc3VsdCIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJub3QiLCJtb2NrRXJyb3IiLCJFcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlIiwidG9CZU51bGwiLCJjb2RlIiwibWVzc2FnZSIsImZhbGxiYWNrVmFsdWUiLCJ0b0JlIiwicmVzdWx0MSIsInJlc3VsdDIiLCJyZXN1bHQzIiwibW9ja0RhdGEiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJtZXRhIiwidGFyZ2V0IiwibW9ja1VzZXJzIiwibmV3VXNlciIsImVtYWlsIiwiZGF0YSIsIm1vY2tTaG9wIiwid2hlcmUiLCJ1bmRlZmluZWQiLCJjb25uZWN0aW9uRXJyb3IiLCJyZWplY3RzIiwidG9UaHJvdyJdLCJtYXBwaW5ncyI6IkFBQUEsa0NBQWtDO0FBQ2xDLHdFQUF3RTs7QUF3QnhFLG9DQUFvQztBQUNwQ0EsS0FBS0MsSUFBSSxDQUFDLGtCQUFrQixJQUFPLENBQUE7UUFDakNDLGNBQWNGLEtBQUtHLEVBQUUsR0FBR0Msa0JBQWtCLENBQUMsSUFBTUM7SUFDbkQsQ0FBQTs7Ozt3QkF6QjZCO0FBRTdCLG9CQUFvQjtBQUNwQixNQUFNQSxtQkFBbUI7SUFDdkJDLFVBQVVOLEtBQUtHLEVBQUU7SUFDakJJLGFBQWFQLEtBQUtHLEVBQUU7SUFDcEJLLE1BQU07UUFDSkMsVUFBVVQsS0FBS0csRUFBRTtRQUNqQk8sWUFBWVYsS0FB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