8414d6ad602cf0bb540b9c70f871669b
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock NextResponse constructor
const NextResponse = {
    json: (data, init)=>({
            status: init?.status || 200,
            json: data
        })
};
// Mock implementations for testing
const mockPrisma = {
    user: {
        findUnique: jest.fn(),
        create: jest.fn(),
        findMany: jest.fn(),
        update: jest.fn(),
        delete: jest.fn()
    },
    product: {
        findMany: jest.fn(),
        findUnique: jest.fn(),
        create: jest.fn(),
        update: jest.fn(),
        delete: jest.fn()
    },
    shop: {
        findUnique: jest.fn(),
        create: jest.fn()
    },
    refreshToken: {
        create: jest.fn(),
        findUnique: jest.fn(),
        delete: jest.fn()
    },
    $disconnect: jest.fn()
};
// Mock API handlers
const authHandler = {
    POST: async (req)=>{
        const body = await req.json();
        const { email, password } = body;
        if (!email || !password) {
            return NextResponse.json({
                error: "Email and password are required"
            }, {
                status: 400
            });
        }
        // Find user
        const user = await mockPrisma.user.findUnique({
            where: {
                email
            }
        });
        if (!user) {
            return NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        // Verify password
        const isValid = await _bcryptjs.default.compare(password, user.password);
        if (!isValid) {
            return NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        // Generate token
        const token = _jsonwebtoken.default.sign({
            userId: user.id,
            email: user.email
        }, process.env.JWT_SECRET || "test-secret", {
            expiresIn: "1h"
        });
        return NextResponse.json({
            user: {
                id: user.id,
                email: user.email,
                name: user.name
            },
            token
        });
    }
};
const productsHandler = {
    GET: async (req)=>{
        const url = new URL(req.url);
        const shopId = url.searchParams.get("shopId");
        const page = parseInt(url.searchParams.get("page") || "1");
        const limit = parseInt(url.searchParams.get("limit") || "10");
        const search = url.searchParams.get("search");
        if (!shopId) {
            return NextResponse.json({
                error: "Shop ID is required"
            }, {
                status: 400
            });
        }
        // Build where clause
        const where = {
            shopId
        };
        if (search) {
            where.OR = [
                {
                    name: {
                        contains: search,
                        mode: "insensitive"
                    }
                },
                {
                    description: {
                        contains: search,
                        mode: "insensitive"
                    }
                },
                {
                    sku: {
                        contains: search,
                        mode: "insensitive"
                    }
                }
            ];
        }
        const products = await mockPrisma.product.findMany({
            where,
            skip: (page - 1) * limit,
            take: limit,
            orderBy: {
                createdAt: "desc"
            }
        });
        return NextResponse.json({
            products,
            pagination: {
                page,
                limit,
                total: products.length
            }
        });
    },
    POST: async (req)=>{
        const authHeader = req.headers.get("authorization");
        if (!authHeader?.startsWith("Bearer ")) {
            return NextResponse.json({
                error: "Unauthorized"
            }, {
                status: 401
            });
        }
        const token = authHeader.substring(7);
        try {
            _jsonwebtoken.default.verify(token, process.env.JWT_SECRET || "test-secret");
        } catch  {
            return NextResponse.json({
                error: "Invalid token"
            }, {
                status: 401
            });
        }
        const body = await req.json();
        const { name, description, price, sku, shopId } = body;
        // Validation
        if (!name || !price || !sku || !shopId) {
            return NextResponse.json({
                error: "Name, price, SKU, and shop ID are required"
            }, {
                status: 400
            });
        }
        if (price <= 0) {
            return NextResponse.json({
                error: "Price must be greater than 0"
            }, {
                status: 400
            });
        }
        // Check if SKU already exists
        const existingProduct = await mockPrisma.product.findUnique({
            where: {
                sku_shopId: {
                    sku,
                    shopId
                }
            }
        });
        if (existingProduct) {
            return NextResponse.json({
                error: "Product with this SKU already exists"
            }, {
                status: 409
            });
        }
        const product = await mockPrisma.product.create({
            data: {
                name,
                description,
                price,
                sku,
                shopId,
                createdAt: new Date(),
                updatedAt: new Date()
            }
        });
        return NextResponse.json(product, {
            status: 201
        });
    }
};
const userHandler = {
    GET: async (req)=>{
        const authHeader = req.headers.get("authorization");
        if (!authHeader?.startsWith("Bearer ")) {
            return NextResponse.json({
                error: "Unauthorized"
            }, {
                status: 401
            });
        }
        const token = authHeader.substring(7);
        let decoded;
        try {
            decoded = _jsonwebtoken.default.verify(token, process.env.JWT_SECRET || "test-secret");
        } catch  {
            return NextResponse.json({
                error: "Invalid token"
            }, {
                status: 401
            });
        }
        const user = await mockPrisma.user.findUnique({
            where: {
                id: decoded.userId
            },
            select: {
                id: true,
                email: true,
                name: true,
                permissions: true,
                shopId: true,
                isActive: true
            }
        });
        if (!user) {
            return NextResponse.json({
                error: "User not found"
            }, {
                status: 404
            });
        }
        return NextResponse.json({
            user
        });
    }
};
(0, _globals.describe)("API Routes Integration Tests", ()=>{
    (0, _globals.beforeAll)(()=>{
        process.env.JWT_SECRET = "test-secret";
    });
    (0, _globals.beforeEach)(()=>{
        jest.clearAllMocks();
    });
    (0, _globals.afterEach)(()=>{
        jest.resetAllMocks();
    });
    (0, _globals.afterAll)(async ()=>{
        await mockPrisma.$disconnect();
    });
    (0, _globals.describe)("POST /api/auth/login", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            password: "$2a$10$hashedPassword",
            name: "Test User",
            shopId: "shop-1"
        };
        (0, _globals.it)("should successfully login with valid credentials", async ()=>{
            // Arrange
            mockPrisma.user.findUnique.mockResolvedValue(mockUser);
            jest.spyOn(_bcryptjs.default, "compare").mockResolvedValue(true);
            jest.spyOn(_jsonwebtoken.default, "sign").mockReturnValue("mock-token");
            const request = new NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Act
            const response = await authHandler.POST(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(data).toEqual({
                user: {
                    id: 1,
                    email: "test@example.com",
                    name: "Test User"
                },
                token: "mock-token"
            });
            (0, _globals.expect)(mockPrisma.user.findUnique).toHaveBeenCalledWith({
                where: {
                    email: "test@example.com"
                }
            });
        });
        (0, _globals.it)("should return 400 for missing credentials", async ()=>{
            // Arrange
            const request = new NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: "test@example.com"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Act
            const response = await authHandler.POST(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(data.error).toBe("Email and password are required");
        });
        (0, _globals.it)("should return 401 for invalid credentials", async ()=>{
            // Arrange
            mockPrisma.user.findUnique.mockResolvedValue(null);
            const request = new NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: "nonexistent@example.com",
                    password: "password123"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Act
            const response = await authHandler.POST(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(data.error).toBe("Invalid credentials");
        });
        (0, _globals.it)("should return 401 for wrong password", async ()=>{
            // Arrange
            mockPrisma.user.findUnique.mockResolvedValue(mockUser);
            jest.spyOn(_bcryptjs.default, "compare").mockResolvedValue(false);
            const request = new NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "wrongpassword"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Act
            const response = await authHandler.POST(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(data.error).toBe("Invalid credentials");
        });
    });
    (0, _globals.describe)("GET /api/products", ()=>{
        const mockProducts = [
            {
                id: 1,
                name: "Product 1",
                description: "Description 1",
                price: 100,
                sku: "SKU001",
                shopId: "shop-1",
                createdAt: new Date()
            },
            {
                id: 2,
                name: "Product 2",
                description: "Description 2",
                price: 200,
                sku: "SKU002",
                shopId: "shop-1",
                createdAt: new Date()
            }
        ];
        (0, _globals.it)("should return products for valid shop ID", async ()=>{
            // Arrange
            mockPrisma.product.findMany.mockResolvedValue(mockProducts);
            const request = new NextRequest("http://localhost:3000/api/products?shopId=shop-1&page=1&limit=10");
            // Act
            const response = await productsHandler.GET(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(data.products).toEqual(mockProducts);
            (0, _globals.expect)(data.pagination).toEqual({
                page: 1,
                limit: 10,
                total: 2
            });
        });
        (0, _globals.it)("should return 400 for missing shop ID", async ()=>{
            // Arrange
            const request = new NextRequest("http://localhost:3000/api/products");
            // Act
            const response = await productsHandler.GET(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(data.error).toBe("Shop ID is required");
        });
        (0, _globals.it)("should handle search functionality", async ()=>{
            // Arrange
            const filteredProducts = [
                mockProducts[0]
            ];
            mockPrisma.product.findMany.mockResolvedValue(filteredProducts);
            const request = new NextRequest("http://localhost:3000/api/products?shopId=shop-1&search=Product%201");
            // Act
            const response = await productsHandler.GET(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(data.products).toEqual(filteredProducts);
            (0, _globals.expect)(mockPrisma.product.findMany).toHaveBeenCalledWith({
                where: {
                    shopId: "shop-1",
                    OR: [
                        {
                            name: {
                                contains: "Product 1",
                                mode: "insensitive"
                            }
                        },
                        {
                            description: {
                                contains: "Product 1",
                                mode: "insensitive"
                            }
                        },
                        {
                            sku: {
                                contains: "Product 1",
                                mode: "insensitive"
                            }
                        }
                    ]
                },
                skip: 0,
                take: 10,
                orderBy: {
                    createdAt: "desc"
                }
            });
        });
    });
    (0, _globals.describe)("POST /api/products", ()=>{
        const validToken = "valid-token";
        const mockProduct = {
            id: 1,
            name: "New Product",
            description: "New Description",
            price: 150,
            sku: "SKU003",
            shopId: "shop-1",
            createdAt: new Date(),
            updatedAt: new Date()
        };
        (0, _globals.beforeEach)(()=>{
            jest.spyOn(_jsonwebtoken.default, "verify").mockReturnValue({
                userId: 1
            });
        });
        (0, _globals.it)("should create product with valid data and auth", async ()=>{
            // Arrange
            mockPrisma.product.findUnique.mockResolvedValue(null); // SKU doesn't exist
            mockPrisma.product.create.mockResolvedValue(mockProduct);
            const request = new NextRequest("http://localhost:3000/api/products", {
                method: "POST",
                body: JSON.stringify({
                    name: "New Product",
                    description: "New Description",
                    price: 150,
                    sku: "SKU003",
                    shopId: "shop-1"
                }),
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${validToken}`
                }
            });
            // Act
            const response = await productsHandler.POST(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(201);
            (0, _globals.expect)(data).toEqual(mockProduct);
            (0, _globals.expect)(mockPrisma.product.create).toHaveBeenCalledWith({
                data: _globals.expect.objectContaining({
                    name: "New Product",
                    description: "New Description",
                    price: 150,
                    sku: "SKU003",
                    shopId: "shop-1"
                })
            });
        });
        (0, _globals.it)("should return 401 for missing authorization", async ()=>{
            // Arrange
            const request = new NextRequest("http://localhost:3000/api/products", {
                method: "POST",
                body: JSON.stringify({
                    name: "New Product",
                    price: 150,
                    sku: "SKU003",
                    shopId: "shop-1"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Act
            const response = await productsHandler.POST(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(data.error).toBe("Unauthorized");
        });
        (0, _globals.it)("should return 400 for invalid price", async ()=>{
            // Arrange
            const request = new NextRequest("http://localhost:3000/api/products", {
                method: "POST",
                body: JSON.stringify({
                    name: "New Product",
                    price: -10,
                    sku: "SKU003",
                    shopId: "shop-1"
                }),
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${validToken}`
                }
            });
            // Act
            const response = await productsHandler.POST(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(data.error).toBe("Price must be greater than 0");
        });
        (0, _globals.it)("should return 409 for duplicate SKU", async ()=>{
            // Arrange
            mockPrisma.product.findUnique.mockResolvedValue(mockProduct); // SKU exists
            const request = new NextRequest("http://localhost:3000/api/products", {
                method: "POST",
                body: JSON.stringify({
                    name: "New Product",
                    price: 150,
                    sku: "SKU003",
                    shopId: "shop-1"
                }),
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${validToken}`
                }
            });
            // Act
            const response = await productsHandler.POST(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(409);
            (0, _globals.expect)(data.error).toBe("Product with this SKU already exists");
        });
    });
    (0, _globals.describe)("GET /api/user", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            name: "Test User",
            permissions: [
                "inventory:read",
                "sales:create"
            ],
            shopId: "shop-1",
            isActive: true
        };
        (0, _globals.it)("should return user data for valid token", async ()=>{
            // Arrange
            jest.spyOn(_jsonwebtoken.default, "verify").mockReturnValue({
                userId: 1
            });
            mockPrisma.user.findUnique.mockResolvedValue(mockUser);
            const request = new NextRequest("http://localhost:3000/api/user", {
                headers: {
                    "Authorization": "Bearer valid-token"
                }
            });
            // Act
            const response = await userHandler.GET(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(200);
            (0, _globals.expect)(data.user).toEqual(mockUser);
            (0, _globals.expect)(mockPrisma.user.findUnique).toHaveBeenCalledWith({
                where: {
                    id: 1
                },
                select: {
                    id: true,
                    email: true,
                    name: true,
                    permissions: true,
                    shopId: true,
                    isActive: true
                }
            });
        });
        (0, _globals.it)("should return 401 for invalid token", async ()=>{
            // Arrange
            jest.spyOn(_jsonwebtoken.default, "verify").mockImplementation(()=>{
                throw new Error("Invalid token");
            });
            const request = new NextRequest("http://localhost:3000/api/user", {
                headers: {
                    "Authorization": "Bearer invalid-token"
                }
            });
            // Act
            const response = await userHandler.GET(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(data.error).toBe("Invalid token");
        });
        (0, _globals.it)("should return 404 for non-existent user", async ()=>{
            // Arrange
            jest.spyOn(_jsonwebtoken.default, "verify").mockReturnValue({
                userId: 999
            });
            mockPrisma.user.findUnique.mockResolvedValue(null);
            const request = new NextRequest("http://localhost:3000/api/user", {
                headers: {
                    "Authorization": "Bearer valid-token"
                }
            });
            // Act
            const response = await userHandler.GET(request);
            const data = await response.json();
            // Assert
            (0, _globals.expect)(response.status).toBe(404);
            (0, _globals.expect)(data.error).toBe("User not found");
        });
    });
    (0, _globals.describe)("Error Handling", ()=>{
        (0, _globals.it)("should handle database connection errors", async ()=>{
            // Arrange
            mockPrisma.user.findUnique.mockRejectedValue(new Error("Database connection failed"));
            const request = new NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: JSON.stringify({
                    email: "test@example.com",
                    password: "password123"
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Act & Assert
            await (0, _globals.expect)(authHandler.POST(request)).rejects.toThrow("Database connection failed");
        });
        (0, _globals.it)("should handle malformed JSON requests", async ()=>{
            // Arrange
            const request = new NextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: "invalid json",
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Act & Assert
            await (0, _globals.expect)(authHandler.POST(request)).rejects.toThrow();
        });
    });
    (0, _globals.describe)("Rate Limiting Simulation", ()=>{
        (0, _globals.it)("should handle multiple concurrent requests", async ()=>{
            // Arrange
            const mockUser = {
                id: 1,
                email: "test@example.com",
                password: "$2a$10$hashedPassword",
                name: "Test User",
                shopId: "shop-1"
            };
            mockPrisma.user.findUnique.mockResolvedValue(mockUser);
            jest.spyOn(_bcryptjs.default, "compare").mockResolvedValue(true);
            jest.spyOn(_jsonwebtoken.default, "sign").mockReturnValue("mock-token");
            const requests = Array.from({
                length: 5
            }, ()=>new NextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: JSON.stringify({
                        email: "test@example.com",
                        password: "password123"
                    }),
                    headers: {
                        "Content-Type": "application/json"
                    }
                }));
            // Act
            const responses = await Promise.all(requests.map((req)=>authHandler.POST(req)));
            // Assert
            responses.forEach((response)=>{
                (0, _globals.expect)(response.status).toBe(200);
            });
            (0, _globals.expect)(mockPrisma.user.findUnique).toHaveBeenCalledTimes(5);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvaW50ZWdyYXRpb24vYXBpLXJvdXRlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVBbGwsIGFmdGVyQWxsLCBiZWZvcmVFYWNoLCBhZnRlckVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IGNyZWF0ZU1vY2tzIH0gZnJvbSAnbm9kZS1tb2Nrcy1odHRwJztcbmltcG9ydCB7IFByaXNtYUNsaWVudCB9IGZyb20gJ0BwcmlzbWEvY2xpZW50JztcbmltcG9ydCBiY3J5cHQgZnJvbSAnYmNyeXB0anMnO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuXG4vLyBNb2NrIE5leHQuanMgdHlwZXMgZm9yIHRlc3RpbmdcbmludGVyZmFjZSBOZXh0UmVxdWVzdCB7XG4gIG1ldGhvZDogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgaGVhZGVyczogSGVhZGVycztcbiAganNvbigpOiBQcm9taXNlPGFueT47XG4gIHRleHQoKTogUHJvbWlzZTxzdHJpbmc+O1xufVxuXG5pbnRlcmZhY2UgTmV4dFJlc3BvbnNlIHtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIGpzb246IGFueTtcbn1cblxuLy8gTW9jayBOZXh0UmVzcG9uc2UgY29uc3RydWN0b3JcbmNvbnN0IE5leHRSZXNwb25zZSA9IHtcbiAganNvbjogKGRhdGE6IGFueSwgaW5pdD86IHsgc3RhdHVzPzogbnVtYmVyIH0pID0+ICh7XG4gICAgc3RhdHVzOiBpbml0Py5zdGF0dXMgfHwgMjAwLFxuICAgIGpzb246IGRhdGEsXG4gIH0pLFxufTtcblxuLy8gSW1wb3J0IEFQSSBoYW5kbGVycyAoYWRqdXN0IHBhdGhzIGFzIG5lZWRlZClcbi8vIFRoZXNlIHdvdWxkIGJlIHRoZSBhY3R1YWwgQVBJIHJvdXRlIGhhbmRsZXJzXG5pbnRlcmZhY2UgTW9ja0FwaUhhbmRsZXIge1xuICBQT1NUPzogKHJlcTogTmV4dFJlcXVlc3QpID0+IFByb21pc2U8TmV4dFJlc3BvbnNlPjtcbiAgR0VUPzogKHJlcTogTmV4dFJlcXVlc3QpID0+IFByb21pc2U8TmV4dFJlc3BvbnNlPjtcbiAgUFVUPzogKHJlcTogTmV4dFJlcXVlc3QpID0+IFByb21pc2U8TmV4dFJlc3BvbnNlPjtcbiAgREVMRVRFPzogKHJlcTogTmV4dFJlcXVlc3QpID0+IFByb21pc2U8TmV4dFJlc3BvbnNlPjtcbn1cblxuLy8gTW9jayBpbXBsZW1lbnRhdGlvbnMgZm9yIHRlc3RpbmdcbmNvbnN0IG1vY2tQcmlzbWEgPSB7XG4gIHVzZXI6IHtcbiAgICBmaW5kVW5pcXVlOiBqZXN0LmZuKCksXG4gICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICBkZWxldGU6IGplc3QuZm4oKSxcbiAgfSxcbiAgcHJvZHVjdDoge1xuICAgIGZpbmRNYW55OiBqZXN0LmZuKCksXG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpLFxuICAgIGNyZWF0ZTogamVzdC5mbigpLFxuICAgIHVwZGF0ZTogamVzdC5mbigpLFxuICAgIGRlbGV0ZTogamVzdC5mbigpLFxuICB9LFxuICBzaG9wOiB7XG4gICAgZmluZFVuaXF1ZTogamVzdC5mbigpLFxuICAgIGNyZWF0ZTogamVzdC5mbigpLFxuICB9LFxuICByZWZyZXNoVG9rZW46IHtcbiAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgICBmaW5kVW5pcXVlOiBqZXN0LmZuKCksXG4gICAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIH0sXG4gICRkaXNjb25uZWN0OiBqZXN0LmZuKCksXG59IGFzIGFueTtcblxuLy8gTW9jayBBUEkgaGFuZGxlcnNcbmNvbnN0IGF1dGhIYW5kbGVyOiBNb2NrQXBpSGFuZGxlciA9IHtcbiAgUE9TVDogYXN5bmMgKHJlcTogTmV4dFJlcXVlc3QpID0+IHtcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxLmpzb24oKTtcbiAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCB9ID0gYm9keTtcblxuICAgIGlmICghZW1haWwgfHwgIXBhc3N3b3JkKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdFbWFpbCBhbmQgcGFzc3dvcmQgYXJlIHJlcXVpcmVkJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB1c2VyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgIHdoZXJlOiB7IGVtYWlsIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgY3JlZGVudGlhbHMnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgcGFzc3dvcmRcbiAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUocGFzc3dvcmQsIHVzZXIucGFzc3dvcmQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCBjcmVkZW50aWFscycgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMSB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHRva2VuXG4gICAgY29uc3QgdG9rZW4gPSBqd3Quc2lnbihcbiAgICAgIHsgdXNlcklkOiB1c2VyLmlkLCBlbWFpbDogdXNlci5lbWFpbCB9LFxuICAgICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCB8fCAndGVzdC1zZWNyZXQnLFxuICAgICAgeyBleHBpcmVzSW46ICcxaCcgfVxuICAgICk7XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgdXNlcjoge1xuICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgIG5hbWU6IHVzZXIubmFtZSxcbiAgICAgIH0sXG4gICAgICB0b2tlbixcbiAgICB9KTtcbiAgfSxcbn07XG5cbmNvbnN0IHByb2R1Y3RzSGFuZGxlcjogTW9ja0FwaUhhbmRsZXIgPSB7XG4gIEdFVDogYXN5bmMgKHJlcTogTmV4dFJlcXVlc3QpID0+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICAgIGNvbnN0IHNob3BJZCA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdzaG9wSWQnKTtcbiAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQodXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3BhZ2UnKSB8fCAnMScpO1xuICAgIGNvbnN0IGxpbWl0ID0gcGFyc2VJbnQodXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2xpbWl0JykgfHwgJzEwJyk7XG4gICAgY29uc3Qgc2VhcmNoID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3NlYXJjaCcpO1xuXG4gICAgaWYgKCFzaG9wSWQpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1Nob3AgSUQgaXMgcmVxdWlyZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB3aGVyZSBjbGF1c2VcbiAgICBjb25zdCB3aGVyZTogYW55ID0geyBzaG9wSWQgfTtcbiAgICBpZiAoc2VhcmNoKSB7XG4gICAgICB3aGVyZS5PUiA9IFtcbiAgICAgICAgeyBuYW1lOiB7IGNvbnRhaW5zOiBzZWFyY2gsIG1vZGU6ICdpbnNlbnNpdGl2ZScgfSB9LFxuICAgICAgICB7IGRlc2NyaXB0aW9uOiB7IGNvbnRhaW5zOiBzZWFyY2gsIG1vZGU6ICdpbnNlbnNpdGl2ZScgfSB9LFxuICAgICAgICB7IHNrdTogeyBjb250YWluczogc2VhcmNoLCBtb2RlOiAnaW5zZW5zaXRpdmUnIH0gfSxcbiAgICAgIF07XG4gICAgfVxuXG4gICAgY29uc3QgcHJvZHVjdHMgPSBhd2FpdCBtb2NrUHJpc21hLnByb2R1Y3QuZmluZE1hbnkoe1xuICAgICAgd2hlcmUsXG4gICAgICBza2lwOiAocGFnZSAtIDEpICogbGltaXQsXG4gICAgICB0YWtlOiBsaW1pdCxcbiAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiAnZGVzYycgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBwcm9kdWN0cyxcbiAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgbGltaXQsXG4gICAgICAgIHRvdGFsOiBwcm9kdWN0cy5sZW5ndGgsXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuXG4gIFBPU1Q6IGFzeW5jIChyZXE6IE5leHRSZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcS5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpO1xuICAgIGlmICghYXV0aEhlYWRlcj8uc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdVbmF1dGhvcml6ZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbiA9IGF1dGhIZWFkZXIuc3Vic3RyaW5nKDcpO1xuICAgIHRyeSB7XG4gICAgICBqd3QudmVyaWZ5KHRva2VuLCBwcm9jZXNzLmVudi5KV1RfU0VDUkVUIHx8ICd0ZXN0LXNlY3JldCcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCB0b2tlbicgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMSB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXEuanNvbigpO1xuICAgIGNvbnN0IHsgbmFtZSwgZGVzY3JpcHRpb24sIHByaWNlLCBza3UsIHNob3BJZCB9ID0gYm9keTtcblxuICAgIC8vIFZhbGlkYXRpb25cbiAgICBpZiAoIW5hbWUgfHwgIXByaWNlIHx8ICFza3UgfHwgIXNob3BJZCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnTmFtZSwgcHJpY2UsIFNLVSwgYW5kIHNob3AgSUQgYXJlIHJlcXVpcmVkJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHByaWNlIDw9IDApIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1ByaWNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBTS1UgYWxyZWFkeSBleGlzdHNcbiAgICBjb25zdCBleGlzdGluZ1Byb2R1Y3QgPSBhd2FpdCBtb2NrUHJpc21hLnByb2R1Y3QuZmluZFVuaXF1ZSh7XG4gICAgICB3aGVyZTogeyBza3Vfc2hvcElkOiB7IHNrdSwgc2hvcElkIH0gfSxcbiAgICB9KTtcblxuICAgIGlmIChleGlzdGluZ1Byb2R1Y3QpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1Byb2R1Y3Qgd2l0aCB0aGlzIFNLVSBhbHJlYWR5IGV4aXN0cycgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwOSB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCBtb2NrUHJpc21hLnByb2R1Y3QuY3JlYXRlKHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIHByaWNlLFxuICAgICAgICBza3UsXG4gICAgICAgIHNob3BJZCxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHByb2R1Y3QsIHsgc3RhdHVzOiAyMDEgfSk7XG4gIH0sXG59O1xuXG5jb25zdCB1c2VySGFuZGxlcjogTW9ja0FwaUhhbmRsZXIgPSB7XG4gIEdFVDogYXN5bmMgKHJlcTogTmV4dFJlcXVlc3QpID0+IHtcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gcmVxLmhlYWRlcnMuZ2V0KCdhdXRob3JpemF0aW9uJyk7XG4gICAgaWYgKCFhdXRoSGVhZGVyPy5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMSB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0gYXV0aEhlYWRlci5zdWJzdHJpbmcoNyk7XG4gICAgbGV0IGRlY29kZWQ6IGFueTtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IGp3dC52ZXJpZnkodG9rZW4sIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQgfHwgJ3Rlc3Qtc2VjcmV0Jyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIHRva2VuJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgIHdoZXJlOiB7IGlkOiBkZWNvZGVkLnVzZXJJZCB9LFxuICAgICAgc2VsZWN0OiB7XG4gICAgICAgIGlkOiB0cnVlLFxuICAgICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgICAgbmFtZTogdHJ1ZSxcbiAgICAgICAgcGVybWlzc2lvbnM6IHRydWUsXG4gICAgICAgIHNob3BJZDogdHJ1ZSxcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdVc2VyIG5vdCBmb3VuZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwNCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IHVzZXIgfSk7XG4gIH0sXG59O1xuXG5kZXNjcmliZSgnQVBJIFJvdXRlcyBJbnRlZ3JhdGlvbiBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtc2VjcmV0JztcbiAgfSk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5yZXNldEFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGFmdGVyQWxsKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBtb2NrUHJpc21hLiRkaXNjb25uZWN0KCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQT1NUIC9hcGkvYXV0aC9sb2dpbicsICgpID0+IHtcbiAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgIGlkOiAxLFxuICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIHBhc3N3b3JkOiAnJDJhJDEwJGhhc2hlZFBhc3N3b3JkJyxcbiAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgc2hvcElkOiAnc2hvcC0xJyxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgbG9naW4gd2l0aCB2YWxpZCBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIGplc3Quc3B5T24oYmNyeXB0LCAnY29tcGFyZScpLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUgYXMgbmV2ZXIpO1xuICAgICAgamVzdC5zcHlPbihqd3QsICdzaWduJykubW9ja1JldHVyblZhbHVlKCdtb2NrLXRva2VuJyBhcyBuZXZlcik7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhIYW5kbGVyLlBPU1QhKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9FcXVhbCh7XG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogMSxcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICB9LFxuICAgICAgICB0b2tlbjogJ21vY2stdG9rZW4nLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgd2hlcmU6IHsgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgZm9yIG1pc3NpbmcgY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAvLyBwYXNzd29yZCBtaXNzaW5nXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aEhhbmRsZXIuUE9TVCEocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdFbWFpbCBhbmQgcGFzc3dvcmQgYXJlIHJlcXVpcmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgZm9yIGludmFsaWQgY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAnbm9uZXhpc3RlbnRAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhIYW5kbGVyLlBPU1QhKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnSW52YWxpZCBjcmVkZW50aWFscycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIGZvciB3cm9uZyBwYXNzd29yZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIGplc3Quc3B5T24oYmNyeXB0LCAnY29tcGFyZScpLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlIGFzIG5ldmVyKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoSGFuZGxlci5QT1NUIShyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0ludmFsaWQgY3JlZGVudGlhbHMnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0dFVCAvYXBpL3Byb2R1Y3RzJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tQcm9kdWN0cyA9IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdQcm9kdWN0IDEnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0Rlc2NyaXB0aW9uIDEnLFxuICAgICAgICBwcmljZTogMTAwLFxuICAgICAgICBza3U6ICdTS1UwMDEnLFxuICAgICAgICBzaG9wSWQ6ICdzaG9wLTEnLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogMixcbiAgICAgICAgbmFtZTogJ1Byb2R1Y3QgMicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRGVzY3JpcHRpb24gMicsXG4gICAgICAgIHByaWNlOiAyMDAsXG4gICAgICAgIHNrdTogJ1NLVTAwMicsXG4gICAgICAgIHNob3BJZDogJ3Nob3AtMScsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHByb2R1Y3RzIGZvciB2YWxpZCBzaG9wIElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja1ByaXNtYS5wcm9kdWN0LmZpbmRNYW55Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9kdWN0cyk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoXG4gICAgICAgICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3Byb2R1Y3RzP3Nob3BJZD1zaG9wLTEmcGFnZT0xJmxpbWl0PTEwJ1xuICAgICAgKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHByb2R1Y3RzSGFuZGxlci5HRVQhKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YS5wcm9kdWN0cykudG9FcXVhbChtb2NrUHJvZHVjdHMpO1xuICAgICAgZXhwZWN0KGRhdGEucGFnaW5hdGlvbikudG9FcXVhbCh7XG4gICAgICAgIHBhZ2U6IDEsXG4gICAgICAgIGxpbWl0OiAxMCxcbiAgICAgICAgdG90YWw6IDIsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCBmb3IgbWlzc2luZyBzaG9wIElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wcm9kdWN0cycpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJvZHVjdHNIYW5kbGVyLkdFVCEocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdTaG9wIElEIGlzIHJlcXVpcmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZWFyY2ggZnVuY3Rpb25hbGl0eScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGZpbHRlcmVkUHJvZHVjdHMgPSBbbW9ja1Byb2R1Y3RzWzBdXTtcbiAgICAgIG1vY2tQcmlzbWEucHJvZHVjdC5maW5kTWFueS5tb2NrUmVzb2x2ZWRWYWx1ZShmaWx0ZXJlZFByb2R1Y3RzKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcHJvZHVjdHM/c2hvcElkPXNob3AtMSZzZWFyY2g9UHJvZHVjdCUyMDEnXG4gICAgICApO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJvZHVjdHNIYW5kbGVyLkdFVCEocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnByb2R1Y3RzKS50b0VxdWFsKGZpbHRlcmVkUHJvZHVjdHMpO1xuICAgICAgZXhwZWN0KG1vY2tQcmlzbWEucHJvZHVjdC5maW5kTWFueSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIHNob3BJZDogJ3Nob3AtMScsXG4gICAgICAgICAgT1I6IFtcbiAgICAgICAgICAgIHsgbmFtZTogeyBjb250YWluczogJ1Byb2R1Y3QgMScsIG1vZGU6ICdpbnNlbnNpdGl2ZScgfSB9LFxuICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogeyBjb250YWluczogJ1Byb2R1Y3QgMScsIG1vZGU6ICdpbnNlbnNpdGl2ZScgfSB9LFxuICAgICAgICAgICAgeyBza3U6IHsgY29udGFpbnM6ICdQcm9kdWN0IDEnLCBtb2RlOiAnaW5zZW5zaXRpdmUnIH0gfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBza2lwOiAwLFxuICAgICAgICB0YWtlOiAxMCxcbiAgICAgICAgb3JkZXJCeTogeyBjcmVhdGVkQXQ6ICdkZXNjJyB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQT1NUIC9hcGkvcHJvZHVjdHMnLCAoKSA9PiB7XG4gICAgY29uc3QgdmFsaWRUb2tlbiA9ICd2YWxpZC10b2tlbic7XG4gICAgY29uc3QgbW9ja1Byb2R1Y3QgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6ICdOZXcgUHJvZHVjdCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ05ldyBEZXNjcmlwdGlvbicsXG4gICAgICBwcmljZTogMTUwLFxuICAgICAgc2t1OiAnU0tVMDAzJyxcbiAgICAgIHNob3BJZDogJ3Nob3AtMScsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgamVzdC5zcHlPbihqd3QsICd2ZXJpZnknKS5tb2NrUmV0dXJuVmFsdWUoeyB1c2VySWQ6IDEgfSBhcyBuZXZlcik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBwcm9kdWN0IHdpdGggdmFsaWQgZGF0YSBhbmQgYXV0aCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIG1vY2tQcmlzbWEucHJvZHVjdC5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpOyAvLyBTS1UgZG9lc24ndCBleGlzdFxuICAgICAgbW9ja1ByaXNtYS5wcm9kdWN0LmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUHJvZHVjdCk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcHJvZHVjdHMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbmFtZTogJ05ldyBQcm9kdWN0JyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ05ldyBEZXNjcmlwdGlvbicsXG4gICAgICAgICAgcHJpY2U6IDE1MCxcbiAgICAgICAgICBza3U6ICdTS1UwMDMnLFxuICAgICAgICAgIHNob3BJZDogJ3Nob3AtMScsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt2YWxpZFRva2VufWAsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHByb2R1Y3RzSGFuZGxlci5QT1NUIShyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvRXF1YWwobW9ja1Byb2R1Y3QpO1xuICAgICAgZXhwZWN0KG1vY2tQcmlzbWEucHJvZHVjdC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgZGF0YTogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIG5hbWU6ICdOZXcgUHJvZHVjdCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdOZXcgRGVzY3JpcHRpb24nLFxuICAgICAgICAgIHByaWNlOiAxNTAsXG4gICAgICAgICAgc2t1OiAnU0tVMDAzJyxcbiAgICAgICAgICBzaG9wSWQ6ICdzaG9wLTEnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIGZvciBtaXNzaW5nIGF1dGhvcml6YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3Byb2R1Y3RzJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG5hbWU6ICdOZXcgUHJvZHVjdCcsXG4gICAgICAgICAgcHJpY2U6IDE1MCxcbiAgICAgICAgICBza3U6ICdTS1UwMDMnLFxuICAgICAgICAgIHNob3BJZDogJ3Nob3AtMScsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJvZHVjdHNIYW5kbGVyLlBPU1QhKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnVW5hdXRob3JpemVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgZm9yIGludmFsaWQgcHJpY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3Byb2R1Y3RzJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG5hbWU6ICdOZXcgUHJvZHVjdCcsXG4gICAgICAgICAgcHJpY2U6IC0xMCwgLy8gSW52YWxpZCBwcmljZVxuICAgICAgICAgIHNrdTogJ1NLVTAwMycsXG4gICAgICAgICAgc2hvcElkOiAnc2hvcC0xJyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3ZhbGlkVG9rZW59YCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJvZHVjdHNIYW5kbGVyLlBPU1QhKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnUHJpY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDA5IGZvciBkdXBsaWNhdGUgU0tVJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja1ByaXNtYS5wcm9kdWN0LmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2R1Y3QpOyAvLyBTS1UgZXhpc3RzXG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcHJvZHVjdHMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbmFtZTogJ05ldyBQcm9kdWN0JyxcbiAgICAgICAgICBwcmljZTogMTUwLFxuICAgICAgICAgIHNrdTogJ1NLVTAwMycsXG4gICAgICAgICAgc2hvcElkOiAnc2hvcC0xJyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3ZhbGlkVG9rZW59YCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJvZHVjdHNIYW5kbGVyLlBPU1QhKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwOSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnUHJvZHVjdCB3aXRoIHRoaXMgU0tVIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdHRVQgL2FwaS91c2VyJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICBwZXJtaXNzaW9uczogWydpbnZlbnRvcnk6cmVhZCcsICdzYWxlczpjcmVhdGUnXSxcbiAgICAgIHNob3BJZDogJ3Nob3AtMScsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdXNlciBkYXRhIGZvciB2YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGplc3Quc3B5T24oand0LCAndmVyaWZ5JykubW9ja1JldHVyblZhbHVlKHsgdXNlcklkOiAxIH0gYXMgbmV2ZXIpO1xuICAgICAgbW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3VzZXInLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtdG9rZW4nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1c2VySGFuZGxlci5HRVQhKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YS51c2VyKS50b0VxdWFsKG1vY2tVc2VyKTtcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZTogeyBpZDogMSB9LFxuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICBpZDogdHJ1ZSxcbiAgICAgICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgICAgICBuYW1lOiB0cnVlLFxuICAgICAgICAgIHBlcm1pc3Npb25zOiB0cnVlLFxuICAgICAgICAgIHNob3BJZDogdHJ1ZSxcbiAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIGZvciBpbnZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgamVzdC5zcHlPbihqd3QsICd2ZXJpZnknKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4nKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3VzZXInLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgaW52YWxpZC10b2tlbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVzZXJIYW5kbGVyLkdFVCEocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdJbnZhbGlkIHRva2VuJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDQgZm9yIG5vbi1leGlzdGVudCB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgamVzdC5zcHlPbihqd3QsICd2ZXJpZnknKS5tb2NrUmV0dXJuVmFsdWUoeyB1c2VySWQ6IDk5OSB9IGFzIG5ldmVyKTtcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kVW5pcXVlLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3VzZXInLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtdG9rZW4nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB1c2VySGFuZGxlci5HRVQhKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwNCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnVXNlciBub3QgZm91bmQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGNvbm5lY3Rpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgbW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3QgJiBBc3NlcnRcbiAgICAgIGF3YWl0IGV4cGVjdChhdXRoSGFuZGxlci5QT1NUIShyZXF1ZXN0KSkucmVqZWN0cy50b1Rocm93KCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWFsZm9ybWVkIEpTT04gcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiAnaW52YWxpZCBqc29uJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0XG4gICAgICBhd2FpdCBleHBlY3QoYXV0aEhhbmRsZXIuUE9TVCEocmVxdWVzdCkpLnJlamVjdHMudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmF0ZSBMaW1pdGluZyBTaW11bGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG11bHRpcGxlIGNvbmN1cnJlbnQgcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHBhc3N3b3JkOiAnJDJhJDEwJGhhc2hlZFBhc3N3b3JkJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHNob3BJZDogJ3Nob3AtMScsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG4gICAgICBqZXN0LnNweU9uKGJjcnlwdCwgJ2NvbXBhcmUnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlIGFzIG5ldmVyKTtcbiAgICAgIGplc3Quc3B5T24oand0LCAnc2lnbicpLm1vY2tSZXR1cm5WYWx1ZSgnbW9jay10b2tlbicgYXMgbmV2ZXIpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSwgKCkgPT4gXG4gICAgICAgIG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICByZXF1ZXN0cy5tYXAocmVxID0+IGF1dGhIYW5kbGVyLlBPU1QhKHJlcSkpXG4gICAgICApO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKHJlc3BvbnNlID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg1KTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwianNvbiIsImRhdGEiLCJpbml0Iiwic3RhdHVzIiwibW9ja1ByaXNtYSIsInVzZXIiLCJmaW5kVW5pcXVlIiwiamVzdCIsImZuIiwiY3JlYXRlIiwiZmluZE1hbnkiLCJ1cGRhdGUiLCJkZWxldGUiLCJwcm9kdWN0Iiwic2hvcCIsInJlZnJlc2hUb2tlbiIsIiRkaXNjb25uZWN0IiwiYXV0aEhhbmRsZXIiLCJQT1NUIiwicmVxIiwiYm9keSIsImVtYWlsIiwicGFzc3dvcmQiLCJlcnJvciIsIndoZXJlIiwiaXNWYWxpZCIsImJjcnlwdCIsImNvbXBhcmUiLCJ0b2tlbiIsImp3dCIsInNpZ24iLCJ1c2VySWQiLCJpZCIsInByb2Nlc3MiLCJlbnYiLCJKV1RfU0VDUkVUIiwiZXhwaXJlc0luIiwibmFtZSIsInByb2R1Y3RzSGFuZGxlciIsIkdFVCIsInVybCIsIlVSTCIsInNob3BJZCIsInNlYXJjaFBhcmFtcyIsImdldCIsInBhZ2UiLCJwYXJzZUludCIsImxpbWl0Iiwic2VhcmNoIiwiT1IiLCJjb250YWlucyIsIm1vZGUiLCJkZXNjcmlwdGlvbiIsInNrdSIsInByb2R1Y3RzIiwic2tpcCIsInRha2UiLCJvcmRlckJ5IiwiY3JlYXRlZEF0IiwicGFnaW5hdGlvbiIsInRvdGFsIiwibGVuZ3RoIiwiYXV0aEhlYWRlciIsImhlYWRlcnMiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwidmVyaWZ5IiwicHJpY2UiLCJleGlzdGluZ1Byb2R1Y3QiLCJza3Vfc2hvcElkIiwiRGF0ZSIsInVwZGF0ZWRBdCIsInVzZXJIYW5kbGVyIiwiZGVjb2RlZCIsInNlbGVjdCIsInBlcm1pc3Npb25zIiwiaXNBY3RpdmUiLCJkZXNjcmliZSIsImJlZm9yZUFsbCIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiYWZ0ZXJFYWNoIiwicmVzZXRBbGxNb2NrcyIsImFmdGVyQWxsIiwibW9ja1VzZXIiLCJpdCIsIm1vY2tSZXNvbHZlZFZhbHVlIiwic3B5T24iLCJtb2NrUmV0dXJuVmFsdWUiLCJyZXF1ZXN0IiwiTmV4dFJlcXVlc3QiLCJtZXRob2QiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJleHBlY3QiLCJ0b0JlIiwidG9FcXVhbCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwibW9ja1Byb2R1Y3RzIiwiZmlsdGVyZWRQcm9kdWN0cyIsInZhbGlkVG9rZW4iLCJtb2NrUHJvZHVjdCIsIm9iamVjdENvbnRhaW5pbmciLCJtb2NrSW1wbGVtZW50YXRpb24iLCJFcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlIiwicmVqZWN0cyIsInRvVGhyb3ciLCJyZXF1ZXN0cyIsIkFycmF5IiwiZnJvbSIsInJlc3BvbnNlcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJmb3JFYWNoIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIl0sIm1hcHBpbmdzIjoiOzs7O3lCQUFpRjtpRUFHOUQ7cUVBQ0g7Ozs7OztBQWdCaEIsZ0NBQWdDO0FBQ2hDLE1BQU1BLGVBQWU7SUFDbkJDLE1BQU0sQ0FBQ0MsTUFBV0MsT0FBZ0MsQ0FBQTtZQUNoREMsUUFBUUQsTUFBTUMsVUFBVTtZQUN4QkgsTUFBTUM7UUFDUixDQUFBO0FBQ0Y7QUFXQSxtQ0FBbUM7QUFDbkMsTUFBTUcsYUFBYTtJQUNqQkMsTUFBTTtRQUNKQyxZQUFZQyxLQUFLQyxFQUFFO1FBQ25CQyxRQUFRRixLQUFLQyxFQUFFO1FBQ2ZFLFVBQVVILEtBQUtDLEVBQUU7UUFDakJHLFFBQVFKLEtBQUtDLEVBQUU7UUFDZkksUUFBUUwsS0FBS0MsRUFBRTtJQUNqQjtJQUNBSyxTQUFTO1FBQ1BILFVBQVVILEtBQUtDLEVBQUU7UUFDakJGLFlBQVlDLEtBQUtDLEVBQUU7UUFDbkJDLFFBQVFGLEtBQUtDLEVBQUU7UUFDZkcsUUFBUUosS0FBS0MsRUFBRTtRQUNmSSxRQUFRTCxLQUFLQyxFQUFFO0lBQ2pCO0lBQ0FNLE1BQU07UUFDSlIsWUFBWUMsS0FBS0Ms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