912ccbdaca46578e5e890e0d61ca093b
// Mock the Product model
// Mock Product is defined in the jest.mock call below
// Mock the models
"use strict";
jest.mock("@/lib/models", ()=>({
        Product: {
            findAll: jest.fn(),
            findOne: jest.fn(),
            findByPk: jest.fn(),
            create: jest.fn(),
            update: jest.fn(),
            destroy: jest.fn(),
            count: jest.fn()
        }
    }));
// Mock prisma
jest.mock("@/lib/prisma", ()=>({
        prisma: {
            refreshToken: {
                deleteMany: jest.fn(),
                updateMany: jest.fn(),
                findFirst: jest.fn(),
                findUnique: jest.fn(),
                create: jest.fn(),
                update: jest.fn(),
                delete: jest.fn()
            },
            auditLog: {
                findMany: jest.fn(),
                create: jest.fn()
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _productService = require("../../src/services/productService");
const _auditService = require("../../src/services/auditService");
const _refreshTokenService = /*#__PURE__*/ _interop_require_wildcard(require("../../src/services/refreshTokenService"));
const _prisma = require("../../src/lib/prisma");
const _models = require("../../src/lib/models");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Get the mocked Product
const mockedProduct = _models.Product;
// Get the mocked prisma instance
const mockPrisma = _prisma.prisma;
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Service Layer Tests", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("ProductService", ()=>{
        const mockProductData = {
            id: 1,
            name: "Test Product",
            description: "Test Description",
            price: 99.99,
            costPrice: 50.00,
            sku: "TEST-001",
            isActive: true,
            createdAt: new Date(),
            updatedAt: new Date()
        };
        describe("getAllProducts", ()=>{
            it("should fetch all active products successfully", async ()=>{
                const mockProducts = [
                    mockProductData,
                    {
                        ...mockProductData,
                        id: 2,
                        name: "Product 2"
                    }
                ];
                mockedProduct.findAll.mockResolvedValue(mockProducts);
                const result = await _productService.productService.getAllProducts();
                expect(mockedProduct.findAll).toHaveBeenCalledWith({
                    where: {
                        isActive: true
                    }
                });
                expect(result).toEqual(mockProducts);
                expect(result).toHaveLength(2);
            });
            it("should handle database errors gracefully", async ()=>{
                const dbError = new Error("Database connection failed");
                mockedProduct.findAll.mockRejectedValue(dbError);
                await expect(_productService.productService.getAllProducts()).rejects.toThrow("Database connection failed");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error fetching products:", dbError);
            });
            it("should return empty array when no products found", async ()=>{
                mockedProduct.findAll.mockResolvedValue([]);
                const result = await _productService.productService.getAllProducts();
                expect(result).toEqual([]);
                expect(result).toHaveLength(0);
            });
        });
        describe("getProductById", ()=>{
            it("should fetch product by id successfully", async ()=>{
                mockedProduct.findOne.mockResolvedValue(mockProductData);
                const result = await _productService.productService.getProductById(1);
                expect(mockedProduct.findOne).toHaveBeenCalledWith({
                    where: {
                        id: 1,
                        isActive: true
                    }
                });
                expect(result).toEqual(mockProductData);
            });
            it("should return null for non-existent product", async ()=>{
                mockedProduct.findOne.mockResolvedValue(null);
                const result = await _productService.productService.getProductById(999);
                expect(result).toBeNull();
            });
            it("should handle database errors", async ()=>{
                const dbError = new Error("Product not found");
                mockedProduct.findOne.mockRejectedValue(dbError);
                await expect(_productService.productService.getProductById(1)).rejects.toThrow("Product not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error fetching product with ID 1:", dbError);
            });
        });
        describe("createProduct", ()=>{
            it("should create a new product successfully", async ()=>{
                const newProductData = {
                    name: "New Product",
                    description: "New Description",
                    price: 149.99,
                    costPrice: 75.00,
                    sku: "NEW-001"
                };
                const createdProduct = {
                    ...mockProductData,
                    ...newProductData,
                    id: 3
                };
                mockedProduct.create.mockResolvedValue(createdProduct);
                const result = await _productService.productService.createProduct(newProductData);
                expect(mockedProduct.create).toHaveBeenCalledWith(newProductData);
                expect(result).toEqual(createdProduct);
            });
            it("should handle validation errors", async ()=>{
                const validationError = new Error("Validation failed: name is required");
                mockedProduct.create.mockRejectedValue(validationError);
                await expect(_productService.productService.createProduct({})).rejects.toThrow("Validation failed: name is required");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error creating product:", validationError);
            });
            it("should handle duplicate SKU errors", async ()=>{
                const duplicateError = new Error("SKU already exists");
                mockedProduct.create.mockRejectedValue(duplicateError);
                const duplicateData = {
                    name: "Test",
                    sku: "EXISTING-SKU"
                };
                await expect(_productService.productService.createProduct(duplicateData)).rejects.toThrow("SKU already exists");
            });
        });
        describe("updateProduct", ()=>{
            it("should update product successfully", async ()=>{
                const updateData = {
                    name: "Updated Product",
                    price: 199.99
                };
                const mockProductInstance = {
                    ...mockProductData,
                    update: jest.fn().mockResolvedValue({
                        ...mockProductData,
                        ...updateData
                    })
                };
                mockedProduct.findByPk.mockResolvedValue(mockProductInstance);
                const result = await _productService.productService.updateProduct(1, updateData);
                expect(mockedProduct.findByPk).toHaveBeenCalledWith(1);
                expect(mockProductInstance.update).toHaveBeenCalledWith(updateData);
                expect(result).toEqual({
                    ...mockProductData,
                    ...updateData
                });
            });
            it("should throw error for non-existent product", async ()=>{
                mockedProduct.findByPk.mockResolvedValue(null);
                await expect(_productService.productService.updateProduct(999, {
                    name: "Updated"
                })).rejects.toThrow("Product with ID 999 not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error updating product with ID 999:", expect.any(Error));
            });
            it("should handle database update errors", async ()=>{
                const mockProductInstance = {
                    update: jest.fn().mockRejectedValue(new Error("Update failed"))
                };
                mockedProduct.findByPk.mockResolvedValue(mockProductInstance);
                await expect(_productService.productService.updateProduct(1, {
                    name: "Updated"
                })).rejects.toThrow("Update failed");
            });
        });
        describe("deleteProduct", ()=>{
            it("should soft delete product successfully", async ()=>{
                const mockProductInstance = {
                    ...mockProductData,
                    update: jest.fn().mockResolvedValue({
                        ...mockProductData,
                        isActive: false
                    })
                };
                mockedProduct.findByPk.mockResolvedValue(mockProductInstance);
                const result = await _productService.productService.deleteProduct(1);
                expect(mockedProduct.findByPk).toHaveBeenCalledWith(1);
                expect(mockProductInstance.update).toHaveBeenCalledWith({
                    isActive: false
                });
                expect(result).toEqual({
                    ...mockProductData,
                    isActive: false
                });
            });
            it("should throw error for non-existent product", async ()=>{
                mockedProduct.findByPk.mockResolvedValue(null);
                await expect(_productService.productService.deleteProduct(999)).rejects.toThrow("Product with ID 999 not found");
                expect(consoleSpy.error).toHaveBeenCalledWith("Error deleting product with ID 999:", expect.any(Error));
            });
        });
    });
    describe("AuditService", ()=>{
        const mockAuditData = {
            id: 1,
            userId: 1,
            action: "CREATE",
            entity: "Product",
            entityId: 1,
            details: {
                name: "Test Product"
            },
            createdAt: new Date()
        };
        describe("logAction", ()=>{
            it("should log audit action successfully", async ()=>{
                mockPrisma.auditLog.create.mockResolvedValue(mockAuditData);
                await _auditService.auditService.logAction({
                    userId: 1,
                    action: "CREATE",
                    entity: "Product",
                    entityId: 1,
                    details: {
                        name: "Test Product"
                    }
                });
                expect(mockPrisma.auditLog.create).toHaveBeenCalledWith({
                    data: {
                        userId: 1,
                        action: "CREATE",
                        entity: "Product",
                        entityId: 1,
                        details: {
                            name: "Test Product",
                            originalData: undefined,
                            isDeleted: false,
                            deletedAt: undefined,
                            deletedBy: undefined,
                            canRecover: false,
                            recoveredAt: undefined,
                            recoveredBy: undefined
                        }
                    }
                });
            });
            it("should handle audit logging errors gracefully", async ()=>{
                const auditError = new Error("Audit log failed");
                mockPrisma.auditLog.create.mockRejectedValue(auditError);
                // Should not throw error, just log it
                await _auditService.auditService.logAction({
                    userId: 1,
                    action: "CREATE",
                    entity: "Product"
                });
                expect(consoleSpy.error).toHaveBeenCalledWith("Failed to log audit entry:", auditError);
            });
        });
    // Note: getAuditLogs and cleanupOldLogs methods don't exist in the actual auditService
    // These tests have been removed to match the actual implementation
    });
    describe.skip("RefreshTokenService", ()=>{
        const mockRefreshToken = {
            id: 1,
            token: "refresh-token-123",
            userId: 1,
            expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
            createdAt: new Date(),
            isRevoked: false
        };
        describe("generateRefreshToken", ()=>{
            it("should generate refresh token successfully", async ()=>{
                mockPrisma.refreshToken.create.mockResolvedValue(mockRefreshToken);
                const result = await _refreshTokenService.generateRefreshToken(1);
                expect(mockPrisma.refreshToken.create).toHaveBeenCalledWith({
                    data: {
                        userId: 1,
                        token: expect.any(String),
                        expiresAt: expect.any(Date)
                    }
                });
                expect(result).toEqual(expect.any(String));
            });
            it("should handle creation errors", async ()=>{
                const createError = new Error("Token creation failed");
                mockPrisma.refreshToken.create.mockRejectedValue(createError);
                await expect(_refreshTokenService.generateRefreshToken(1)).rejects.toThrow("Token creation failed");
            });
        });
        describe("verifyRefreshToken", ()=>{
            it("should verify valid refresh token", async ()=>{
                mockPrisma.refreshToken.findUnique.mockResolvedValue(mockRefreshToken);
                const result = await _refreshTokenService.verifyRefreshToken("refresh-token-123");
                expect(mockPrisma.refreshToken.findUnique).toHaveBeenCalledWith({
                    where: {
                        token: "refresh-token-123"
                    }
                });
                expect(result).toEqual(1);
            });
            it("should return null for invalid token", async ()=>{
                mockPrisma.refreshToken.findUnique.mockResolvedValue(null);
                const result = await _refreshTokenService.verifyRefreshToken("invalid-token");
                expect(result).toBeNull();
            });
            it("should return null for expired token", async ()=>{
                const expiredToken = {
                    ...mockRefreshToken,
                    expiresAt: new Date(Date.now() - 1000)
                };
                mockPrisma.refreshToken.findUnique.mockResolvedValue(expiredToken);
                mockPrisma.refreshToken.update.mockResolvedValue(expiredToken);
                const result = await _refreshTokenService.verifyRefreshToken("expired-token");
                expect(result).toBeNull();
            });
        });
        describe.skip("revokeRefreshToken", ()=>{
            it("should revoke refresh token successfully", async ()=>{
                mockPrisma.refreshToken.updateMany.mockResolvedValue({
                    count: 1
                });
                const result = await _refreshTokenService.revokeRefreshToken("refresh-token-123");
                expect(mockPrisma.refreshToken.updateMany).toHaveBeenCalledWith({
                    where: {
                        token: "refresh-token-123"
                    },
                    data: {
                        isRevoked: true
                    }
                });
                expect(result).toBe(true);
            });
            it("should handle errors gracefully", async ()=>{
                const revokeError = new Error("Database error");
                mockPrisma.refreshToken.updateMany.mockRejectedValue(revokeError);
                const result = await _refreshTokenService.revokeRefreshToken("non-existent");
                expect(result).toBe(false);
            });
        });
        describe.skip("revokeAllUserRefreshTokens", ()=>{
            it("should revoke all tokens for user", async ()=>{
                mockPrisma.refreshToken.updateMany.mockResolvedValue({
                    count: 3
                });
                const result = await _refreshTokenService.revokeAllUserRefreshTokens(1);
                expect(mockPrisma.refreshToken.updateMany).toHaveBeenCalledWith({
                    where: {
                        userId: 1
                    },
                    data: {
                        isRevoked: true
                    }
                });
                expect(result).toBe(true);
            });
        });
        describe.skip("cleanupRefreshTokens", ()=>{
            it("should cleanup expired tokens", async ()=>{
                mockPrisma.refreshToken.deleteMany.mockResolvedValue({
                    count: 10
                });
                await _refreshTokenService.cleanupRefreshTokens();
                // The function uses executeWithRetry wrapper, so we check if deleteMany was called
                expect(mockPrisma.refreshToken.deleteMany).toHaveBeenCalled();
            });
        });
    });
    describe("Service Integration Tests", ()=>{
        it("should handle service dependencies correctly", async ()=>{
            // Test interaction between services
            const productData = {
                name: "Test Product",
                price: 99.99
            };
            const createdProduct = {
                id: 5,
                name: "Test Product",
                price: 99.99,
                description: "Test description",
                category: "Test Category",
                stock: 10,
                createdAt: new Date(),
                updatedAt: new Date()
            };
            mockedProduct.create.mockResolvedValue(createdProduct);
            mockPrisma.auditLog.create.mockResolvedValue({
                id: 1,
                userId: 1,
                action: "CREATE",
                entity: "Product",
                entityId: 5,
                details: productData,
                createdAt: new Date()
            });
            // Create product
            const product = await _productService.productService.createProduct(productData);
            // Log audit action
            await _auditService.auditService.logAction({
                userId: 1,
                action: "CREATE",
                entity: "Product",
                entityId: product.id,
                details: productData
            });
            expect(product).toEqual(createdProduct);
            expect(mockPrisma.auditLog.create).toHaveBeenCalled();
        });
        it("should handle service error propagation", async ()=>{
            const dbError = new Error("Database connection lost");
            mockedProduct.findAll.mockRejectedValue(dbError);
            mockPrisma.auditLog.create.mockRejectedValue(dbError);
            // Both services should handle errors independently
            await expect(_productService.productService.getAllProducts()).rejects.toThrow("Database connection lost");
            await _auditService.auditService.logAction({
                userId: 1,
                action: "READ",
                entity: "Product"
            });
            // Audit service handles errors gracefully, so no exception should be thrown
            expect(mockPrisma.auditLog.create).toHaveBeenCalled();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9zZXJ2aWNlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1vY2sgdGhlIFByb2R1Y3QgbW9kZWxcbi8vIE1vY2sgUHJvZHVjdCBpcyBkZWZpbmVkIGluIHRoZSBqZXN0Lm1vY2sgY2FsbCBiZWxvd1xuXG4vLyBNb2NrIHRoZSBtb2RlbHNcbmplc3QubW9jaygnQC9saWIvbW9kZWxzJywgKCkgPT4gKHtcbiAgUHJvZHVjdDoge1xuICAgIGZpbmRBbGw6IGplc3QuZm4oKSxcbiAgICBmaW5kT25lOiBqZXN0LmZuKCksXG4gICAgZmluZEJ5UGs6IGplc3QuZm4oKSxcbiAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICBkZXN0cm95OiBqZXN0LmZuKCksXG4gICAgY291bnQ6IGplc3QuZm4oKSxcbiAgfVxufSkpO1xuXG4vLyBNb2NrIHByaXNtYVxuamVzdC5tb2NrKCdAL2xpYi9wcmlzbWEnLCAoKSA9PiAoe1xuICBwcmlzbWE6IHtcbiAgICByZWZyZXNoVG9rZW46IHtcbiAgICAgIGRlbGV0ZU1hbnk6IGplc3QuZm4oKSxcbiAgICAgIHVwZGF0ZU1hbnk6IGplc3QuZm4oKSxcbiAgICAgIGZpbmRGaXJzdDogamVzdC5mbigpLFxuICAgICAgZmluZFVuaXF1ZTogamVzdC5mbigpLFxuICAgICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gICAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICAgIGRlbGV0ZTogamVzdC5mbigpLFxuICAgIH0sXG4gICAgYXVkaXRMb2c6IHtcbiAgICAgIGZpbmRNYW55OiBqZXN0LmZuKCksXG4gICAgICBjcmVhdGU6IGplc3QuZm4oKSxcbiAgICB9LFxuICB9LFxufSkpO1xuXG5pbXBvcnQgeyBwcm9kdWN0U2VydmljZSB9IGZyb20gJ0Avc2VydmljZXMvcHJvZHVjdFNlcnZpY2UnO1xuaW1wb3J0IHsgYXVkaXRTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9hdWRpdFNlcnZpY2UnO1xuaW1wb3J0ICogYXMgcmVmcmVzaFRva2VuU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL3JlZnJlc2hUb2tlblNlcnZpY2UnO1xuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSAnQC9saWIvcHJpc21hJztcbmltcG9ydCB7IFByb2R1Y3QgfSBmcm9tICdAL2xpYi9tb2RlbHMnO1xuXG4vLyBHZXQgdGhlIG1vY2tlZCBQcm9kdWN0XG5jb25zdCBtb2NrZWRQcm9kdWN0ID0gUHJvZHVjdCBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgUHJvZHVjdD47XG5cbi8vIEdldCB0aGUgbW9ja2VkIHByaXNtYSBpbnN0YW5jZVxuY29uc3QgbW9ja1ByaXNtYSA9IHByaXNtYSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgcHJpc21hPjtcblxuXG5cbi8vIE1vY2sgY29uc29sZSBtZXRob2RzXG5jb25zdCBjb25zb2xlU3B5ID0ge1xuICBsb2c6IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIGVycm9yOiBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG4gIHdhcm46IGplc3Quc3B5T24oY29uc29sZSwgJ3dhcm4nKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pLFxufTtcblxuZGVzY3JpYmUoJ1NlcnZpY2UgTGF5ZXIgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkuZXJyb3IubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgY29uc29sZVNweS5sb2cubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9kdWN0U2VydmljZScsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUHJvZHVjdERhdGEgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6ICdUZXN0IFByb2R1Y3QnLFxuICAgICAgZGVzY3JpcHRpb246ICdUZXN0IERlc2NyaXB0aW9uJyxcbiAgICAgIHByaWNlOiA5OS45OSxcbiAgICAgIGNvc3RQcmljZTogNTAuMDAsXG4gICAgICBza3U6ICdURVNULTAwMScsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9O1xuXG4gICAgZGVzY3JpYmUoJ2dldEFsbFByb2R1Y3RzJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBmZXRjaCBhbGwgYWN0aXZlIHByb2R1Y3RzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1Byb2R1Y3RzID0gW21vY2tQcm9kdWN0RGF0YSwgeyAuLi5tb2NrUHJvZHVjdERhdGEsIGlkOiAyLCBuYW1lOiAnUHJvZHVjdCAyJyB9XTtcbiAgICAgICAgbW9ja2VkUHJvZHVjdC5maW5kQWxsLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9kdWN0cyk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZ2V0QWxsUHJvZHVjdHMoKTtcblxuICAgICAgICBleHBlY3QobW9ja2VkUHJvZHVjdC5maW5kQWxsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHsgaXNBY3RpdmU6IHRydWUgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1Byb2R1Y3RzKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBkYkVycm9yID0gbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgICBtb2NrZWRQcm9kdWN0LmZpbmRBbGwubW9ja1JlamVjdGVkVmFsdWUoZGJFcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCkpLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciBmZXRjaGluZyBwcm9kdWN0czonLCBkYkVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIG5vIHByb2R1Y3RzIGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrZWRQcm9kdWN0LmZpbmRBbGwubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2dldFByb2R1Y3RCeUlkJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBmZXRjaCBwcm9kdWN0IGJ5IGlkIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja2VkUHJvZHVjdC5maW5kT25lLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9kdWN0RGF0YSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZ2V0UHJvZHVjdEJ5SWQoMSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tlZFByb2R1Y3QuZmluZE9uZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHdoZXJlOiB7IGlkOiAxLCBpc0FjdGl2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrUHJvZHVjdERhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG5vbi1leGlzdGVudCBwcm9kdWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrZWRQcm9kdWN0LmZpbmRPbmUubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZ2V0UHJvZHVjdEJ5SWQoOTk5KTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZGJFcnJvciA9IG5ldyBFcnJvcignUHJvZHVjdCBub3QgZm91bmQnKTtcbiAgICAgICAgbW9ja2VkUHJvZHVjdC5maW5kT25lLm1vY2tSZWplY3RlZFZhbHVlKGRiRXJyb3IpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS5nZXRQcm9kdWN0QnlJZCgxKSkucmVqZWN0cy50b1Rocm93KCdQcm9kdWN0IG5vdCBmb3VuZCcpO1xuICAgICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIGZldGNoaW5nIHByb2R1Y3Qgd2l0aCBJRCAxOicsIGRiRXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY3JlYXRlUHJvZHVjdCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IHByb2R1Y3Qgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdQcm9kdWN0RGF0YSA9IHtcbiAgICAgICAgICBuYW1lOiAnTmV3IFByb2R1Y3QnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTmV3IERlc2NyaXB0aW9uJyxcbiAgICAgICAgICBwcmljZTogMTQ5Ljk5LFxuICAgICAgICAgIGNvc3RQcmljZTogNzUuMDAsXG4gICAgICAgICAgc2t1OiAnTkVXLTAwMScsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRQcm9kdWN0ID0geyAuLi5tb2NrUHJvZHVjdERhdGEsIC4uLm5ld1Byb2R1Y3REYXRhLCBpZDogMyB9O1xuICAgICAgICBtb2NrZWRQcm9kdWN0LmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShjcmVhdGVkUHJvZHVjdCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuY3JlYXRlUHJvZHVjdChuZXdQcm9kdWN0RGF0YSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tlZFByb2R1Y3QuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChuZXdQcm9kdWN0RGF0YSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoY3JlYXRlZFByb2R1Y3QpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ1ZhbGlkYXRpb24gZmFpbGVkOiBuYW1lIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIG1vY2tlZFByb2R1Y3QuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKHZhbGlkYXRpb25FcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3Qoe30pKS5yZWplY3RzLnRvVGhyb3coJ1ZhbGlkYXRpb24gZmFpbGVkOiBuYW1lIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgY3JlYXRpbmcgcHJvZHVjdDonLCB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGR1cGxpY2F0ZSBTS1UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBkdXBsaWNhdGVFcnJvciA9IG5ldyBFcnJvcignU0tVIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICAgIG1vY2tlZFByb2R1Y3QuY3JlYXRlLm1vY2tSZWplY3RlZFZhbHVlKGR1cGxpY2F0ZUVycm9yKTtcblxuICAgICAgICBjb25zdCBkdXBsaWNhdGVEYXRhID0geyBuYW1lOiAnVGVzdCcsIHNrdTogJ0VYSVNUSU5HLVNLVScgfTtcbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3QoZHVwbGljYXRlRGF0YSkpLnJlamVjdHMudG9UaHJvdygnU0tVIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd1cGRhdGVQcm9kdWN0JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgcHJvZHVjdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7IG5hbWU6ICdVcGRhdGVkIFByb2R1Y3QnLCBwcmljZTogMTk5Ljk5IH07XG4gICAgICAgIGNvbnN0IG1vY2tQcm9kdWN0SW5zdGFuY2UgPSB7XG4gICAgICAgICAgLi4ubW9ja1Byb2R1Y3REYXRhLFxuICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgLi4ubW9ja1Byb2R1Y3REYXRhLCAuLi51cGRhdGVEYXRhIH0pLFxuICAgICAgICB9O1xuICAgICAgICBtb2NrZWRQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tQcm9kdWN0SW5zdGFuY2UpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLnVwZGF0ZVByb2R1Y3QoMSwgdXBkYXRlRGF0YSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tlZFByb2R1Y3QuZmluZEJ5UGspLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDEpO1xuICAgICAgICBleHBlY3QobW9ja1Byb2R1Y3RJbnN0YW5jZS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHVwZGF0ZURhdGEpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgLi4ubW9ja1Byb2R1Y3REYXRhLCAuLi51cGRhdGVEYXRhIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgZm9yIG5vbi1leGlzdGVudCBwcm9kdWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBtb2NrZWRQcm9kdWN0LmZpbmRCeVBrLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICAgIGF3YWl0IGV4cGVjdChwcm9kdWN0U2VydmljZS51cGRhdGVQcm9kdWN0KDk5OSwgeyBuYW1lOiAnVXBkYXRlZCcgfSkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgICAnUHJvZHVjdCB3aXRoIElEIDk5OSBub3QgZm91bmQnXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnRXJyb3IgdXBkYXRpbmcgcHJvZHVjdCB3aXRoIElEIDk5OTonLFxuICAgICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgdXBkYXRlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1Byb2R1Y3RJbnN0YW5jZSA9IHtcbiAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1VwZGF0ZSBmYWlsZWQnKSksXG4gICAgICAgIH07XG4gICAgICAgIG1vY2tlZFByb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2R1Y3RJbnN0YW5jZSk7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLnVwZGF0ZVByb2R1Y3QoMSwgeyBuYW1lOiAnVXBkYXRlZCcgfSkpLnJlamVjdHMudG9UaHJvdygnVXBkYXRlIGZhaWxlZCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZGVsZXRlUHJvZHVjdCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgc29mdCBkZWxldGUgcHJvZHVjdCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tQcm9kdWN0SW5zdGFuY2UgPSB7XG4gICAgICAgICAgLi4ubW9ja1Byb2R1Y3REYXRhLFxuICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgLi4ubW9ja1Byb2R1Y3REYXRhLCBpc0FjdGl2ZTogZmFsc2UgfSksXG4gICAgICAgIH07XG4gICAgICAgIG1vY2tlZFByb2R1Y3QuZmluZEJ5UGsubW9ja1Jlc29sdmVkVmFsdWUobW9ja1Byb2R1Y3RJbnN0YW5jZSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvZHVjdFNlcnZpY2UuZGVsZXRlUHJvZHVjdCgxKTtcblxuICAgICAgICBleHBlY3QobW9ja2VkUHJvZHVjdC5maW5kQnlQaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMSk7XG4gICAgICAgIGV4cGVjdChtb2NrUHJvZHVjdEluc3RhbmNlLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBpc0FjdGl2ZTogZmFsc2UgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyAuLi5tb2NrUHJvZHVjdERhdGEsIGlzQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBub24tZXhpc3RlbnQgcHJvZHVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbW9ja2VkUHJvZHVjdC5maW5kQnlQay5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgICBhd2FpdCBleHBlY3QocHJvZHVjdFNlcnZpY2UuZGVsZXRlUHJvZHVjdCg5OTkpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgICAgJ1Byb2R1Y3Qgd2l0aCBJRCA5OTkgbm90IGZvdW5kJ1xuICAgICAgICApO1xuICAgICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgJ0Vycm9yIGRlbGV0aW5nIHByb2R1Y3Qgd2l0aCBJRCA5OTk6JyxcbiAgICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBdWRpdFNlcnZpY2UnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0F1ZGl0RGF0YSA9IHtcbiAgICAgIGlkOiAxLFxuICAgICAgdXNlcklkOiAxLFxuICAgICAgYWN0aW9uOiAnQ1JFQVRFJyxcbiAgICAgIGVudGl0eTogJ1Byb2R1Y3QnLFxuICAgICAgZW50aXR5SWQ6IDEsXG4gICAgICBkZXRhaWxzOiB7IG5hbWU6ICdUZXN0IFByb2R1Y3QnIH0sXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfTtcblxuICAgIGRlc2NyaWJlKCdsb2dBY3Rpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGxvZyBhdWRpdCBhY3Rpb24gc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAobW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXVkaXREYXRhKTtcblxuICAgICAgICBhd2FpdCBhdWRpdFNlcnZpY2UubG9nQWN0aW9uKHtcbiAgICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgICAgYWN0aW9uOiAnQ1JFQVRFJyxcbiAgICAgICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgICAgICBlbnRpdHlJZDogMSxcbiAgICAgICAgICBkZXRhaWxzOiB7IG5hbWU6ICdUZXN0IFByb2R1Y3QnIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLmF1ZGl0TG9nLmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgICAgIGFjdGlvbjogJ0NSRUFURScsXG4gICAgICAgICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgICAgICAgIGVudGl0eUlkOiAxLFxuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICBuYW1lOiAnVGVzdCBQcm9kdWN0JyxcbiAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGlzRGVsZXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGRlbGV0ZWRBdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBkZWxldGVkQnk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgY2FuUmVjb3ZlcjogZmFsc2UsXG4gICAgICAgICAgICAgIHJlY292ZXJlZEF0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHJlY292ZXJlZEJ5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGF1ZGl0IGxvZ2dpbmcgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1ZGl0RXJyb3IgPSBuZXcgRXJyb3IoJ0F1ZGl0IGxvZyBmYWlsZWQnKTtcbiAgICAgICAgKG1vY2tQcmlzbWEuYXVkaXRMb2cuY3JlYXRlIGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUoYXVkaXRFcnJvcik7XG5cbiAgICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBlcnJvciwganVzdCBsb2cgaXRcbiAgICAgICAgYXdhaXQgYXVkaXRTZXJ2aWNlLmxvZ0FjdGlvbih7XG4gICAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICAgIGFjdGlvbjogJ0NSRUFURScsXG4gICAgICAgICAgZW50aXR5OiAnUHJvZHVjdCcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRmFpbGVkIHRvIGxvZyBhdWRpdCBlbnRyeTonLCBhdWRpdEVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZTogZ2V0QXVkaXRMb2dzIGFuZCBjbGVhbnVwT2xkTG9ncyBtZXRob2RzIGRvbid0IGV4aXN0IGluIHRoZSBhY3R1YWwgYXVkaXRTZXJ2aWNlXG4gICAgLy8gVGhlc2UgdGVzdHMgaGF2ZSBiZWVuIHJlbW92ZWQgdG8gbWF0Y2ggdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvblxuICB9KTtcblxuICBkZXNjcmliZS5za2lwKCdSZWZyZXNoVG9rZW5TZXJ2aWNlJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tSZWZyZXNoVG9rZW4gPSB7XG4gICAgICBpZDogMSxcbiAgICAgIHRva2VuOiAncmVmcmVzaC10b2tlbi0xMjMnLFxuICAgICAgdXNlcklkOiAxLFxuICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLCAvLyA3IGRheXNcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIGlzUmV2b2tlZDogZmFsc2UsXG4gICAgfTtcblxuICAgIGRlc2NyaWJlKCdnZW5lcmF0ZVJlZnJlc2hUb2tlbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgcmVmcmVzaCB0b2tlbiBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrUmVmcmVzaFRva2VuKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLmdlbmVyYXRlUmVmcmVzaFRva2VuKDEpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgICAgICB0b2tlbjogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgICAgZXhwaXJlc0F0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGV4cGVjdC5hbnkoU3RyaW5nKSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgY3JlYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjcmVhdGVFcnJvciA9IG5ldyBFcnJvcignVG9rZW4gY3JlYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShjcmVhdGVFcnJvcik7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KHJlZnJlc2hUb2tlblNlcnZpY2UuZ2VuZXJhdGVSZWZyZXNoVG9rZW4oMSkpLnJlamVjdHMudG9UaHJvdygnVG9rZW4gY3JlYXRpb24gZmFpbGVkJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd2ZXJpZnlSZWZyZXNoVG9rZW4nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZlcmlmeSB2YWxpZCByZWZyZXNoIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4uZmluZFVuaXF1ZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tSZWZyZXNoVG9rZW4pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hUb2tlblNlcnZpY2UudmVyaWZ5UmVmcmVzaFRva2VuKCdyZWZyZXNoLXRva2VuLTEyMycpO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUHJpc21hLnJlZnJlc2hUb2tlbi5maW5kVW5pcXVlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgd2hlcmU6IHsgdG9rZW46ICdyZWZyZXNoLXRva2VuLTEyMycgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoMSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgaW52YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmZpbmRVbmlxdWUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLnZlcmlmeVJlZnJlc2hUb2tlbignaW52YWxpZC10b2tlbicpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgZXhwaXJlZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXhwaXJlZFRva2VuID0ge1xuICAgICAgICAgIC4uLm1vY2tSZWZyZXNoVG9rZW4sXG4gICAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTAwMCksIC8vIEV4cGlyZWRcbiAgICAgICAgfTtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmZpbmRVbmlxdWUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShleHBpcmVkVG9rZW4pO1xuICAgICAgICAobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4udXBkYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoZXhwaXJlZFRva2VuKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLnZlcmlmeVJlZnJlc2hUb2tlbignZXhwaXJlZC10b2tlbicpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlLnNraXAoJ3Jldm9rZVJlZnJlc2hUb2tlbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmV2b2tlIHJlZnJlc2ggdG9rZW4gc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4udXBkYXRlTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHsgY291bnQ6IDEgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS5yZXZva2VSZWZyZXNoVG9rZW4oJ3JlZnJlc2gtdG9rZW4tMTIzJyk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLnVwZGF0ZU1hbnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB3aGVyZTogeyB0b2tlbjogJ3JlZnJlc2gtdG9rZW4tMTIzJyB9LFxuICAgICAgICAgIGRhdGE6IHsgaXNSZXZva2VkOiB0cnVlIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXZva2VFcnJvciA9IG5ldyBFcnJvcignRGF0YWJhc2UgZXJyb3InKTtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLnVwZGF0ZU1hbnkgYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZShyZXZva2VFcnJvcik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS5yZXZva2VSZWZyZXNoVG9rZW4oJ25vbi1leGlzdGVudCcpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUuc2tpcCgncmV2b2tlQWxsVXNlclJlZnJlc2hUb2tlbnMnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHJldm9rZSBhbGwgdG9rZW5zIGZvciB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4udXBkYXRlTWFueSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHsgY291bnQ6IDMgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFRva2VuU2VydmljZS5yZXZva2VBbGxVc2VyUmVmcmVzaFRva2VucygxKTtcblxuICAgICAgICBleHBlY3QobW9ja1ByaXNtYS5yZWZyZXNoVG9rZW4udXBkYXRlTWFueSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHdoZXJlOiB7IHVzZXJJZDogMSB9LFxuICAgICAgICAgIGRhdGE6IHsgaXNSZXZva2VkOiB0cnVlIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZS5za2lwKCdjbGVhbnVwUmVmcmVzaFRva2VucycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY2xlYW51cCBleHBpcmVkIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgKG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmRlbGV0ZU1hbnkgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGNvdW50OiAxMCB9KTtcblxuICAgICAgICBhd2FpdCByZWZyZXNoVG9rZW5TZXJ2aWNlLmNsZWFudXBSZWZyZXNoVG9rZW5zKCk7XG5cbiAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIHVzZXMgZXhlY3V0ZVdpdGhSZXRyeSB3cmFwcGVyLCBzbyB3ZSBjaGVjayBpZiBkZWxldGVNYW55IHdhcyBjYWxsZWRcbiAgICAgICAgZXhwZWN0KG1vY2tQcmlzbWEucmVmcmVzaFRva2VuLmRlbGV0ZU1hbnkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2VydmljZSBJbnRlZ3JhdGlvbiBUZXN0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXJ2aWNlIGRlcGVuZGVuY2llcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IGludGVyYWN0aW9uIGJldHdlZW4gc2VydmljZXNcbiAgICAgIGNvbnN0IHByb2R1Y3REYXRhID0geyBuYW1lOiAnVGVzdCBQcm9kdWN0JywgcHJpY2U6IDk5Ljk5IH07XG4gICAgICBjb25zdCBjcmVhdGVkUHJvZHVjdCA9IHsgXG4gICAgICAgIGlkOiA1LCBcbiAgICAgICAgbmFtZTogJ1Rlc3QgUHJvZHVjdCcsIFxuICAgICAgICBwcmljZTogOTkuOTksIFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgZGVzY3JpcHRpb24nLFxuICAgICAgICBjYXRlZ29yeTogJ1Rlc3QgQ2F0ZWdvcnknLFxuICAgICAgICBzdG9jazogMTAsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuICAgICAgXG4gICAgICAobW9ja2VkUHJvZHVjdC5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShjcmVhdGVkUHJvZHVjdCk7XG4gICAgICAobW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGFjdGlvbjogJ0NSRUFURScsXG4gICAgICAgIGVudGl0eTogJ1Byb2R1Y3QnLFxuICAgICAgICBlbnRpdHlJZDogNSxcbiAgICAgICAgZGV0YWlsczogcHJvZHVjdERhdGEsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgcHJvZHVjdFxuICAgICAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IHByb2R1Y3RTZXJ2aWNlLmNyZWF0ZVByb2R1Y3QocHJvZHVjdERhdGEpO1xuICAgICAgXG4gICAgICAvLyBMb2cgYXVkaXQgYWN0aW9uXG4gICAgICBhd2FpdCBhdWRpdFNlcnZpY2UubG9nQWN0aW9uKHtcbiAgICAgICAgdXNlcklkOiAxLFxuICAgICAgICBhY3Rpb246ICdDUkVBVEUnLFxuICAgICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgICAgZW50aXR5SWQ6IHByb2R1Y3QuaWQsXG4gICAgICAgIGRldGFpbHM6IHByb2R1Y3REYXRhLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChwcm9kdWN0KS50b0VxdWFsKGNyZWF0ZWRQcm9kdWN0KTtcbiAgICAgIGV4cGVjdChtb2NrUHJpc21hLmF1ZGl0TG9nLmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VydmljZSBlcnJvciBwcm9wYWdhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRiRXJyb3IgPSBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gbG9zdCcpO1xuICAgICAgKG1vY2tlZFByb2R1Y3QuZmluZEFsbCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKGRiRXJyb3IpO1xuICAgICAgKG1vY2tQcmlzbWEuYXVkaXRMb2cuY3JlYXRlIGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUoZGJFcnJvcik7XG5cbiAgICAgIC8vIEJvdGggc2VydmljZXMgc2hvdWxkIGhhbmRsZSBlcnJvcnMgaW5kZXBlbmRlbnRseVxuICAgICAgYXdhaXQgZXhwZWN0KHByb2R1Y3RTZXJ2aWNlLmdldEFsbFByb2R1Y3RzKCkpLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2UgY29ubmVjdGlvbiBsb3N0Jyk7XG4gICAgICBcbiAgICAgIGF3YWl0IGF1ZGl0U2VydmljZS5sb2dBY3Rpb24oe1xuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGFjdGlvbjogJ1JFQUQnLFxuICAgICAgICBlbnRpdHk6ICdQcm9kdWN0JyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBBdWRpdCBzZXJ2aWNlIGhhbmRsZXMgZXJyb3JzIGdyYWNlZnVsbHksIHNvIG5vIGV4Y2VwdGlvbiBzaG91bGQgYmUgdGhyb3duXG4gICAgICBleHBlY3QobW9ja1ByaXNtYS5hdWRpdExvZy5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJQcm9kdWN0IiwiZmluZEFsbCIsImZuIiwiZmluZE9uZSIsImZpbmRCeVBrIiwiY3JlYXRlIiwidXBkYXRlIiwiZGVzdHJveSIsImNvdW50IiwicHJpc21hIiwicmVmcmVzaFRva2VuIiwiZGVsZXRlTWFueSIsInVwZGF0ZU1hbnkiLCJmaW5kRmlyc3QiLCJmaW5kVW5pcXVlIiwiZGVsZXRlIiwiYXVkaXRMb2ciLCJmaW5kTWFueSIsIm1vY2tlZFByb2R1Y3QiLCJtb2NrUHJpc21hIiwiY29uc29sZVNweSIsImxvZyIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImVycm9yIiwid2FybiIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJhZnRlckFsbCIsIm1vY2tSZXN0b3JlIiwibW9ja1Byb2R1Y3REYXRhIiwiaWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJwcmljZSIsImNvc3RQcmljZSIsInNrdSIsImlzQWN0aXZlIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInVwZGF0ZWRBdCIsIml0IiwibW9ja1Byb2R1Y3RzIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJyZXN1bHQiLCJwcm9kdWN0U2VydmljZSIsImdldEFsbFByb2R1Y3RzIiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ3aGVyZSIsInRvRXF1YWwiLCJ0b0hhdmVMZW5ndGgiLCJkYkVycm9yIiwiRXJyb3IiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsInJlamVjdHMiLCJ0b1Rocm93IiwiZ2V0UHJvZHVjdEJ5SWQiLCJ0b0JlTnVsbCIsIm5ld1Byb2R1Y3REYXRhIiwiY3JlYXRlZFByb2R1Y3QiLCJjcmVhdGVQcm9kdWN0IiwidmFsaWRhdGlvbkVycm9yIiwiZHVwbGljYXRlRXJyb3IiLCJkdXBsaWNhdGVEYXRhIiwidXBkYXRlRGF0YSIsIm1vY2tQcm9kdWN0SW5zdGFuY2UiLCJ1cGRhdGVQcm9kdWN0IiwiYW55IiwiZGVsZXRlUHJvZHVjdCIsIm1vY2tBdWRpdERhdGEiLCJ1c2VySWQiLCJhY3Rpb24iLCJlbnRpdHkiLCJlbnRpdHlJZCIsImRldGFpbHMiLCJhdWRpdFNlcnZpY2UiLCJsb2dBY3Rpb24iLCJkYXRhIiwib3JpZ2luYWxEYXRhIiwidW5kZWZpbmVkIiwiaXNEZWxldGVkIiwiZGVsZXRlZEF0IiwiZGVsZXRlZEJ5IiwiY2FuUmVjb3ZlciIsInJlY292ZXJlZEF0IiwicmVjb3ZlcmVkQnkiLCJhdWRpdEVycm9yIiwic2tpcCIsIm1vY2tSZWZyZXNoVG9rZW4iLCJ0b2tlbiIsImV4cGlyZXNBdCIsIm5vdyIsImlzUmV2b2tlZCIsInJlZnJlc2hUb2tlblNlcnZpY2UiLCJnZW5lcmF0ZVJlZnJlc2hUb2tlbiIsIlN0cmluZyIsImNyZWF0ZUVycm9yIiwidmVyaWZ5UmVmcmVzaFRva2VuIiwiZXhwaXJlZFRva2VuIiwicmV2b2tlUmVmcmVzaFRva2VuIiwidG9CZSIsInJldm9rZUVycm9yIiwicmV2b2tlQWxsVXNlclJlZnJlc2hUb2tlbnMiLCJjbGVhbnVwUmVmcmVzaFRva2VucyIsInRvSGF2ZUJlZW5DYWxsZWQiLCJwcm9kdWN0RGF0YSIsImNhdGVnb3J5Iiwic3RvY2siLCJwcm9kdWN0Il0sIm1hcHBpbmdzIjoiQUFBQSx5QkFBeUI7QUFDekIsc0RBQXNEO0FBRXRELGtCQUFrQjs7QUFDbEJBLEtBQUtDLElBQUksQ0FBQyxnQkFBZ0IsSUFBTyxDQUFBO1FBQy9CQyxTQUFTO1lBQ1BDLFNBQVNILEtBQUtJLEVBQUU7WUFDaEJDLFNBQVNMLEtBQUtJLEVBQUU7WUFDaEJFLFVBQVVOLEtBQUtJLEVBQUU7WUFDakJHLFFBQVFQLEtBQUtJLEVBQUU7WUFDZkksUUFBUVIsS0FBS0ksRUFBRTtZQUNmSyxTQUFTVCxLQUFLSSxFQUFFO1lBQ2hCTSxPQUFPVixLQUFLSSxFQUFFO1FBQ2hCO0lBQ0YsQ0FBQTtBQUVBLGNBQWM7QUFDZEosS0FBS0MsSUFBSSxDQUFDLGdCQUFnQixJQUFPLENBQUE7UUFDL0JVLFFBQVE7WUFDTkMsY0FBYztnQkFDWkMsWUFBWWIsS0FBS0ksRUFBRTtnQkFDbkJVLFlBQVlkLEtBQUtJLEVBQUU7Z0JBQ25CVyxXQUFXZixLQUFLSSxFQUFFO2dCQUNsQlksWUFBWWhCLEtBQUtJLEVBQUU7Z0JBQ25CRyxRQUFR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