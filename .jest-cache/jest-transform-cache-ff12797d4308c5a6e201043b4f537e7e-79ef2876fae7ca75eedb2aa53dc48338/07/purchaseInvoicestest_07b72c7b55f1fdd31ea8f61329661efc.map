{"version":3,"sources":["/Users/sachin/Documents/md-sports-/tests/integration/purchaseInvoices.test.ts"],"sourcesContent":["/**\n * @jest-environment node\n */\nimport { PrismaClient } from '@prisma/client';\nimport { POST as createPurchaseInvoice } from '@/app/api/purchases/route'; // Adjust if direct import isn't feasible\nimport { PUT as updatePurchaseInvoice } from '@/app/api/purchases/[id]/route'; // Adjust\nimport { DELETE as deletePurchaseInvoice } from '@/app/api/purchases/[id]/route'; // Adjust\nimport { NextRequest } from 'next/server';\nimport { createMocks } from 'node-mocks-http'; // Or any other way to mock NextRequest/Response\n\nconst prisma = new PrismaClient();\n\ndescribe('Purchase Invoice API Integration Tests', () => {\n    let createdShopId: string;\n    let createdSupplierId: number;\n    let createdProductId: number;\n\n    beforeAll(async () => {\n        // Seed initial data if necessary, e.g., a default supplier or shop\n        // For now, we'll create them in beforeEach or specific tests\n    });\n\n    beforeEach(async () => {\n        // Clean up database tables to ensure test isolation\n        await prisma.purchaseInvoiceItem.deleteMany({});\n        await prisma.purchaseInvoice.deleteMany({});\n        await prisma.inventoryItem.deleteMany({});\n        await prisma.product.deleteMany({});\n        await prisma.supplier.deleteMany({});\n        await prisma.shop.deleteMany({});\n\n        // Create a shop for testing\n        const shop = await prisma.shop.create({\n            data: {\n                name: 'Test Shop Local',\n                location: 'Test Location',\n                // Add other required fields if any\n            },\n        });\n        createdShopId = shop.id;\n\n        // Create a supplier for testing\n        const supplier = await prisma.supplier.create({\n            data: {\n                name: 'Test Supplier Local',\n                // Add other required fields\n            },\n        });\n        createdSupplierId = supplier.id;\n\n        // Create a product for testing updates/deletes (not for create new product test)\n        const product = await prisma.product.create({\n            data: {\n                name: 'Existing Product',\n                price: 100, // retail price\n                sku: 'EXISTING001',\n                shopId: createdShopId, // Optional: associate with a shop by default\n                // weightedAverageCost will be set by purchases\n            }\n        });\n        createdProductId = product.id;\n    });\n\n    afterAll(async () => {\n        // Clean up database after all tests\n        await prisma.purchaseInvoiceItem.deleteMany({});\n        await prisma.purchaseInvoice.deleteMany({});\n        await prisma.inventoryItem.deleteMany({});\n        await prisma.product.deleteMany({});\n        await prisma.supplier.deleteMany({});\n        await prisma.shop.deleteMany({});\n        await prisma.$disconnect();\n    });\n\n    describe('POST /api/purchases (Create Purchase Invoice)', () => {\n        it('should create a purchase invoice for a new product, update inventory, and set WAC', async () => {\n            // 1. Define data for a new product\n            const newProductName = 'Brand New Racket';\n            const newProductSku = 'NEWB001';\n            const purchasePrice = 150;\n            const purchaseQuantity = 10;\n\n            // Create product first (as API expects productId)\n            // In a real scenario, the UI might create product then purchase, or purchase API handles product creation\n            // For this test, assume product is created just before, or API implies its creation from purchase (not current API)\n            // Let's assume for now product must exist, if API doesn't create it from purchase items.\n            // The current API's POST /api/purchases expects item.productId, implying product exists.\n\n            const newTestProduct = await prisma.product.create({\n                data: {\n                    name: newProductName,\n                    sku: newProductSku,\n                    price: 250, // Retail price\n                    shopId: createdShopId // Optional default shop association\n                }\n            });\n            const newTestProductId = newTestProduct.id;\n\n            // 2. Prepare the request body for POST /api/purchases\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: newTestProductId.toString(),\n                        quantity: purchaseQuantity,\n                        price: purchasePrice,\n                    },\n                ],\n                distributions: [ // Explicit distribution is crucial based on current POST API\n                    {\n                        [createdShopId]: purchaseQuantity\n                    }\n                ],\n                totalAmount: purchaseQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            // 3. Construct a NextRequest instance\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            });\n\n            // Simulate the API call\n            const response = await createPurchaseInvoice(req);\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(201); // Or 200 depending on your API's success response for POST\n            expect(responseBody.data).toHaveProperty('id');\n            const createdInvoiceId = responseBody.data.id;\n\n            // Verify PurchaseInvoice in DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: createdInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice).not.toBeNull();\n            expect(dbInvoice?.supplierId).toBe(createdSupplierId);\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].productId).toBe(newTestProductId);\n            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity);\n            expect(dbInvoice?.items[0].price).toBe(purchasePrice);\n\n            // Verify InventoryItem in DB\n            const dbInventoryItem = await prisma.inventoryItem.findFirst({\n                where: {\n                    productId: newTestProductId,\n                    shopId: createdShopId,\n                },\n            });\n            expect(dbInventoryItem).not.toBeNull();\n            expect(dbInventoryItem?.quantity).toBe(purchaseQuantity);\n            // The POST route seems to calculate shopSpecificCost too.\n            // WAC = (Current Total Value + New Purchase Value) / (Current Quantity + New Quantity)\n            // For new item, existing shopSpecificCost is 0, currentQuantity is 0.\n            // So newShopSpecificCost should be newCost (purchasePrice)\n            expect(dbInventoryItem?.shopSpecificCost).toBe(purchasePrice);\n\n\n            // Verify Product WAC in DB\n            const dbProduct = await prisma.product.findUnique({\n                where: { id: newTestProductId },\n            });\n            expect(dbProduct).not.toBeNull();\n            // For a new product, WAC should be equal to the purchase price of this first batch\n            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);\n        }, 15000); // Increased timeout\n\n        it('should create a purchase for an existing product, update inventory, and recalculate WACs', async () => {\n            // 0. Initial state: Product exists, potentially with some inventory and WAC\n            const initialPurchasePrice = 120;\n            const initialPurchaseQuantity = 5;\n            const existingProductId = createdProductId; // From beforeEach\n\n            // Create an initial purchase to set up existing inventory and WAC\n            const initialPayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date(Date.now() - 86400000).toISOString(), // Yesterday\n                items: [{\n                    productId: existingProductId.toString(),\n                    quantity: initialPurchaseQuantity,\n                    price: initialPurchasePrice,\n                }],\n                distributions: [{ [createdShopId]: initialPurchaseQuantity }],\n                totalAmount: initialPurchaseQuantity * initialPurchasePrice,\n                status: 'paid',\n            };\n            const initialReq = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(initialPayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            await createPurchaseInvoice(initialReq);\n\n            const productBeforeNewPurchase = await prisma.product.findUnique({ where: { id: existingProductId } });\n            const inventoryBeforeNewPurchase = await prisma.inventoryItem.findFirst({ where: { productId: existingProductId, shopId: createdShopId } });\n\n            expect(productBeforeNewPurchase?.weightedAverageCost).toBe(initialPurchasePrice);\n            expect(inventoryBeforeNewPurchase?.quantity).toBe(initialPurchaseQuantity);\n            expect(inventoryBeforeNewPurchase?.shopSpecificCost).toBe(initialPurchasePrice);\n\n            // 1. Define data for the new purchase of the existing product\n            const newPurchasePrice = 100;\n            const newPurchaseQuantity = 8;\n\n            // 2. Prepare the request body\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: existingProductId.toString(),\n                        quantity: newPurchaseQuantity,\n                        price: newPurchasePrice,\n                    },\n                ],\n                distributions: [\n                    {\n                        [createdShopId]: newPurchaseQuantity\n                    }\n                ],\n                totalAmount: newPurchaseQuantity * newPurchasePrice,\n                status: 'paid',\n            };\n\n            // 3. Simulate API call\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(201);\n            const createdInvoiceId = responseBody.data.id;\n\n            // Verify InventoryItem\n            const dbInventoryItem = await prisma.inventoryItem.findFirst({\n                where: {\n                    productId: existingProductId,\n                    shopId: createdShopId,\n                },\n            });\n            const expectedTotalQuantity = initialPurchaseQuantity + newPurchaseQuantity;\n            expect(dbInventoryItem?.quantity).toBe(expectedTotalQuantity);\n\n            // Verify shopSpecificCost recalculation\n            // SSC = ((oldQty * oldSSC) + (newQty * newPrice)) / (oldQty + newQty)\n            const expectedShopSpecificCost =\n                ((initialPurchaseQuantity * initialPurchasePrice) + (newPurchaseQuantity * newPurchasePrice)) /\n                (initialPurchaseQuantity + newPurchaseQuantity);\n            expect(dbInventoryItem?.shopSpecificCost).toBeCloseTo(expectedShopSpecificCost);\n\n            // Verify Product WAC recalculation\n            // WAC = ((oldTotalQty * oldWAC) + (newPurchaseQty * newPurchasePrice)) / (newTotalQty + newPurchaseQty)\n            // In this case, product WAC was initialPurchasePrice for initialPurchaseQuantity.\n            const expectedProductWAC =\n                ((initialPurchaseQuantity * initialPurchasePrice) + (newPurchaseQuantity * newPurchasePrice)) /\n                (initialPurchaseQuantity + newPurchaseQuantity);\n            const dbProduct = await prisma.product.findUnique({ where: { id: existingProductId } });\n            expect(dbProduct?.weightedAverageCost).toBeCloseTo(expectedProductWAC);\n        }, 15000); // Increased timeout\n\n        it('should create a purchase with multiple items and update inventory/WAC for each', async () => {\n            // 1. Create two distinct products for this test\n            const product1Data = { name: 'MultiItem Product A', sku: 'MULTI001', price: 50, shopId: createdShopId };\n            const product2Data = { name: 'MultiItem Product B', sku: 'MULTI002', price: 75, shopId: createdShopId };\n            const product1 = await prisma.product.create({ data: product1Data });\n            const product2 = await prisma.product.create({ data: product2Data });\n\n            const purchasePrice1 = 40;\n            const purchaseQuantity1 = 5;\n            const purchasePrice2 = 60;\n            const purchaseQuantity2 = 3;\n\n            // 2. Prepare the request body\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: product1.id.toString(),\n                        quantity: purchaseQuantity1,\n                        price: purchasePrice1,\n                    },\n                    {\n                        productId: product2.id.toString(),\n                        quantity: purchaseQuantity2,\n                        price: purchasePrice2,\n                    },\n                ],\n                distributions: [ // Explicit distribution for each item\n                    { [createdShopId]: purchaseQuantity1 }, // Distribution for item 1\n                    { [createdShopId]: purchaseQuantity2 }  // Distribution for item 2\n                ],\n                totalAmount: (purchaseQuantity1 * purchasePrice1) + (purchaseQuantity2 * purchasePrice2),\n                status: 'pending',\n            };\n\n            // 3. Simulate API call\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(201);\n            const createdInvoiceId = responseBody.data.id;\n\n            // Verify PurchaseInvoice and its items\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: createdInvoiceId },\n                include: { items: { orderBy: { productId: 'asc' } } } // Order to ensure consistent assertion\n            });\n            expect(dbInvoice?.items.length).toBe(2);\n            // Assuming product1.id < product2.id due to creation order for consistent checks\n            const sortedProducts = [product1, product2].sort((a, b) => a.id - b.id);\n\n            expect(dbInvoice?.items[0].productId).toBe(sortedProducts[0].id);\n            expect(dbInvoice?.items[0].quantity).toBe(purchaseQuantity1);\n            expect(dbInvoice?.items[0].price).toBe(purchasePrice1);\n\n            expect(dbInvoice?.items[1].productId).toBe(sortedProducts[1].id);\n            expect(dbInvoice?.items[1].quantity).toBe(purchaseQuantity2);\n            expect(dbInvoice?.items[1].price).toBe(purchasePrice2);\n\n            // Verify InventoryItem and Product WAC for Product 1\n            const dbInventoryItem1 = await prisma.inventoryItem.findFirst({\n                where: { productId: product1.id, shopId: createdShopId },\n            });\n            expect(dbInventoryItem1?.quantity).toBe(purchaseQuantity1);\n            expect(dbInventoryItem1?.shopSpecificCost).toBe(purchasePrice1);\n            const dbProduct1 = await prisma.product.findUnique({ where: { id: product1.id } });\n            expect(dbProduct1?.weightedAverageCost).toBe(purchasePrice1);\n\n            // Verify InventoryItem and Product WAC for Product 2\n            const dbInventoryItem2 = await prisma.inventoryItem.findFirst({\n                where: { productId: product2.id, shopId: createdShopId },\n            });\n            expect(dbInventoryItem2?.quantity).toBe(purchaseQuantity2);\n            expect(dbInventoryItem2?.shopSpecificCost).toBe(purchasePrice2);\n            const dbProduct2 = await prisma.product.findUnique({ where: { id: product2.id } });\n            expect(dbProduct2?.weightedAverageCost).toBe(purchasePrice2);\n        }, 15000); // Increased timeout\n\n        it('should distribute a single purchase item to multiple shops', async () => {\n            // 1. Create two new shops for this test\n            const shopA = await prisma.shop.create({ data: { name: 'Test Shop A', location: 'Loc A' } });\n            const shopB = await prisma.shop.create({ data: { name: 'Test Shop B', location: 'Loc B' } });\n\n            // 2. Create a new product\n            const product = await prisma.product.create({ data: { name: 'Split Product', sku: 'SPLIT001', price: 200 } });\n            const purchasePrice = 180;\n            const totalQuantity = 10;\n            const quantityForShopA = 6;\n            const quantityForShopB = 4;\n\n            expect(quantityForShopA + quantityForShopB).toBe(totalQuantity); // Sanity check\n\n            // 3. Prepare request body\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: product.id.toString(),\n                        quantity: totalQuantity, // Total quantity for the item line\n                        price: purchasePrice,\n                    },\n                ],\n                distributions: [\n                    { // Distribution for the single item, split into two shops\n                        [shopA.id]: quantityForShopA,\n                        [shopB.id]: quantityForShopB,\n                    }\n                ],\n                totalAmount: totalQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            // 4. Simulate API call\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n            const responseBody = await response.json();\n\n            // 5. Assertions\n            expect(response.status).toBe(201);\n\n            // Verify InventoryItem for Shop A\n            const invItemA = await prisma.inventoryItem.findFirst({\n                where: { productId: product.id, shopId: shopA.id }\n            });\n            expect(invItemA).not.toBeNull();\n            expect(invItemA?.quantity).toBe(quantityForShopA);\n            expect(invItemA?.shopSpecificCost).toBe(purchasePrice);\n\n            // Verify InventoryItem for Shop B\n            const invItemB = await prisma.inventoryItem.findFirst({\n                where: { productId: product.id, shopId: shopB.id }\n            });\n            expect(invItemB).not.toBeNull();\n            expect(invItemB?.quantity).toBe(quantityForShopB);\n            expect(invItemB?.shopSpecificCost).toBe(purchasePrice);\n\n            // Verify Product WAC (should be the purchase price as it's all new stock)\n            const dbProduct = await prisma.product.findUnique({ where: { id: product.id } });\n            expect(dbProduct?.weightedAverageCost).toBe(purchasePrice);\n        }, 15000); // Increased timeout\n\n        it('should fail to create a purchase if a productId does not exist', async () => {\n            const nonExistentProductId = 999999; // Assuming this ID won't exist\n            const purchasePrice = 100;\n            const purchaseQuantity = 5;\n\n            const purchaseInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: nonExistentProductId.toString(),\n                        quantity: purchaseQuantity,\n                        price: purchasePrice,\n                    },\n                ],\n                distributions: [\n                    { [createdShopId]: purchaseQuantity }\n                ],\n                totalAmount: purchaseQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n\n            // Expect a client error (e.g., 400 or 404) or potentially 500 if not handled gracefully\n            // For robust error handling, API should return specific error code.\n            // Prisma will throw an error if a related record (product) is not found for foreign key.\n            // This will likely result in a 500 if not caught and handled by the API route.\n            // Let's aim for the API to catch this and return a more specific client error.\n            // For now, we'll check if it's NOT a success (201).\n            // A more precise check would be for 400/404/422 depending on planned error handling.\n            expect(response.status).toBe(500); // Or 400/404 if you implement specific error handling\n\n            const responseBody = await response.json();\n            expect(responseBody.error).toBeDefined();\n            // Optionally, check for a specific error message or code if your API provides one.\n        }, 15000); // Increased timeout\n\n        it('should fail to create a purchase if a supplierId does not exist', async () => {\n            const newTestProduct = await prisma.product.create({\n                data: {\n                    name: 'Product For Invalid Supplier Test',\n                    sku: 'INV SUP001',\n                    price: 100,\n                }\n            });\n            const purchasePrice = 80;\n            const purchaseQuantity = 5;\n            const nonExistentSupplierId = 999999; // Assuming this ID won't exist\n\n            const purchaseInvoicePayload = {\n                supplierId: nonExistentSupplierId.toString(), // Invalid supplier\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: newTestProduct.id.toString(),\n                        quantity: purchaseQuantity,\n                        price: purchasePrice,\n                    },\n                ],\n                distributions: [\n                    { [createdShopId]: purchaseQuantity }\n                ],\n                totalAmount: purchaseQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(purchaseInvoicePayload),\n                headers: { 'Content-Type': 'application/json' }\n            });\n            const response = await createPurchaseInvoice(req);\n\n            expect(response.status).toBe(500); // Expecting 500 as Prisma throws P2003\n\n            const responseBody = await response.json();\n            expect(responseBody.error).toBeDefined();\n        });\n    });\n\n    describe('PUT /api/purchases/:id (Update Purchase Invoice)', () => {\n        let existingInvoiceId: string;\n        let productForUpdateTestsId: number;\n        const initialPurchasePrice = 50;\n        const initialPurchaseQuantity = 10;\n\n        beforeEach(async () => {\n            // Create a product specifically for these update/delete tests if not already created\n            // The global createdProductId can be used if it fits, or make a new one.\n            // Let's use the global one for simplicity, assuming beforeEach cleans it up.\n            productForUpdateTestsId = createdProductId;\n\n            // Create an initial purchase invoice to be updated or deleted in tests\n            const initialInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date(Date.now() - 86400000).toISOString(), // Yesterday\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: initialPurchaseQuantity,\n                        price: initialPurchasePrice,\n                    },\n                ],\n                distributions: [\n                    { [createdShopId]: initialPurchaseQuantity }\n                ],\n                totalAmount: initialPurchaseQuantity * initialPurchasePrice,\n                status: 'paid',\n            };\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(initialInvoicePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const response = await createPurchaseInvoice(req);\n            const body = await response.json();\n            existingInvoiceId = body.data.id;\n\n            // Sanity check: verify initial state\n            const initialProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(initialProduct?.weightedAverageCost).toBe(initialPurchasePrice);\n            const initialInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(initialInventory?.quantity).toBe(initialPurchaseQuantity);\n            expect(initialInventory?.shopSpecificCost).toBe(initialPurchasePrice);\n        });\n\n        it('should update item quantity (increase), recalculate stock and WACs', async () => {\n            const quantityIncrease = 5;\n            const newQuantity = initialPurchaseQuantity + quantityIncrease;\n            // Price remains the same for this item in this update scenario\n            const updatedPriceForItem = initialPurchasePrice;\n\n            const updatePayload = {\n                // We need to send the complete structure expected by the PUT route\n                // This includes all items, even if only one is changing.\n                // The PUT route logic might compare with existing items to see what changed.\n                items: [\n                    {\n                        // If the item had an ID (PurchaseInvoiceItem id), it might be needed.\n                        // Let's assume for now the PUT matches items based on productId if not item ID.\n                        // Based on current PUT route, it expects productId.\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: newQuantity,\n                        price: updatedPriceForItem, // Send the original price if it hasn't changed\n                    }\n                ],\n                distributions: [\n                    // The distributions in PUT might need to reflect the *new total* for the item\n                    { [createdShopId]: newQuantity }\n                ],\n                // Other fields like supplierId, date, totalAmount might be updatable too.\n                // For this test, focus on item quantity change.\n                // The PUT route recalculates totalAmount based on items if not provided or if items change.\n                // Let's assume totalAmount will be recalculated by the API.\n                // supplierId and date could be part of the payload if they are updatable.\n                // For now, keeping it minimal to test item update.\n                // The PUT handler re-calculates total amount, so not sending it.\n            };\n\n            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayload),\n                headers: { 'Content-Type': 'application/json' },\n                // IMPORTANT: Need to pass route params for [id] to the handler\n                // This is not standard NextRequest but how test setup might need it or how handler expects it.\n                // The actual handler `updatePurchaseInvoice(request: NextRequest, { params }: { params: { id: string } })`\n                // needs `params`. node-mocks-http `createMocks` handles this well.\n                // For direct NextRequest, we pass it in context to the handler call.\n            });\n\n            // Simulate API call - updatePurchaseInvoice(req, { params: { id: existingInvoiceId } })\n            // This is how you call it if you are testing the handler directly in Jest with context\n            const response = await updatePurchaseInvoice(req, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify InventoryItem stock and shopSpecificCost\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(updatedInventory?.quantity).toBe(newQuantity);\n\n            // WAC calculation: ((oldQty * oldSSC) + (addedQty * priceOfAddedQty)) / (newTotalQty)\n            // In this specific update, the PUT route reverses the old item and adds the new one as if it's a new purchase line for WAC calcs.\n            // So, the old initialPurchaseQuantity at initialPurchasePrice is reversed.\n            // Then, newQuantity at updatedPriceForItem is added.\n            // However, the current PUT logic first reverses *all* old items based on their *original* recorded cost.\n            // Then it adds *all* new items based on their *new* cost.\n            // So for the product WAC: (TotalValueBefore - OldItemValue + NewItemValue) / (TotalStockBefore - OldItemQty + NewItemQty)\n            // And for shop specific WAC: (ShopValueBefore - OldItemValueInShop + NewItemValueInShop) / (ShopStockBefore - OldItemQtyInShop + NewItemQtyInShop)\n\n            // Let's check the logic from src/app/api/purchases/[id]/route.ts\n            // 1. It fetches the old invoice.\n            // 2. It reverses inventory adjustments for ALL old items (decrease stock, WAC updated).\n            // 3. It processes ALL new/updated items as if they are new purchases (increase stock, WAC updated).\n\n            // So, after reversal of initialPurchaseQuantity at initialPurchasePrice:\n            // Product WAC and ShopSpecificCost would be effectively 0 if this were the only product/stock.\n            // Then, adding newQuantity at updatedPriceForItem:\n            // The new WACs should become updatedPriceForItem.\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);\n\n            // Verify Product WAC\n            const updatedProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);\n\n            // Verify PurchaseInvoiceItem in DB reflects the change\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);\n            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);\n            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);\n        }, 15000); // Increased timeout\n\n        it('should update item quantity (decrease), recalculate stock and WACs', async () => {\n            const quantityDecrease = 3;\n            const newQuantity = initialPurchaseQuantity - quantityDecrease;\n            expect(newQuantity).toBeGreaterThanOrEqual(0); // Ensure we don't go negative for this test logic\n\n            const updatedPriceForItem = initialPurchasePrice; // Price remains the same\n\n            const updatePayload = {\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: newQuantity,\n                        price: updatedPriceForItem,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: newQuantity }\n                ],\n            };\n\n            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n\n            const response = await updatePurchaseInvoice(req, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify InventoryItem stock and shopSpecificCost\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(updatedInventory?.quantity).toBe(newQuantity);\n\n            // Due to the reversal and re-addition logic of the PUT route:\n            // The old initialPurchaseQuantity at initialPurchasePrice is reversed.\n            // Then, newQuantity at updatedPriceForItem is added.\n            // So, new WACs should become updatedPriceForItem (which is initialPurchasePrice).\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(updatedPriceForItem);\n\n            // Verify Product WAC\n            const updatedProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(updatedPriceForItem);\n\n            // Verify PurchaseInvoiceItem in DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].quantity).toBe(newQuantity);\n            expect(dbInvoice?.items[0].price).toBe(updatedPriceForItem);\n            expect(dbInvoice?.total).toBe(newQuantity * updatedPriceForItem);\n        }, 15000); // Increased timeout\n\n        it('should update item price, recalculate stock and WACs', async () => {\n            const newPriceForItem = initialPurchasePrice + 25; // New price, e.g., 50 + 25 = 75\n            const quantityUnchanged = initialPurchaseQuantity; // Quantity remains the same\n\n            const updatePayload = {\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: quantityUnchanged,\n                        price: newPriceForItem,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: quantityUnchanged }\n                ],\n                // totalAmount will be recalculated by the API\n            };\n\n            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n\n            const response = await updatePurchaseInvoice(req, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify InventoryItem stock (should be unchanged) and shopSpecificCost\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(updatedInventory?.quantity).toBe(quantityUnchanged);\n            // WAC logic in PUT: reverses old, adds new. So shopSpecificCost should reflect newPriceForItem.\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(newPriceForItem);\n\n            // Verify Product WAC\n            const updatedProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(updatedProduct?.weightedAverageCost).toBeCloseTo(newPriceForItem);\n\n            // Verify PurchaseInvoiceItem in DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].quantity).toBe(quantityUnchanged);\n            expect(dbInvoice?.items[0].price).toBe(newPriceForItem);\n            expect(dbInvoice?.total).toBe(quantityUnchanged * newPriceForItem);\n        }, 15000); // Increased timeout\n\n        it('should add a new item to an existing invoice, update stock and WACs', async () => {\n            // 1. Define a new product for the new item\n            const newItemProduct = await prisma.product.create({\n                data: {\n                    name: 'Newly Added Product for PUT',\n                    sku: 'PUTNEW001',\n                    price: 200, // Retail price\n                }\n            });\n            const newItemProductId = newItemProduct.id;\n            const newItemQuantity = 7;\n            const newItemPrice = 120;\n\n            // Original item details (from beforeEach setup)\n            const originalItemProductId = productForUpdateTestsId;\n            const originalItemQuantity = initialPurchaseQuantity;\n            const originalItemPrice = initialPurchasePrice;\n\n            // 2. Prepare the update payload with both original and new item\n            const updatePayload = {\n                items: [\n                    {\n                        productId: originalItemProductId.toString(),\n                        quantity: originalItemQuantity,\n                        price: originalItemPrice,\n                    },\n                    {\n                        productId: newItemProductId.toString(),\n                        quantity: newItemQuantity,\n                        price: newItemPrice,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: originalItemQuantity }, // Distribution for original item\n                    { [createdShopId]: newItemQuantity }      // Distribution for new item\n                ],\n                // totalAmount will be recalculated by the API\n            };\n\n            // 3. Simulate API call\n            const req = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const response = await updatePurchaseInvoice(req, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify PurchaseInvoice in DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: { orderBy: { productId: 'asc' } } }, // Order for consistent checks\n            });\n            expect(dbInvoice?.items.length).toBe(2);\n\n            const expectedTotal = (originalItemQuantity * originalItemPrice) + (newItemQuantity * newItemPrice);\n            expect(dbInvoice?.total).toBe(expectedTotal);\n\n            // Find the items in the response (order might vary, so find by productId)\n            const dbOriginalItem = dbInvoice?.items.find(item => item.productId === originalItemProductId);\n            const dbNewItem = dbInvoice?.items.find(item => item.productId === newItemProductId);\n\n            expect(dbOriginalItem).toBeDefined();\n            expect(dbOriginalItem?.quantity).toBe(originalItemQuantity);\n            expect(dbOriginalItem?.price).toBe(originalItemPrice);\n\n            expect(dbNewItem).toBeDefined();\n            expect(dbNewItem?.quantity).toBe(newItemQuantity);\n            expect(dbNewItem?.price).toBe(newItemPrice);\n\n            // Verify InventoryItem and Product WAC for the original item\n            // (Due to PUT logic of reverse & re-add, WACs should reflect its current price)\n            const originalInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: originalItemProductId, shopId: createdShopId }\n            });\n            expect(originalInventory?.quantity).toBe(originalItemQuantity);\n            expect(originalInventory?.shopSpecificCost).toBeCloseTo(originalItemPrice);\n            const originalProduct = await prisma.product.findUnique({ where: { id: originalItemProductId } });\n            expect(originalProduct?.weightedAverageCost).toBeCloseTo(originalItemPrice);\n\n            // Verify InventoryItem and Product WAC for the NEW item\n            const newInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: newItemProductId, shopId: createdShopId }\n            });\n            expect(newInventory?.quantity).toBe(newItemQuantity);\n            expect(newInventory?.shopSpecificCost).toBeCloseTo(newItemPrice);\n            const newProductDb = await prisma.product.findUnique({ where: { id: newItemProductId } });\n            expect(newProductDb?.weightedAverageCost).toBeCloseTo(newItemPrice);\n        }, 15000); // Increased timeout\n\n        it('should remove an item from an existing invoice, update stock and WACs', async () => {\n            // 1. Setup: Ensure an invoice with at least two items exists.\n            // We'll use the existing `productForUpdateTestsId` and create one more product and item.\n            const productToRemove = await prisma.product.create({\n                data: {\n                    name: 'Product To Be Removed',\n                    sku: 'PUTRMV001',\n                    price: 300,\n                }\n            });\n            const productToRemoveId = productToRemove.id;\n            const productToRemoveQuantity = 4;\n            const productToRemovePrice = 40;\n\n            // Update the existing invoice (created in global beforeEach for PUT) to include this second item first.\n            const addSecondItemPayload = {\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(),\n                        quantity: initialPurchaseQuantity,\n                        price: initialPurchasePrice,\n                    },\n                    {\n                        productId: productToRemoveId.toString(),\n                        quantity: productToRemoveQuantity,\n                        price: productToRemovePrice,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: initialPurchaseQuantity },\n                    { [createdShopId]: productToRemoveQuantity }\n                ],\n            };\n            const addReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(addSecondItemPayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            await updatePurchaseInvoice(addReq, { params: { id: existingInvoiceId } });\n\n            // Sanity check: Invoice should have 2 items\n            let invoiceWithTwoItems = await prisma.purchaseInvoice.findUnique({ where: { id: existingInvoiceId }, include: { items: true } });\n            expect(invoiceWithTwoItems?.items.length).toBe(2);\n\n            // 2. Prepare the update payload that only contains the item we want to keep.\n            const updatePayloadToRemoveItem = {\n                items: [\n                    {\n                        productId: productForUpdateTestsId.toString(), // Keep this one\n                        quantity: initialPurchaseQuantity,\n                        price: initialPurchasePrice,\n                    }\n                ],\n                distributions: [\n                    { [createdShopId]: initialPurchaseQuantity } // Distribution for the kept item\n                ],\n            };\n\n            // 3. Simulate API call to remove the item\n            const removeReq = new NextRequest(`http://localhost/api/purchases/${existingInvoiceId}`, {\n                method: 'PUT',\n                body: JSON.stringify(updatePayloadToRemoveItem),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const response = await updatePurchaseInvoice(removeReq, { params: { id: existingInvoiceId } });\n            const responseBody = await response.json();\n\n            // 4. Assertions\n            expect(response.status).toBe(200);\n            expect(responseBody.data).toHaveProperty('id', existingInvoiceId);\n\n            // Verify PurchaseInvoice in DB - should now have only 1 item\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: existingInvoiceId },\n                include: { items: true },\n            });\n            expect(dbInvoice?.items.length).toBe(1);\n            expect(dbInvoice?.items[0].productId).toBe(productForUpdateTestsId);\n            expect(dbInvoice?.items[0].quantity).toBe(initialPurchaseQuantity);\n            expect(dbInvoice?.items[0].price).toBe(initialPurchasePrice);\n            expect(dbInvoice?.total).toBe(initialPurchaseQuantity * initialPurchasePrice);\n\n            // Verify InventoryItem and Product WAC for the KEPT item\n            const keptInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForUpdateTestsId, shopId: createdShopId }\n            });\n            expect(keptInventory?.quantity).toBe(initialPurchaseQuantity);\n            expect(keptInventory?.shopSpecificCost).toBeCloseTo(initialPurchasePrice);\n            const keptProduct = await prisma.product.findUnique({ where: { id: productForUpdateTestsId } });\n            expect(keptProduct?.weightedAverageCost).toBeCloseTo(initialPurchasePrice);\n\n            // Verify InventoryItem and Product WAC for the REMOVED item\n            // Stock should be zero or the item might be gone from inventory if it was the only purchase\n            // WAC on product should be 0 if no other purchases exist.\n            const removedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productToRemoveId, shopId: createdShopId }\n            });\n            // The PUT logic reverses stock. If this was the only stock, it becomes 0.\n            expect(removedInventory?.quantity).toBe(0);\n            // ShopSpecificCost might become 0 or NaN if quantity is 0. The API sets it to 0 for safety.\n            expect(removedInventory?.shopSpecificCost).toBeCloseTo(0);\n\n            const removedProductDb = await prisma.product.findUnique({ where: { id: productToRemoveId } });\n            // If no other purchase items for this product, WAC should become 0.\n            const otherPurchasesOfRemovedItem = await prisma.purchaseInvoiceItem.count({\n                where: { productId: productToRemoveId }\n            });\n            if (otherPurchasesOfRemovedItem === 0) {\n                expect(removedProductDb?.weightedAverageCost).toBeCloseTo(0);\n            } // Else, it would be based on other purchases, which this test doesn't set up.\n\n        }, 15000); // Increased timeout\n    });\n\n    describe('DELETE /api/purchases/:id (Delete Purchase Invoice)', () => {\n        let invoiceToDeleteId: string;\n        let productForDeleteTestId: number;\n        const deleteTestInitialPrice = 60;\n        const deleteTestInitialQuantity = 12;\n\n        beforeEach(async () => {\n            // Ensure product exists for the test\n            const product = await prisma.product.create({\n                data: {\n                    name: 'Product For Delete Test',\n                    sku: 'DELPROD001',\n                    price: 100, // retail\n                }\n            });\n            productForDeleteTestId = product.id;\n\n            // Create an initial purchase invoice to be deleted\n            const initialInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: productForDeleteTestId.toString(),\n                        quantity: deleteTestInitialQuantity,\n                        price: deleteTestInitialPrice,\n                    },\n                ],\n                distributions: [\n                    { [createdShopId]: deleteTestInitialQuantity } // Explicit distribution\n                ],\n                totalAmount: deleteTestInitialQuantity * deleteTestInitialPrice,\n                status: 'paid',\n            };\n            const req = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(initialInvoicePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const response = await createPurchaseInvoice(req);\n            const body = await response.json();\n            invoiceToDeleteId = body.data.id;\n\n            // Sanity check: verify initial state after creation\n            const initialProductDB = await prisma.product.findUnique({ where: { id: productForDeleteTestId } });\n            expect(initialProductDB?.weightedAverageCost).toBe(deleteTestInitialPrice);\n            const initialInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForDeleteTestId, shopId: createdShopId }\n            });\n            expect(initialInventory?.quantity).toBe(deleteTestInitialQuantity);\n            expect(initialInventory?.shopSpecificCost).toBe(deleteTestInitialPrice);\n        });\n\n        it('should delete a purchase invoice and correctly reverse stock and WACs for a single-item invoice with explicit distribution', async () => {\n            // 1. Call the DELETE endpoint\n            const deleteReq = new NextRequest(`http://localhost/api/purchases/${invoiceToDeleteId}`, {\n                method: 'DELETE',\n            });\n            const deleteResponse = await deletePurchaseInvoice(deleteReq, { params: { id: invoiceToDeleteId } });\n\n            // 2. Assertions for DELETE response\n            expect(deleteResponse.status).toBe(200);\n            const deleteResponseBody = await deleteResponse.json();\n            expect(deleteResponseBody.message).toBe('Purchase invoice deleted successfully');\n\n            // 3. Verify PurchaseInvoice is deleted from DB\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({\n                where: { id: invoiceToDeleteId },\n            });\n            expect(dbInvoice).toBeNull();\n\n            // 4. Verify PurchaseInvoiceItems are deleted\n            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({\n                where: { purchaseInvoiceId: invoiceToDeleteId },\n            });\n            expect(dbInvoiceItems.length).toBe(0);\n\n            // 5. Verify InventoryItem stock is reversed\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: productForDeleteTestId, shopId: createdShopId }\n            });\n            // Assuming this was the only purchase, stock should be 0\n            expect(updatedInventory?.quantity).toBe(0);\n            // ShopSpecificCost should also be 0 if stock is 0\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);\n\n\n            // 6. Verify Product WAC is recalculated (should be 0 if this was the only purchase)\n            const updatedProduct = await prisma.product.findUnique({\n                where: { id: productForDeleteTestId },\n            });\n            // If no other purchase items for this product, WAC should become 0.\n            const otherPurchasesOfProduct = await prisma.purchaseInvoiceItem.count({\n                where: {\n                    productId: productForDeleteTestId,\n                    // purchaseInvoiceId: { not: invoiceToDeleteId } // Not needed as original invoice items are gone\n                }\n            });\n            if (otherPurchasesOfProduct === 0) { // This should be true for this test\n                expect(updatedProduct?.weightedAverageCost).toBeCloseTo(0);\n            }\n        });\n\n        it('should delete a purchase and reverse stock/WAC when product is in a single inferred shop', async () => {\n            // 1. Setup: Create dedicated entities for this test to ensure isolation.\n            const testShop = await prisma.shop.create({\n                data: { name: 'Inferred Delete Test Shop', location: 'Loc X' }\n            });\n            const testSupplier = await prisma.supplier.create({\n                data: { name: 'Inferred Delete Test Supplier' }\n            });\n            const testProduct = await prisma.product.create({\n                data: {\n                    name: 'Product for Inferred Delete',\n                    sku: 'INFDEL001',\n                    price: 200, // retail price\n                    weightedAverageCost: 0\n                }\n            });\n\n            // Create an inventory item for this product in the test shop.\n            // This makes it the \"single inferred shop\".\n            await prisma.inventoryItem.create({\n                data: {\n                    productId: testProduct.id,\n                    shopId: testShop.id,\n                    quantity: 0, // Will be updated by the purchase\n                    shopSpecificCost: 0\n                }\n            });\n\n            const purchaseQuantity = 12;\n            const purchasePrice = 60;\n\n            const inferredShopInvoicePayload = {\n                supplierId: testSupplier.id.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    {\n                        productId: testProduct.id.toString(),\n                        quantity: purchaseQuantity,\n                        price: purchasePrice,\n                    },\n                ],\n                // NO distributions property here for inference to kick in on POST\n                totalAmount: purchaseQuantity * purchasePrice,\n                status: 'paid',\n            };\n\n            // Create the purchase invoice (this is where the failure was happening)\n            const createReq = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(inferredShopInvoicePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const createResponse = await createPurchaseInvoice(createReq);\n            expect(createResponse.status).toBe(201); // Assert successful creation\n\n            const createBody = await createResponse.json();\n            const invoiceIdForInferredDelete = createBody.data.id;\n\n            // Sanity check: Verify stock and WAC after creation\n            const inventoryAfterCreate = await prisma.inventoryItem.findFirst({\n                where: { productId: testProduct.id, shopId: testShop.id }\n            });\n            expect(inventoryAfterCreate?.quantity).toBe(purchaseQuantity);\n            expect(inventoryAfterCreate?.shopSpecificCost).toBeCloseTo(purchasePrice);\n            const productAfterCreate = await prisma.product.findUnique({ where: { id: testProduct.id } });\n            expect(productAfterCreate?.weightedAverageCost).toBeCloseTo(purchasePrice);\n\n            // 2. Call the DELETE endpoint\n            const deleteReq = new NextRequest(`http://localhost/api/purchases/${invoiceIdForInferredDelete}`, {\n                method: 'DELETE',\n            });\n            const deleteResponse = await deletePurchaseInvoice(deleteReq, { params: { id: invoiceIdForInferredDelete } });\n\n            // 3. Assertions for DELETE response\n            expect(deleteResponse.status).toBe(200);\n            const deleteResponseBody = await deleteResponse.json();\n            expect(deleteResponseBody.message).toBe('Purchase invoice deleted successfully');\n\n            // 4. Verify PurchaseInvoice and Items are deleted\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({ where: { id: invoiceIdForInferredDelete } });\n            expect(dbInvoice).toBeNull();\n            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({ where: { purchaseInvoiceId: invoiceIdForInferredDelete } });\n            expect(dbInvoiceItems.length).toBe(0);\n\n            // 5. Verify InventoryItem stock and shopSpecificCost are reversed in the inferred shop\n            const updatedInventory = await prisma.inventoryItem.findFirst({\n                where: { productId: testProduct.id, shopId: testShop.id }\n            });\n            expect(updatedInventory?.quantity).toBe(0);\n            expect(updatedInventory?.shopSpecificCost).toBeCloseTo(0);\n\n            // 6. Verify Product WAC is recalculated to 0\n            const updatedProductDB = await prisma.product.findUnique({ where: { id: testProduct.id } });\n            expect(updatedProductDB?.weightedAverageCost).toBeCloseTo(0);\n\n            // Cleanup dedicated entities for this test\n            await prisma.inventoryItem.deleteMany({ where: { productId: testProduct.id } });\n            await prisma.product.delete({ where: { id: testProduct.id } });\n            await prisma.supplier.delete({ where: { id: testSupplier.id } });\n            await prisma.shop.delete({ where: { id: testShop.id } });\n        }, 15000); // Added a longer timeout as a precaution\n\n        it('should delete an invoice with multiple items, reversing stock/WAC for each', async () => {\n            // 1. Setup: Create multiple products and an invoice with items from these products.\n            // For simplicity, distribute each to the main createdShopId from global beforeEach.\n\n            const productA = await prisma.product.create({\n                data: { name: 'Multi-Del Prod A', sku: 'MDEL00A', price: 100, weightedAverageCost: 0 }\n            });\n            const productB = await prisma.product.create({\n                data: { name: 'Multi-Del Prod B', sku: 'MDEL00B', price: 200, weightedAverageCost: 0 }\n            });\n\n            const quantityA = 5;\n            const priceA = 50;\n            const quantityB = 3;\n            const priceB = 120;\n\n            const multiItemInvoicePayload = {\n                supplierId: createdSupplierId.toString(),\n                date: new Date().toISOString(),\n                items: [\n                    { productId: productA.id.toString(), quantity: quantityA, price: priceA },\n                    { productId: productB.id.toString(), quantity: quantityB, price: priceB },\n                ],\n                distributions: [\n                    { [createdShopId]: quantityA }, // Item A to main shop\n                    { [createdShopId]: quantityB }  // Item B to main shop\n                ],\n                totalAmount: (quantityA * priceA) + (quantityB * priceB),\n                status: 'paid',\n            };\n\n            const createReq = new NextRequest('http://localhost/api/purchases', {\n                method: 'POST',\n                body: JSON.stringify(multiItemInvoicePayload),\n                headers: { 'Content-Type': 'application/json' },\n            });\n            const createResponse = await createPurchaseInvoice(createReq);\n            expect(createResponse.status).toBe(201);\n            const createBody = await createResponse.json();\n            const multiItemInvoiceId = createBody.data.id;\n\n            // Sanity check inventory and WAC after creation\n            const invA_afterCreate = await prisma.inventoryItem.findFirst({ where: { productId: productA.id, shopId: createdShopId } });\n            expect(invA_afterCreate?.quantity).toBe(quantityA);\n            expect(invA_afterCreate?.shopSpecificCost).toBe(priceA);\n            const prodA_afterCreate = await prisma.product.findUnique({ where: { id: productA.id } });\n            expect(prodA_afterCreate?.weightedAverageCost).toBe(priceA);\n\n            const invB_afterCreate = await prisma.inventoryItem.findFirst({ where: { productId: productB.id, shopId: createdShopId } });\n            expect(invB_afterCreate?.quantity).toBe(quantityB);\n            expect(invB_afterCreate?.shopSpecificCost).toBe(priceB);\n            const prodB_afterCreate = await prisma.product.findUnique({ where: { id: productB.id } });\n            expect(prodB_afterCreate?.weightedAverageCost).toBe(priceB);\n\n            // 2. Call DELETE endpoint\n            const deleteReq = new NextRequest(`http://localhost/api/purchases/${multiItemInvoiceId}`, {\n                method: 'DELETE',\n            });\n            const deleteResponse = await deletePurchaseInvoice(deleteReq, { params: { id: multiItemInvoiceId } });\n            expect(deleteResponse.status).toBe(200);\n\n            // 3. Verify invoice and items are deleted\n            const dbInvoice = await prisma.purchaseInvoice.findUnique({ where: { id: multiItemInvoiceId } });\n            expect(dbInvoice).toBeNull();\n            const dbInvoiceItems = await prisma.purchaseInvoiceItem.findMany({ where: { purchaseInvoiceId: multiItemInvoiceId } });\n            expect(dbInvoiceItems.length).toBe(0);\n\n            // 4. Verify stock and WAC for Product A are reversed\n            const invA_afterDelete = await prisma.inventoryItem.findFirst({ where: { productId: productA.id, shopId: createdShopId } });\n            expect(invA_afterDelete?.quantity).toBe(0);\n            expect(invA_afterDelete?.shopSpecificCost).toBeCloseTo(0);\n            const prodA_afterDelete = await prisma.product.findUnique({ where: { id: productA.id } });\n            expect(prodA_afterDelete?.weightedAverageCost).toBeCloseTo(0);\n\n            // 5. Verify stock and WAC for Product B are reversed\n            const invB_afterDelete = await prisma.inventoryItem.findFirst({ where: { productId: productB.id, shopId: createdShopId } });\n            expect(invB_afterDelete?.quantity).toBe(0);\n            expect(invB_afterDelete?.shopSpecificCost).toBeCloseTo(0);\n            const prodB_afterDelete = await prisma.product.findUnique({ where: { id: productB.id } });\n            expect(prodB_afterDelete?.weightedAverageCost).toBeCloseTo(0);\n\n            // Clean up products and their inventory items created for this test\n            await prisma.inventoryItem.deleteMany({ where: { productId: { in: [productA.id, productB.id] } } });\n            await prisma.product.deleteMany({ where: { id: { in: [productA.id, productB.id] } } });\n        }, 15000); // Timeout for safety\n    });\n\n}); "],"names":["prisma","PrismaClient","describe","createdShopId","createdSupplierId","createdProductId","beforeAll","beforeEach","purchaseInvoiceItem","deleteMany","purchaseInvoice","inventoryItem","product","supplier","shop","create","data","name","location","id","price","sku","shopId","afterAll","$disconnect","it","newProductName","newProductSku","purchasePrice","purchaseQuantity","newTestProduct","newTestProductId","purchaseInvoicePayload","supplierId","toString","date","Date","toISOString","items","productId","quantity","distributions","totalAmount","status","req","NextRequest","method","body","JSON","stringify","headers","response","createPurchaseInvoice","responseBody","json","expect","toBe","toHaveProperty","createdInvoiceId","dbInvoice","findUnique","where","include","not","toBeNull","length","dbInventoryItem","findFirst","shopSpecificCost","dbProduct","weightedAverageCost","initialPurchasePrice","initialPurchaseQuantity","existingProductId","initialPayload","now","initialReq","productBeforeNewPurchase","inventoryBeforeNewPurchase","newPurchasePrice","newPurchaseQuantity","expectedTotalQuantity","expectedShopSpecificCost","toBeCloseTo","expectedProductWAC","product1Data","product2Data","product1","product2","purchasePrice1","purchaseQuantity1","purchasePrice2","purchaseQuantity2","orderBy","sortedProducts","sort","a","b","dbInventoryItem1","dbProduct1","dbInventoryItem2","dbProduct2","shopA","shopB","totalQuantity","quantityForShopA","quantityForShopB","invItemA","invItemB","nonExistentProductId","error","toBeDefined","nonExistentSupplierId","existingInvoiceId","productForUpdateTestsId","initialInvoicePayload","initialProduct","initialInventory","quantityIncrease","newQuantity","updatedPriceForItem","updatePayload","updatePurchaseInvoice","params","updatedInventory","updatedProduct","total","quantityDecrease","toBeGreaterThanOrEqual","newPriceForItem","quantityUnchanged","newItemProduct","newItemProductId","newItemQuantity","newItemPrice","originalItemProductId","originalItemQuantity","originalItemPrice","expectedTotal","dbOriginalItem","find","item","dbNewItem","originalInventory","originalProduct","newInventory","newProductDb","productToRemove","productToRemoveId","productToRemoveQuantity","productToRemovePrice","addSecondItemPayload","addReq","invoiceWithTwoItems","updatePayloadToRemoveItem","removeReq","keptInventory","keptProduct","removedInventory","removedProductDb","otherPurchasesOfRemovedItem","count","invoiceToDeleteId","productForDeleteTestId","deleteTestInitialPrice","deleteTestInitialQuantity","initialProductDB","deleteReq","deleteResponse","deletePurchaseInvoice","deleteResponseBody","message","dbInvoiceItems","findMany","purchaseInvoiceId","otherPurchasesOfProduct","testShop","testSupplier","testProduct","inferredShopInvoicePayload","createReq","createResponse","createBody","invoiceIdForInferredDelete","inventoryAfterCreate","productAfterCreate","updatedProductDB","delete","productA","productB","quantityA","priceA","quantityB","priceB","multiItemInvoicePayload","multiItemInvoiceId","invA_afterCreate","prodA_afterCreate","invB_afterCreate","prodB_afterCreate","invA_afterDelete","prodA_afterDelete","invB_afterDelete","prodB_afterDelete","in"],"mappings":"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"}