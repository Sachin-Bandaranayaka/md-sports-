{"version":3,"sources":["/Users/sachin/Documents/md-sports-/tests/unit/authService.test.ts"],"sourcesContent":["import { authenticateUser, generateTokens, verifyToken, parseTimeStringToSeconds, getUserFromDecodedPayload, getUserFromToken } from '@/services/authService';\nimport { refreshTokenService } from '@/services/refreshTokenService';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport prisma from '@/lib/prisma';\n\n// Mock dependencies\njest.mock('@/lib/prisma', () => ({\n  user: {\n    findFirst: jest.fn(),\n  },\n  refreshToken: {\n    create: jest.fn(),\n  },\n}));\n\njest.mock('bcryptjs');\njest.mock('jsonwebtoken');\njest.mock('@/services/refreshTokenService');\n\nconst mockPrisma = prisma as jest.Mocked<typeof prisma>;\nconst mockBcrypt = bcrypt as jest.Mocked<typeof bcrypt>;\nconst mockJwt = jwt as jest.Mocked<typeof jwt>;\nconst mockRefreshTokenService = refreshTokenService as jest.Mocked<typeof refreshTokenService>;\n\ndescribe('AuthService', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    process.env.JWT_SECRET = 'test-secret';\n    process.env.JWT_EXPIRES_IN = '1h';\n    process.env.REFRESH_TOKEN_EXPIRES_IN = '7d';\n  });\n\n  describe('parseTimeStringToSeconds', () => {\n    test('should parse seconds correctly', () => {\n      expect(parseTimeStringToSeconds('30s')).toBe(30);\n    });\n\n    test('should parse minutes correctly', () => {\n      expect(parseTimeStringToSeconds('5m')).toBe(300);\n    });\n\n    test('should parse hours correctly', () => {\n      expect(parseTimeStringToSeconds('2h')).toBe(7200);\n    });\n\n    test('should parse days correctly', () => {\n      expect(parseTimeStringToSeconds('1d')).toBe(86400);\n    });\n\n    test('should return 0 for invalid input', () => {\n      expect(parseTimeStringToSeconds('')).toBe(0);\n      expect(parseTimeStringToSeconds('invalid')).toBe(0);\n      expect(parseTimeStringToSeconds('abc')).toBe(0);\n    });\n\n    test('should handle edge cases', () => {\n      expect(parseTimeStringToSeconds('0s')).toBe(0);\n      expect(parseTimeStringToSeconds('100x')).toBe(0);\n    });\n  });\n\n  describe('authenticateUser', () => {\n    const mockUser = {\n      id: 1,\n      email: 'test@example.com',\n      username: 'testuser',\n      passwordHash: 'hashedpassword',\n      isActive: true,\n      roleId: 1,\n      shopId: 1,\n      role: {\n        id: 1,\n        name: 'admin',\n        permissions: [\n          { name: 'read_products' },\n          { name: 'write_products' }\n        ]\n      }\n    };\n\n    test('should authenticate valid user credentials', async () => {\n      mockPrisma.user.findFirst.mockResolvedValue(mockUser);\n      mockBcrypt.compare.mockResolvedValue(true);\n\n      const result = await authenticateUser('test@example.com', 'password123');\n\n      expect(result.success).toBe(true);\n      expect(result.user).toEqual({\n        id: 1,\n        email: 'test@example.com',\n        username: 'testuser',\n        roleId: 1,\n        shopId: 1,\n        permissions: ['read_products', 'write_products']\n      });\n      expect(mockPrisma.user.findFirst).toHaveBeenCalledWith({\n        where: {\n          email: 'test@example.com',\n          isActive: true\n        },\n        include: {\n          role: {\n            include: {\n              permissions: {\n                select: { name: true }\n              }\n            }\n          }\n        }\n      });\n    });\n\n    test('should reject invalid email', async () => {\n      mockPrisma.user.findFirst.mockResolvedValue(null);\n\n      const result = await authenticateUser('invalid@example.com', 'password123');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Invalid email or password');\n      expect(result.user).toBeNull();\n    });\n\n    test('should reject invalid password', async () => {\n      mockPrisma.user.findFirst.mockResolvedValue(mockUser);\n      mockBcrypt.compare.mockResolvedValue(false);\n\n      const result = await authenticateUser('test@example.com', 'wrongpassword');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Invalid email or password');\n      expect(result.user).toBeNull();\n    });\n\n    test('should reject inactive user', async () => {\n      const inactiveUser = { ...mockUser, isActive: false };\n      mockPrisma.user.findFirst.mockResolvedValue(null); // findFirst with isActive: true returns null\n\n      const result = await authenticateUser('test@example.com', 'password123');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Invalid email or password');\n    });\n\n    test('should handle database errors gracefully', async () => {\n      mockPrisma.user.findFirst.mockRejectedValue(new Error('Database connection failed'));\n\n      const result = await authenticateUser('test@example.com', 'password123');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Authentication failed');\n      expect(result.user).toBeNull();\n    });\n\n    test('should handle bcrypt errors gracefully', async () => {\n      mockPrisma.user.findFirst.mockResolvedValue(mockUser);\n      mockBcrypt.compare.mockRejectedValue(new Error('Bcrypt error'));\n\n      const result = await authenticateUser('test@example.com', 'password123');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Authentication failed');\n    });\n  });\n\n  describe('generateTokens', () => {\n    const mockUser = {\n      id: 1,\n      email: 'test@example.com',\n      username: 'testuser',\n      roleId: 1,\n      shopId: 1,\n      permissions: ['read_products', 'write_products']\n    };\n\n    test('should generate access and refresh tokens', async () => {\n      const mockAccessToken = 'mock-access-token';\n      const mockRefreshToken = 'mock-refresh-token';\n      \n      mockJwt.sign.mockReturnValueOnce(mockAccessToken);\n      mockRefreshTokenService.createRefreshToken.mockResolvedValue(mockRefreshToken);\n\n      const result = await generateTokens(mockUser);\n\n      expect(result.accessToken).toBe(mockAccessToken);\n      expect(result.refreshToken).toBe(mockRefreshToken);\n      expect(mockJwt.sign).toHaveBeenCalledWith(\n        {\n          sub: 1,\n          username: 'testuser',\n          email: 'test@example.com',\n          roleId: 1,\n          shopId: 1,\n          permissions: ['read_products', 'write_products']\n        },\n        'test-secret',\n        { expiresIn: '1h' }\n      );\n      expect(mockRefreshTokenService.createRefreshToken).toHaveBeenCalledWith(1);\n    });\n\n    test('should handle refresh token creation failure', async () => {\n      const mockAccessToken = 'mock-access-token';\n      \n      mockJwt.sign.mockReturnValueOnce(mockAccessToken);\n      mockRefreshTokenService.createRefreshToken.mockRejectedValue(new Error('Refresh token creation failed'));\n\n      await expect(generateTokens(mockUser)).rejects.toThrow('Refresh token creation failed');\n    });\n  });\n\n  describe('verifyToken', () => {\n    test('should verify valid token', async () => {\n      const mockPayload = {\n        sub: 1,\n        username: 'testuser',\n        email: 'test@example.com',\n        roleId: 1,\n        iat: Math.floor(Date.now() / 1000),\n        exp: Math.floor(Date.now() / 1000) + 3600\n      };\n      \n      mockJwt.verify.mockReturnValue(mockPayload);\n\n      const result = await verifyToken('valid-token');\n\n      expect(result).toEqual(mockPayload);\n      expect(mockJwt.verify).toHaveBeenCalledWith('valid-token', 'test-secret');\n    });\n\n    test('should return null for invalid token', async () => {\n      mockJwt.verify.mockImplementation(() => {\n        throw new Error('Invalid token');\n      });\n\n      const result = await verifyToken('invalid-token');\n\n      expect(result).toBeNull();\n    });\n\n    test('should return null for expired token', async () => {\n      mockJwt.verify.mockImplementation(() => {\n        const error = new Error('Token expired');\n        error.name = 'TokenExpiredError';\n        throw error;\n      });\n\n      const result = await verifyToken('expired-token');\n\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('getUserFromDecodedPayload', () => {\n    const mockUser = {\n      id: 1,\n      email: 'test@example.com',\n      username: 'testuser',\n      isActive: true,\n      roleId: 1,\n      shopId: 1,\n      role: {\n        id: 1,\n        name: 'admin',\n        permissions: [\n          { name: 'read_products' },\n          { name: 'write_products' }\n        ]\n      }\n    };\n\n    test('should return user from valid payload', async () => {\n      const payload = {\n        sub: 1,\n        username: 'testuser',\n        email: 'test@example.com',\n        roleId: 1\n      };\n      \n      mockPrisma.user.findFirst.mockResolvedValue(mockUser);\n\n      const result = await getUserFromDecodedPayload(payload);\n\n      expect(result).toEqual({\n        id: 1,\n        email: 'test@example.com',\n        username: 'testuser',\n        roleId: 1,\n        shopId: 1,\n        permissions: ['read_products', 'write_products']\n      });\n    });\n\n    test('should return null for null payload', async () => {\n      const result = await getUserFromDecodedPayload(null);\n      expect(result).toBeNull();\n    });\n\n    test('should return null for invalid payload', async () => {\n      const result = await getUserFromDecodedPayload({} as any);\n      expect(result).toBeNull();\n    });\n\n    test('should return null when user not found', async () => {\n      const payload = {\n        sub: 999,\n        username: 'nonexistent',\n        email: 'nonexistent@example.com',\n        roleId: 1\n      };\n      \n      mockPrisma.user.findFirst.mockResolvedValue(null);\n\n      const result = await getUserFromDecodedPayload(payload);\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('getUserFromToken', () => {\n    test('should return user from valid token', async () => {\n      const mockPayload = {\n        sub: 1,\n        username: 'testuser',\n        email: 'test@example.com',\n        roleId: 1\n      };\n      \n      const mockUser = {\n        id: 1,\n        email: 'test@example.com',\n        username: 'testuser',\n        roleId: 1,\n        shopId: 1,\n        permissions: ['read_products']\n      };\n\n      mockJwt.verify.mockReturnValue(mockPayload);\n      mockPrisma.user.findFirst.mockResolvedValue({\n        id: 1,\n        email: 'test@example.com',\n        username: 'testuser',\n        isActive: true,\n        roleId: 1,\n        shopId: 1,\n        role: {\n          id: 1,\n          name: 'admin',\n          permissions: [{ name: 'read_products' }]\n        }\n      });\n\n      const result = await getUserFromToken('valid-token');\n      expect(result).toEqual(mockUser);\n    });\n\n    test('should return null for invalid token', async () => {\n      mockJwt.verify.mockImplementation(() => {\n        throw new Error('Invalid token');\n      });\n\n      const result = await getUserFromToken('invalid-token');\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should handle missing JWT_SECRET', async () => {\n      delete process.env.JWT_SECRET;\n      \n      const result = await verifyToken('any-token');\n      expect(result).toBeNull();\n    });\n\n    test('should handle malformed tokens gracefully', async () => {\n      const result = await verifyToken('not.a.valid.jwt.token');\n      expect(result).toBeNull();\n    });\n\n    test('should handle empty token', async () => {\n      const result = await verifyToken('');\n      expect(result).toBeNull();\n    });\n  });\n});"],"names":["jest","mock","user","findFirst","fn","refreshToken","create","mockPrisma","prisma","mockBcrypt","bcrypt","mockJwt","jwt","mockRefreshTokenService","refreshTokenService","describe","beforeEach","clearAllMocks","process","env","JWT_SECRET","JWT_EXPIRES_IN","REFRESH_TOKEN_EXPIRES_IN","test","expect","parseTimeStringToSeconds","toBe","mockUser","id","email","username","passwordHash","isActive","roleId","shopId","role","name","permissions","mockResolvedValue","compare","result","authenticateUser","success","toEqual","toHaveBeenCalledWith","where","include","select","message","toBeNull","inactiveUser","mockRejectedValue","Error","mockAccessToken","mockRefreshToken","sign","mockReturnValueOnce","createRefreshToken","generateTokens","accessToken","sub","expiresIn","rejects","toThrow","mockPayload","iat","Math","floor","Date","now","exp","verify","mockReturnValue","verifyToken","mockImplementation","error","payload","getUserFromDecodedPayload","getUserFromToken"],"mappings":";AAMA,oBAAoB;AACpBA,KAAKC,IAAI,CAAC,gBAAgB,IAAO,CAAA;QAC/BC,MAAM;YACJC,WAAWH,KAAKI,EAAE;QACpB;QACAC,cAAc;YACZC,QAAQN,KAAKI,EAAE;QACjB;IACF,CAAA;AAEAJ,KAAKC,IAAI,CAAC;AACVD,KAAKC,IAAI,CAAC;AACVD,KAAKC,IAAI,CAAC;;;;6BAlB2H;qCACjG;iEACjB;qEACH;+DACG;;;;;;AAgBnB,MAAMM,aAAaC,eAAM;AACzB,MAAMC,aAAaC,iBAAM;AACzB,MAAMC,UAAUC,qBAAG;AACnB,MAAMC,0BAA0BC,wCAAmB;AAEnDC,SAAS,eAAe;IACtBC,WAAW;QACThB,KAAKiB,aAAa;QAClBC,QAAQC,GAAG,CAACC,UAAU,GAAG;QACzBF,QAAQC,GAAG,CAACE,cAAc,GAAG;QAC7BH,QAAQC,GAAG,CAACG,wBAAwB,GAAG;IACzC;IAEAP,SAAS,4BAA4B;QACnCQ,KAAK,kCAAkC;YACrCC,OAAOC,IAAAA,qCAAwB,EAAC,QAAQC,IAAI,CAAC;QAC/C;QAEAH,KAAK,kCAAkC;YACrCC,OAAOC,IAAAA,qCAAwB,EAAC,OAAOC,IAAI,CAAC;QAC9C;QAEAH,KAAK,gCAAgC;YACnCC,OAAOC,IAAAA,qCAAwB,EAAC,OAAOC,IAAI,CAAC;QAC9C;QAEAH,KAAK,+BAA+B;YAClCC,OAAOC,IAAAA,qCAAwB,EAAC,OAAOC,IAAI,CAAC;QAC9C;QAEAH,KAAK,qCAAqC;YACxCC,OAAOC,IAAAA,qCAAwB,EAAC,KAAKC,IAAI,CAAC;YAC1CF,OAAOC,IAAAA,qCAAwB,EAAC,YAAYC,IAAI,CAAC;YACjDF,OAAOC,IAAAA,qCAAwB,EAAC,QAAQC,IAAI,CAAC;QAC/C;QAEAH,KAAK,4BAA4B;YAC/BC,OAAOC,IAAAA,qCAAwB,EAAC,OAAOC,IAAI,CAAC;YAC5CF,OAAOC,IAAAA,qCAAwB,EAAC,SAASC,IAAI,CAAC;QAChD;IACF;IAEAX,SAAS,oBAAoB;QAC3B,MAAMY,WAAW;YACfC,IAAI;YACJC,OAAO;YACPC,UAAU;YACVC,cAAc;YACdC,UAAU;YACVC,QAAQ;YACRC,QAAQ;YACRC,MAAM;gBACJP,IAAI;gBACJQ,MAAM;gBACNC,aAAa;oBACX;wBAAED,MAAM;oBAAgB;oBACxB;wBAAEA,MAAM;oBAAiB;iBAC1B;YACH;QACF;QAEAb,KAAK,8CAA8C;YACjDhB,WAAWL,IAAI,CAACC,SAAS,CAACmC,iBAAiB,CAACX;YAC5ClB,WAAW8B,OAAO,CAACD,iBAAiB,CAAC;YAErC,MAAME,SAAS,MAAMC,IAAAA,6BAAgB,EAAC,oBAAoB;YAE1DjB,OAAOgB,OAAOE,OAAO,EAAEhB,IAAI,CAAC;YAC5BF,OAAOgB,OAAOtC,IAAI,EAAEyC,OAAO,CAAC;gBAC1Bf,IAAI;gBACJC,OAAO;gBACPC,UAAU;gBACVG,QAAQ;gBACRC,QAAQ;gBACRG,aAAa;oBAAC;oBAAiB;iBAAiB;YAClD;YACAb,OAAOjB,WAAWL,IAAI,CAACC,SAAS,EAAEyC,oBAAoB,CAAC;gBACrDC,OAAO;oBACLhB,OAAO;oBACPG,UAAU;gBACZ;gBACAc,SAAS;oBACPX,MAAM;wBACJW,SAAS;4BACPT,aAAa;gCACXU,QAAQ;oCAAEX,MAAM;gCAAK;4BACvB;wBACF;oBACF;gBACF;YACF;QACF;QAEAb,KAAK,+BAA+B;YAClChB,WAAWL,IAAI,CAACC,SAAS,CAACmC,iBAAiB,CAAC;YAE5C,MAAME,SAAS,MAAMC,IAAAA,6BAAgB,EAAC,uBAAuB;YAE7DjB,OAAOgB,OAAOE,OAAO,EAAEhB,IAAI,CAAC;YAC5BF,OAAOgB,OAAOQ,OAAO,EAAEtB,IAAI,CAAC;YAC5BF,OAAOgB,OAAOtC,IAAI,EAAE+C,QAAQ;QAC9B;QAEA1B,KAAK,kCAAkC;YACrChB,WAAWL,IAAI,CAACC,SAAS,CAACmC,iBAAiB,CAACX;YAC5ClB,WAAW8B,OAAO,CAACD,iBAAiB,CAAC;YAErC,MAAME,SAAS,MAAMC,IAAAA,6BAAgB,EAAC,oBAAoB;YAE1DjB,OAAOgB,OAAOE,OAAO,EAAEhB,IAAI,CAAC;YAC5BF,OAAOgB,OAAOQ,OAAO,EAAEtB,IAAI,CAAC;YAC5BF,OAAOgB,OAAOtC,IAAI,EAAE+C,QAAQ;QAC9B;QAEA1B,KAAK,+BAA+B;YAClC,MAAM2B,eAAe;gBAAE,GAAGvB,QAAQ;gBAAEK,UAAU;YAAM;YACpDzB,WAAWL,IAAI,CAACC,SAAS,CAACmC,iBAAiB,CAAC,OAAO,6CAA6C;YAEhG,MAAME,SAAS,MAAMC,IAAAA,6BAAgB,EAAC,oBAAoB;YAE1DjB,OAAOgB,OAAOE,OAAO,EAAEhB,IAAI,CAAC;YAC5BF,OAAOgB,OAAOQ,OAAO,EAAEtB,IAAI,CAAC;QAC9B;QAEAH,KAAK,4CAA4C;YAC/ChB,WAAWL,IAAI,CAACC,SAAS,CAACgD,iBAAiB,CAAC,IAAIC,MAAM;YAEtD,MAAMZ,SAAS,MAAMC,IAAAA,6BAAgB,EAAC,oBAAoB;YAE1DjB,OAAOgB,OAAOE,OAAO,EAAEhB,IAAI,CAAC;YAC5BF,OAAOgB,OAAOQ,OAAO,EAAEtB,IAAI,CAAC;YAC5BF,OAAOgB,OAAOtC,IAAI,EAAE+C,QAAQ;QAC9B;QAEA1B,KAAK,0CAA0C;YAC7ChB,WAAWL,IAAI,CAACC,SAAS,CAACmC,iBAAiB,CAACX;YAC5ClB,WAAW8B,OAAO,CAACY,iBAAiB,CAAC,IAAIC,MAAM;YAE/C,MAAMZ,SAAS,MAAMC,IAAAA,6BAAgB,EAAC,oBAAoB;YAE1DjB,OAAOgB,OAAOE,OAAO,EAAEhB,IAAI,CAAC;YAC5BF,OAAOgB,OAAOQ,OAAO,EAAEtB,IAAI,CAAC;QAC9B;IACF;IAEAX,SAAS,kBAAkB;QACzB,MAAMY,WAAW;YACfC,IAAI;YACJC,OAAO;YACPC,UAAU;YACVG,QAAQ;YACRC,QAAQ;YACRG,aAAa;gBAAC;gBAAiB;aAAiB;QAClD;QAEAd,KAAK,6CAA6C;YAChD,MAAM8B,kBAAkB;YACxB,MAAMC,mBAAmB;YAEzB3C,QAAQ4C,IAAI,CAACC,mBAAmB,CAACH;YACjCxC,wBAAwB4C,kBAAkB,CAACnB,iBAAiB,CAACgB;YAE7D,MAAMd,SAAS,MAAMkB,IAAAA,2BAAc,EAAC/B;YAEpCH,OAAOgB,OAAOmB,WAAW,EAAEjC,IAAI,CAAC2B;YAChC7B,OAAOgB,OAAOnC,YAAY,EAAEqB,IAAI,CAAC4B;YACjC9B,OAAOb,QAAQ4C,IAAI,EAAEX,oBAAoB,CACvC;gBACEgB,KAAK;gBACL9B,UAAU;gBACVD,OAAO;gBACPI,QAAQ;gBACRC,QAAQ;gBACRG,aAAa;oBAAC;oBAAiB;iBAAiB;YAClD,GACA,eACA;gBAAEwB,WAAW;YAAK;YAEpBrC,OAAOX,wBAAwB4C,kBAAkB,EAAEb,oBAAoB,CAAC;QAC1E;QAEArB,KAAK,gDAAgD;YACnD,MAAM8B,kBAAkB;YAExB1C,QAAQ4C,IAAI,CAACC,mBAAmB,CAACH;YACjCxC,wBAAwB4C,kBAAkB,CAACN,iBAAiB,CAAC,IAAIC,MAAM;YAEvE,MAAM5B,OAAOkC,IAAAA,2BAAc,EAAC/B,WAAWmC,OAAO,CAACC,OAAO,CAAC;QACzD;IACF;IAEAhD,SAAS,eAAe;QACtBQ,KAAK,6BAA6B;YAChC,MAAMyC,cAAc;gBAClBJ,KAAK;gBACL9B,UAAU;gBACVD,OAAO;gBACPI,QAAQ;gBACRgC,KAAKC,KAAKC,KAAK,CAACC,KAAKC,GAAG,KAAK;gBAC7BC,KAAKJ,KAAKC,KAAK,CAACC,KAAKC,GAAG,KAAK,QAAQ;YACvC;YAEA1D,QAAQ4D,MAAM,CAACC,eAAe,CAACR;YAE/B,MAAMxB,SAAS,MAAMiC,IAAAA,wBAAW,EAAC;YAEjCjD,OAAOgB,QAAQG,OAAO,CAACqB;YACvBxC,OAAOb,QAAQ4D,MAAM,EAAE3B,oBAAoB,CAAC,eAAe;QAC7D;QAEArB,KAAK,wCAAwC;YAC3CZ,QAAQ4D,MAAM,CAACG,kBAAkB,CAAC;gBAChC,MAAM,IAAItB,MAAM;YAClB;YAEA,MAAMZ,SAAS,MAAMiC,IAAAA,wBAAW,EAAC;YAEjCjD,OAAOgB,QAAQS,QAAQ;QACzB;QAEA1B,KAAK,wCAAwC;YAC3CZ,QAAQ4D,MAAM,CAACG,kBAAkB,CAAC;gBAChC,MAAMC,QAAQ,IAAIvB,MAAM;gBACxBuB,MAAMvC,IAAI,GAAG;gBACb,MAAMuC;YACR;YAEA,MAAMnC,SAAS,MAAMiC,IAAAA,wBAAW,EAAC;YAEjCjD,OAAOgB,QAAQS,QAAQ;QACzB;IACF;IAEAlC,SAAS,6BAA6B;QACpC,MAAMY,WAAW;YACfC,IAAI;YACJC,OAAO;YACPC,UAAU;YACVE,UAAU;YACVC,QAAQ;YACRC,QAAQ;YACRC,MAAM;gBACJP,IAAI;gBACJQ,MAAM;gBACNC,aAAa;oBACX;wBAAED,MAAM;oBAAgB;oBACxB;wBAAEA,MAAM;oBAAiB;iBAC1B;YACH;QACF;QAEAb,KAAK,yCAAyC;YAC5C,MAAMqD,UAAU;gBACdhB,KAAK;gBACL9B,UAAU;gBACVD,OAAO;gBACPI,QAAQ;YACV;YAEA1B,WAAWL,IAAI,CAACC,SAAS,CAACmC,iBAAiB,CAACX;YAE5C,MAAMa,SAAS,MAAMqC,IAAAA,sCAAyB,EAACD;YAE/CpD,OAAOgB,QAAQG,OAAO,CAAC;gBACrBf,IAAI;gBACJC,OAAO;gBACPC,UAAU;gBACVG,QAAQ;gBACRC,QAAQ;gBACRG,aAAa;oBAAC;oBAAiB;iBAAiB;YAClD;QACF;QAEAd,KAAK,uCAAuC;YAC1C,MAAMiB,SAAS,MAAMqC,IAAAA,sCAAyB,EAAC;YAC/CrD,OAAOgB,QAAQS,QAAQ;QACzB;QAEA1B,KAAK,0CAA0C;YAC7C,MAAMiB,SAAS,MAAMqC,IAAAA,sCAAyB,EAAC,CAAC;YAChDrD,OAAOgB,QAAQS,QAAQ;QACzB;QAEA1B,KAAK,0CAA0C;YAC7C,MAAMqD,UAAU;gBACdhB,KAAK;gBACL9B,UAAU;gBACVD,OAAO;gBACPI,QAAQ;YACV;YAEA1B,WAAWL,IAAI,CAACC,SAAS,CAACmC,iBAAiB,CAAC;YAE5C,MAAME,SAAS,MAAMqC,IAAAA,sCAAyB,EAACD;YAC/CpD,OAAOgB,QAAQS,QAAQ;QACzB;IACF;IAEAlC,SAAS,oBAAoB;QAC3BQ,KAAK,uCAAuC;YAC1C,MAAMyC,cAAc;gBAClBJ,KAAK;gBACL9B,UAAU;gBACVD,OAAO;gBACPI,QAAQ;YACV;YAEA,MAAMN,WAAW;gBACfC,IAAI;gBACJC,OAAO;gBACPC,UAAU;gBACVG,QAAQ;gBACRC,QAAQ;gBACRG,aAAa;oBAAC;iBAAgB;YAChC;YAEA1B,QAAQ4D,MAAM,CAACC,eAAe,CAACR;YAC/BzD,WAAWL,IAAI,CAACC,SAAS,CAACmC,iBAAiB,CAAC;gBAC1CV,IAAI;gBACJC,OAAO;gBACPC,UAAU;gBACVE,UAAU;gBACVC,QAAQ;gBACRC,QAAQ;gBACRC,MAAM;oBACJP,IAAI;oBACJQ,MAAM;oBACNC,aAAa;wBAAC;4BAAED,MAAM;wBAAgB;qBAAE;gBAC1C;YACF;YAEA,MAAMI,SAAS,MAAMsC,IAAAA,6BAAgB,EAAC;YACtCtD,OAAOgB,QAAQG,OAAO,CAAChB;QACzB;QAEAJ,KAAK,wCAAwC;YAC3CZ,QAAQ4D,MAAM,CAACG,kBAAkB,CAAC;gBAChC,MAAM,IAAItB,MAAM;YAClB;YAEA,MAAMZ,SAAS,MAAMsC,IAAAA,6BAAgB,EAAC;YACtCtD,OAAOgB,QAAQS,QAAQ;QACzB;IACF;IAEAlC,SAAS,kBAAkB;QACzBQ,KAAK,oCAAoC;YACvC,OAAOL,QAAQC,GAAG,CAACC,UAAU;YAE7B,MAAMoB,SAAS,MAAMiC,IAAAA,wBAAW,EAAC;YACjCjD,OAAOgB,QAAQS,QAAQ;QACzB;QAEA1B,KAAK,6CAA6C;YAChD,MAAMiB,SAAS,MAAMiC,IAAAA,wBAAW,EAAC;YACjCjD,OAAOgB,QAAQS,QAAQ;QACzB;QAEA1B,KAAK,6BAA6B;YAChC,MAAMiB,SAAS,MAAMiC,IAAAA,wBAAW,EAAC;YACjCjD,OAAOgB,QAAQS,QAAQ;QACzB;IACF;AACF"}