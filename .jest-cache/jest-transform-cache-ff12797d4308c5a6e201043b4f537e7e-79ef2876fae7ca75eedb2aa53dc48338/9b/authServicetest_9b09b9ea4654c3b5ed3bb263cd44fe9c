1148101c92a59f05859df615e525457c
"use strict";
// Mock dependencies
jest.mock("@/lib/prisma", ()=>({
        user: {
            findFirst: jest.fn()
        },
        refreshToken: {
            create: jest.fn()
        }
    }));
jest.mock("bcryptjs");
jest.mock("jsonwebtoken");
jest.mock("@/services/refreshTokenService");
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _authService = require("../../src/services/authService");
const _refreshTokenService = require("../../src/services/refreshTokenService");
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _prisma = /*#__PURE__*/ _interop_require_default(require("../../src/lib/prisma"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const mockPrisma = _prisma.default;
const mockBcrypt = _bcryptjs.default;
const mockJwt = _jsonwebtoken.default;
const mockRefreshTokenService = _refreshTokenService.refreshTokenService;
describe("AuthService", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        process.env.JWT_SECRET = "test-secret";
        process.env.JWT_EXPIRES_IN = "1h";
        process.env.REFRESH_TOKEN_EXPIRES_IN = "7d";
    });
    describe("parseTimeStringToSeconds", ()=>{
        test("should parse seconds correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("30s")).toBe(30);
        });
        test("should parse minutes correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("5m")).toBe(300);
        });
        test("should parse hours correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("2h")).toBe(7200);
        });
        test("should parse days correctly", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("1d")).toBe(86400);
        });
        test("should return 0 for invalid input", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("invalid")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("abc")).toBe(0);
        });
        test("should handle edge cases", ()=>{
            expect((0, _authService.parseTimeStringToSeconds)("0s")).toBe(0);
            expect((0, _authService.parseTimeStringToSeconds)("100x")).toBe(0);
        });
    });
    describe("authenticateUser", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            username: "testuser",
            passwordHash: "hashedpassword",
            isActive: true,
            roleId: 1,
            shopId: 1,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should authenticate valid user credentials", async ()=>{
            mockPrisma.user.findFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(true);
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(true);
            expect(result.user).toEqual({
                id: 1,
                email: "test@example.com",
                username: "testuser",
                roleId: 1,
                shopId: 1,
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
            expect(mockPrisma.user.findFirst).toHaveBeenCalledWith({
                where: {
                    email: "test@example.com",
                    isActive: true
                },
                include: {
                    role: {
                        include: {
                            permissions: {
                                select: {
                                    name: true
                                }
                            }
                        }
                    }
                }
            });
        });
        test("should reject invalid email", async ()=>{
            mockPrisma.user.findFirst.mockResolvedValue(null);
            const result = await (0, _authService.authenticateUser)("invalid@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
            expect(result.user).toBeNull();
        });
        test("should reject invalid password", async ()=>{
            mockPrisma.user.findFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockResolvedValue(false);
            const result = await (0, _authService.authenticateUser)("test@example.com", "wrongpassword");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
            expect(result.user).toBeNull();
        });
        test("should reject inactive user", async ()=>{
            const inactiveUser = {
                ...mockUser,
                isActive: false
            };
            mockPrisma.user.findFirst.mockResolvedValue(null); // findFirst with isActive: true returns null
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Invalid email or password");
        });
        test("should handle database errors gracefully", async ()=>{
            mockPrisma.user.findFirst.mockRejectedValue(new Error("Database connection failed"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
            expect(result.user).toBeNull();
        });
        test("should handle bcrypt errors gracefully", async ()=>{
            mockPrisma.user.findFirst.mockResolvedValue(mockUser);
            mockBcrypt.compare.mockRejectedValue(new Error("Bcrypt error"));
            const result = await (0, _authService.authenticateUser)("test@example.com", "password123");
            expect(result.success).toBe(false);
            expect(result.message).toBe("Authentication failed");
        });
    });
    describe("generateTokens", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            username: "testuser",
            roleId: 1,
            shopId: 1,
            permissions: [
                "read_products",
                "write_products"
            ]
        };
        test("should generate access and refresh tokens", async ()=>{
            const mockAccessToken = "mock-access-token";
            const mockRefreshToken = "mock-refresh-token";
            mockJwt.sign.mockReturnValueOnce(mockAccessToken);
            mockRefreshTokenService.createRefreshToken.mockResolvedValue(mockRefreshToken);
            const result = await (0, _authService.generateTokens)(mockUser);
            expect(result.accessToken).toBe(mockAccessToken);
            expect(result.refreshToken).toBe(mockRefreshToken);
            expect(mockJwt.sign).toHaveBeenCalledWith({
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                shopId: 1,
                permissions: [
                    "read_products",
                    "write_products"
                ]
            }, "test-secret", {
                expiresIn: "1h"
            });
            expect(mockRefreshTokenService.createRefreshToken).toHaveBeenCalledWith(1);
        });
        test("should handle refresh token creation failure", async ()=>{
            const mockAccessToken = "mock-access-token";
            mockJwt.sign.mockReturnValueOnce(mockAccessToken);
            mockRefreshTokenService.createRefreshToken.mockRejectedValue(new Error("Refresh token creation failed"));
            await expect((0, _authService.generateTokens)(mockUser)).rejects.toThrow("Refresh token creation failed");
        });
    });
    describe("verifyToken", ()=>{
        test("should verify valid token", async ()=>{
            const mockPayload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 3600
            };
            mockJwt.verify.mockReturnValue(mockPayload);
            const result = await (0, _authService.verifyToken)("valid-token");
            expect(result).toEqual(mockPayload);
            expect(mockJwt.verify).toHaveBeenCalledWith("valid-token", "test-secret");
        });
        test("should return null for invalid token", async ()=>{
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("Invalid token");
            });
            const result = await (0, _authService.verifyToken)("invalid-token");
            expect(result).toBeNull();
        });
        test("should return null for expired token", async ()=>{
            mockJwt.verify.mockImplementation(()=>{
                const error = new Error("Token expired");
                error.name = "TokenExpiredError";
                throw error;
            });
            const result = await (0, _authService.verifyToken)("expired-token");
            expect(result).toBeNull();
        });
    });
    describe("getUserFromDecodedPayload", ()=>{
        const mockUser = {
            id: 1,
            email: "test@example.com",
            username: "testuser",
            isActive: true,
            roleId: 1,
            shopId: 1,
            role: {
                id: 1,
                name: "admin",
                permissions: [
                    {
                        name: "read_products"
                    },
                    {
                        name: "write_products"
                    }
                ]
            }
        };
        test("should return user from valid payload", async ()=>{
            const payload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            mockPrisma.user.findFirst.mockResolvedValue(mockUser);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toEqual({
                id: 1,
                email: "test@example.com",
                username: "testuser",
                roleId: 1,
                shopId: 1,
                permissions: [
                    "read_products",
                    "write_products"
                ]
            });
        });
        test("should return null for null payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)(null);
            expect(result).toBeNull();
        });
        test("should return null for invalid payload", async ()=>{
            const result = await (0, _authService.getUserFromDecodedPayload)({});
            expect(result).toBeNull();
        });
        test("should return null when user not found", async ()=>{
            const payload = {
                sub: 999,
                username: "nonexistent",
                email: "nonexistent@example.com",
                roleId: 1
            };
            mockPrisma.user.findFirst.mockResolvedValue(null);
            const result = await (0, _authService.getUserFromDecodedPayload)(payload);
            expect(result).toBeNull();
        });
    });
    describe("getUserFromToken", ()=>{
        test("should return user from valid token", async ()=>{
            const mockPayload = {
                sub: 1,
                username: "testuser",
                email: "test@example.com",
                roleId: 1
            };
            const mockUser = {
                id: 1,
                email: "test@example.com",
                username: "testuser",
                roleId: 1,
                shopId: 1,
                permissions: [
                    "read_products"
                ]
            };
            mockJwt.verify.mockReturnValue(mockPayload);
            mockPrisma.user.findFirst.mockResolvedValue({
                id: 1,
                email: "test@example.com",
                username: "testuser",
                isActive: true,
                roleId: 1,
                shopId: 1,
                role: {
                    id: 1,
                    name: "admin",
                    permissions: [
                        {
                            name: "read_products"
                        }
                    ]
                }
            });
            const result = await (0, _authService.getUserFromToken)("valid-token");
            expect(result).toEqual(mockUser);
        });
        test("should return null for invalid token", async ()=>{
            mockJwt.verify.mockImplementation(()=>{
                throw new Error("Invalid token");
            });
            const result = await (0, _authService.getUserFromToken)("invalid-token");
            expect(result).toBeNull();
        });
    });
    describe("Error Handling", ()=>{
        test("should handle missing JWT_SECRET", async ()=>{
            delete process.env.JWT_SECRET;
            const result = await (0, _authService.verifyToken)("any-token");
            expect(result).toBeNull();
        });
        test("should handle malformed tokens gracefully", async ()=>{
            const result = await (0, _authService.verifyToken)("not.a.valid.jwt.token");
            expect(result).toBeNull();
        });
        test("should handle empty token", async ()=>{
            const result = await (0, _authService.verifyToken)("");
            expect(result).toBeNull();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC9hdXRoU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF1dGhlbnRpY2F0ZVVzZXIsIGdlbmVyYXRlVG9rZW5zLCB2ZXJpZnlUb2tlbiwgcGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzLCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkLCBnZXRVc2VyRnJvbVRva2VuIH0gZnJvbSAnQC9zZXJ2aWNlcy9hdXRoU2VydmljZSc7XG5pbXBvcnQgeyByZWZyZXNoVG9rZW5TZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9yZWZyZXNoVG9rZW5TZXJ2aWNlJztcbmltcG9ydCBiY3J5cHQgZnJvbSAnYmNyeXB0anMnO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuaW1wb3J0IHByaXNtYSBmcm9tICdAL2xpYi9wcmlzbWEnO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCdAL2xpYi9wcmlzbWEnLCAoKSA9PiAoe1xuICB1c2VyOiB7XG4gICAgZmluZEZpcnN0OiBqZXN0LmZuKCksXG4gIH0sXG4gIHJlZnJlc2hUb2tlbjoge1xuICAgIGNyZWF0ZTogamVzdC5mbigpLFxuICB9LFxufSkpO1xuXG5qZXN0Lm1vY2soJ2JjcnlwdGpzJyk7XG5qZXN0Lm1vY2soJ2pzb253ZWJ0b2tlbicpO1xuamVzdC5tb2NrKCdAL3NlcnZpY2VzL3JlZnJlc2hUb2tlblNlcnZpY2UnKTtcblxuY29uc3QgbW9ja1ByaXNtYSA9IHByaXNtYSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgcHJpc21hPjtcbmNvbnN0IG1vY2tCY3J5cHQgPSBiY3J5cHQgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGJjcnlwdD47XG5jb25zdCBtb2NrSnd0ID0gand0IGFzIGplc3QuTW9ja2VkPHR5cGVvZiBqd3Q+O1xuY29uc3QgbW9ja1JlZnJlc2hUb2tlblNlcnZpY2UgPSByZWZyZXNoVG9rZW5TZXJ2aWNlIGFzIGplc3QuTW9ja2VkPHR5cGVvZiByZWZyZXNoVG9rZW5TZXJ2aWNlPjtcblxuZGVzY3JpYmUoJ0F1dGhTZXJ2aWNlJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtc2VjcmV0JztcbiAgICBwcm9jZXNzLmVudi5KV1RfRVhQSVJFU19JTiA9ICcxaCc7XG4gICAgcHJvY2Vzcy5lbnYuUkVGUkVTSF9UT0tFTl9FWFBJUkVTX0lOID0gJzdkJztcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3BhcnNlVGltZVN0cmluZ1RvU2Vjb25kcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcGFyc2Ugc2Vjb25kcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCczMHMnKSkudG9CZSgzMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgbWludXRlcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCc1bScpKS50b0JlKDMwMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcGFyc2UgaG91cnMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnMmgnKSkudG9CZSg3MjAwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBwYXJzZSBkYXlzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzFkJykpLnRvQmUoODY0MDApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiAwIGZvciBpbnZhbGlkIGlucHV0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHBhcnNlVGltZVN0cmluZ1RvU2Vjb25kcygnJykpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCdpbnZhbGlkJykpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCdhYmMnKSkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZWRnZSBjYXNlcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMoJzBzJykpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocGFyc2VUaW1lU3RyaW5nVG9TZWNvbmRzKCcxMDB4JykpLnRvQmUoMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhdXRoZW50aWNhdGVVc2VyJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRwYXNzd29yZCcsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIHJvbGVJZDogMSxcbiAgICAgIHNob3BJZDogMSxcbiAgICAgIHJvbGU6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbXG4gICAgICAgICAgeyBuYW1lOiAncmVhZF9wcm9kdWN0cycgfSxcbiAgICAgICAgICB7IG5hbWU6ICd3cml0ZV9wcm9kdWN0cycgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCBhdXRoZW50aWNhdGUgdmFsaWQgdXNlciBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuICAgICAgbW9ja0JjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcikudG9FcXVhbCh7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgcm9sZUlkOiAxLFxuICAgICAgICBzaG9wSWQ6IDEsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja1ByaXNtYS51c2VyLmZpbmRGaXJzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgaXNBY3RpdmU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIHJvbGU6IHtcbiAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1ByaXNtYS51c2VyLmZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlVXNlcignaW52YWxpZEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnVzZXIpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgcGFzc3dvcmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZEZpcnN0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIG1vY2tCY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnd3JvbmdwYXNzd29yZCcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnVzZXIpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGluYWN0aXZlIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbmFjdGl2ZVVzZXIgPSB7IC4uLm1vY2tVc2VyLCBpc0FjdGl2ZTogZmFsc2UgfTtcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7IC8vIGZpbmRGaXJzdCB3aXRoIGlzQWN0aXZlOiB0cnVlIHJldHVybnMgbnVsbFxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUHJpc21hLnVzZXIuZmluZEZpcnN0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZVVzZXIoJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9CZSgnQXV0aGVudGljYXRpb24gZmFpbGVkJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnVzZXIpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGJjcnlwdCBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuICAgICAgbW9ja0JjcnlwdC5jb21wYXJlLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQmNyeXB0IGVycm9yJykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoZW50aWNhdGVVc2VyKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQmUoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2VuZXJhdGVUb2tlbnMnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgIHJvbGVJZDogMSxcbiAgICAgIHNob3BJZDogMSxcbiAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnLCAnd3JpdGVfcHJvZHVjdHMnXVxuICAgIH07XG5cbiAgICB0ZXN0KCdzaG91bGQgZ2VuZXJhdGUgYWNjZXNzIGFuZCByZWZyZXNoIHRva2VucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBY2Nlc3NUb2tlbiA9ICdtb2NrLWFjY2Vzcy10b2tlbic7XG4gICAgICBjb25zdCBtb2NrUmVmcmVzaFRva2VuID0gJ21vY2stcmVmcmVzaC10b2tlbic7XG4gICAgICBcbiAgICAgIG1vY2tKd3Quc2lnbi5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tBY2Nlc3NUb2tlbik7XG4gICAgICBtb2NrUmVmcmVzaFRva2VuU2VydmljZS5jcmVhdGVSZWZyZXNoVG9rZW4ubW9ja1Jlc29sdmVkVmFsdWUobW9ja1JlZnJlc2hUb2tlbik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlVG9rZW5zKG1vY2tVc2VyKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5hY2Nlc3NUb2tlbikudG9CZShtb2NrQWNjZXNzVG9rZW4pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yZWZyZXNoVG9rZW4pLnRvQmUobW9ja1JlZnJlc2hUb2tlbik7XG4gICAgICBleHBlY3QobW9ja0p3dC5zaWduKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAge1xuICAgICAgICAgIHN1YjogMSxcbiAgICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgICBzaG9wSWQ6IDEsXG4gICAgICAgICAgcGVybWlzc2lvbnM6IFsncmVhZF9wcm9kdWN0cycsICd3cml0ZV9wcm9kdWN0cyddXG4gICAgICAgIH0sXG4gICAgICAgICd0ZXN0LXNlY3JldCcsXG4gICAgICAgIHsgZXhwaXJlc0luOiAnMWgnIH1cbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja1JlZnJlc2hUb2tlblNlcnZpY2UuY3JlYXRlUmVmcmVzaFRva2VuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgcmVmcmVzaCB0b2tlbiBjcmVhdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjY2Vzc1Rva2VuID0gJ21vY2stYWNjZXNzLXRva2VuJztcbiAgICAgIFxuICAgICAgbW9ja0p3dC5zaWduLm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0FjY2Vzc1Rva2VuKTtcbiAgICAgIG1vY2tSZWZyZXNoVG9rZW5TZXJ2aWNlLmNyZWF0ZVJlZnJlc2hUb2tlbi5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JlZnJlc2ggdG9rZW4gY3JlYXRpb24gZmFpbGVkJykpO1xuXG4gICAgICBhd2FpdCBleHBlY3QoZ2VuZXJhdGVUb2tlbnMobW9ja1VzZXIpKS5yZWplY3RzLnRvVGhyb3coJ1JlZnJlc2ggdG9rZW4gY3JlYXRpb24gZmFpbGVkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd2ZXJpZnlUb2tlbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdmVyaWZ5IHZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMSxcbiAgICAgICAgaWF0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDM2MDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tKd3QudmVyaWZ5Lm1vY2tSZXR1cm5WYWx1ZShtb2NrUGF5bG9hZCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCd2YWxpZC10b2tlbicpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tQYXlsb2FkKTtcbiAgICAgIGV4cGVjdChtb2NrSnd0LnZlcmlmeSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3ZhbGlkLXRva2VuJywgJ3Rlc3Qtc2VjcmV0Jyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGludmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrSnd0LnZlcmlmeS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4nKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2ZXJpZnlUb2tlbignaW52YWxpZC10b2tlbicpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBleHBpcmVkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1Rva2VuIGV4cGlyZWQnKTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdUb2tlbkV4cGlyZWRFcnJvcic7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCdleHBpcmVkLXRva2VuJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgIHJvbGVJZDogMSxcbiAgICAgIHNob3BJZDogMSxcbiAgICAgIHJvbGU6IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdhZG1pbicsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbXG4gICAgICAgICAgeyBuYW1lOiAncmVhZF9wcm9kdWN0cycgfSxcbiAgICAgICAgICB7IG5hbWU6ICd3cml0ZV9wcm9kdWN0cycgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIHZhbGlkIHBheWxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBzdWI6IDEsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByb2xlSWQ6IDFcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyRnJvbURlY29kZWRQYXlsb2FkKHBheWxvYWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHVzZXJuYW1lOiAndGVzdHVzZXInLFxuICAgICAgICByb2xlSWQ6IDEsXG4gICAgICAgIHNob3BJZDogMSxcbiAgICAgICAgcGVybWlzc2lvbnM6IFsncmVhZF9wcm9kdWN0cycsICd3cml0ZV9wcm9kdWN0cyddXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgbnVsbCBwYXlsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChudWxsKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIGludmFsaWQgcGF5bG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQoe30gYXMgYW55KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIG51bGwgd2hlbiB1c2VyIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHN1YjogOTk5LFxuICAgICAgICB1c2VybmFtZTogJ25vbmV4aXN0ZW50JyxcbiAgICAgICAgZW1haWw6ICdub25leGlzdGVudEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbW9ja1ByaXNtYS51c2VyLmZpbmRGaXJzdC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21EZWNvZGVkUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRVc2VyRnJvbVRva2VuJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdXNlciBmcm9tIHZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BheWxvYWQgPSB7XG4gICAgICAgIHN1YjogMSxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGVJZDogMVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB1c2VybmFtZTogJ3Rlc3R1c2VyJyxcbiAgICAgICAgcm9sZUlkOiAxLFxuICAgICAgICBzaG9wSWQ6IDEsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbJ3JlYWRfcHJvZHVjdHMnXVxuICAgICAgfTtcblxuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja1JldHVyblZhbHVlKG1vY2tQYXlsb2FkKTtcbiAgICAgIG1vY2tQcmlzbWEudXNlci5maW5kRmlyc3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgdXNlcm5hbWU6ICd0ZXN0dXNlcicsXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgICByb2xlSWQ6IDEsXG4gICAgICAgIHNob3BJZDogMSxcbiAgICAgICAgcm9sZToge1xuICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgIG5hbWU6ICdhZG1pbicsXG4gICAgICAgICAgcGVybWlzc2lvbnM6IFt7IG5hbWU6ICdyZWFkX3Byb2R1Y3RzJyB9XVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21Ub2tlbigndmFsaWQtdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja1VzZXIpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBpbnZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0p3dC52ZXJpZnkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlckZyb21Ub2tlbignaW52YWxpZC10b2tlbicpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyBKV1RfU0VDUkVUJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQ7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCdhbnktdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIG1hbGZvcm1lZCB0b2tlbnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVRva2VuKCdub3QuYS52YWxpZC5qd3QudG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmVyaWZ5VG9rZW4oJycpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJ1c2VyIiwiZmluZEZpcnN0IiwiZm4iLCJyZWZyZXNoVG9rZW4iLCJjcmVhdGUiLCJtb2NrUHJpc21hIiwicHJpc21hIiwibW9ja0JjcnlwdCIsImJjcnlwdCIsIm1vY2tKd3QiLCJqd3QiLCJtb2NrUmVmcmVzaFRva2VuU2VydmljZSIsInJlZnJlc2hUb2tlblNlcnZpY2UiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJKV1RfRVhQSVJFU19JTiIsIlJFRlJFU0hfVE9LRU5fRVhQSVJFU19JTiIsInRlc3QiLCJleHBlY3QiLCJwYXJzZVRpbWVTdHJpbmdUb1NlY29uZHMiLCJ0b0JlIiwibW9ja1VzZXIiLCJpZCIsImVtYWlsIiwidXNlcm5hbWUiLCJwYXNzd29yZEhhc2giLCJpc0FjdGl2ZSIsInJvbGVJZCIsInNob3BJZCIsInJvbGUiLCJuYW1lIiwicGVybWlzc2lvbnMiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImNvbXBhcmUiLCJyZXN1bHQiLCJhdXRoZW50aWNhdGVVc2VyIiwic3VjY2VzcyIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIndoZXJlIiwiaW5jbHVkZSIsInNlbGVjdCIsIm1lc3NhZ2UiLCJ0b0JlTnVsbCIsImluYWN0aXZlVXNlciIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJtb2NrQWNjZXNzVG9rZW4iLCJtb2NrUmVmcmVzaFRva2VuIiwic2lnbiIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJjcmVhdGVSZWZyZXNoVG9rZW4iLCJnZW5lcmF0ZVRva2VucyIsImFjY2Vzc1Rva2VuIiwic3ViIiwiZXhwaXJlc0luIiwicmVqZWN0cyIsInRvVGhyb3ciLCJtb2NrUGF5bG9hZCIsImlhdCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJleHAiLCJ2ZXJpZnkiLCJtb2NrUmV0dXJuVmFsdWUiLCJ2ZXJpZnlUb2tlbiIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImVycm9yIiwicGF5bG9hZCIsImdldFVzZXJGcm9tRGVjb2RlZFBheWxvYWQiLCJnZXRVc2VyRnJvbVRva2VuIl0sIm1hcHBpbmdzIjoiO0FBTUEsb0JBQW9CO0FBQ3BCQSxLQUFLQyxJQUFJLENBQUMsZ0JBQWdCLElBQU8sQ0FBQTtRQUMvQkMsTUFBTTtZQUNKQyxXQUFXSCxLQUFLSSxFQUFFO1FBQ3BCO1FBQ0FDLGNBQWM7WUFDWkMsUUFBUU4sS0FBS0ksRUFBRTtRQUNqQjtJQUNGLENBQUE7QUFFQUosS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7Ozs7NkJBbEIySDtxQ0FDakc7aUVBQ2pCO3FFQUNIOytEQUNHOzs7Ozs7QUFnQm5CLE1BQU1NLGFBQWFDLGVBQU07QUFDekIsTUFBTUMsYUFBYUMsaUJBQU07QUFDekIsTUFBTUMsVUFBVUMscUJBQUc7QUFDbkIsTUFBTUMsMEJBQTBCQyx3Q0FBbUI7QUFFbkRDLFNBQVMsZUFBZTtJQUN0QkMsV0FBVztRQUNUaEIsS0FBS2lCLGFBQWE7UUFDbEJDLFFBQVFDLEdBQUcsQ0FBQ0MsVUFBVSxHQUFHO1FBQ3pCRixRQUFRQyxHQUFHLENBQUNFLGNBQWMsR0FBRztRQUM3QkgsUUFBUUMsR0FBRyxDQUFDRyx3QkFBd0IsR0FBRztJQUN6QztJQUVBUCxTQUFTLDRCQUE0QjtRQUNuQ1EsS0FBSyxrQ0FBa0M7WUFDckNDLE9BQU9DLElBQUFBLHFDQUF3QixFQUFDLFFBQVFDLElBQUksQ0FBQztRQUMvQztRQUVBSCxLQUFLLGtDQUFrQztZQUNyQ0MsT0FBT0MsSUFBQUEscUNBQXdCLEVBQUMsT0FBT0MsSUFBSSxDQUFDO1FBQzlDO1FBRUFILEtBQUssZ0NBQWdDO1lBQ25DQyxPQUFPQyxJQUFB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