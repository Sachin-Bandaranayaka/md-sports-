1fa95a8ef2962e41d085ecc51ed42a1c
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
// Mock console methods
const consoleSpy = {
    log: jest.spyOn(console, "log").mockImplementation(()=>{}),
    error: jest.spyOn(console, "error").mockImplementation(()=>{}),
    warn: jest.spyOn(console, "warn").mockImplementation(()=>{})
};
describe("Utility Functions Tests", ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleSpy.log.mockClear();
        consoleSpy.error.mockClear();
        consoleSpy.warn.mockClear();
    });
    afterAll(()=>{
        consoleSpy.log.mockRestore();
        consoleSpy.error.mockRestore();
        consoleSpy.warn.mockRestore();
    });
    describe("Formatting Functions", ()=>{
        describe("formatCurrency", ()=>{
            it("should format currency with default settings", ()=>{
                const mockFormatCurrency = jest.fn((amount, currency = "USD", locale = "en-US")=>{
                    return new Intl.NumberFormat(locale, {
                        style: "currency",
                        currency: currency
                    }).format(amount);
                });
                expect(mockFormatCurrency(1234.56)).toBe("$1,234.56");
                expect(mockFormatCurrency(0)).toBe("$0.00");
                expect(mockFormatCurrency(-500.25)).toBe("-$500.25");
            });
            it("should format currency with different currencies", ()=>{
                const mockFormatCurrency = jest.fn((amount, currency = "USD", locale = "en-US")=>{
                    return new Intl.NumberFormat(locale, {
                        style: "currency",
                        currency: currency
                    }).format(amount);
                });
                expect(mockFormatCurrency(1000, "EUR", "de-DE")).toBe("1.000,00 â‚¬");
                expect(mockFormatCurrency(1000, "GBP", "en-GB")).toBe("\xa31,000.00");
                expect(mockFormatCurrency(1000, "JPY", "ja-JP")).toBe("\xa51,000");
            });
            it("should handle edge cases", ()=>{
                const mockFormatCurrency = jest.fn((amount, currency = "USD", locale = "en-US")=>{
                    if (isNaN(amount) || !isFinite(amount)) {
                        return "$0.00";
                    }
                    return new Intl.NumberFormat(locale, {
                        style: "currency",
                        currency: currency
                    }).format(amount);
                });
                expect(mockFormatCurrency(NaN)).toBe("$0.00");
                expect(mockFormatCurrency(Infinity)).toBe("$0.00");
                expect(mockFormatCurrency(-Infinity)).toBe("$0.00");
            });
        });
        describe("formatDate", ()=>{
            it("should format dates with default settings", ()=>{
                const mockFormatDate = jest.fn((date, format = "MM/dd/yyyy")=>{
                    const d = new Date(date);
                    if (isNaN(d.getTime())) return "Invalid Date";
                    const month = String(d.getMonth() + 1).padStart(2, "0");
                    const day = String(d.getDate()).padStart(2, "0");
                    const year = d.getFullYear();
                    return `${month}/${day}/${year}`;
                });
                const testDate = new Date("2024-01-15");
                expect(mockFormatDate(testDate)).toBe("01/15/2024");
                expect(mockFormatDate("2024-12-25")).toBe("12/25/2024");
            });
            it("should format dates with different formats", ()=>{
                const mockFormatDate = jest.fn((date, format)=>{
                    const d = new Date(date);
                    if (isNaN(d.getTime())) return "Invalid Date";
                    const formatMap = {
                        "yyyy-MM-dd": `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`,
                        "dd/MM/yyyy": `${String(d.getDate()).padStart(2, "0")}/${String(d.getMonth() + 1).padStart(2, "0")}/${d.getFullYear()}`,
                        "MMM dd, yyyy": d.toLocaleDateString("en-US", {
                            year: "numeric",
                            month: "short",
                            day: "numeric"
                        })
                    };
                    return formatMap[format] || formatMap["MM/dd/yyyy"];
                });
                const testDate = new Date("2024-01-15");
                expect(mockFormatDate(testDate, "yyyy-MM-dd")).toBe("2024-01-15");
                expect(mockFormatDate(testDate, "dd/MM/yyyy")).toBe("15/01/2024");
                expect(mockFormatDate(testDate, "MMM dd, yyyy")).toBe("Jan 15, 2024");
            });
            it("should handle invalid dates", ()=>{
                const mockFormatDate = jest.fn((date)=>{
                    const d = new Date(date);
                    return isNaN(d.getTime()) ? "Invalid Date" : d.toLocaleDateString();
                });
                expect(mockFormatDate("invalid-date")).toBe("Invalid Date");
                expect(mockFormatDate("")).toBe("Invalid Date");
            });
        });
        describe("formatPhoneNumber", ()=>{
            it("should format US phone numbers", ()=>{
                const mockFormatPhoneNumber = jest.fn((phone, country = "US")=>{
                    const cleaned = phone.replace(/\D/g, "");
                    if (country === "US" && cleaned.length === 10) {
                        return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
                    }
                    return phone;
                });
                expect(mockFormatPhoneNumber("1234567890")).toBe("(123) 456-7890");
                expect(mockFormatPhoneNumber("123-456-7890")).toBe("(123) 456-7890");
                expect(mockFormatPhoneNumber("(123) 456-7890")).toBe("(123) 456-7890");
            });
            it("should handle international phone numbers", ()=>{
                const mockFormatPhoneNumber = jest.fn((phone, country)=>{
                    const cleaned = phone.replace(/\D/g, "");
                    if (country === "UK" && cleaned.length === 11) {
                        return `+44 ${cleaned.slice(1, 5)} ${cleaned.slice(5, 8)} ${cleaned.slice(8)}`;
                    }
                    return phone;
                });
                expect(mockFormatPhoneNumber("01234567890", "UK")).toBe("+44 1234 567 890");
            });
            it("should handle invalid phone numbers", ()=>{
                const mockFormatPhoneNumber = jest.fn((phone)=>{
                    const cleaned = phone.replace(/\D/g, "");
                    return cleaned.length < 10 ? phone : `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
                });
                expect(mockFormatPhoneNumber("123")).toBe("123");
                expect(mockFormatPhoneNumber("")).toBe("");
                expect(mockFormatPhoneNumber("abc")).toBe("abc");
            });
        });
    });
    describe("Validation Functions", ()=>{
        describe("validateEmail", ()=>{
            it("should validate correct email addresses", ()=>{
                const mockValidateEmail = jest.fn((email)=>{
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    return emailRegex.test(email);
                });
                expect(mockValidateEmail("test@example.com")).toBe(true);
                expect(mockValidateEmail("user.name@domain.co.uk")).toBe(true);
                expect(mockValidateEmail("user+tag@example.org")).toBe(true);
            });
            it("should reject invalid email addresses", ()=>{
                const mockValidateEmail = jest.fn((email)=>{
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    return emailRegex.test(email);
                });
                expect(mockValidateEmail("invalid-email")).toBe(false);
                expect(mockValidateEmail("test@")).toBe(false);
                expect(mockValidateEmail("@example.com")).toBe(false);
                expect(mockValidateEmail("test@.com")).toBe(false);
                expect(mockValidateEmail("")).toBe(false);
            });
        });
        describe("validatePassword", ()=>{
            it("should validate strong passwords", ()=>{
                const mockValidatePassword = jest.fn((password)=>{
                    const minLength = password.length >= 8;
                    const hasUpper = /[A-Z]/.test(password);
                    const hasLower = /[a-z]/.test(password);
                    const hasNumber = /\d/.test(password);
                    const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
                    return minLength && hasUpper && hasLower && hasNumber && hasSpecial;
                });
                expect(mockValidatePassword("Password123!")).toBe(true);
                expect(mockValidatePassword("MySecure@Pass1")).toBe(true);
                expect(mockValidatePassword("Complex#Password9")).toBe(true);
            });
            it("should reject weak passwords", ()=>{
                const mockValidatePassword = jest.fn((password)=>{
                    const minLength = password.length >= 8;
                    const hasUpper = /[A-Z]/.test(password);
                    const hasLower = /[a-z]/.test(password);
                    const hasNumber = /\d/.test(password);
                    const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
                    return minLength && hasUpper && hasLower && hasNumber && hasSpecial;
                });
                expect(mockValidatePassword("weak")).toBe(false);
                expect(mockValidatePassword("password")).toBe(false);
                expect(mockValidatePassword("Password")).toBe(false);
                expect(mockValidatePassword("Password123")).toBe(false);
                expect(mockValidatePassword("")).toBe(false);
            });
        });
        describe("validatePhoneNumber", ()=>{
            it("should validate US phone numbers", ()=>{
                const mockValidatePhoneNumber = jest.fn((phone, country = "US")=>{
                    const cleaned = phone.replace(/\D/g, "");
                    if (country === "US") {
                        return cleaned.length === 10 || cleaned.length === 11 && cleaned.startsWith("1");
                    }
                    return cleaned.length >= 10;
                });
                expect(mockValidatePhoneNumber("(123) 456-7890")).toBe(true);
                expect(mockValidatePhoneNumber("123-456-7890")).toBe(true);
                expect(mockValidatePhoneNumber("1234567890")).toBe(true);
                expect(mockValidatePhoneNumber("11234567890")).toBe(true);
            });
            it("should reject invalid phone numbers", ()=>{
                const mockValidatePhoneNumber = jest.fn((phone)=>{
                    const cleaned = phone.replace(/\D/g, "");
                    return cleaned.length === 10 || cleaned.length === 11 && cleaned.startsWith("1");
                });
                expect(mockValidatePhoneNumber("123")).toBe(false);
                expect(mockValidatePhoneNumber("123-456")).toBe(false);
                expect(mockValidatePhoneNumber("")).toBe(false);
                expect(mockValidatePhoneNumber("abc-def-ghij")).toBe(false);
            });
        });
        describe("validateRequired", ()=>{
            it("should validate required fields", ()=>{
                const mockValidateRequired = jest.fn((value)=>{
                    if (typeof value === "string") {
                        return value.trim().length > 0;
                    }
                    return value !== null && value !== undefined;
                });
                expect(mockValidateRequired("test")).toBe(true);
                expect(mockValidateRequired("  test  ")).toBe(true);
                expect(mockValidateRequired(123)).toBe(true);
                expect(mockValidateRequired(0)).toBe(true);
                expect(mockValidateRequired(false)).toBe(true);
            });
            it("should reject empty or null values", ()=>{
                const mockValidateRequired = jest.fn((value)=>{
                    if (typeof value === "string") {
                        return value.trim().length > 0;
                    }
                    return value !== null && value !== undefined;
                });
                expect(mockValidateRequired("")).toBe(false);
                expect(mockValidateRequired("   ")).toBe(false);
                expect(mockValidateRequired(null)).toBe(false);
                expect(mockValidateRequired(undefined)).toBe(false);
            });
        });
    });
    describe("Utility Helper Functions", ()=>{
        describe("generateId", ()=>{
            it("should generate unique IDs", ()=>{
                const mockGenerateId = jest.fn((prefix = "", length = 8)=>{
                    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    let result = prefix;
                    for(let i = 0; i < length; i++){
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return result;
                });
                const id1 = mockGenerateId();
                const id2 = mockGenerateId();
                expect(id1).toHaveLength(8);
                expect(id2).toHaveLength(8);
                expect(id1).not.toBe(id2);
            });
            it("should generate IDs with custom prefix and length", ()=>{
                const mockGenerateId = jest.fn((prefix = "", length = 8)=>{
                    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    let result = prefix;
                    for(let i = 0; i < length; i++){
                        result += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return result;
                });
                const id = mockGenerateId("USER_", 12);
                expect(id).toHaveLength(17); // 5 (prefix) + 12 (generated)
                expect(id).toStartWith("USER_");
            });
        });
        describe("slugify", ()=>{
            it("should create URL-friendly slugs", ()=>{
                const mockSlugify = jest.fn((text)=>{
                    return text.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
                });
                expect(mockSlugify("Hello World")).toBe("hello-world");
                expect(mockSlugify("Product Name & Description")).toBe("product-name-description");
                expect(mockSlugify("  Multiple   Spaces  ")).toBe("multiple-spaces");
                expect(mockSlugify("Special!@#$%Characters")).toBe("specialcharacters");
            });
            it("should handle edge cases", ()=>{
                const mockSlugify = jest.fn((text)=>{
                    return text.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
                });
                expect(mockSlugify("")).toBe("");
                expect(mockSlugify("   ")).toBe("");
                expect(mockSlugify("!@#$%^&*()")).toBe("");
                expect(mockSlugify("123-456-789")).toBe("123-456-789");
            });
        });
        describe("truncateText", ()=>{
            it("should truncate long text", ()=>{
                const mockTruncateText = jest.fn((text, maxLength, suffix = "...")=>{
                    if (text.length <= maxLength) return text;
                    return text.slice(0, maxLength - suffix.length) + suffix;
                });
                const longText = "This is a very long text that should be truncated";
                expect(mockTruncateText(longText, 20)).toBe("This is a very lo...");
                expect(mockTruncateText(longText, 10)).toBe("This is...");
                expect(mockTruncateText("Short", 20)).toBe("Short");
            });
            it("should handle custom suffix", ()=>{
                const mockTruncateText = jest.fn((text, maxLength, suffix = "...")=>{
                    if (text.length <= maxLength) return text;
                    const truncateLength = Math.max(0, maxLength - suffix.length);
                    return text.slice(0, truncateLength) + suffix;
                });
                const text = "This is a long text";
                expect(mockTruncateText(text, 15, " [more]")).toBe("This is [more]");
                expect(mockTruncateText(text, 10, "")).toBe("This is a");
            });
        });
        describe("debounce", ()=>{
            it("should debounce function calls", async ()=>{
                let callCount = 0;
                const mockFunction = jest.fn(()=>callCount++);
                const mockDebounce = jest.fn((func, delay)=>{
                    let timeoutId;
                    return (...args)=>{
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(()=>func.apply(null, args), delay);
                    };
                });
                const debouncedFunction = mockDebounce(mockFunction, 100);
                // Call multiple times quickly
                debouncedFunction();
                debouncedFunction();
                debouncedFunction();
                // Should not have been called yet
                expect(mockFunction).not.toHaveBeenCalled();
                // Wait for debounce delay
                await new Promise((resolve)=>setTimeout(resolve, 150));
                // Should have been called only once
                expect(mockFunction).toHaveBeenCalledTimes(1);
            });
        });
        describe("throttle", ()=>{
            it("should throttle function calls", async ()=>{
                let callCount = 0;
                const mockFunction = jest.fn(()=>callCount++);
                const mockThrottle = jest.fn((func, delay)=>{
                    let lastCall = 0;
                    return (...args)=>{
                        const now = Date.now();
                        if (now - lastCall >= delay) {
                            lastCall = now;
                            return func.apply(null, args);
                        }
                    };
                });
                const throttledFunction = mockThrottle(mockFunction, 100);
                // Call multiple times quickly
                throttledFunction();
                throttledFunction();
                throttledFunction();
                // Should have been called only once immediately
                expect(mockFunction).toHaveBeenCalledTimes(1);
                // Wait for throttle delay
                await new Promise((resolve)=>setTimeout(resolve, 150));
                // Call again
                throttledFunction();
                // Should have been called twice total
                expect(mockFunction).toHaveBeenCalledTimes(2);
            });
        });
    });
    describe("Calculation Functions", ()=>{
        describe("calculateTax", ()=>{
            it("should calculate tax correctly", ()=>{
                const mockCalculateTax = jest.fn((amount, taxRate)=>{
                    return Math.round(amount * taxRate * 100) / 100;
                });
                expect(mockCalculateTax(100, 0.08)).toBe(8);
                expect(mockCalculateTax(250.50, 0.075)).toBe(18.79);
                expect(mockCalculateTax(0, 0.08)).toBe(0);
            });
            it("should handle edge cases", ()=>{
                const mockCalculateTax = jest.fn((amount, taxRate)=>{
                    if (amount < 0 || taxRate < 0) return 0;
                    return Math.round(amount * taxRate * 100) / 100;
                });
                expect(mockCalculateTax(-100, 0.08)).toBe(0);
                expect(mockCalculateTax(100, -0.08)).toBe(0);
                expect(mockCalculateTax(100, 0)).toBe(0);
            });
        });
        describe("calculateDiscount", ()=>{
            it("should calculate percentage discount", ()=>{
                const mockCalculateDiscount = jest.fn((amount, discount, isPercentage = true)=>{
                    if (isPercentage) {
                        return Math.round(amount * (discount / 100) * 100) / 100;
                    }
                    return Math.min(discount, amount);
                });
                expect(mockCalculateDiscount(100, 10, true)).toBe(10);
                expect(mockCalculateDiscount(250, 15, true)).toBe(37.5);
                expect(mockCalculateDiscount(50, 20, true)).toBe(10);
            });
            it("should calculate fixed discount", ()=>{
                const mockCalculateDiscount = jest.fn((amount, discount, isPercentage = true)=>{
                    if (isPercentage) {
                        return Math.round(amount * (discount / 100) * 100) / 100;
                    }
                    return Math.min(discount, amount);
                });
                expect(mockCalculateDiscount(100, 15, false)).toBe(15);
                expect(mockCalculateDiscount(50, 75, false)).toBe(50); // Can't discount more than amount
                expect(mockCalculateDiscount(200, 25, false)).toBe(25);
            });
        });
        describe("calculateTotal", ()=>{
            it("should calculate total with tax and discount", ()=>{
                const mockCalculateTotal = jest.fn((subtotal, tax, discount)=>{
                    const afterDiscount = subtotal - discount;
                    return Math.round((afterDiscount + tax) * 100) / 100;
                });
                expect(mockCalculateTotal(100, 8, 10)).toBe(98); // 100 - 10 + 8
                expect(mockCalculateTotal(250, 20, 25)).toBe(245); // 250 - 25 + 20
                expect(mockCalculateTotal(50, 0, 0)).toBe(50);
            });
            it("should handle negative results", ()=>{
                const mockCalculateTotal = jest.fn((subtotal, tax, discount)=>{
                    const afterDiscount = subtotal - discount;
                    const total = afterDiscount + tax;
                    return Math.max(0, Math.round(total * 100) / 100);
                });
                expect(mockCalculateTotal(10, 1, 15)).toBe(0); // Can't go negative
                expect(mockCalculateTotal(0, 0, 5)).toBe(0);
            });
        });
    });
    describe("Sanitization Functions", ()=>{
        describe("sanitizeInput", ()=>{
            it("should sanitize user input", ()=>{
                const mockSanitizeInput = jest.fn((input)=>{
                    return input.replace(/<script[^>]*>.*?<\/script>/gi, "").replace(/<[^>]*>/g, "").trim();
                });
                expect(mockSanitizeInput('Hello <script>alert("xss")</script> World')).toBe("Hello  World");
                expect(mockSanitizeInput("<b>Bold</b> text")).toBe("Bold text");
                expect(mockSanitizeInput("  Normal text  ")).toBe("Normal text");
            });
            it("should handle malicious input", ()=>{
                const mockSanitizeInput = jest.fn((input)=>{
                    return input.replace(/<script[^>]*>.*?<\/script>/gi, "").replace(/javascript:/gi, "").replace(/on\w+\s*=/gi, "").replace(/<[^>]*>/g, "").trim();
                });
                expect(mockSanitizeInput('<img src="x" onerror="alert(1)">')).toBe("");
                expect(mockSanitizeInput('javascript:alert("xss")')).toBe('alert("xss")');
                expect(mockSanitizeInput('<a href="javascript:void(0)">Link</a>')).toBe("Link");
            });
        });
        describe("escapeHtml", ()=>{
            it("should escape HTML entities", ()=>{
                const mockEscapeHtml = jest.fn((text)=>{
                    const entityMap = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    return text.replace(/[&<>"']/g, (char)=>entityMap[char]);
                });
                expect(mockEscapeHtml('<div>Hello & "World"</div>')).toBe("&lt;div&gt;Hello &amp; &quot;World&quot;&lt;/div&gt;");
                expect(mockEscapeHtml("It's a 'test'")).toBe("It&#39;s a &#39;test&#39;");
                expect(mockEscapeHtml("Normal text")).toBe("Normal text");
            });
        });
        describe("parseQueryParams", ()=>{
            it("should parse URL query parameters", ()=>{
                const mockParseQueryParams = jest.fn((queryString)=>{
                    const params = {};
                    const urlParams = new URLSearchParams(queryString);
                    for (const [key, value] of urlParams){
                        params[key] = value;
                    }
                    return params;
                });
                expect(mockParseQueryParams("?name=John&age=30&city=NYC")).toEqual({
                    name: "John",
                    age: "30",
                    city: "NYC"
                });
                expect(mockParseQueryParams("search=test&page=1&limit=10")).toEqual({
                    search: "test",
                    page: "1",
                    limit: "10"
                });
            });
            it("should handle empty or malformed query strings", ()=>{
                const mockParseQueryParams = jest.fn((queryString)=>{
                    const params = {};
                    // Handle empty strings
                    if (!queryString || queryString === "?") {
                        return params;
                    }
                    // Handle malformed query strings (no = sign)
                    if (!queryString.includes("=") && !queryString.startsWith("?")) {
                        return params;
                    }
                    try {
                        const urlParams = new URLSearchParams(queryString);
                        for (const [key, value] of urlParams){
                            params[key] = value;
                        }
                    } catch (error) {
                    // Return empty object for malformed queries
                    }
                    return params;
                });
                expect(mockParseQueryParams("")).toEqual({});
                expect(mockParseQueryParams("?")).toEqual({});
                expect(mockParseQueryParams("invalid")).toEqual({});
            });
            it("should handle URL encoding", ()=>{
                const mockParseQueryParams = jest.fn((queryString)=>{
                    const params = {};
                    const urlParams = new URLSearchParams(queryString);
                    for (const [key, value] of urlParams){
                        params[key] = decodeURIComponent(value);
                    }
                    return params;
                });
                expect(mockParseQueryParams("search=hello%20world&special=%21%40%23")).toEqual({
                    search: "hello world",
                    special: "!@#"
                });
            });
        });
    });
    describe("Error Handling in Utilities", ()=>{
        it("should handle errors in formatting functions", ()=>{
            const mockFormatCurrencyWithError = jest.fn((amount)=>{
                try {
                    if (typeof amount !== "number") {
                        throw new Error("Invalid amount type");
                    }
                    return `$${amount.toFixed(2)}`;
                } catch (error) {
                    consoleSpy.error("Currency formatting error:", error);
                    return "$0.00";
                }
            });
            expect(mockFormatCurrencyWithError("invalid")).toBe("$0.00");
            expect(consoleSpy.error).toHaveBeenCalledWith("Currency formatting error:", expect.any(Error));
        });
        it("should handle errors in validation functions", ()=>{
            const mockValidateEmailWithError = jest.fn((email)=>{
                try {
                    if (typeof email !== "string") {
                        throw new Error("Email must be a string");
                    }
                    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
                } catch (error) {
                    consoleSpy.error("Email validation error:", error);
                    return false;
                }
            });
            expect(mockValidateEmailWithError(null)).toBe(false);
            expect(mockValidateEmailWithError(123)).toBe(false);
            expect(consoleSpy.error).toHaveBeenCalledWith("Email validation error:", expect.any(Error));
        });
        it("should handle errors in utility functions", ()=>{
            const mockSlugifyWithError = jest.fn((text)=>{
                try {
                    if (typeof text !== "string") {
                        throw new Error("Text must be a string");
                    }
                    return text.toLowerCase().replace(/[^a-z0-9]/g, "-");
                } catch (error) {
                    consoleSpy.error("Slugify error:", error);
                    return "";
                }
            });
            expect(mockSlugifyWithError(null)).toBe("");
            expect(mockSlugifyWithError({})).toBe("");
            expect(consoleSpy.error).toHaveBeenCalledWith("Slugify error:", expect.any(Error));
        });
    });
    describe("Performance Tests for Utilities", ()=>{
        it("should handle large datasets efficiently", ()=>{
            const mockBatchProcess = jest.fn((items, batchSize = 100)=>{
                const results = [];
                for(let i = 0; i < items.length; i += batchSize){
                    const batch = items.slice(i, i + batchSize);
                    results.push(...batch.map((item)=>item.id));
                }
                return results;
            });
            const largeDataset = Array.from({
                length: 10000
            }, (_, i)=>({
                    id: i,
                    name: `Item ${i}`
                }));
            const startTime = Date.now();
            const result = mockBatchProcess(largeDataset);
            const endTime = Date.now();
            expect(result).toHaveLength(10000);
            expect(endTime - startTime).toBeLessThan(100); // Should process quickly
        });
        it("should handle concurrent utility operations", async ()=>{
            const mockAsyncUtility = jest.fn(async (data)=>{
                await new Promise((resolve)=>setTimeout(resolve, 10));
                return data.toUpperCase();
            });
            const operations = Array.from({
                length: 100
            }, (_, i)=>mockAsyncUtility(`test-${i}`));
            const startTime = Date.now();
            const results = await Promise.all(operations);
            const endTime = Date.now();
            expect(results).toHaveLength(100);
            expect(results[0]).toBe("TEST-0");
            expect(endTime - startTime).toBeLessThan(500); // Should handle concurrency well
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vRG9jdW1lbnRzL21kLXNwb3J0cy0vdGVzdHMvdW5pdC91dGlsaXR5RnVuY3Rpb25zLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0Q3VycmVuY3ksIGZvcm1hdERhdGUsIGZvcm1hdFBob25lTnVtYmVyIH0gZnJvbSAnQC9saWIvZm9ybWF0dGVycyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUVtYWlsLCB2YWxpZGF0ZVBhc3N3b3JkLCB2YWxpZGF0ZVBob25lTnVtYmVyLCB2YWxpZGF0ZVJlcXVpcmVkIH0gZnJvbSAnQC9saWIvdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkLCBzbHVnaWZ5LCB0cnVuY2F0ZVRleHQsIGRlYm91bmNlLCB0aHJvdHRsZSB9IGZyb20gJ0AvbGliL3V0aWxzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVRheCwgY2FsY3VsYXRlRGlzY291bnQsIGNhbGN1bGF0ZVRvdGFsIH0gZnJvbSAnQC9saWIvY2FsY3VsYXRpb25zJztcbmltcG9ydCB7IHNhbml0aXplSW5wdXQsIGVzY2FwZUh0bWwsIHBhcnNlUXVlcnlQYXJhbXMgfSBmcm9tICdAL2xpYi9zYW5pdGl6ZXJzJztcblxuLy8gTW9jayBjb25zb2xlIG1ldGhvZHNcbmNvbnN0IGNvbnNvbGVTcHkgPSB7XG4gIGxvZzogamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbiAgZXJyb3I6IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KSxcbiAgd2FybjogamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSksXG59O1xuXG5kZXNjcmliZSgnVXRpbGl0eSBGdW5jdGlvbnMgVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnNvbGVTcHkubG9nLm1vY2tDbGVhcigpO1xuICAgIGNvbnNvbGVTcHkuZXJyb3IubW9ja0NsZWFyKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgY29uc29sZVNweS5sb2cubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlU3B5LmVycm9yLm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVNweS53YXJuLm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGb3JtYXR0aW5nIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICBkZXNjcmliZSgnZm9ybWF0Q3VycmVuY3knLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBjdXJyZW5jeSB3aXRoIGRlZmF1bHQgc2V0dGluZ3MnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRDdXJyZW5jeSA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCBjdXJyZW5jeSA9ICdVU0QnLCBsb2NhbGUgPSAnZW4tVVMnKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcbiAgICAgICAgICAgIHN0eWxlOiAnY3VycmVuY3knLFxuICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5LFxuICAgICAgICAgIH0pLmZvcm1hdChhbW91bnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KDEyMzQuNTYpKS50b0JlKCckMSwyMzQuNTYnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeSgwKSkudG9CZSgnJDAuMDAnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeSgtNTAwLjI1KSkudG9CZSgnLSQ1MDAuMjUnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBjdXJyZW5jeSB3aXRoIGRpZmZlcmVudCBjdXJyZW5jaWVzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrRm9ybWF0Q3VycmVuY3kgPSBqZXN0LmZuKChhbW91bnQ6IG51bWJlciwgY3VycmVuY3kgPSAnVVNEJywgbG9jYWxlID0gJ2VuLVVTJykgPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCB7XG4gICAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5JyxcbiAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICAgICAgICB9KS5mb3JtYXQoYW1vdW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeSgxMDAwLCAnRVVSJywgJ2RlLURFJykpLnRvQmUoJzEuMDAwLDAwIOKCrCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KDEwMDAsICdHQlAnLCAnZW4tR0InKSkudG9CZSgnwqMxLDAwMC4wMCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5KDEwMDAsICdKUFknLCAnamEtSlAnKSkudG9CZSgnwqUxLDAwMCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRDdXJyZW5jeSA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCBjdXJyZW5jeSA9ICdVU0QnLCBsb2NhbGUgPSAnZW4tVVMnKSA9PiB7XG4gICAgICAgICAgaWYgKGlzTmFOKGFtb3VudCkgfHwgIWlzRmluaXRlKGFtb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJDAuMDAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwge1xuICAgICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXG4gICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3ksXG4gICAgICAgICAgfSkuZm9ybWF0KGFtb3VudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0Q3VycmVuY3koTmFOKSkudG9CZSgnJDAuMDAnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRDdXJyZW5jeShJbmZpbml0eSkpLnRvQmUoJyQwLjAwJyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0Q3VycmVuY3koLUluZmluaXR5KSkudG9CZSgnJDAuMDAnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2Zvcm1hdERhdGUnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBkYXRlcyB3aXRoIGRlZmF1bHQgc2V0dGluZ3MnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXREYXRlID0gamVzdC5mbigoZGF0ZTogRGF0ZSB8IHN0cmluZywgZm9ybWF0ID0gJ01NL2RkL3l5eXknKSA9PiB7XG4gICAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgIGlmIChpc05hTihkLmdldFRpbWUoKSkpIHJldHVybiAnSW52YWxpZCBEYXRlJztcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBtb250aCA9IFN0cmluZyhkLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICAgIGNvbnN0IGRheSA9IFN0cmluZyhkLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgICBjb25zdCB5ZWFyID0gZC5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBgJHttb250aH0vJHtkYXl9LyR7eWVhcn1gO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0ZXN0RGF0ZSA9IG5ldyBEYXRlKCcyMDI0LTAxLTE1Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0RGF0ZSh0ZXN0RGF0ZSkpLnRvQmUoJzAxLzE1LzIwMjQnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXREYXRlKCcyMDI0LTEyLTI1JykpLnRvQmUoJzEyLzI1LzIwMjQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGZvcm1hdCBkYXRlcyB3aXRoIGRpZmZlcmVudCBmb3JtYXRzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrRm9ybWF0RGF0ZSA9IGplc3QuZm4oKGRhdGU6IERhdGUgfCBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgIGlmIChpc05hTihkLmdldFRpbWUoKSkpIHJldHVybiAnSW52YWxpZCBEYXRlJztcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBmb3JtYXRNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICAgICAneXl5eS1NTS1kZCc6IGAke2QuZ2V0RnVsbFllYXIoKX0tJHtTdHJpbmcoZC5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKX0tJHtTdHJpbmcoZC5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyl9YCxcbiAgICAgICAgICAgICdkZC9NTS95eXl5JzogYCR7U3RyaW5nKGQuZ2V0RGF0ZSgpKS5wYWRTdGFydCgyLCAnMCcpfS8ke1N0cmluZyhkLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpfS8ke2QuZ2V0RnVsbFllYXIoKX1gLFxuICAgICAgICAgICAgJ01NTSBkZCwgeXl5eSc6IGQudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycgfSksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gZm9ybWF0TWFwW2Zvcm1hdF0gfHwgZm9ybWF0TWFwWydNTS9kZC95eXl5J107XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRlc3REYXRlID0gbmV3IERhdGUoJzIwMjQtMDEtMTUnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXREYXRlKHRlc3REYXRlLCAneXl5eS1NTS1kZCcpKS50b0JlKCcyMDI0LTAxLTE1Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0RGF0ZSh0ZXN0RGF0ZSwgJ2RkL01NL3l5eXknKSkudG9CZSgnMTUvMDEvMjAyNCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdERhdGUodGVzdERhdGUsICdNTU0gZGQsIHl5eXknKSkudG9CZSgnSmFuIDE1LCAyMDI0Jyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW52YWxpZCBkYXRlcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0Zvcm1hdERhdGUgPSBqZXN0LmZuKChkYXRlOiBEYXRlIHwgc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgIHJldHVybiBpc05hTihkLmdldFRpbWUoKSkgPyAnSW52YWxpZCBEYXRlJyA6IGQudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0RGF0ZSgnaW52YWxpZC1kYXRlJykpLnRvQmUoJ0ludmFsaWQgRGF0ZScpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdERhdGUoJycpKS50b0JlKCdJbnZhbGlkIERhdGUnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2Zvcm1hdFBob25lTnVtYmVyJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBmb3JtYXQgVVMgcGhvbmUgbnVtYmVycycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0Zvcm1hdFBob25lTnVtYmVyID0gamVzdC5mbigocGhvbmU6IHN0cmluZywgY291bnRyeSA9ICdVUycpID0+IHtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gcGhvbmUucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICAgICAgICBpZiAoY291bnRyeSA9PT0gJ1VTJyAmJiBjbGVhbmVkLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgICAgIHJldHVybiBgKCR7Y2xlYW5lZC5zbGljZSgwLCAzKX0pICR7Y2xlYW5lZC5zbGljZSgzLCA2KX0tJHtjbGVhbmVkLnNsaWNlKDYpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwaG9uZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRQaG9uZU51bWJlcignMTIzNDU2Nzg5MCcpKS50b0JlKCcoMTIzKSA0NTYtNzg5MCcpO1xuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdFBob25lTnVtYmVyKCcxMjMtNDU2LTc4OTAnKSkudG9CZSgnKDEyMykgNDU2LTc4OTAnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRQaG9uZU51bWJlcignKDEyMykgNDU2LTc4OTAnKSkudG9CZSgnKDEyMykgNDU2LTc4OTAnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnRlcm5hdGlvbmFsIHBob25lIG51bWJlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRQaG9uZU51bWJlciA9IGplc3QuZm4oKHBob25lOiBzdHJpbmcsIGNvdW50cnk6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGNsZWFuZWQgPSBwaG9uZS5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgICAgICAgIGlmIChjb3VudHJ5ID09PSAnVUsnICYmIGNsZWFuZWQubGVuZ3RoID09PSAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGArNDQgJHtjbGVhbmVkLnNsaWNlKDEsIDUpfSAke2NsZWFuZWQuc2xpY2UoNSwgOCl9ICR7Y2xlYW5lZC5zbGljZSg4KX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGhvbmU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0UGhvbmVOdW1iZXIoJzAxMjM0NTY3ODkwJywgJ1VLJykpLnRvQmUoJys0NCAxMjM0IDU2NyA4OTAnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHBob25lIG51bWJlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tGb3JtYXRQaG9uZU51bWJlciA9IGplc3QuZm4oKHBob25lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gcGhvbmUucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICAgICAgICByZXR1cm4gY2xlYW5lZC5sZW5ndGggPCAxMCA/IHBob25lIDogYCgke2NsZWFuZWQuc2xpY2UoMCwgMyl9KSAke2NsZWFuZWQuc2xpY2UoMywgNil9LSR7Y2xlYW5lZC5zbGljZSg2KX1gO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0Zvcm1hdFBob25lTnVtYmVyKCcxMjMnKSkudG9CZSgnMTIzJyk7XG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0UGhvbmVOdW1iZXIoJycpKS50b0JlKCcnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tGb3JtYXRQaG9uZU51bWJlcignYWJjJykpLnRvQmUoJ2FiYycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdWYWxpZGF0aW9uIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgICBkZXNjcmliZSgndmFsaWRhdGVFbWFpbCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgY29ycmVjdCBlbWFpbCBhZGRyZXNzZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZUVtYWlsID0gamVzdC5mbigoZW1haWw6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskLztcbiAgICAgICAgICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsKCd0ZXN0QGV4YW1wbGUuY29tJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbCgndXNlci5uYW1lQGRvbWFpbi5jby51aycpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlRW1haWwoJ3VzZXIrdGFnQGV4YW1wbGUub3JnJykpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBlbWFpbCBhZGRyZXNzZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZUVtYWlsID0gamVzdC5mbigoZW1haWw6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskLztcbiAgICAgICAgICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsKCdpbnZhbGlkLWVtYWlsJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlRW1haWwoJ3Rlc3RAJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlRW1haWwoJ0BleGFtcGxlLmNvbScpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsKCd0ZXN0QC5jb20nKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbCgnJykpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndmFsaWRhdGVQYXNzd29yZCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgc3Ryb25nIHBhc3N3b3JkcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlUGFzc3dvcmQgPSBqZXN0LmZuKChwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWluTGVuZ3RoID0gcGFzc3dvcmQubGVuZ3RoID49IDg7XG4gICAgICAgICAgY29uc3QgaGFzVXBwZXIgPSAvW0EtWl0vLnRlc3QocGFzc3dvcmQpO1xuICAgICAgICAgIGNvbnN0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNOdW1iZXIgPSAvXFxkLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNTcGVjaWFsID0gL1shQCMkJV4mKigpLC4/XCI6e318PD5dLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gbWluTGVuZ3RoICYmIGhhc1VwcGVyICYmIGhhc0xvd2VyICYmIGhhc051bWJlciAmJiBoYXNTcGVjaWFsO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ1Bhc3N3b3JkMTIzIScpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ015U2VjdXJlQFBhc3MxJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgnQ29tcGxleCNQYXNzd29yZDknKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCB3ZWFrIHBhc3N3b3JkcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlUGFzc3dvcmQgPSBqZXN0LmZuKChwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWluTGVuZ3RoID0gcGFzc3dvcmQubGVuZ3RoID49IDg7XG4gICAgICAgICAgY29uc3QgaGFzVXBwZXIgPSAvW0EtWl0vLnRlc3QocGFzc3dvcmQpO1xuICAgICAgICAgIGNvbnN0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNOdW1iZXIgPSAvXFxkLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBjb25zdCBoYXNTcGVjaWFsID0gL1shQCMkJV4mKigpLC4/XCI6e318PD5dLy50ZXN0KHBhc3N3b3JkKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gbWluTGVuZ3RoICYmIGhhc1VwcGVyICYmIGhhc0xvd2VyICYmIGhhc051bWJlciAmJiBoYXNTcGVjaWFsO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGFzc3dvcmQoJ3dlYWsnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgncGFzc3dvcmQnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgnUGFzc3dvcmQnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgnUGFzc3dvcmQxMjMnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQYXNzd29yZCgnJykpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndmFsaWRhdGVQaG9uZU51bWJlcicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgVVMgcGhvbmUgbnVtYmVycycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIgPSBqZXN0LmZuKChwaG9uZTogc3RyaW5nLCBjb3VudHJ5ID0gJ1VTJykgPT4ge1xuICAgICAgICAgIGNvbnN0IGNsZWFuZWQgPSBwaG9uZS5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgICAgICAgIGlmIChjb3VudHJ5ID09PSAnVVMnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xlYW5lZC5sZW5ndGggPT09IDEwIHx8IChjbGVhbmVkLmxlbmd0aCA9PT0gMTEgJiYgY2xlYW5lZC5zdGFydHNXaXRoKCcxJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2xlYW5lZC5sZW5ndGggPj0gMTA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignKDEyMykgNDU2LTc4OTAnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVBob25lTnVtYmVyKCcxMjMtNDU2LTc4OTAnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVBob25lTnVtYmVyKCcxMjM0NTY3ODkwJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignMTEyMzQ1Njc4OTAnKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIHBob25lIG51bWJlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZVBob25lTnVtYmVyID0gamVzdC5mbigocGhvbmU6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGNsZWFuZWQgPSBwaG9uZS5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgICAgICAgIHJldHVybiBjbGVhbmVkLmxlbmd0aCA9PT0gMTAgfHwgKGNsZWFuZWQubGVuZ3RoID09PSAxMSAmJiBjbGVhbmVkLnN0YXJ0c1dpdGgoJzEnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignMTIzJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIoJzEyMy00NTYnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVQaG9uZU51bWJlcignJykpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUGhvbmVOdW1iZXIoJ2FiYy1kZWYtZ2hpaicpKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3ZhbGlkYXRlUmVxdWlyZWQnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlUmVxdWlyZWQgPSBqZXN0LmZuKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmltKCkubGVuZ3RoID4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZCgndGVzdCcpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQoJyAgdGVzdCAgJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZCgxMjMpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQoMCkpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZChmYWxzZSkpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgZW1wdHkgb3IgbnVsbCB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tWYWxpZGF0ZVJlcXVpcmVkID0gamVzdC5mbigodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1ZhbGlkYXRlUmVxdWlyZWQoJycpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZVJlcXVpcmVkKCcgICAnKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZChudWxsKSkudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVSZXF1aXJlZCh1bmRlZmluZWQpKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVXRpbGl0eSBIZWxwZXIgRnVuY3Rpb25zJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCdnZW5lcmF0ZUlkJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSB1bmlxdWUgSURzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrR2VuZXJhdGVJZCA9IGplc3QuZm4oKHByZWZpeCA9ICcnLCBsZW5ndGggPSA4KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBwcmVmaXg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgaWQxID0gbW9ja0dlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgaWQyID0gbW9ja0dlbmVyYXRlSWQoKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChpZDEpLnRvSGF2ZUxlbmd0aCg4KTtcbiAgICAgICAgZXhwZWN0KGlkMikudG9IYXZlTGVuZ3RoKDgpO1xuICAgICAgICBleHBlY3QoaWQxKS5ub3QudG9CZShpZDIpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgSURzIHdpdGggY3VzdG9tIHByZWZpeCBhbmQgbGVuZ3RoJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrR2VuZXJhdGVJZCA9IGplc3QuZm4oKHByZWZpeCA9ICcnLCBsZW5ndGggPSA4KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBwcmVmaXg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgaWQgPSBtb2NrR2VuZXJhdGVJZCgnVVNFUl8nLCAxMik7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoaWQpLnRvSGF2ZUxlbmd0aCgxNyk7IC8vIDUgKHByZWZpeCkgKyAxMiAoZ2VuZXJhdGVkKVxuICAgICAgICBleHBlY3QoaWQpLnRvU3RhcnRXaXRoKCdVU0VSXycpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc2x1Z2lmeScsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY3JlYXRlIFVSTC1mcmllbmRseSBzbHVncycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1NsdWdpZnkgPSBqZXN0LmZuKCh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxcd1xccy1dL2csICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHNfLV0rL2csICctJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eLSt8LSskL2csICcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5KCdIZWxsbyBXb3JsZCcpKS50b0JlKCdoZWxsby13b3JsZCcpO1xuICAgICAgICBleHBlY3QobW9ja1NsdWdpZnkoJ1Byb2R1Y3QgTmFtZSAmIERlc2NyaXB0aW9uJykpLnRvQmUoJ3Byb2R1Y3QtbmFtZS1kZXNjcmlwdGlvbicpO1xuICAgICAgICBleHBlY3QobW9ja1NsdWdpZnkoJyAgTXVsdGlwbGUgICBTcGFjZXMgICcpKS50b0JlKCdtdWx0aXBsZS1zcGFjZXMnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5KCdTcGVjaWFsIUAjJCVDaGFyYWN0ZXJzJykpLnRvQmUoJ3NwZWNpYWxjaGFyYWN0ZXJzJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZWRnZSBjYXNlcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1NsdWdpZnkgPSBqZXN0LmZuKCh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxcd1xccy1dL2csICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHNfLV0rL2csICctJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eLSt8LSskL2csICcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5KCcnKSkudG9CZSgnJyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeSgnICAgJykpLnRvQmUoJycpO1xuICAgICAgICBleHBlY3QobW9ja1NsdWdpZnkoJyFAIyQlXiYqKCknKSkudG9CZSgnJyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeSgnMTIzLTQ1Ni03ODknKSkudG9CZSgnMTIzLTQ1Ni03ODknKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3RydW5jYXRlVGV4dCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdHJ1bmNhdGUgbG9uZyB0ZXh0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVHJ1bmNhdGVUZXh0ID0gamVzdC5mbigodGV4dDogc3RyaW5nLCBtYXhMZW5ndGg6IG51bWJlciwgc3VmZml4ID0gJy4uLicpID0+IHtcbiAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoKSByZXR1cm4gdGV4dDtcbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZSgwLCBtYXhMZW5ndGggLSBzdWZmaXgubGVuZ3RoKSArIHN1ZmZpeDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbG9uZ1RleHQgPSAnVGhpcyBpcyBhIHZlcnkgbG9uZyB0ZXh0IHRoYXQgc2hvdWxkIGJlIHRydW5jYXRlZCc7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QobW9ja1RydW5jYXRlVGV4dChsb25nVGV4dCwgMjApKS50b0JlKCdUaGlzIGlzIGEgdmVyeSBsby4uLicpO1xuICAgICAgICBleHBlY3QobW9ja1RydW5jYXRlVGV4dChsb25nVGV4dCwgMTApKS50b0JlKCdUaGlzIGlzLi4uJyk7XG4gICAgICAgIGV4cGVjdChtb2NrVHJ1bmNhdGVUZXh0KCdTaG9ydCcsIDIwKSkudG9CZSgnU2hvcnQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBjdXN0b20gc3VmZml4JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVHJ1bmNhdGVUZXh0ID0gamVzdC5mbigodGV4dDogc3RyaW5nLCBtYXhMZW5ndGg6IG51bWJlciwgc3VmZml4ID0gJy4uLicpID0+IHtcbiAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoKSByZXR1cm4gdGV4dDtcbiAgICAgICAgICBjb25zdCB0cnVuY2F0ZUxlbmd0aCA9IE1hdGgubWF4KDAsIG1heExlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKDAsIHRydW5jYXRlTGVuZ3RoKSArIHN1ZmZpeDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdGV4dCA9ICdUaGlzIGlzIGEgbG9uZyB0ZXh0JztcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChtb2NrVHJ1bmNhdGVUZXh0KHRleHQsIDE1LCAnIFttb3JlXScpKS50b0JlKCdUaGlzIGlzIFttb3JlXScpO1xuICAgICAgICBleHBlY3QobW9ja1RydW5jYXRlVGV4dCh0ZXh0LCAxMCwgJycpKS50b0JlKCdUaGlzIGlzIGEnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2RlYm91bmNlJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBkZWJvdW5jZSBmdW5jdGlvbiBjYWxscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IG1vY2tGdW5jdGlvbiA9IGplc3QuZm4oKCkgPT4gY2FsbENvdW50KyspO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbW9ja0RlYm91bmNlID0gamVzdC5mbigoZnVuYzogRnVuY3Rpb24sIGRlbGF5OiBudW1iZXIpID0+IHtcbiAgICAgICAgICBsZXQgdGltZW91dElkOiBOb2RlSlMuVGltZW91dDtcbiAgICAgICAgICByZXR1cm4gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gZnVuYy5hcHBseShudWxsLCBhcmdzKSwgZGVsYXkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRlYm91bmNlZEZ1bmN0aW9uID0gbW9ja0RlYm91bmNlKG1vY2tGdW5jdGlvbiwgMTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGwgbXVsdGlwbGUgdGltZXMgcXVpY2tseVxuICAgICAgICBkZWJvdW5jZWRGdW5jdGlvbigpO1xuICAgICAgICBkZWJvdW5jZWRGdW5jdGlvbigpO1xuICAgICAgICBkZWJvdW5jZWRGdW5jdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXZlIGJlZW4gY2FsbGVkIHlldFxuICAgICAgICBleHBlY3QobW9ja0Z1bmN0aW9uKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBmb3IgZGVib3VuY2UgZGVsYXlcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDE1MCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgYmVlbiBjYWxsZWQgb25seSBvbmNlXG4gICAgICAgIGV4cGVjdChtb2NrRnVuY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3Rocm90dGxlJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB0aHJvdHRsZSBmdW5jdGlvbiBjYWxscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IG1vY2tGdW5jdGlvbiA9IGplc3QuZm4oKCkgPT4gY2FsbENvdW50KyspO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbW9ja1Rocm90dGxlID0gamVzdC5mbigoZnVuYzogRnVuY3Rpb24sIGRlbGF5OiBudW1iZXIpID0+IHtcbiAgICAgICAgICBsZXQgbGFzdENhbGwgPSAwO1xuICAgICAgICAgIHJldHVybiAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZiAobm93IC0gbGFzdENhbGwgPj0gZGVsYXkpIHtcbiAgICAgICAgICAgICAgbGFzdENhbGwgPSBub3c7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRocm90dGxlZEZ1bmN0aW9uID0gbW9ja1Rocm90dGxlKG1vY2tGdW5jdGlvbiwgMTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGwgbXVsdGlwbGUgdGltZXMgcXVpY2tseVxuICAgICAgICB0aHJvdHRsZWRGdW5jdGlvbigpO1xuICAgICAgICB0aHJvdHRsZWRGdW5jdGlvbigpO1xuICAgICAgICB0aHJvdHRsZWRGdW5jdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgYmVlbiBjYWxsZWQgb25seSBvbmNlIGltbWVkaWF0ZWx5XG4gICAgICAgIGV4cGVjdChtb2NrRnVuY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIHRocm90dGxlIGRlbGF5XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGwgYWdhaW5cbiAgICAgICAgdGhyb3R0bGVkRnVuY3Rpb24oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBoYXZlIGJlZW4gY2FsbGVkIHR3aWNlIHRvdGFsXG4gICAgICAgIGV4cGVjdChtb2NrRnVuY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FsY3VsYXRpb24gRnVuY3Rpb25zJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCdjYWxjdWxhdGVUYXgnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSB0YXggY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrQ2FsY3VsYXRlVGF4ID0gamVzdC5mbigoYW1vdW50OiBudW1iZXIsIHRheFJhdGU6IG51bWJlcikgPT4ge1xuICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbW91bnQgKiB0YXhSYXRlKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVGF4KDEwMCwgMC4wOCkpLnRvQmUoOCk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVGF4KDI1MC41MCwgMC4wNzUpKS50b0JlKDE4Ljc5KTtcbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUYXgoMCwgMC4wOCkpLnRvQmUoMCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZWRnZSBjYXNlcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0NhbGN1bGF0ZVRheCA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCB0YXhSYXRlOiBudW1iZXIpID0+IHtcbiAgICAgICAgICBpZiAoYW1vdW50IDwgMCB8fCB0YXhSYXRlIDwgMCkgcmV0dXJuIDA7XG4gICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGFtb3VudCAqIHRheFJhdGUpICogMTAwKSAvIDEwMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUYXgoLTEwMCwgMC4wOCkpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVGF4KDEwMCwgLTAuMDgpKS50b0JlKDApO1xuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRheCgxMDAsIDApKS50b0JlKDApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY2FsY3VsYXRlRGlzY291bnQnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSBwZXJjZW50YWdlIGRpc2NvdW50JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrQ2FsY3VsYXRlRGlzY291bnQgPSBqZXN0LmZuKChhbW91bnQ6IG51bWJlciwgZGlzY291bnQ6IG51bWJlciwgaXNQZXJjZW50YWdlID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgIGlmIChpc1BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbW91bnQgKiAoZGlzY291bnQgLyAxMDApKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbihkaXNjb3VudCwgYW1vdW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVEaXNjb3VudCgxMDAsIDEwLCB0cnVlKSkudG9CZSgxMCk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlRGlzY291bnQoMjUwLCAxNSwgdHJ1ZSkpLnRvQmUoMzcuNSk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlRGlzY291bnQoNTAsIDIwLCB0cnVlKSkudG9CZSgxMCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgZml4ZWQgZGlzY291bnQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tDYWxjdWxhdGVEaXNjb3VudCA9IGplc3QuZm4oKGFtb3VudDogbnVtYmVyLCBkaXNjb3VudDogbnVtYmVyLCBpc1BlcmNlbnRhZ2UgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgaWYgKGlzUGVyY2VudGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGFtb3VudCAqIChkaXNjb3VudCAvIDEwMCkpICogMTAwKSAvIDEwMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKGRpc2NvdW50LCBhbW91bnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZURpc2NvdW50KDEwMCwgMTUsIGZhbHNlKSkudG9CZSgxNSk7XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlRGlzY291bnQoNTAsIDc1LCBmYWxzZSkpLnRvQmUoNTApOyAvLyBDYW4ndCBkaXNjb3VudCBtb3JlIHRoYW4gYW1vdW50XG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlRGlzY291bnQoMjAwLCAyNSwgZmFsc2UpKS50b0JlKDI1KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NhbGN1bGF0ZVRvdGFsJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgdG90YWwgd2l0aCB0YXggYW5kIGRpc2NvdW50JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrQ2FsY3VsYXRlVG90YWwgPSBqZXN0LmZuKChzdWJ0b3RhbDogbnVtYmVyLCB0YXg6IG51bWJlciwgZGlzY291bnQ6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGFmdGVyRGlzY291bnQgPSBzdWJ0b3RhbCAtIGRpc2NvdW50O1xuICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhZnRlckRpc2NvdW50ICsgdGF4KSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrQ2FsY3VsYXRlVG90YWwoMTAwLCA4LCAxMCkpLnRvQmUoOTgpOyAvLyAxMDAgLSAxMCArIDhcbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUb3RhbCgyNTAsIDIwLCAyNSkpLnRvQmUoMjQ1KTsgLy8gMjUwIC0gMjUgKyAyMFxuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRvdGFsKDUwLCAwLCAwKSkudG9CZSg1MCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmVnYXRpdmUgcmVzdWx0cycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0NhbGN1bGF0ZVRvdGFsID0gamVzdC5mbigoc3VidG90YWw6IG51bWJlciwgdGF4OiBudW1iZXIsIGRpc2NvdW50OiBudW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBhZnRlckRpc2NvdW50ID0gc3VidG90YWwgLSBkaXNjb3VudDtcbiAgICAgICAgICBjb25zdCB0b3RhbCA9IGFmdGVyRGlzY291bnQgKyB0YXg7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgucm91bmQodG90YWwgKiAxMDApIC8gMTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tDYWxjdWxhdGVUb3RhbCgxMCwgMSwgMTUpKS50b0JlKDApOyAvLyBDYW4ndCBnbyBuZWdhdGl2ZVxuICAgICAgICBleHBlY3QobW9ja0NhbGN1bGF0ZVRvdGFsKDAsIDAsIDUpKS50b0JlKDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTYW5pdGl6YXRpb24gRnVuY3Rpb25zJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCdzYW5pdGl6ZUlucHV0JywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSB1c2VyIGlucHV0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrU2FuaXRpemVJbnB1dCA9IGplc3QuZm4oKGlucHV0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICByZXR1cm4gaW5wdXRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88c2NyaXB0W14+XSo+Lio/PFxcL3NjcmlwdD4vZ2ksICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzxbXj5dKj4vZywgJycpXG4gICAgICAgICAgICAudHJpbSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1Nhbml0aXplSW5wdXQoJ0hlbGxvIDxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD4gV29ybGQnKSkudG9CZSgnSGVsbG8gIFdvcmxkJyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2FuaXRpemVJbnB1dCgnPGI+Qm9sZDwvYj4gdGV4dCcpKS50b0JlKCdCb2xkIHRleHQnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tTYW5pdGl6ZUlucHV0KCcgIE5vcm1hbCB0ZXh0ICAnKSkudG9CZSgnTm9ybWFsIHRleHQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBtYWxpY2lvdXMgaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tTYW5pdGl6ZUlucHV0ID0gamVzdC5mbigoaW5wdXQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHJldHVybiBpbnB1dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzxzY3JpcHRbXj5dKj4uKj88XFwvc2NyaXB0Pi9naSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvamF2YXNjcmlwdDovZ2ksICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL29uXFx3K1xccyo9L2dpLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88W14+XSo+L2csICcnKVxuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tTYW5pdGl6ZUlucHV0KCc8aW1nIHNyYz1cInhcIiBvbmVycm9yPVwiYWxlcnQoMSlcIj4nKSkudG9CZSgnJyk7XG4gICAgICAgIGV4cGVjdChtb2NrU2FuaXRpemVJbnB1dCgnamF2YXNjcmlwdDphbGVydChcInhzc1wiKScpKS50b0JlKCdhbGVydChcInhzc1wiKScpO1xuICAgICAgICBleHBlY3QobW9ja1Nhbml0aXplSW5wdXQoJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIj5MaW5rPC9hPicpKS50b0JlKCdMaW5rJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdlc2NhcGVIdG1sJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBlc2NhcGUgSFRNTCBlbnRpdGllcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja0VzY2FwZUh0bWwgPSBqZXN0LmZuKCh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBlbnRpdHlNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICAgICAnJic6ICcmYW1wOycsXG4gICAgICAgICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICAgICAgICc+JzogJyZndDsnLFxuICAgICAgICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICAgICAgICBcIidcIjogJyYjMzk7JyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1smPD5cIiddL2csIChjaGFyKSA9PiBlbnRpdHlNYXBbY2hhcl0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja0VzY2FwZUh0bWwoJzxkaXY+SGVsbG8gJiBcIldvcmxkXCI8L2Rpdj4nKSkudG9CZSgnJmx0O2RpdiZndDtIZWxsbyAmYW1wOyAmcXVvdDtXb3JsZCZxdW90OyZsdDsvZGl2Jmd0OycpO1xuICAgICAgICBleHBlY3QobW9ja0VzY2FwZUh0bWwoXCJJdCdzIGEgJ3Rlc3QnXCIpKS50b0JlKCdJdCYjMzk7cyBhICYjMzk7dGVzdCYjMzk7Jyk7XG4gICAgICAgIGV4cGVjdChtb2NrRXNjYXBlSHRtbCgnTm9ybWFsIHRleHQnKSkudG9CZSgnTm9ybWFsIHRleHQnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3BhcnNlUXVlcnlQYXJhbXMnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHBhcnNlIFVSTCBxdWVyeSBwYXJhbWV0ZXJzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrUGFyc2VRdWVyeVBhcmFtcyA9IGplc3QuZm4oKHF1ZXJ5U3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5U3RyaW5nKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB1cmxQYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb2NrUGFyc2VRdWVyeVBhcmFtcygnP25hbWU9Sm9obiZhZ2U9MzAmY2l0eT1OWUMnKSkudG9FcXVhbCh7XG4gICAgICAgICAgbmFtZTogJ0pvaG4nLFxuICAgICAgICAgIGFnZTogJzMwJyxcbiAgICAgICAgICBjaXR5OiAnTllDJyxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QobW9ja1BhcnNlUXVlcnlQYXJhbXMoJ3NlYXJjaD10ZXN0JnBhZ2U9MSZsaW1pdD0xMCcpKS50b0VxdWFsKHtcbiAgICAgICAgICBzZWFyY2g6ICd0ZXN0JyxcbiAgICAgICAgICBwYWdlOiAnMScsXG4gICAgICAgICAgbGltaXQ6ICcxMCcsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IG9yIG1hbGZvcm1lZCBxdWVyeSBzdHJpbmdzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrUGFyc2VRdWVyeVBhcmFtcyA9IGplc3QuZm4oKHF1ZXJ5U3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBIYW5kbGUgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgIGlmICghcXVlcnlTdHJpbmcgfHwgcXVlcnlTdHJpbmcgPT09ICc/Jykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGFuZGxlIG1hbGZvcm1lZCBxdWVyeSBzdHJpbmdzIChubyA9IHNpZ24pXG4gICAgICAgICAgaWYgKCFxdWVyeVN0cmluZy5pbmNsdWRlcygnPScpICYmICFxdWVyeVN0cmluZy5zdGFydHNXaXRoKCc/JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5U3RyaW5nKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHVybFBhcmFtcykge1xuICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gZW1wdHkgb2JqZWN0IGZvciBtYWxmb3JtZWQgcXVlcmllc1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QobW9ja1BhcnNlUXVlcnlQYXJhbXMoJycpKS50b0VxdWFsKHt9KTtcbiAgICAgICAgZXhwZWN0KG1vY2tQYXJzZVF1ZXJ5UGFyYW1zKCc/JykpLnRvRXF1YWwoe30pO1xuICAgICAgICBleHBlY3QobW9ja1BhcnNlUXVlcnlQYXJhbXMoJ2ludmFsaWQnKSkudG9FcXVhbCh7fSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgVVJMIGVuY29kaW5nJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrUGFyc2VRdWVyeVBhcmFtcyA9IGplc3QuZm4oKHF1ZXJ5U3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5U3RyaW5nKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB1cmxQYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtc1trZXldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KG1vY2tQYXJzZVF1ZXJ5UGFyYW1zKCdzZWFyY2g9aGVsbG8lMjB3b3JsZCZzcGVjaWFsPSUyMSU0MCUyMycpKS50b0VxdWFsKHtcbiAgICAgICAgICBzZWFyY2g6ICdoZWxsbyB3b3JsZCcsXG4gICAgICAgICAgc3BlY2lhbDogJyFAIycsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZyBpbiBVdGlsaXRpZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGluIGZvcm1hdHRpbmcgZnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Zvcm1hdEN1cnJlbmN5V2l0aEVycm9yID0gamVzdC5mbigoYW1vdW50OiBhbnkpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFtb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhbW91bnQgdHlwZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYCQke2Ftb3VudC50b0ZpeGVkKDIpfWA7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZVNweS5lcnJvcignQ3VycmVuY3kgZm9ybWF0dGluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuICckMC4wMCc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0Zvcm1hdEN1cnJlbmN5V2l0aEVycm9yKCdpbnZhbGlkJykpLnRvQmUoJyQwLjAwJyk7XG4gICAgICBleHBlY3QoY29uc29sZVNweS5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdDdXJyZW5jeSBmb3JtYXR0aW5nIGVycm9yOicsXG4gICAgICAgIGV4cGVjdC5hbnkoRXJyb3IpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGluIHZhbGlkYXRpb24gZnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1ZhbGlkYXRlRW1haWxXaXRoRXJyb3IgPSBqZXN0LmZuKChlbWFpbDogYW55KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW1haWwgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC8udGVzdChlbWFpbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZVNweS5lcnJvcignRW1haWwgdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tWYWxpZGF0ZUVtYWlsV2l0aEVycm9yKG51bGwpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVFbWFpbFdpdGhFcnJvcigxMjMpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5LmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0VtYWlsIHZhbGlkYXRpb24gZXJyb3I6JyxcbiAgICAgICAgZXhwZWN0LmFueShFcnJvcilcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgaW4gdXRpbGl0eSBmdW5jdGlvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2x1Z2lmeVdpdGhFcnJvciA9IGplc3QuZm4oKHRleHQ6IGFueSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0ZXh0LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTldL2csICctJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZVNweS5lcnJvcignU2x1Z2lmeSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tTbHVnaWZ5V2l0aEVycm9yKG51bGwpKS50b0JlKCcnKTtcbiAgICAgIGV4cGVjdChtb2NrU2x1Z2lmeVdpdGhFcnJvcih7fSkpLnRvQmUoJycpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnU2x1Z2lmeSBlcnJvcjonLFxuICAgICAgICBleHBlY3QuYW55KEVycm9yKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFRlc3RzIGZvciBVdGlsaXRpZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgZGF0YXNldHMgZWZmaWNpZW50bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQmF0Y2hQcm9jZXNzID0gamVzdC5mbigoaXRlbXM6IGFueVtdLCBiYXRjaFNpemUgPSAxMDApID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICAgICAgICBjb25zdCBiYXRjaCA9IGl0ZW1zLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xuICAgICAgICAgIHJlc3VsdHMucHVzaCguLi5iYXRjaC5tYXAoaXRlbSA9PiBpdGVtLmlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbGFyZ2VEYXRhc2V0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwMDAgfSwgKF8sIGkpID0+ICh7IGlkOiBpLCBuYW1lOiBgSXRlbSAke2l9YCB9KSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBtb2NrQmF0Y2hQcm9jZXNzKGxhcmdlRGF0YXNldCk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDEwMDAwKTtcbiAgICAgIGV4cGVjdChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTsgLy8gU2hvdWxkIHByb2Nlc3MgcXVpY2tseVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCB1dGlsaXR5IG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQXN5bmNVdGlsaXR5ID0gamVzdC5mbihhc3luYyAoZGF0YTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMCkpO1xuICAgICAgICByZXR1cm4gZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGkpID0+IFxuICAgICAgICBtb2NrQXN5bmNVdGlsaXR5KGB0ZXN0LSR7aX1gKVxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChvcGVyYXRpb25zKTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKDEwMCk7XG4gICAgICBleHBlY3QocmVzdWx0c1swXSkudG9CZSgnVEVTVC0wJyk7XG4gICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDUwMCk7IC8vIFNob3VsZCBoYW5kbGUgY29uY3VycmVuY3kgd2VsbFxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJjb25zb2xlU3B5IiwibG9nIiwiamVzdCIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImVycm9yIiwid2FybiIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJhZnRlckFsbCIsIm1vY2tSZXN0b3JlIiwiaXQiLCJtb2NrRm9ybWF0Q3VycmVuY3kiLCJmbiIsImFtb3VudCIsImN1cnJlbmN5IiwibG9jYWxlIiwiSW50bCIsIk51bWJlckZvcm1hdCIsInN0eWxlIiwiZm9ybWF0IiwiZXhwZWN0IiwidG9CZSIsImlzTmFOIiwiaXNGaW5pdGUiLCJOYU4iLCJJbmZpbml0eSIsIm1vY2tGb3JtYXREYXRlIiwiZGF0ZSIsImQiLCJEYXRlIiwiZ2V0VGltZSIsIm1vbnRoIiwiU3RyaW5nIiwiZ2V0TW9udGgiLCJwYWRTdGFydCIsImRheSIsImdldERhdGUiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJ0ZXN0RGF0ZSIsImZvcm1hdE1hcCIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIm1vY2tGb3JtYXRQaG9uZU51bWJlciIsInBob25lIiwiY291bnRyeSIsImNsZWFuZWQiLCJyZXBsYWNlIiwibGVuZ3RoIiwic2xpY2UiLCJtb2NrVmFsaWRhdGVFbWFpbCIsImVtYWlsIiwiZW1haWxSZWdleCIsInRlc3QiLCJtb2NrVmFsaWRhdGVQYXNzd29yZCIsInBhc3N3b3JkIiwibWluTGVuZ3RoIiwiaGFzVXBwZXIiLCJoYXNMb3dlciIsImhhc051bWJlciIsImhhc1NwZWNpYWwiLCJtb2NrVmFsaWRhdGVQaG9uZU51bWJlciIsInN0YXJ0c1dpdGgiLCJtb2NrVmFsaWRhdGVSZXF1aXJlZCIsInZhbHVlIiwidHJpbSIsInVuZGVmaW5lZCIsIm1vY2tHZW5lcmF0ZUlkIiwicHJlZml4IiwiY2hhcnMiLCJyZXN1bHQiLCJpIiwiY2hhckF0IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiaWQxIiwiaWQyIiwidG9IYXZlTGVuZ3RoIiwibm90IiwiaWQiLCJ0b1N0YXJ0V2l0aCIsIm1vY2tTbHVnaWZ5IiwidGV4dCIsInRvTG93ZXJDYXNlIiwibW9ja1RydW5jYXRlVGV4dCIsIm1heExlbmd0aCIsInN1ZmZpeCIsImxvbmdUZXh0IiwidHJ1bmNhdGVMZW5ndGgiLCJtYXgiLCJjYWxsQ291bnQiLCJtb2NrRnVuY3Rpb24iLCJtb2NrRGVib3VuY2UiLCJmdW5jIiwiZGVsYXkiLCJ0aW1lb3V0SWQiLCJhcmdzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImFwcGx5IiwiZGVib3VuY2VkRnVuY3Rpb24iLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJtb2NrVGhyb3R0bGUiLCJsYXN0Q2FsbCIsIm5vdyIsInRocm90dGxlZEZ1bmN0aW9uIiwibW9ja0NhbGN1bGF0ZVRheCIsInRheFJhdGUiLCJyb3VuZCIsIm1vY2tDYWxjdWxhdGVEaXNjb3VudCIsImRpc2NvdW50IiwiaXNQZXJjZW50YWdlIiwibWluIiwibW9ja0NhbGN1bGF0ZVRvdGFsIiwic3VidG90YWwiLCJ0YXgiLCJhZnRlckRpc2NvdW50IiwidG90YWwiLCJtb2NrU2FuaXRpemVJbnB1dCIsImlucHV0IiwibW9ja0VzY2FwZUh0bWwiLCJlbnRpdHlNYXAiLCJjaGFyIiwibW9ja1BhcnNlUXVlcnlQYXJhbXMiLCJxdWVyeVN0cmluZyIsInBhcmFtcyIsInVybFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImtleSIsInRvRXF1YWwiLCJuYW1lIiwiYWdlIiwiY2l0eSIsInNlYXJjaCIsInBhZ2UiLCJsaW1pdCIsImluY2x1ZGVzIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic3BlY2lhbCIsIm1vY2tGb3JtYXRDdXJyZW5jeVdpdGhFcnJvciIsIkVycm9yIiwidG9GaXhlZCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiYW55IiwibW9ja1ZhbGlkYXRlRW1haWxXaXRoRXJyb3IiLCJtb2NrU2x1Z2lmeVdpdGhFcnJvciIsIm1vY2tCYXRjaFByb2Nlc3MiLCJpdGVtcyIsImJhdGNoU2l6ZSIsInJlc3VsdHMiLCJiYXRjaCIsInB1c2giLCJtYXAiLCJpdGVtIiwibGFyZ2VEYXRhc2V0IiwiQXJyYXkiLCJmcm9tIiwiXyIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJ0b0JlTGVzc1RoYW4iLCJtb2NrQXN5bmNVdGlsaXR5IiwiZGF0YSIsInRvVXBwZXJDYXNlIiwib3BlcmF0aW9ucyIsImFsbCJdLCJtYXBwaW5ncyI6Ijs7OztBQU1BLHVCQUF1QjtBQUN2QixNQUFNQSxhQUFhO0lBQ2pCQyxLQUFLQyxLQUFLQyxLQUFLLENBQUNDLFNBQVMsT0FBT0Msa0JBQWtCLENBQUMsS0FBTztJQUMxREMsT0FBT0osS0FBS0MsS0FBSyxDQUFDQyxTQUFTLFNBQVNDLGtCQUFrQixDQUFDLEtBQU87SUFDOURFLE1BQU1MLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxRQUFRQyxrQkFBa0IsQ0FBQyxL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